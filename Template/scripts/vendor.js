window.Modernizr = (function (t, e, n) { function i (t) { g.cssText = t } function r (t, e) { return i(x.join(t + ';') + (e || '')) } function a (t, e) { return typeof t === e } function o (t, e) { return !!~('' + t).indexOf(e) } function s (t, e) { for (const i in t) { const r = t[i]; if (!o(r, '-') && g[r] !== n) return e != 'pfx' || r } return !1 } function l (t, e, i) { for (const r in t) { const o = e[t[r]]; if (o !== n) return !1 === i ? t[r] : a(o, 'function') ? o.bind(i || e) : o } return !1 } function c (t, e, n) { const i = t.charAt(0).toUpperCase() + t.slice(1); let r = (t + ' ' + _.join(i + ' ') + i).split(' '); return a(e, 'string') || a(e, 'undefined') ? s(r, e) : (r = (t + ' ' + $.join(i + ' ') + i).split(' '), l(r, e, n)) } let u; let h; const p = {}; const d = e.documentElement; const f = 'modernizr'; let m = e.createElement(f); var g = m.style; let v = e.createElement('input'); const y = ':)'; const b = {}.toString; var x = ' -webkit- -moz- -o- -ms- '.split(' '); const w = 'Webkit Moz O ms'; var _ = w.split(' '); var $ = w.toLowerCase().split(' '); const T = { svg: 'http://www.w3.org/2000/svg' }; const S = {}; const M = {}; const C = {}; const E = []; const A = E.slice; const P = function (t, n, i, r) { let a; let o; let s; let l; const c = e.createElement('div'); const u = e.body; const h = u || e.createElement('body'); if (parseInt(i, 10)) for (;i--;)s = e.createElement('div'), s.id = r ? r[i] : f + (i + 1), c.appendChild(s); return a = ['&#173;', '<style id="s', f, '">', t, '</style>'].join(''), c.id = f, (u ? c : h).innerHTML += a, h.appendChild(c), u || (h.style.background = '', h.style.overflow = 'hidden', l = d.style.overflow, d.style.overflow = 'hidden', d.appendChild(h)), o = n(c, t), u ? c.parentNode.removeChild(c) : (h.parentNode.removeChild(h), d.style.overflow = l), !!o }; const k = function (e) { const n = t.matchMedia || t.msMatchMedia; if (n) return n(e) && n(e).matches || !1; let i; return P('@media ' + e + ' { #' + f + ' { position: absolute; } }', function (e) { i = (t.getComputedStyle ? getComputedStyle(e, null) : e.currentStyle).position == 'absolute' }), i }; const D = (function () { function t (t, r) { r = r || e.createElement(i[t] || 'div'), t = 'on' + t; let o = t in r; return o || (r.setAttribute || (r = e.createElement('div')), r.setAttribute && r.removeAttribute && (r.setAttribute(t, ''), o = a(r[t], 'function'), a(r[t], 'undefined') || (r[t] = n), r.removeAttribute(t))), r = null, o } var i = { select: 'input', change: 'input', submit: 'form', reset: 'form', error: 'img', load: 'img', abort: 'img' }; return t }()); const O = {}.hasOwnProperty; h = a(O, 'undefined') || a(O.call, 'undefined') ? function (t, e) { return e in t && a(t.constructor.prototype[e], 'undefined') } : function (t, e) { return O.call(t, e) }, Function.prototype.bind || (Function.prototype.bind = function (t) { const e = this; if (typeof e !== 'function') throw new TypeError(); const n = A.call(arguments, 1); const i = function () { if (this instanceof i) { const r = function () {}; r.prototype = e.prototype; const a = new r(); const o = e.apply(a, n.concat(A.call(arguments))); return Object(o) === o ? o : a } return e.apply(t, n.concat(A.call(arguments))) }; return i }), S.flexbox = function () { return c('flexWrap') }, S.flexboxlegacy = function () { return c('boxDirection') }, S.canvas = function () { const t = e.createElement('canvas'); return !(!t.getContext || !t.getContext('2d')) }, S.canvastext = function () { return !(!p.canvas || !a(e.createElement('canvas').getContext('2d').fillText, 'function')) }, S.webgl = function () { return !!t.WebGLRenderingContext }, S.touch = function () { let n; return 'ontouchstart' in t || t.DocumentTouch && e instanceof DocumentTouch ? n = !0 : P(['@media (', x.join('touch-enabled),('), f, ')', '{#modernizr{top:9px;position:absolute}}'].join(''), function (t) { n = t.offsetTop === 9 }), n }, S.geolocation = function () { return 'geolocation' in navigator }, S.postmessage = function () { return !!t.postMessage }, S.websqldatabase = function () { return !!t.openDatabase }, S.indexedDB = function () { return !!c('indexedDB', t) }, S.hashchange = function () { return D('hashchange', t) && (e.documentMode === n || e.documentMode > 7) }, S.history = function () { return !(!t.history || !history.pushState) }, S.draganddrop = function () { const t = e.createElement('div'); return 'draggable' in t || 'ondragstart' in t && 'ondrop' in t }, S.websockets = function () { return 'WebSocket' in t || 'MozWebSocket' in t }, S.rgba = function () { return i('background-color:rgba(150,255,150,.5)'), o(g.backgroundColor, 'rgba') }, S.hsla = function () { return i('background-color:hsla(120,40%,100%,.5)'), o(g.backgroundColor, 'rgba') || o(g.backgroundColor, 'hsla') }, S.multiplebgs = function () { return i('background:url(https://),url(https://),red url(https://)'), /(url\s*\(.*?){3}/.test(g.background) }, S.backgroundsize = function () { return c('backgroundSize') }, S.borderimage = function () { return c('borderImage') }, S.borderradius = function () { return c('borderRadius') }, S.boxshadow = function () { return c('boxShadow') }, S.textshadow = function () { return e.createElement('div').style.textShadow === '' }, S.opacity = function () { return r('opacity:.55'), /^0.55$/.test(g.opacity) }, S.cssanimations = function () { return c('animationName') }, S.csscolumns = function () { return c('columnCount') }, S.cssgradients = function () { const t = 'background-image:'; return i((t + '-webkit- '.split(' ').join('gradient(linear,left top,right bottom,from(#9f9),to(white));' + t) + x.join('linear-gradient(left top,#9f9, white);' + t)).slice(0, -t.length)), o(g.backgroundImage, 'gradient') }, S.cssreflections = function () { return c('boxReflect') }, S.csstransforms = function () { return !!c('transform') }, S.csstransforms3d = function () { let t = !!c('perspective'); return t && 'webkitPerspective' in d.style && P('@media (transform-3d),(-webkit-transform-3d){#modernizr{left:9px;position:absolute;height:3px;}}', function (e, n) { t = e.offsetLeft === 9 && e.offsetHeight === 3 }), t }, S.csstransitions = function () { return c('transition') }, S.fontface = function () { let t; return P('@font-face {font-family:"font";src:url("https://")}', function (n, i) { const r = e.getElementById('smodernizr'); const a = r.sheet || r.styleSheet; const o = a ? a.cssRules && a.cssRules[0] ? a.cssRules[0].cssText : a.cssText || '' : ''; t = /src/i.test(o) && o.indexOf(i.split(' ')[0]) === 0 }), t }, S.generatedcontent = function () { let t; return P(['#', f, '{font:0/0 a}#', f, ':after{content:"', y, '";visibility:hidden;font:3px/1 a}'].join(''), function (e) { t = e.offsetHeight >= 3 }), t }, S.video = function () { const t = e.createElement('video'); let n = !1; try { (n = !!t.canPlayType) && (n = new Boolean(n), n.ogg = t.canPlayType('video/ogg; codecs="theora"').replace(/^no$/, ''), n.h264 = t.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/, ''), n.webm = t.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/, '')) } catch (t) {} return n }, S.audio = function () { const t = e.createElement('audio'); let n = !1; try { (n = !!t.canPlayType) && (n = new Boolean(n), n.ogg = t.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''), n.mp3 = t.canPlayType('audio/mpeg;').replace(/^no$/, ''), n.wav = t.canPlayType('audio/wav; codecs="1"').replace(/^no$/, ''), n.m4a = (t.canPlayType('audio/x-m4a;') || t.canPlayType('audio/aac;')).replace(/^no$/, '')) } catch (t) {} return n }, S.localstorage = function () { try { return localStorage.setItem(f, f), localStorage.removeItem(f), !0 } catch (t) { return !1 } }, S.sessionstorage = function () { try { return sessionStorage.setItem(f, f), sessionStorage.removeItem(f), !0 } catch (t) { return !1 } }, S.webworkers = function () { return !!t.Worker }, S.applicationcache = function () { return !!t.applicationCache }, S.svg = function () { return !!e.createElementNS && !!e.createElementNS(T.svg, 'svg').createSVGRect }, S.inlinesvg = function () { const t = e.createElement('div'); return t.innerHTML = '<svg/>', (t.firstChild && t.firstChild.namespaceURI) == T.svg }, S.smil = function () { return !!e.createElementNS && /SVGAnimate/.test(b.call(e.createElementNS(T.svg, 'animate'))) }, S.svgclippaths = function () { return !!e.createElementNS && /SVGClipPath/.test(b.call(e.createElementNS(T.svg, 'clipPath'))) }; for (const L in S)h(S, L) && (u = L.toLowerCase(), p[u] = S[L](), E.push((p[u] ? '' : 'no-') + u)); return p.input || (function () { p.input = (function (n) { for (let i = 0, r = n.length; i < r; i++)C[n[i]] = !!(n[i] in v); return C.list && (C.list = !(!e.createElement('datalist') || !t.HTMLDataListElement)), C }('autocomplete autofocus list placeholder max min multiple pattern required step'.split(' '))), p.inputtypes = (function (t) { for (var i, r, a, o = 0, s = t.length; o < s; o++)v.setAttribute('type', r = t[o]), i = v.type !== 'text', i && (v.value = y, v.style.cssText = 'position:absolute;visibility:hidden;', /^range$/.test(r) && v.style.WebkitAppearance !== n ? (d.appendChild(v), a = e.defaultView, i = a.getComputedStyle && a.getComputedStyle(v, null).WebkitAppearance !== 'textfield' && v.offsetHeight !== 0, d.removeChild(v)) : /^(search|tel)$/.test(r) || (i = /^(url|email)$/.test(r) ? v.checkValidity && !1 === v.checkValidity() : v.value != y)), M[t[o]] = !!i; return M }('search tel url email datetime date month week time datetime-local number range color'.split(' '))) }()), p.addTest = function (t, e) { if (typeof t === 'object') for (const i in t)h(t, i) && p.addTest(i, t[i]); else { if (t = t.toLowerCase(), p[t] !== n) return p; e = typeof e === 'function' ? e() : e, d.className += ' ' + (e ? '' : 'no-') + t, p[t] = e } return p }, i(''), m = v = null, (function (t, e) { function n (t, e) { const n = t.createElement('p'); const i = t.getElementsByTagName('head')[0] || t.documentElement; return n.innerHTML = 'x<style>' + e + '</style>', i.insertBefore(n.lastChild, i.firstChild) } function i () { const t = v.elements; return typeof t === 'string' ? t.split(' ') : t } function r (t) { let e = g[t[f]]; return e || (e = {}, m++, t[f] = m, g[m] = e), e } function a (t, n, i) { if (n || (n = e), u) return n.createElement(t); i || (i = r(n)); let a; return a = i.cache[t] ? i.cache[t].cloneNode() : d.test(t) ? (i.cache[t] = i.createElem(t)).cloneNode() : i.createElem(t), !a.canHaveChildren || p.test(t) || a.tagUrn ? a : i.frag.appendChild(a) } function o (t, n) { if (t || (t = e), u) return t.createDocumentFragment(); n = n || r(t); for (var a = n.frag.cloneNode(), o = 0, s = i(), l = s.length; o < l; o++)a.createElement(s[o]); return a } function s (t, e) { e.cache || (e.cache = {}, e.createElem = t.createElement, e.createFrag = t.createDocumentFragment, e.frag = e.createFrag()), t.createElement = function (n) { return v.shivMethods ? a(n, t, e) : e.createElem(n) }, t.createDocumentFragment = Function('h,f', 'return function(){var n=f.cloneNode(),c=n.createElement;h.shivMethods&&(' + i().join().replace(/[\w\-]+/g, function (t) { return e.createElem(t), e.frag.createElement(t), 'c("' + t + '")' }) + ');return n}')(v, e.frag) } function l (t) { t || (t = e); const i = r(t); return !v.shivCSS || c || i.hasCSS || (i.hasCSS = !!n(t, 'article,aside,dialog,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}mark{background:#FF0;color:#000}template{display:none}')), u || s(t, i), t } let c; let u; const h = t.html5 || {}; var p = /^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i; var d = /^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i; var f = '_html5shiv'; var m = 0; var g = {}; !(function () { try { const t = e.createElement('a'); t.innerHTML = '<xyz></xyz>', c = 'hidden' in t, u = t.childNodes.length == 1 || (function () { e.createElement('a'); const t = e.createDocumentFragment(); return void 0 === t.cloneNode || void 0 === t.createDocumentFragment || void 0 === t.createElement }()) } catch (t) { c = !0, u = !0 } }()); var v = { elements: h.elements || 'abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video', version: '3.7.0', shivCSS: !1 !== h.shivCSS, supportsUnknownElements: u, shivMethods: !1 !== h.shivMethods, type: 'default', shivDocument: l, createElement: a, createDocumentFragment: o }; t.html5 = v, l(e) }(this, e)), p._version = '2.8.3', p._prefixes = x, p._domPrefixes = $, p._cssomPrefixes = _, p.mq = k, p.hasEvent = D, p.testProp = function (t) { return s([t]) }, p.testAllProps = c, p.testStyles = P, p.prefixed = function (t, e, n) { return e ? c(t, e, n) : c(t, 'pfx') }, d.className = d.className.replace(/(^|\s)no-js(\s|$)/, '$1$2') + ' js ' + E.join(' '), p }(this, this.document)), (function (t) {
  'use strict'; function e (t, e) { return e = e || Error, function () { let n; let i; const r = arguments; const a = r[0]; let o = '[' + (t ? t + ':' : '') + a + '] '; const s = r[1]; for (o += s.replace(/\{\d+\}/g, function (t) { const e = +t.slice(1, -1); const n = e + 2; return n < r.length ? bt(r[n]) : t }), o += '\nhttp://errors.angularjs.org/1.6.2/' + (t ? t + '/' : '') + a, i = 2, n = '?'; i < r.length; i++, n = '&')o += n + 'p' + (i - 2) + '=' + encodeURIComponent(bt(r[i])); return new e(o) } } function n (t) { if (t == null || M(t)) return !1; if (ar(t) || w(t) || qi && t instanceof qi) return !0; const e = 'length' in Object(t) && t.length; return _(e) && (e >= 0 && (e - 1 in t || t instanceof Array) || typeof t.item === 'function') } function i (t, e, r) { let a, o; if (t) if (T(t)) for (a in t)a !== 'prototype' && a !== 'length' && a !== 'name' && t.hasOwnProperty(a) && e.call(r, t[a], a, t); else if (ar(t) || n(t)) { const s = typeof t !== 'object'; for (a = 0, o = t.length; a < o; a++)(s || a in t) && e.call(r, t[a], a, t) } else if (t.forEach && t.forEach !== i)t.forEach(e, r, t); else if (x(t)) for (a in t)e.call(r, t[a], a, t); else if (typeof t.hasOwnProperty === 'function') for (a in t)t.hasOwnProperty(a) && e.call(r, t[a], a, t); else for (a in t)Bi.call(t, a) && e.call(r, t[a], a, t); return t } function r (t, e, n) { for (var i = Object.keys(t).sort(), r = 0; r < i.length; r++)e.call(n, t[i[r]], i[r]); return i } function a (t) { return function (e, n) { t(n, e) } } function o () { return ++ir } function s (t, e) { e ? t.$$hashKey = e : delete t.$$hashKey } function l (t, e, n) { for (var i = t.$$hashKey, r = 0, a = e.length; r < a; ++r) { const o = e[r]; if (b(o) || T(o)) for (let c = Object.keys(o), u = 0, h = c.length; u < h; u++) { const p = c[u]; const d = o[p]; n && b(d) ? $(d) ? t[p] = new Date(d.valueOf()) : S(d) ? t[p] = new RegExp(d) : d.nodeName ? t[p] = d.cloneNode(!0) : I(d) ? t[p] = d.clone() : (b(t[p]) || (t[p] = ar(d) ? [] : {}), l(t[p], [d], !0)) : t[p] = d } } return s(t, i), t } function c (t) { return l(t, Zi.call(arguments, 1), !1) } function u (t) { return l(t, Zi.call(arguments, 1), !0) } function h (t) { return parseInt(t, 10) } function p (t, e) { return c(Object.create(t), e) } function d () {} function f (t) { return t } function m (t) { return function () { return t } } function g (t) { return T(t.toString) && t.toString !== Qi } function v (t) { return void 0 === t } function y (t) { return void 0 !== t } function b (t) { return t !== null && typeof t === 'object' } function x (t) { return t !== null && typeof t === 'object' && !tr(t) } function w (t) { return typeof t === 'string' } function _ (t) { return typeof t === 'number' } function $ (t) { return Qi.call(t) === '[object Date]' } function T (t) { return typeof t === 'function' } function S (t) { return Qi.call(t) === '[object RegExp]' } function M (t) { return t && t.window === t } function C (t) { return t && t.$evalAsync && t.$watch } function E (t) { return Qi.call(t) === '[object File]' } function A (t) { return Qi.call(t) === '[object FormData]' } function P (t) { return Qi.call(t) === '[object Blob]' } function k (t) { return typeof t === 'boolean' } function D (t) { return t && T(t.then) } function O (t) { return t && _(t.length) && or.test(Qi.call(t)) } function L (t) { return Qi.call(t) === '[object ArrayBuffer]' } function I (t) { return !(!t || !(t.nodeName || t.prop && t.attr && t.find)) } function R (t) { let e; const n = {}; const i = t.split(','); for (e = 0; e < i.length; e++)n[i[e]] = !0; return n } function N (t) { return ji(t.nodeName || t[0] && t[0].nodeName) } function F (t, e) { return Array.prototype.indexOf.call(t, e) !== -1 } function U (t, e) { const n = t.indexOf(e); return n >= 0 && t.splice(n, 1), n } function z (t, e) { function n (t, e) { let n; const i = e.$$hashKey; if (ar(t)) for (let a = 0, o = t.length; a < o; a++)e.push(r(t[a])); else if (x(t)) for (n in t)e[n] = r(t[n]); else if (t && typeof t.hasOwnProperty === 'function') for (n in t)t.hasOwnProperty(n) && (e[n] = r(t[n])); else for (n in t)Bi.call(t, n) && (e[n] = r(t[n])); return s(e, i), e } function r (t) { if (!b(t)) return t; const e = o.indexOf(t); if (e !== -1) return l[e]; if (M(t) || C(t)) throw er('cpws', "Can't copy! Making copies of Window or Scope instances is not supported."); let i = !1; let r = a(t); return void 0 === r && (r = ar(t) ? [] : Object.create(tr(t)), i = !0), o.push(t), l.push(r), i ? n(t, r) : r } function a (t) { switch (Qi.call(t)) { case '[object Int8Array]':case '[object Int16Array]':case '[object Int32Array]':case '[object Float32Array]':case '[object Float64Array]':case '[object Uint8Array]':case '[object Uint8ClampedArray]':case '[object Uint16Array]':case '[object Uint32Array]':return new t.constructor(r(t.buffer), t.byteOffset, t.length); case '[object ArrayBuffer]':if (!t.slice) { const e = new ArrayBuffer(t.byteLength); return new Uint8Array(e).set(new Uint8Array(t)), e } return t.slice(0); case '[object Boolean]':case '[object Number]':case '[object String]':case '[object Date]':return new t.constructor(t.valueOf()); case '[object RegExp]':var n = new RegExp(t.source, t.toString().match(/[^\/]*$/)[0]); return n.lastIndex = t.lastIndex, n; case '[object Blob]':return new t.constructor([t], { type: t.type }) } if (T(t.cloneNode)) return t.cloneNode(!0) } var o = []; var l = []; if (e) { if (O(e) || L(e)) throw er('cpta', "Can't copy! TypedArray destination cannot be mutated."); if (t === e) throw er('cpi', "Can't copy! Source and destination are identical."); return ar(e) ? e.length = 0 : i(e, function (t, n) { n !== '$$hashKey' && delete e[n] }), o.push(t), l.push(e), n(t, e) } return r(t) } function B (t, e) { if (t === e) return !0; if (t === null || e === null) return !1; if (t !== t && e !== e) return !0; let n; let i; let r; const a = typeof t; const o = typeof e; if (a === o && a === 'object') { if (!ar(t)) { if ($(t)) return !!$(e) && B(t.getTime(), e.getTime()); if (S(t)) return !!S(e) && t.toString() === e.toString(); if (C(t) || C(e) || M(t) || M(e) || ar(e) || $(e) || S(e)) return !1; r = ft(); for (i in t) if (i.charAt(0) !== '$' && !T(t[i])) { if (!B(t[i], e[i])) return !1; r[i] = !0 } for (i in e) if (!(i in r) && i.charAt(0) !== '$' && y(e[i]) && !T(e[i])) return !1; return !0 } if (!ar(e)) return !1; if ((n = t.length) === e.length) { for (i = 0; i < n; i++) if (!B(t[i], e[i])) return !1; return !0 } } return !1 } function j (t, e, n) { return t.concat(Zi.call(e, n)) } function V (t, e) { return Zi.call(t, e || 0) } function G (t, e) { const n = arguments.length > 2 ? V(arguments, 2) : []; return !T(e) || e instanceof RegExp ? e : n.length ? function () { return arguments.length ? e.apply(t, j(n, arguments, 0)) : e.apply(t, n) } : function () { return arguments.length ? e.apply(t, arguments) : e.call(t) } } function H (e, n) { let i = n; return typeof e === 'string' && e.charAt(0) === '$' && e.charAt(1) === '$' ? i = void 0 : M(n) ? i = '$WINDOW' : n && t.document === n ? i = '$DOCUMENT' : C(n) && (i = '$SCOPE'), i } function W (t, e) { if (!v(t)) return _(e) || (e = e ? 2 : null), JSON.stringify(t, H, e) } function q (t) { return w(t) ? JSON.parse(t) : t } function X (t, e) { t = t.replace(hr, ''); const n = Date.parse('Jan 01, 1970 00:00:00 ' + t) / 6e4; return rr(n) ? e : n } function Y (t, e) { return t = new Date(t.getTime()), t.setMinutes(t.getMinutes() + e), t } function Z (t, e, n) { n = n ? -1 : 1; const i = t.getTimezoneOffset(); return Y(t, n * (X(e, i) - i)) } function K (t) { t = qi(t).clone(); try { t.empty() } catch (t) {} const e = qi('<div>').append(t).html(); try { return t[0].nodeType === vr ? ji(e) : e.match(/^(<[^>]+>)/)[1].replace(/^<([\w-]+)/, function (t, e) { return '<' + ji(e) }) } catch (t) { return ji(e) } } function J (t) { try { return decodeURIComponent(t) } catch (t) {} } function Q (t) { const e = {}; return i((t || '').split('&'), function (t) { let n, i, r; t && (i = t = t.replace(/\+/g, '%20'), n = t.indexOf('='), n !== -1 && (i = t.substring(0, n), r = t.substring(n + 1)), i = J(i), y(i) && (r = !y(r) || J(r), Bi.call(e, i) ? ar(e[i]) ? e[i].push(r) : e[i] = [e[i], r] : e[i] = r)) }), e } function tt (t) { const e = []; return i(t, function (t, n) { ar(t) ? i(t, function (t) { e.push(nt(n, !0) + (!0 === t ? '' : '=' + nt(t, !0))) }) : e.push(nt(n, !0) + (!0 === t ? '' : '=' + nt(t, !0))) }), e.length ? e.join('&') : '' } function et (t) { return nt(t, !0).replace(/%26/gi, '&').replace(/%3D/gi, '=').replace(/%2B/gi, '+') } function nt (t, e) { return encodeURIComponent(t).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%3B/gi, ';').replace(/%20/g, e ? '%20' : '+') } function it (t, e) { let n; let i; const r = pr.length; for (i = 0; i < r; ++i) if (n = pr[i] + e, w(n = t.getAttribute(n))) return n; return null } function rt (e, n) { let r; let a; const o = {}; if (i(pr, function (t) { const n = t + 'app'; !r && e.hasAttribute && e.hasAttribute(n) && (r = e, a = e.getAttribute(n)) }), i(pr, function (t) { let n; const i = t + 'app'; !r && (n = e.querySelector('[' + i.replace(':', '\\:') + ']')) && (r = n, a = n.getAttribute(i)) }), r) { if (!dr) return void t.console.error('Angular: disabling automatic bootstrap. <script> protocol indicates an extension, document.location.href does not match.'); o.strictDi = it(r, 'strict-di') !== null, n(r, a ? [a] : [], o) } } function at (e, n, r) { b(r) || (r = {}), r = c({ strictDi: !1 }, r); const a = function () { if (e = qi(e), e.injector()) { const i = e[0] === t.document ? 'document' : K(e); throw er('btstrpd', "App already bootstrapped with this element '{0}'", i.replace(/</, '&lt;').replace(/>/, '&gt;')) }n = n || [], n.unshift(['$provide', function (t) { t.value('$rootElement', e) }]), r.debugInfoEnabled && n.push(['$compileProvider', function (t) { t.debugInfoEnabled(!0) }]), n.unshift('ng'); const a = oe(n, r.strictDi); return a.invoke(['$rootScope', '$rootElement', '$compile', '$injector', function (t, e, n, i) { t.$apply(function () { e.data('$injector', i), n(e)(t) }) }]), a }; const o = /^NG_ENABLE_DEBUG_INFO!/; const s = /^NG_DEFER_BOOTSTRAP!/; if (t && o.test(t.name) && (r.debugInfoEnabled = !0, t.name = t.name.replace(o, '')), t && !s.test(t.name)) return a(); t.name = t.name.replace(s, ''), nr.resumeBootstrap = function (t) { return i(t, function (t) { n.push(t) }), a() }, T(nr.resumeDeferredBootstrap) && nr.resumeDeferredBootstrap() } function ot () { t.name = 'NG_ENABLE_DEBUG_INFO!' + t.name, t.location.reload() } function st (t) { const e = nr.element(t).injector(); if (!e) throw er('test', 'no injector found for element argument to getTestability'); return e.get('$$testability') } function lt (t, e) { return e = e || '_', t.replace(fr, function (t, n) { return (n ? e : '') + t.toLowerCase() }) } function ct (t, e, n) { if (!t) throw er('areq', "Argument '{0}' is {1}", e || '?', n || 'required'); return t } function ut (t, e, n) { return n && ar(t) && (t = t[t.length - 1]), ct(T(t), e, 'not a function, got ' + (t && typeof t === 'object' ? t.constructor.name || 'Object' : typeof t)), t } function ht (t, e) { if (t === 'hasOwnProperty') throw er('badname', 'hasOwnProperty is not a valid {0} name', e) } function pt (t, e, n) { if (!e) return t; for (var i, r = e.split('.'), a = t, o = r.length, s = 0; s < o; s++)i = r[s], t && (t = (a = t)[i]); return !n && T(t) ? G(a, t) : t } function dt (t) { for (var e, n = t[0], i = t[t.length - 1], r = 1; n !== i && (n = n.nextSibling); r++)(e || t[r] !== n) && (e || (e = qi(Zi.call(t, 0, r))), e.push(n)); return e || t } function ft () { return Object.create(null) } function mt (t) { if (t == null) return ''; switch (typeof t) { case 'string':break; case 'number':t = '' + t; break; default:t = !g(t) || ar(t) || $(t) ? W(t) : t.toString() } return t } function gt (t) { function n (t, e, n) { return t[e] || (t[e] = n()) } const i = e('$injector'); const r = e('ng'); const a = n(t, 'angular', Object); return a.$$minErr = a.$$minErr || e, n(a, 'module', function () { const t = {}; return function (e, a, o) { return (function (t, e) { if (t === 'hasOwnProperty') throw r('badname', 'hasOwnProperty is not a valid {0} name', e) }(e, 'module')), a && t.hasOwnProperty(e) && (t[e] = null), n(t, e, function () { function t (t, e, n, i) { return i || (i = r), function () { return i[n || 'push']([t, e, arguments]), u } } function n (t, n, i) { return i || (i = r), function (r, a) { return a && T(a) && (a.$$moduleName = e), i.push([t, n, arguments]), u } } if (!a) throw i('nomod', "Module '{0}' is not available! You either misspelled the module name or forgot to load it. If registering a module ensure that you specify the dependencies as the second argument.", e); var r = []; const s = []; const l = []; const c = t('$injector', 'invoke', 'push', s); var u = { _invokeQueue: r, _configBlocks: s, _runBlocks: l, requires: a, name: e, provider: n('$provide', 'provider'), factory: n('$provide', 'factory'), service: n('$provide', 'service'), value: t('$provide', 'value'), constant: t('$provide', 'constant', 'unshift'), decorator: n('$provide', 'decorator', s), animation: n('$animateProvider', 'register'), filter: n('$filterProvider', 'register'), controller: n('$controllerProvider', 'register'), directive: n('$compileProvider', 'directive'), component: n('$compileProvider', 'component'), config: c, run: function (t) { return l.push(t), this } }; return o && c(o), u }) } }) } function vt (t, e) { if (ar(t)) { e = e || []; for (let n = 0, i = t.length; n < i; n++)e[n] = t[n] } else if (b(t)) { e = e || {}; for (const r in t)r.charAt(0) === '$' && r.charAt(1) === '$' || (e[r] = t[r]) } return e || t } function yt (t) { const e = []; return JSON.stringify(t, function (t, n) { if (n = H(t, n), b(n)) { if (e.indexOf(n) >= 0) return '...'; e.push(n) } return n }) } function bt (t) { return typeof t === 'function' ? t.toString().replace(/ \{[\s\S]*$/, '') : v(t) ? 'undefined' : typeof t !== 'string' ? yt(t) : t } function xt () { return ++$r } function wt (t) { return $t(t.replace(Sr, 'ms-')) } function _t (t, e) { return e.toUpperCase() } function $t (t) { return t.replace(Tr, _t) } function Tt (t) { return !Ar.test(t) } function St (t) { const e = t.nodeType; return e === gr || !e || e === br } function Mt (t) { for (const e in _r[t.ng339]) return !0; return !1 } function Ct (t) { for (let e = 0, n = t.length; e < n; e++)It(t[e]) } function Et (t, e) { let n; let r; let a; let o; const s = e.createDocumentFragment(); let l = []; if (Tt(t))l.push(e.createTextNode(t)); else { for (n = s.appendChild(e.createElement('div')), r = (Pr.exec(t) || ['', ''])[1].toLowerCase(), a = Dr[r] || Dr._default, n.innerHTML = a[1] + t.replace(kr, '<$1></$2>') + a[2], o = a[0]; o--;)n = n.lastChild; l = j(l, n.childNodes), n = s.firstChild, n.textContent = '' } return s.textContent = '', s.innerHTML = '', i(l, function (t) { s.appendChild(t) }), s } function At (e, n) { n = n || t.document; let i; return (i = Er.exec(e)) ? [n.createElement(i[1])] : (i = Et(e, n)) ? i.childNodes : [] } function Pt (t, e) { const n = t.parentNode; n && n.replaceChild(e, t), e.appendChild(t) } function kt (t) { if (t instanceof kt) return t; let e; if (w(t) && (t = sr(t), e = !0), !(this instanceof kt)) { if (e && t.charAt(0) !== '<') throw Cr('nosel', 'Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element'); return new kt(t) }e ? Bt(this, At(t)) : T(t) ? qt(t) : Bt(this, t) } function Dt (t) { return t.cloneNode(!0) } function Ot (t, e) { if (e || It(t), t.querySelectorAll) for (let n = t.querySelectorAll('*'), i = 0, r = n.length; i < r; i++)It(n[i]) } function Lt (t, e, n, r) { if (y(r)) throw Cr('offargs', 'jqLite#off() does not support the `selector` argument'); const a = Rt(t); const o = a && a.events; const s = a && a.handle; if (s) if (e) { const l = function (e) { const i = o[e]; y(n) && U(i || [], n), y(n) && i && i.length > 0 || (t.removeEventListener(e, s), delete o[e]) }; i(e.split(' '), function (t) { l(t), Mr[t] && l(Mr[t]) }) } else for (e in o)e !== '$destroy' && t.removeEventListener(e, s), delete o[e] } function It (t, e) { const n = t.ng339; const i = n && _r[n]; if (i) { if (e) return void delete i.data[e]; i.handle && (i.events.$destroy && i.handle({}, '$destroy'), Lt(t)), delete _r[n], t.ng339 = void 0 } } function Rt (t, e) { let n = t.ng339; let i = n && _r[n]; return e && !i && (t.ng339 = n = xt(), i = _r[n] = { events: {}, data: {}, handle: void 0 }), i } function Nt (t, e, n) { if (St(t)) { let i; const r = y(n); const a = !r && e && !b(e); const o = !e; const s = Rt(t, !a); const l = s && s.data; if (r)l[$t(e)] = n; else { if (o) return l; if (a) return l && l[$t(e)]; for (i in e)l[$t(i)] = e[i] } } } function Ft (t, e) { return !!t.getAttribute && (' ' + (t.getAttribute('class') || '') + ' ').replace(/[\n\t]/g, ' ').indexOf(' ' + e + ' ') > -1 } function Ut (t, e) { e && t.setAttribute && i(e.split(' '), function (e) { t.setAttribute('class', sr((' ' + (t.getAttribute('class') || '') + ' ').replace(/[\n\t]/g, ' ').replace(' ' + sr(e) + ' ', ' '))) }) } function zt (t, e) { if (e && t.setAttribute) { let n = (' ' + (t.getAttribute('class') || '') + ' ').replace(/[\n\t]/g, ' '); i(e.split(' '), function (t) { t = sr(t), n.indexOf(' ' + t + ' ') === -1 && (n += t + ' ') }), t.setAttribute('class', sr(n)) } } function Bt (t, e) { if (e) if (e.nodeType)t[t.length++] = e; else { const n = e.length; if (typeof n === 'number' && e.window !== e) { if (n) for (let i = 0; i < n; i++)t[t.length++] = e[i] } else t[t.length++] = e } } function jt (t, e) { return Vt(t, '$' + (e || 'ngController') + 'Controller') } function Vt (t, e, n) { t.nodeType === br && (t = t.documentElement); for (let i = ar(e) ? e : [e]; t;) { for (let r = 0, a = i.length; r < a; r++) if (y(n = qi.data(t, i[r]))) return n; t = t.parentNode || t.nodeType === xr && t.host } } function Gt (t) { for (Ot(t, !0); t.firstChild;)t.removeChild(t.firstChild) } function Ht (t, e) { e || Ot(t); const n = t.parentNode; n && n.removeChild(t) } function Wt (e, n) { n = n || t, n.document.readyState === 'complete' ? n.setTimeout(e) : qi(n).on('load', e) } function qt (e) { function n () { t.document.removeEventListener('DOMContentLoaded', n), t.removeEventListener('load', n), e() }t.document.readyState === 'complete' ? t.setTimeout(e) : (t.document.addEventListener('DOMContentLoaded', n), t.addEventListener('load', n)) } function Xt (t, e) { const n = Ir[e.toLowerCase()]; return n && Rr[N(t)] && n } function Yt (t) { return Nr[t] } function Zt (t, e) { const n = function (n, i) { n.isDefaultPrevented = function () { return n.defaultPrevented }; let r = e[i || n.type]; const a = r ? r.length : 0; if (a) { if (v(n.immediatePropagationStopped)) { const o = n.stopImmediatePropagation; n.stopImmediatePropagation = function () { n.immediatePropagationStopped = !0, n.stopPropagation && n.stopPropagation(), o && o.call(n) } }n.isImmediatePropagationStopped = function () { return !0 === n.immediatePropagationStopped }; const s = r.specialHandlerWrapper || Kt; a > 1 && (r = vt(r)); for (let l = 0; l < a; l++)n.isImmediatePropagationStopped() || s(t, n, r[l]) } }; return n.elem = t, n } function Kt (t, e, n) { n.call(t, e) } function Jt (t, e, n) { const i = e.relatedTarget; i && (i === t || Or.call(t, i)) || n.call(t, e) } function Qt () { this.$get = function () { return c(kt, { hasClass: function (t, e) { return t.attr && (t = t[0]), Ft(t, e) }, addClass: function (t, e) { return t.attr && (t = t[0]), zt(t, e) }, removeClass: function (t, e) { return t.attr && (t = t[0]), Ut(t, e) } }) } } function te (t, e) { let n = t && t.$$hashKey; if (n) return typeof n === 'function' && (n = t.$$hashKey()), n; const i = typeof t; return n = i === 'function' || i === 'object' && t !== null ? t.$$hashKey = i + ':' + (e || o)() : i + ':' + t } function ee () { this._keys = [], this._values = [], this._lastKey = NaN, this._lastIndex = -1 } function ne (t) { return Function.prototype.toString.call(t) } function ie (t) { const e = ne(t).replace(Hr, ''); return e.match(Br) || e.match(jr) } function re (t) { const e = ie(t); return e ? 'function(' + (e[1] || '').replace(/[\s\r\n]+/, ' ') + ')' : 'fn' } function ae (t, e, n) { let r, a, o; if (typeof t === 'function') { if (!(r = t.$inject)) { if (r = [], t.length) { if (e) throw w(n) && n || (n = t.name || re(t)), Wr('strictdi', '{0} is not using explicit annotation and cannot be invoked in strict mode', n); a = ie(t), i(a[1].split(Vr), function (t) { t.replace(Gr, function (t, e, n) { r.push(n) }) }) }t.$inject = r } } else ar(t) ? (o = t.length - 1, ut(t[o], 'fn'), r = t.slice(0, o)) : ut(t, 'fn', !0); return r } function oe (t, e) { function n (t) { return function (e, n) { if (!b(e)) return t(e, n); i(e, a(t)) } } function r (t, e) { if (ht(t, 'service'), (T(e) || ar(e)) && (e = $.instantiate(e)), !e.$get) throw Wr('pget', "Provider '{0}' must define $get factory method.", t); return _[t + g] = e } function o (t, e) { return function () { const n = C.invoke(e, this); if (v(n)) throw Wr('undef', "Provider '{0}' must return a value from $get factory method.", t); return n } } function s (t, e, n) { return r(t, { $get: !1 !== n ? o(t, e) : e }) } function l (t, e) { return s(t, ['$injector', function (t) { return t.instantiate(e) }]) } function c (t, e) { return s(t, m(e), !1) } function u (t, e) { ht(t, 'constant'), _[t] = e, S[t] = e } function h (t, e) { const n = $.get(t + g); const i = n.$get; n.$get = function () { const t = C.invoke(i, n); return C.invoke(e, null, { $delegate: t }) } } function p (t) { ct(v(t) || ar(t), 'modulesToLoad', 'not an array'); let e; let n = []; return i(t, function (t) { function i (t) { let e, n; for (e = 0, n = t.length; e < n; e++) { const i = t[e]; const r = $.get(i[0]); r[i[1]].apply(r, i[2]) } } if (!x.get(t)) { x.set(t, !0); try { w(t) ? (e = Yi(t), n = n.concat(p(e.requires)).concat(e._runBlocks), i(e._invokeQueue), i(e._configBlocks)) : T(t) ? n.push($.invoke(t)) : ar(t) ? n.push($.invoke(t)) : ut(t, 'module') } catch (e) { throw ar(t) && (t = t[t.length - 1]), e.message && e.stack && e.stack.indexOf(e.message) === -1 && (e = e.message + '\n' + e.stack), Wr('modulerr', 'Failed to instantiate module {0} due to:\n{1}', t, e.stack || e.message || e) } } }), n } function d (t, n) { function i (e, i) { if (t.hasOwnProperty(e)) { if (t[e] === f) throw Wr('cdep', 'Circular dependency found: {0}', e + ' <- ' + y.join(' <- ')); return t[e] } try { return y.unshift(e), t[e] = f, t[e] = n(e, i), t[e] } catch (n) { throw t[e] === f && delete t[e], n } finally { y.shift() } } function r (t, n, r) { for (var a = [], o = oe.$$annotate(t, e, r), s = 0, l = o.length; s < l; s++) { const c = o[s]; if (typeof c !== 'string') throw Wr('itkn', 'Incorrect injection token! Expected service name as string, got {0}', c); a.push(n && n.hasOwnProperty(c) ? n[c] : i(c, r)) } return a } function a (t) { if (Wi || typeof t !== 'function') return !1; let e = t.$$ngIsClass; return k(e) || (e = t.$$ngIsClass = /^(?:class\b|constructor\()/.test(ne(t))), e } function o (t, e, n, i) { typeof n === 'string' && (i = n, n = null); const o = r(t, n, i); return ar(t) && (t = t[t.length - 1]), a(t) ? (o.unshift(null), new (Function.prototype.bind.apply(t, o))()) : t.apply(e, o) } function s (t, e, n) { const i = ar(t) ? t[t.length - 1] : t; const a = r(t, e, n); return a.unshift(null), new (Function.prototype.bind.apply(i, a))() } return { invoke: o, instantiate: s, get: i, annotate: oe.$$annotate, has: function (e) { return _.hasOwnProperty(e + g) || t.hasOwnProperty(e) } } }e = !0 === e; var f = {}; var g = 'Provider'; var y = []; var x = new Ur(); var _ = { $provide: { provider: n(r), factory: n(s), service: n(l), value: n(c), constant: n(u), decorator: h } }; var $ = _.$injector = d(_, function (t, e) { throw nr.isString(e) && y.push(e), Wr('unpr', 'Unknown provider: {0}', y.join(' <- ')) }); var S = {}; const M = d(S, function (t, e) { const n = $.get(t + g, e); return C.invoke(n.$get, n, void 0, t) }); var C = M; _['$injector' + g] = { $get: m(M) }; const E = p(t); return C = M.get('$injector'), C.strictDi = e, i(E, function (t) { t && C.invoke(t) }), C } function se () { let t = !0; this.disableAutoScrolling = function () { t = !1 }, this.$get = ['$window', '$location', '$rootScope', function (e, n, i) { function r (t) { let e = null; return Array.prototype.some.call(t, function (t) { if (N(t) === 'a') return e = t, !0 }), e } function a () { let t = s.yOffset; if (T(t))t = t(); else if (I(t)) { const n = t[0]; const i = e.getComputedStyle(n); t = i.position !== 'fixed' ? 0 : n.getBoundingClientRect().bottom } else _(t) || (t = 0); return t } function o (t) { if (t) { t.scrollIntoView(); const n = a(); if (n) { const i = t.getBoundingClientRect().top; e.scrollBy(0, i - n) } } else e.scrollTo(0, 0) } function s (t) { t = w(t) ? t : _(t) ? t.toString() : n.hash(); let e; t ? (e = l.getElementById(t)) ? o(e) : (e = r(l.getElementsByName(t))) ? o(e) : t === 'top' && o(null) : o(null) } var l = e.document; return t && i.$watch(function () { return n.hash() }, function (t, e) { t === e && t === '' || Wt(function () { i.$evalAsync(s) }) }), s }] } function le (t, e) {
    return t || e
      ? t
        ? e
          ? (ar(t) && (t = t.join(' ')),
            ar(e) && (e = e.join(' ')), t + ' ' + e)
          : t
        : e
      : ''
  } function ce (t) { for (let e = 0; e < t.length; e++) { const n = t[e]; if (n.nodeType === Xr) return n } } function ue (t) { w(t) && (t = t.split(' ')); const e = ft(); return i(t, function (t) { t.length && (e[t] = !0) }), e } function he (t) { return b(t) ? t : {} } function pe (t, e, n, r) { function a (t) { try { t.apply(null, V(arguments, 1)) } finally { if (--y === 0) for (;b.length;) try { b.pop()() } catch (t) { n.error(t) } } } function o (t) { const e = t.indexOf('#'); return e === -1 ? '' : t.substr(e) } function s () { T = null, c() } function l () { x = S(), x = v(x) ? null : x, B(x, E) && (x = E), E = x, w = x } function c () { const t = w; l(), _ === u.url() && t === x || (_ = u.url(), w = x, i(M, function (t) { t(u.url(), x) })) } var u = this; let h = t.location; let p = t.history; const f = t.setTimeout; const m = t.clearTimeout; const g = {}; u.isMock = !1; var y = 0; var b = []; u.$$completeOutstandingRequest = a, u.$$incOutstandingRequestCount = function () { y++ }, u.notifyWhenNoOutstandingRequests = function (t) { y === 0 ? t() : b.push(t) }; let x; let w; var _ = h.href; const $ = e.find('base'); var T = null; var S = r.history ? function () { try { return p.state } catch (t) {} } : d; l(), u.url = function (e, n, i) { if (v(i) && (i = null), h !== t.location && (h = t.location), p !== t.history && (p = t.history), e) { const a = w === i; if (_ === e && (!r.history || a)) return u; const s = _ && qe(_) === qe(e); return _ = e, w = i, !r.history || s && a ? (s || (T = e), n ? h.replace(e) : s ? h.hash = o(e) : h.href = e, h.href !== e && (T = e)) : (p[n ? 'replaceState' : 'pushState'](i, '', e), l()), T && (T = e), u } return T || h.href.replace(/%27/g, "'") }, u.state = function () { return x }; var M = []; let C = !1; var E = null; u.onUrlChange = function (e) { return C || (r.history && qi(t).on('popstate', s), qi(t).on('hashchange', s), C = !0), M.push(e), e }, u.$$applicationDestroyed = function () { qi(t).off('hashchange popstate', s) }, u.$$checkUrlChange = c, u.baseHref = function () { const t = $.attr('href'); return t ? t.replace(/^(https?:)?\/\/[^\/]*/, '') : '' }, u.defer = function (t, e) { let n; return y++, n = f(function () { delete g[n], a(t) }, e || 0), g[n] = !0, n }, u.defer.cancel = function (t) { return !!g[t] && (delete g[t], m(t), a(d), !0) } } function de () { this.$get = ['$window', '$log', '$sniffer', '$document', function (t, e, n, i) { return new pe(t, i, e, n) }] } function fe () { this.$get = function () { function t (t, i) { function r (t) { t !== p && (d ? d === t && (d = t.n) : d = t, a(t.n, t.p), a(t, p), p = t, p.n = null) } function a (t, e) { t !== e && (t && (t.p = e), e && (e.n = t)) } if (t in n) throw e('$cacheFactory')('iid', "CacheId '{0}' is already taken!", t); let o = 0; let s = c({}, i, { id: t }); let l = ft(); const u = i && i.capacity || Number.MAX_VALUE; let h = ft(); var p = null; var d = null; return n[t] = { put: function (t, e) { if (!v(e)) { if (u < Number.MAX_VALUE) { r(h[t] || (h[t] = { key: t })) } return t in l || o++, l[t] = e, o > u && this.remove(d.key), e } }, get: function (t) { if (u < Number.MAX_VALUE) { const e = h[t]; if (!e) return; r(e) } return l[t] }, remove: function (t) { if (u < Number.MAX_VALUE) { const e = h[t]; if (!e) return; e === p && (p = e.p), e === d && (d = e.n), a(e.n, e.p), delete h[t] }t in l && (delete l[t], o--) }, removeAll: function () { l = ft(), o = 0, h = ft(), p = d = null }, destroy: function () { l = null, s = null, h = null, delete n[t] }, info: function () { return c({}, s, { size: o }) } } } var n = {}; return t.info = function () { const t = {}; return i(n, function (e, n) { t[n] = e.info() }), t }, t.get = function (t) { return n[t] }, t } } function me () { this.$get = ['$cacheFactory', function (t) { return t('templates') }] } function ge () {} function ve (e, n) { function r (t, e, n) { const r = ft(); return i(t, function (t, i) { if (t in E) return void (r[i] = E[t]); const a = t.match(/^\s*([@&<]|=(\*?))(\??)\s*([\w$]*)\s*$/); if (!a) throw ea('iscp', "Invalid {3} for directive '{0}'. Definition: {... {1}: '{2}' ...}", e, i, t, n ? 'controller bindings definition' : 'isolate scope definition'); r[i] = { mode: a[1][0], collection: a[2] === '*', optional: a[3] === '?', attrName: a[4] || i }, a[4] && (E[t] = r[i]) }), r } function o (t, e) { const n = { isolateScope: null, bindToController: null }; if (b(t.scope) && (!0 === t.bindToController ? (n.bindToController = r(t.scope, e, !0), n.isolateScope = {}) : n.isolateScope = r(t.scope, e, !1)), b(t.bindToController) && (n.bindToController = r(t.bindToController, e, !0)), n.bindToController && !t.controller) throw ea('noctrl', "Cannot bind to controller without directive '{0}'s controller.", e); return n } function s (t) { const e = t.charAt(0); if (!e || e !== ji(e)) throw ea('baddir', "Directive/Component name '{0}' is invalid. The first character must be a lowercase letter", t); if (t !== t.trim()) throw ea('baddir', "Directive/Component name '{0}' is invalid. The name should not contain leading or trailing whitespaces", t) } function l (t) { const e = t.require || t.controller && t.name; return !ar(e) && b(e) && i(e, function (t, n) { const i = t.match(S); t.substring(i[0].length) || (e[n] = i[0] + n) }), e } function u (t, e) { if (t && (!w(t) || !/[EACM]/.test(t))) throw ea('badrestrict', "Restrict property '{0}' of directive '{1}' is invalid", t, e); return t || 'EA' } const h = {}; const g = 'Directive'; const x = /^\s*directive:\s*([\w-]+)\s+(.*)$/; const _ = /(([\w-]+)(?::([^;]+))?;?)/; const $ = R('ngSrc,ngSrcset,src,srcset'); var S = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/; const M = /^(on[a-z]+|formaction)$/; var E = ft(); this.directive = function t (n, r) { return ct(n, 'name'), ht(n, 'directive'), w(n) ? (s(n), ct(r, 'directiveFactory'), h.hasOwnProperty(n) || (h[n] = [], e.factory(n + g, ['$injector', '$exceptionHandler', function (t, e) { const r = []; return i(h[n], function (i, a) { try { let o = t.invoke(i); T(o) ? o = { compile: m(o) } : !o.compile && o.link && (o.compile = m(o.link)), o.priority = o.priority || 0, o.index = a, o.name = o.name || n, o.require = l(o), o.restrict = u(o.restrict, n), o.$$moduleName = i.$$moduleName, r.push(o) } catch (t) { e(t) } }), r }])), h[n].push(r)) : i(n, a(t)), this }, this.component = function (t, e) { function n (t) { function n (e) { return T(e) || ar(e) ? function (n, i) { return t.invoke(e, this, { $element: n, $attrs: i }) } : e } const a = e.template || e.templateUrl ? e.template : ''; const o = { controller: r, controllerAs: _e(e.controller) || e.controllerAs || '$ctrl', template: n(a), templateUrl: n(e.templateUrl), transclude: e.transclude, scope: {}, bindToController: e.bindings || {}, restrict: 'E', require: e.require }; return i(e, function (t, e) { e.charAt(0) === '$' && (o[e] = t) }), o } var r = e.controller || function () {}; return i(e, function (t, e) { e.charAt(0) === '$' && (n[e] = t, T(r) && (r[e] = t)) }), n.$inject = ['$injector'], this.directive(t, n) }, this.aHrefSanitizationWhitelist = function (t) { return y(t) ? (n.aHrefSanitizationWhitelist(t), this) : n.aHrefSanitizationWhitelist() }, this.imgSrcSanitizationWhitelist = function (t) { return y(t) ? (n.imgSrcSanitizationWhitelist(t), this) : n.imgSrcSanitizationWhitelist() }; let A = !0; this.debugInfoEnabled = function (t) { return y(t) ? (A = t, this) : A }; let P = !1; this.preAssignBindingsEnabled = function (t) { return y(t) ? (P = t, this) : P }; let D = 10; this.onChangesTtl = function (t) { return arguments.length ? (D = t, this) : D }; let O = !0; this.commentDirectivesEnabled = function (t) { return arguments.length ? (O = t, this) : O }; let L = !0; this.cssClassDirectivesEnabled = function (t) { return arguments.length ? (L = t, this) : L }, this.$get = ['$injector', '$interpolate', '$exceptionHandler', '$templateRequest', '$parse', '$controller', '$rootScope', '$sce', '$animate', '$$sanitizeUri', function (e, n, r, a, s, l, u, m, E, I) { function R () { try { if (!--At) throw $t = void 0, ea('infchng', '{0} $onChanges() iterations reached. Aborting!\n', D); u.$apply(function () { for (var t = [], e = 0, n = $t.length; e < n; ++e) try { $t[e]() } catch (e) { t.push(e) } if ($t = void 0, t.length) throw t }) } finally { At++ } } function F (t, e) { if (e) { let n; let i; let r; const a = Object.keys(e); for (n = 0, i = a.length; n < i; n++)r = a[n], this[r] = e[r] } else this.$attr = {}; this.$$element = t } function z (t, e, n) { Mt.innerHTML = '<span ' + e + '>'; const i = Mt.firstChild.attributes; const r = i[0]; i.removeNamedItem(r.name), r.value = n, t.attributes.setNamedItem(r) } function j (t, e) { try { t.addClass(e) } catch (t) {} } function H (t, e, n, i, r) { t instanceof qi || (t = qi(t)); let a = q(t, e, t, n, i, r); H.$$addScopeClass(t); let o = null; return function (e, n, i) { if (!t) throw ea('multilink', 'This element has already been linked.'); ct(e, 'scope'), r && r.needsNewScope && (e = e.$parent.$new()), i = i || {}; let s = i.parentBoundTranscludeFn; const l = i.transcludeControllers; const c = i.futureParentElement; s && s.$$boundTransclude && (s = s.$$boundTransclude), o || (o = W(c)); let u; if (u = o !== 'html' ? qi(gt(o, qi('<div>').append(t).html())) : n ? Lr.clone.call(t) : t, l) for (const h in l)u.data('$' + h + 'Controller', l[h].instance); return H.$$addScopeInfo(u, e), n && n(u, e), a && a(e, u, u, s), n || (t = a = null), u } } function W (t) { const e = t && t[0]; return e && N(e) !== 'foreignobject' && Qi.call(e).match(/SVG/) ? 'svg' : 'html' } function q (t, e, n, i, r, a) { function o (t, n, i, r) { let a, o, s, l, c, u, h, p, m; if (d) { const g = n.length; for (m = new Array(g), c = 0; c < f.length; c += 3)h = f[c], m[h] = n[h] } else m = n; for (c = 0, u = f.length; c < u;)s = m[f[c++]], a = f[c++], o = f[c++], a ? (a.scope ? (l = t.$new(), H.$$addScopeInfo(qi(s), l)) : l = t, p = a.transcludeOnThisElement ? Y(t, a.transclude, r) : !a.templateOnThisElement && r ? r : !r && e ? Y(t, e) : null, a(o, l, s, i, p)) : o && o(t, s.childNodes, void 0, r) } for (var s, l, c, u, h, p, d, f = [], m = ar(t) || t instanceof qi, g = 0; g < t.length; g++)s = new F(), Wi === 11 && X(t, g, m), l = Z(t[g], [], s, g === 0 ? i : void 0, r), c = l.length ? nt(l, t[g], s, e, n, null, [], [], a) : null, c && c.scope && H.$$addScopeClass(s.$$element), h = c && c.terminal || !(u = t[g].childNodes) || !u.length ? null : q(u, c ? (c.transcludeOnThisElement || !c.templateOnThisElement) && c.transclude : e), (c || h) && (f.push(g, c, h), p = !0, d = d || c), a = null; return p ? o : null } function X (t, e, n) { let i; const r = t[e]; const a = r.parentNode; if (r.nodeType === vr) for (;;) { if (!(i = a ? r.nextSibling : t[e + 1]) || i.nodeType !== vr) break; r.nodeValue = r.nodeValue + i.nodeValue, i.parentNode && i.parentNode.removeChild(i), n && i === t[e + 1] && t.splice(e + 1, 1) } } function Y (t, e, n) { function i (i, r, a, o, s) { return i || (i = t.$new(!1, s), i.$$transcluded = !0), e(i, r, { parentBoundTranscludeFn: n, transcludeControllers: a, futureParentElement: o }) } const r = i.$$slots = ft(); for (const a in e.$$slots)e.$$slots[a] ? r[a] = Y(t, e.$$slots[a], n) : r[a] = null; return i } function Z (t, e, n, i, r) { let a; let o; let s; const l = t.nodeType; const c = n.$attr; switch (l) { case gr:o = N(t), ot(e, be(o), 'E', i, r); for (var u, h, p, d, f, m, g = t.attributes, v = 0, y = g && g.length; v < y; v++) { let x = !1; let $ = !1; u = g[v], h = u.name, f = u.value, d = be(h), m = Lt.test(d), m && (h = h.replace(ia, '').substr(8).replace(/_(.)/g, function (t, e) { return e.toUpperCase() })); const T = d.match(It); T && st(T[1]) && (x = h, $ = h.substr(0, h.length - 5) + 'end', h = h.substr(0, h.length - 6)), p = be(h.toLowerCase()), c[p] = h, !m && n.hasOwnProperty(p) || (n[p] = f, Xt(t, p) && (n[p] = !0)), yt(t, e, f, p, m), ot(e, p, 'A', i, r, x, $) } if (o === 'input' && t.getAttribute('type') === 'hidden' && t.setAttribute('autocomplete', 'off'), !Et) break; if (s = t.className, b(s) && (s = s.animVal), w(s) && s !== '') for (;a = _.exec(s);)p = be(a[2]), ot(e, p, 'C', i, r) && (n[p] = sr(a[3])), s = s.substr(a.index + a[0].length); break; case vr:mt(e, t.nodeValue); break; case yr:if (!Ct) break; J(t, e, n, i, r) } return e.sort(pt), e } function J (t, e, n, i, r) { try { const a = x.exec(t.nodeValue); if (a) { const o = be(a[1]); ot(e, o, 'M', i, r) && (n[o] = sr(a[2])) } } catch (t) {} } function Q (t, e, n) { const i = []; let r = 0; if (e && t.hasAttribute && t.hasAttribute(e)) do { if (!t) throw ea('uterdir', "Unterminated attribute, found '{0}' but no matching '{1}' found.", e, n); t.nodeType === gr && (t.hasAttribute(e) && r++, t.hasAttribute(n) && r--), i.push(t), t = t.nextSibling } while (r > 0); else i.push(t); return qi(i) } function tt (t, e, n) { return function (i, r, a, o, s) { return r = Q(r[0], e, n), t(i, r, a, o, s) } } function et (t, e, n, i, r, a) { let o; return t ? H(e, n, i, r, a) : function () { return o || (o = H(e, n, i, r, a), e = n = a = null), o.apply(this, arguments) } } function nt (t, e, n, a, o, s, l, u, h) { function p (t, e, n, i) { t && (n && (t = tt(t, n, i)), t.require = f.require, t.directiveName = m, (S === f || f.$$isolateScope) && (t = xt(t, { isolateScope: !0 })), l.push(t)), e && (n && (e = tt(e, n, i)), e.require = f.require, e.directiveName = m, (S === f || f.$$isolateScope) && (e = xt(e, { isolateScope: !0 })), u.push(e)) } function d (t, a, o, s, h) { function p (t, e, n, i) { let r; if (C(t) || (i = n, n = e, e = t, t = void 0), D && (r = x), n || (n = D ? E.parent() : E), !i) return h(t, e, r, n, U); const a = h.$$slots[i]; if (a) return a(t, e, r, n, U); if (v(a)) throw ea('noslot', 'No parent directive that requires a transclusion with slot name "{0}". Element: {1}', i, K(E)) } let d, f, m, g, y, x, w, E, A, k; e === o ? (A = n, E = n.$$element) : (E = qi(o), A = new F(E, n)), y = a, S ? g = a.$new(!0) : _ && (y = a.$parent), h && (w = p, w.$$boundTransclude = h, w.isSlotFilled = function (t) { return !!h.$$slots[t] }), $ && (x = rt(E, A, w, $, g, a, S)), S && (H.$$addScopeInfo(E, g, !0, !(M && (M === S || M === S.$$originalDirective))), H.$$addScopeClass(E, !0), g.$$isolateBindings = S.$$isolateBindings, k = _t(a, A, g, g.$$isolateBindings, S), k.removeWatches && g.$on('$destroy', k.removeWatches)); for (const O in x) { const L = $[O]; const I = x[O]; const R = L.$$bindings.bindToController; if (P) { I.bindingInfo = R ? _t(y, A, I.instance, R, L) : {}; const N = I(); N !== I.instance && (I.instance = N, E.data('$' + L.name + 'Controller', N), I.bindingInfo.removeWatches && I.bindingInfo.removeWatches(), I.bindingInfo = _t(y, A, I.instance, R, L)) } else I.instance = I(), E.data('$' + L.name + 'Controller', I.instance), I.bindingInfo = _t(y, A, I.instance, R, L) } for (i($, function (t, e) { const n = t.require; t.bindToController && !ar(n) && b(n) && c(x[e].instance, it(e, n, E, x)) }), i(x, function (t) { const e = t.instance; if (T(e.$onChanges)) try { e.$onChanges(t.bindingInfo.initialChanges) } catch (t) { r(t) } if (T(e.$onInit)) try { e.$onInit() } catch (t) { r(t) }T(e.$doCheck) && (y.$watch(function () { e.$doCheck() }), e.$doCheck()), T(e.$onDestroy) && y.$on('$destroy', function () { e.$onDestroy() }) }), d = 0, f = l.length; d < f; d++)m = l[d], wt(m, m.isolateScope ? g : a, E, A, m.require && it(m.directiveName, m.require, E, x), w); var U = a; for (S && (S.template || S.templateUrl === null) && (U = g), t && t(U, o.childNodes, void 0, h), d = u.length - 1; d >= 0; d--)m = u[d], wt(m, m.isolateScope ? g : a, E, A, m.require && it(m.directiveName, m.require, E, x), w); i(x, function (t) { const e = t.instance; T(e.$postLink) && e.$postLink() }) }h = h || {}; for (var f, m, g, y, x, w = -Number.MAX_VALUE, _ = h.newScopeDirective, $ = h.controllerDirectives, S = h.newIsolateScopeDirective, M = h.templateDirective, E = h.nonTlbTranscludeDirective, A = !1, k = !1, D = h.hasElementTranscludeDirective, O = n.$$element = qi(e), L = s, I = a, R = !1, U = !1, z = 0, B = t.length; z < B; z++) { f = t[z]; const j = f.$$start; const W = f.$$end; if (j && (O = Q(e, j, W)), g = void 0, w > f.priority) break; if (x = f.scope, x && (f.templateUrl || (b(x) ? (dt('new/isolated scope', S || _, f, O), S = f) : dt('new/isolated scope', S, f, O)), _ = _ || f), m = f.name, !R && (f.replace && (f.templateUrl || f.template) || f.transclude && !f.$$tlb)) { for (var q, X = z + 1; q = t[X++];) if (q.transclude && !q.$$tlb || q.replace && (q.templateUrl || q.template)) { U = !0; break }R = !0 } if (!f.templateUrl && f.controller && ($ = $ || ft(), dt("'" + m + "' controller", $[m], f, O), $[m] = f), x = f.transclude) if (A = !0, f.$$tlb || (dt('transclusion', E, f, O), E = f), x === 'element')D = !0, w = f.priority, g = O, O = n.$$element = qi(H.$$createComment(m, n[m])), e = O[0], bt(o, V(g), e), g[0].$$parentNode = g[0].parentNode, I = et(U, g, a, w, L && L.name, { nonTlbTranscludeDirective: E }); else { var Y = ft(); if (b(x)) { g = []; var J = ft(); var nt = ft(); i(x, function (t, e) { const n = t.charAt(0) === '?'; t = n ? t.substring(1) : t, J[t] = e, Y[e] = null, nt[e] = n }), i(O.contents(), function (t) { const e = J[be(N(t))]; e ? (nt[e] = !0, Y[e] = Y[e] || [], Y[e].push(t)) : g.push(t) }), i(nt, function (t, e) { if (!t) throw ea('reqslot', 'Required transclusion slot `{0}` was not filled.', e) }); for (const ot in Y)Y[ot] && (Y[ot] = et(U, Y[ot], a)) } else g = qi(Dt(e)).contents(); O.empty(), I = et(U, g, a, void 0, void 0, { needsNewScope: f.$$isolateScope || f.$$newScope }), I.$$slots = Y } if (f.template) if (k = !0, dt('template', M, f, O), M = f, x = T(f.template) ? f.template(O, n) : f.template, x = Ot(x), f.replace) { if (L = f, g = Tt(x) ? [] : we(gt(f.templateNamespace, sr(x))), e = g[0], g.length !== 1 || e.nodeType !== gr) throw ea('tplrt', "Template for directive '{0}' must have exactly one root element. {1}", m, ''); bt(o, O, e); const st = { $attr: {} }; const lt = Z(e, [], st); const ct = t.splice(z + 1, t.length - (z + 1)); (S || _) && at(lt, S, _), t = t.concat(lt).concat(ct), ut(n, st), B = t.length } else O.html(x); if (f.templateUrl)k = !0, dt('template', M, f, O), M = f, f.replace && (L = f), d = ht(t.splice(z, t.length - z), O, n, o, A && I, l, u, { controllerDirectives: $, newScopeDirective: _ !== f && _, newIsolateScopeDirective: S, templateDirective: M, nonTlbTranscludeDirective: E }), B = t.length; else if (f.compile) try { y = f.compile(O, n, I); const pt = f.$$originalDirective || f; T(y) ? p(null, G(pt, y), j, W) : y && p(G(pt, y.pre), G(pt, y.post), j, W) } catch (t) { r(t, K(O)) }f.terminal && (d.terminal = !0, w = Math.max(w, f.priority)) } return d.scope = _ && !0 === _.scope, d.transcludeOnThisElement = A, d.templateOnThisElement = k, d.transclude = I, h.hasElementTranscludeDirective = D, d } function it (t, e, n, r) { let a; if (w(e)) { const o = e.match(S); const s = e.substring(o[0].length); const l = o[1] || o[3]; const c = o[2] === '?'; if (l === '^^' ? n = n.parent() : (a = r && r[s], a = a && a.instance), !a) { const u = '$' + s + 'Controller'; a = l ? n.inheritedData(u) : n.data(u) } if (!a && !c) throw ea('ctreq', "Controller '{0}', required by directive '{1}', can't be found!", s, t) } else if (ar(e)) { a = []; for (let h = 0, p = e.length; h < p; h++)a[h] = it(t, e[h], n, r) } else b(e) && (a = {}, i(e, function (e, i) { a[i] = it(t, e, n, r) })); return a || null } function rt (t, e, n, i, r, a, o) { const s = ft(); for (const c in i) { const u = i[c]; const h = { $scope: u === o || u.$$isolateScope ? r : a, $element: t, $attrs: e, $transclude: n }; let p = u.controller; p === '@' && (p = e[u.name]); const d = l(p, h, !0, u.controllerAs); s[u.name] = d, t.data('$' + u.name + 'Controller', d.instance) } return s } function at (t, e, n) { for (let i = 0, r = t.length; i < r; i++)t[i] = p(t[i], { $$isolateScope: e, $$newScope: n }) } function ot (t, n, i, r, a, s, l) { if (n === a) return null; let c = null; if (h.hasOwnProperty(n)) for (var u, d = e.get(n + g), f = 0, m = d.length; f < m; f++) if (u = d[f], (v(r) || r > u.priority) && u.restrict.indexOf(i) !== -1) { if (s && (u = p(u, { $$start: s, $$end: l })), !u.$$bindings) { const y = u.$$bindings = o(u, u.name); b(y.isolateScope) && (u.$$isolateBindings = y.isolateScope) }t.push(u), c = u } return c } function st (t) { if (h.hasOwnProperty(t)) for (var n, i = e.get(t + g), r = 0, a = i.length; r < a; r++) if (n = i[r], n.multiElement) return !0; return !1 } function ut (t, e) { const n = e.$attr; const r = t.$attr; i(t, function (i, r) { r.charAt(0) !== '$' && (e[r] && e[r] !== i && (i.length ? i += (r === 'style' ? ';' : ' ') + e[r] : i = e[r]), t.$set(r, i, !0, n[r])) }), i(e, function (e, i) { t.hasOwnProperty(i) || i.charAt(0) === '$' || (t[i] = e, i !== 'class' && i !== 'style' && (r[i] = n[i])) }) } function ht (t, e, n, o, s, l, c, u) { let h; let d; let f = []; const m = e[0]; const g = t.shift(); const v = p(g, { templateUrl: null, transclude: null, replace: null, $$originalDirective: g }); const y = T(g.templateUrl) ? g.templateUrl(e, n) : g.templateUrl; const x = g.templateNamespace; return e.empty(), a(y).then(function (r) { let a, p, w, _; if (r = Ot(r), g.replace) { if (w = Tt(r) ? [] : we(gt(x, sr(r))), a = w[0], w.length !== 1 || a.nodeType !== gr) throw ea('tplrt', "Template for directive '{0}' must have exactly one root element. {1}", g.name, y); p = { $attr: {} }, bt(o, e, a); const $ = Z(a, [], p); b(g.scope) && at($, !0), t = $.concat(t), ut(n, p) } else a = m, e.html(r); for (t.unshift(v), h = nt(t, a, n, s, e, g, l, c, u), i(o, function (t, n) { t === a && (o[n] = e[0]) }), d = q(e[0].childNodes, s); f.length;) { const T = f.shift(); const S = f.shift(); const M = f.shift(); const C = f.shift(); let E = e[0]; if (!T.$$destroyed) { if (S !== m) { const A = S.className; u.hasElementTranscludeDirective && g.replace || (E = Dt(a)), bt(M, qi(S), E), j(qi(E), A) }_ = h.transcludeOnThisElement ? Y(T, h.transclude, C) : C, h(d, T, E, o, _) } }f = null }).catch(function (t) { t instanceof Error && r(t) }), function (t, e, n, i, r) { let a = r; e.$$destroyed || (f ? f.push(e, n, i, a) : (h.transcludeOnThisElement && (a = Y(e, h.transclude, r)), h(d, e, n, i, a))) } } function pt (t, e) { const n = e.priority - t.priority; return n !== 0 ? n : t.name !== e.name ? t.name < e.name ? -1 : 1 : t.index - e.index } function dt (t, e, n, i) { function r (t) { return t ? ' (module: ' + t + ')' : '' } if (e) throw ea('multidir', 'Multiple directives [{0}{1}, {2}{3}] asking for {4} on: {5}', e.name, r(e.$$moduleName), n.name, r(n.$$moduleName), t, K(i)) } function mt (t, e) { const i = n(e, !0); i && t.push({ priority: 0, compile: function (t) { const e = t.parent(); const n = !!e.length; return n && H.$$addBindingClass(e), function (t, e) { const r = e.parent(); n || H.$$addBindingClass(r), H.$$addBindingInfo(r, i.expressions), t.$watch(i, function (t) { e[0].nodeValue = t }) } } }) } function gt (e, n) { switch (e = ji(e || 'html')) { case 'svg':case 'math':var i = t.document.createElement('div'); return i.innerHTML = '<' + e + '>' + n + '</' + e + '>', i.childNodes[0].childNodes; default:return n } } function vt (t, e) { if (e === 'srcdoc') return m.HTML; const n = N(t); if (e === 'src' || e === 'ngSrc') { if (['img', 'video', 'audio', 'source', 'track'].indexOf(n) === -1) return m.RESOURCE_URL } else if (e === 'xlinkHref' || n === 'form' && e === 'action' || n === 'link' && e === 'href') return m.RESOURCE_URL } function yt (t, e, i, r, a) { const o = vt(t, r); const s = !a; const l = $[r] || a; let c = n(i, s, o, l); if (c) { if (r === 'multiple' && N(t) === 'select') throw ea('selmulti', "Binding to the 'multiple' attribute is not supported. Element: {0}", K(t)); if (M.test(r)) throw ea('nodomevents', 'Interpolations for HTML DOM event attributes are disallowed.  Please use the ng- versions (such as ng-click instead of onclick) instead.'); e.push({ priority: 100, compile: function () { return { pre: function (t, e, a) { const s = a.$$observers || (a.$$observers = ft()); const u = a[r]; u !== i && (c = u && n(u, !0, o, l), i = u), c && (a[r] = c(t), (s[r] || (s[r] = [])).$$inter = !0, (a.$$observers && a.$$observers[r].$$scope || t).$watch(c, function (t, e) { r === 'class' && t !== e ? a.$updateClass(t, e) : a.$set(r, t) })) } } } }) } } function bt (e, n, i) { let r; let a; const o = n[0]; const s = n.length; const l = o.parentNode; if (e) for (r = 0, a = e.length; r < a; r++) if (e[r] === o) { e[r++] = i; for (let c = r, u = c + s - 1, h = e.length; c < h; c++, u++)u < h ? e[c] = e[u] : delete e[c]; e.length -= s - 1, e.context === o && (e.context = i); break }l && l.replaceChild(i, o); const p = t.document.createDocumentFragment(); for (r = 0; r < s; r++)p.appendChild(n[r]); for (qi.hasData(o) && (qi.data(i, qi.data(o)), qi(o).off('$destroy')), qi.cleanData(p.querySelectorAll('*')), r = 1; r < s; r++) delete n[r]; n[0] = i, n.length = 1 } function xt (t, e) { return c(function () { return t.apply(null, arguments) }, t, e) } function wt (t, e, n, i, a, o) { try { t(e, n, i, a, o) } catch (t) { r(t, K(n)) } } function _t (t, e, r, a, o) { function l (e, n, i) { !T(r.$onChanges) || n === i || n !== n && i !== i || ($t || (t.$$postDigest(R), $t = []), u || (u = {}, $t.push(c)), u[e] && (i = u[e].previousValue), u[e] = new ye(i, n)) } function c () { r.$onChanges(u), u = void 0 } let u; const h = []; const p = {}; return i(a, function (i, a) { let c; let u; let f; let m; let g; const v = i.attrName; const y = i.optional; const b = i.mode; switch (b) { case '@':y || Bi.call(e, v) || (r[a] = e[v] = void 0), g = e.$observe(v, function (t) { if (w(t) || k(t)) { const e = r[a]; l(a, t, e), r[a] = t } }), e.$$observers[v].$$scope = t, c = e[v], w(c) ? r[a] = n(c)(t) : k(c) && (r[a] = c), p[a] = new ye(na, r[a]), h.push(g); break; case '=':if (!Bi.call(e, v)) { if (y) break; e[v] = void 0 } if (y && !e[v]) break; u = s(e[v]), m = u.literal ? B : function (t, e) { return t === e || t !== t && e !== e }, f = u.assign || function () { throw c = r[a] = u(t), ea('nonassign', "Expression '{0}' in attribute '{1}' used with directive '{2}' is non-assignable!", e[v], v, o.name) }, c = r[a] = u(t); var x = function (e) { return m(e, r[a]) || (m(e, c) ? f(t, e = r[a]) : r[a] = e), c = e }; x.$stateful = !0, g = i.collection ? t.$watchCollection(e[v], x) : t.$watch(s(e[v], x), null, u.literal), h.push(g); break; case '<':if (!Bi.call(e, v)) { if (y) break; e[v] = void 0 } if (y && !e[v]) break; u = s(e[v]); var _ = u.literal; var $ = r[a] = u(t); p[a] = new ye(na, r[a]), g = t.$watch(u, function (t, e) { if (e === t) { if (e === $ || _ && B(e, $)) return; e = $ }l(a, t, e), r[a] = t }, _), h.push(g); break; case '&':if ((u = e.hasOwnProperty(v) ? s(e[v]) : d) === d && y) break; r[a] = function (e) { return u(t, e) } } }), { initialChanges: p, removeWatches: h.length && function () { for (let t = 0, e = h.length; t < e; ++t)h[t]() } } } let $t; const St = /^\w/; var Mt = t.document.createElement('div'); var Ct = O; var Et = L; var At = D; F.prototype = { $normalize: be, $addClass: function (t) { t && t.length > 0 && E.addClass(this.$$element, t) }, $removeClass: function (t) { t && t.length > 0 && E.removeClass(this.$$element, t) }, $updateClass: function (t, e) { const n = xe(t, e); n && n.length && E.addClass(this.$$element, n); const i = xe(e, t); i && i.length && E.removeClass(this.$$element, i) }, $set: function (t, e, n, a) { let o; const s = this.$$element[0]; const l = Xt(s, t); const c = Yt(t); let u = t; if (l ? (this.$$element.prop(t, e), a = l) : c && (this[c] = e, u = c), this[t] = e, a ? this.$attr[t] = a : (a = this.$attr[t]) || (this.$attr[t] = a = lt(t, '-')), (o = N(this.$$element)) === 'a' && (t === 'href' || t === 'xlinkHref') || o === 'img' && t === 'src') this[t] = e = I(e, t === 'src'); else if (o === 'img' && t === 'srcset' && y(e)) { for (var h = '', p = sr(e), d = /\s/.test(p) ? /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/ : /(,)/, f = p.split(d), m = Math.floor(f.length / 2), g = 0; g < m; g++) { const b = 2 * g; h += I(sr(f[b]), !0), h += ' ' + sr(f[b + 1]) } const x = sr(f[2 * g]).split(/\s/); h += I(sr(x[0]), !0), x.length === 2 && (h += ' ' + sr(x[1])), this[t] = e = h }!1 !== n && (e === null || v(e) ? this.$$element.removeAttr(a) : St.test(a) ? this.$$element.attr(a, e) : z(this.$$element[0], a, e)); const w = this.$$observers; w && i(w[u], function (t) { try { t(e) } catch (t) { r(t) } }) }, $observe: function (t, e) { const n = this; const i = n.$$observers || (n.$$observers = ft()); const r = i[t] || (i[t] = []); return r.push(e), u.$evalAsync(function () { r.$$inter || !n.hasOwnProperty(t) || v(n[t]) || e(n[t]) }), function () { U(r, e) } } }; const Pt = n.startSymbol(); const kt = n.endSymbol(); var Ot = Pt === '{{' && kt === '}}' ? f : function (t) { return t.replace(/\{\{/g, Pt).replace(/}}/g, kt) }; var Lt = /^ngAttr[A-Z]/; var It = /^(.+)Start$/; return H.$$addBindingInfo = A ? function (t, e) { let n = t.data('$binding') || []; ar(e) ? n = n.concat(e) : n.push(e), t.data('$binding', n) } : d, H.$$addBindingClass = A ? function (t) { j(t, 'ng-binding') } : d, H.$$addScopeInfo = A ? function (t, e, n, i) { const r = n ? i ? '$isolateScopeNoTemplate' : '$isolateScope' : '$scope'; t.data(r, e) } : d, H.$$addScopeClass = A ? function (t, e) { j(t, e ? 'ng-isolate-scope' : 'ng-scope') } : d, H.$$createComment = function (e, n) { let i = ''; return A && (i = ' ' + (e || '') + ': ', n && (i += n + ' ')), t.document.createComment(i) }, H }] } function ye (t, e) { this.previousValue = t, this.currentValue = e } function be (t) { return t.replace(ia, '').replace(ra, _t) } function xe (t, e) { let n = ''; const i = t.split(/\s+/); const r = e.split(/\s+/); t:for (let a = 0; a < i.length; a++) { for (var o = i[a], s = 0; s < r.length; s++) if (o === r[s]) continue t; n += (n.length > 0 ? ' ' : '') + o } return n } function we (t) { t = qi(t); let e = t.length; if (e <= 1) return t; for (;e--;) { const n = t[e]; (n.nodeType === yr || n.nodeType === vr && n.nodeValue.trim() === '') && Ki.call(t, e, 1) } return t } function _e (t, e) { if (e && w(e)) return e; if (w(t)) { const n = oa.exec(t); if (n) return n[3] } } function $e () { const t = {}; let n = !1; this.has = function (e) { return t.hasOwnProperty(e) }, this.register = function (e, n) { ht(e, 'controller'), b(e) ? c(t, e) : t[e] = n }, this.allowGlobals = function () { n = !0 }, this.$get = ['$injector', '$window', function (i, r) { function a (t, n, i, r) { if (!t || !b(t.$scope)) throw e('$controller')('noscp', "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.", r, n); t.$scope[n] = i } return function (e, o, s, l) { let u, h, p, d; if (s = !0 === s, l && w(l) && (d = l), w(e)) { if (!(h = e.match(oa))) throw aa('ctrlfmt', "Badly formed controller string '{0}'. Must match `__name__ as __id__` or `__name__`.", e); if (p = h[1], d = d || h[3], !(e = t.hasOwnProperty(p) ? t[p] : pt(o.$scope, p, !0) || (n ? pt(r, p, !0) : void 0))) throw aa('ctrlreg', "The controller with the name '{0}' is not registered.", p); ut(e, p, !0) } if (s) { const f = (ar(e) ? e[e.length - 1] : e).prototype; return u = Object.create(f || null), d && a(o, d, u, p || e.name), c(function () { const t = i.invoke(e, u, o, p); return t !== u && (b(t) || T(t)) && (u = t, d && a(o, d, u, p || e.name)), u }, { instance: u, identifier: d }) } return u = i.instantiate(e, o, p), d && a(o, d, u, p || e.name), u } }] } function Te () { this.$get = ['$window', function (t) { return qi(t.document) }] } function Se () { this.$get = ['$document', '$rootScope', function (t, e) { function n () { r = i.hidden } var i = t[0]; var r = i && i.hidden; return t.on('visibilitychange', n), e.$on('$destroy', function () { t.off('visibilitychange', n) }), function () { return r } }] } function Me () { this.$get = ['$log', function (t) { return function (e, n) { t.error.apply(t, arguments) } }] } function Ce (t) { return b(t) ? $(t) ? t.toISOString() : W(t) : t } function Ee () { this.$get = function () { return function (t) { if (!t) return ''; const e = []; return r(t, function (t, n) { t === null || v(t) || (ar(t) ? i(t, function (t) { e.push(nt(n) + '=' + nt(Ce(t))) }) : e.push(nt(n) + '=' + nt(Ce(t)))) }), e.join('&') } } } function Ae () { this.$get = function () { return function (t) { function e (t, a, o) { t === null || v(t) || (ar(t) ? i(t, function (t, n) { e(t, a + '[' + (b(t) ? n : '') + ']') }) : b(t) && !$(t) ? r(t, function (t, n) { e(t, a + (o ? '' : '[') + n + (o ? '' : ']')) }) : n.push(nt(a) + '=' + nt(Ce(t)))) } if (!t) return ''; var n = []; return e(t, '', !0), n.join('&') } } } function Pe (t, e) { if (w(t)) { const n = t.replace(pa, '').trim(); if (n) { const i = e('Content-Type'); (i && i.indexOf(la) === 0 || ke(n)) && (t = q(n)) } } return t } function ke (t) { const e = t.match(ua); return e && ha[e[0]].test(t) } function De (t) { function e (t, e) { t && (r[t] = r[t] ? r[t] + ', ' + e : e) } let n; var r = ft(); return w(t) ? i(t.split('\n'), function (t) { n = t.indexOf(':'), e(ji(sr(t.substr(0, n))), sr(t.substr(n + 1))) }) : b(t) && i(t, function (t, n) { e(ji(n), sr(t)) }), r } function Oe (t) { let e; return function (n) { if (e || (e = De(t)), n) { let i = e[ji(n)]; return void 0 === i && (i = null), i } return e } } function Le (t, e, n, r) { return T(r) ? r(t, e, n) : (i(r, function (i) { t = i(t, e, n) }), t) } function Ie (t) { return t >= 200 && t < 300 } function Re () { const t = this.defaults = { transformResponse: [Pe], transformRequest: [function (t) { return !b(t) || E(t) || P(t) || A(t) ? t : W(t) }], headers: { common: { Accept: 'application/json, text/plain, */*' }, post: vt(ca), put: vt(ca), patch: vt(ca) }, xsrfCookieName: 'XSRF-TOKEN', xsrfHeaderName: 'X-XSRF-TOKEN', paramSerializer: '$httpParamSerializer', jsonpCallbackParam: 'callback' }; let n = !1; this.useApplyAsync = function (t) { return y(t) ? (n = !!t, this) : n }; const r = this.interceptors = []; this.$get = ['$browser', '$httpBackend', '$$cookieReader', '$cacheFactory', '$rootScope', '$q', '$injector', '$sce', function (a, o, s, l, u, h, p, f) { function m (n) { function r (t, e) { for (let n = 0, i = e.length; n < i;) { const r = e[n++]; const a = e[n++]; t = t.then(r, a) } return e.length = 0, t } function o () { a.$$completeOutstandingRequest(d) } function s (t, e) { let n; const r = {}; return i(t, function (t, i) { T(t) ? (n = t(e)) != null && (r[i] = n) : r[i] = t }), r } function l (e) { const n = e.headers; const r = Le(e.data, Oe(n), void 0, e.transformRequest); return v(r) && i(n, function (t, e) { ji(e) === 'content-type' && delete n[e] }), v(e.withCredentials) && !v(t.withCredentials) && (e.withCredentials = t.withCredentials), g(e, r).then(u, u) } function u (t) { const e = c({}, t); return e.data = Le(t.data, t.headers, t.status, m.transformResponse), Ie(t.status) ? e : h.reject(e) } if (!b(n)) throw e('$http')('badreq', 'Http request configuration must be an object.  Received: {0}', n); if (!w(f.valueOf(n.url))) throw e('$http')('badreq', 'Http request configuration url must be a string or a $sce trusted object.  Received: {0}', n.url); var m = c({ method: 'get', transformRequest: t.transformRequest, transformResponse: t.transformResponse, paramSerializer: t.paramSerializer, jsonpCallbackParam: t.jsonpCallbackParam }, n); m.headers = (function (e) { let n; let i; let r; let a = t.headers; const o = c({}, e.headers); a = c({}, a.common, a[ji(e.method)]); t:for (n in a) { i = ji(n); for (r in o) if (ji(r) === i) continue t; o[n] = a[n] } return s(o, vt(e)) }(n)), m.method = Vi(m.method), m.paramSerializer = w(m.paramSerializer) ? p.get(m.paramSerializer) : m.paramSerializer, a.$$incOutstandingRequestCount(); const y = []; const x = []; let _ = h.resolve(m); return i(S, function (t) { (t.request || t.requestError) && y.unshift(t.request, t.requestError), (t.response || t.responseError) && x.push(t.response, t.responseError) }), _ = r(_, y), _ = _.then(l), _ = r(_, x), _ = _.finally(o) } function g (e, r) { function a (t) { if (t) { const e = {}; return i(t, function (t, i) { e[i] = function (e) { function i () { t(e) }n ? u.$applyAsync(i) : u.$$phase ? i() : u.$apply(i) } }), e } } function l (t, e, i, r) { function a () { c(e, t, i, r) }g && (Ie(t) ? g.put(A, [t, e, De(i), r]) : g.remove(A)), n ? u.$applyAsync(a) : (a(), u.$$phase || u.$apply()) } function c (t, n, i, r) { n = n >= -1 ? n : 0, (Ie(n) ? S.resolve : S.reject)({ data: t, status: n, headers: Oe(i), config: e, statusText: r }) } function p (t) { c(t.data, t.status, vt(t.headers()), t.statusText) } function d () { const t = m.pendingRequests.indexOf(e); t !== -1 && m.pendingRequests.splice(t, 1) } let g; let T; var S = h.defer(); const M = S.promise; const C = e.headers; const E = ji(e.method) === 'jsonp'; var A = e.url; if (E ? A = f.getTrustedResourceUrl(A) : w(A) || (A = f.valueOf(A)), A = x(A, e.paramSerializer(e.params)), E && (A = _(A, e.jsonpCallbackParam)), m.pendingRequests.push(e), M.then(d, d), !e.cache && !t.cache || !1 === e.cache || e.method !== 'GET' && e.method !== 'JSONP' || (g = b(e.cache) ? e.cache : b(t.cache) ? t.cache : $), g && (T = g.get(A), y(T) ? D(T) ? T.then(p, p) : ar(T) ? c(T[1], T[0], vt(T[2]), T[3]) : c(T, 200, {}, 'OK') : g.put(A, M)), v(T)) { const P = In(e.url) ? s()[e.xsrfCookieName || t.xsrfCookieName] : void 0; P && (C[e.xsrfHeaderName || t.xsrfHeaderName] = P), o(e.method, A, r, l, C, e.timeout, e.withCredentials, e.responseType, a(e.eventHandlers), a(e.uploadEventHandlers)) } return M } function x (t, e) { return e.length > 0 && (t += (t.indexOf('?') === -1 ? '?' : '&') + e), t } function _ (t, e) { if (/[&?][^=]+=JSON_CALLBACK/.test(t)) throw da('badjsonp', 'Illegal use of JSON_CALLBACK in url, "{0}"', t); if (new RegExp('[&?]' + e + '=').test(t)) throw da('badjsonp', 'Illegal use of callback param, "{0}", in url, "{1}"', e, t); return t += (t.indexOf('?') === -1 ? '?' : '&') + e + '=JSON_CALLBACK' } var $ = l('$http'); t.paramSerializer = w(t.paramSerializer) ? p.get(t.paramSerializer) : t.paramSerializer; var S = []; return i(r, function (t) { S.unshift(w(t) ? p.get(t) : p.invoke(t)) }), m.pendingRequests = [], (function (t) { i(arguments, function (t) { m[t] = function (e, n) { return m(c({}, n || {}, { method: t, url: e })) } }) }('get', 'delete', 'head', 'jsonp')), (function (t) { i(arguments, function (t) { m[t] = function (e, n, i) { return m(c({}, i || {}, { method: t, url: e, data: n })) } }) }('post', 'put', 'patch')), m.defaults = t, m }] } function Ne () { this.$get = function () { return function () { return new t.XMLHttpRequest() } } } function Fe () { this.$get = ['$browser', '$jsonpCallbacks', '$document', '$xhrFactory', function (t, e, n, i) { return Ue(t, i, t.defer, e, n[0]) }] } function Ue (t, e, n, r, a) {
    function o (t, e, n) { t = t.replace('JSON_CALLBACK', e); let i = a.createElement('script'); let o = null; return i.type = 'text/javascript', i.src = t, i.async = !0, o = function (t) { i.removeEventListener('load', o), i.removeEventListener('error', o), a.body.removeChild(i), i = null; let s = -1; let l = 'unknown'; t && (t.type !== 'load' || r.wasCalled(e) || (t = { type: 'error' }), l = t.type, s = t.type === 'error' ? 404 : 200), n && n(s, l) }, i.addEventListener('load', o), i.addEventListener('error', o), a.body.appendChild(i), o } return function (a, s, l, c, u, h, p, d, f, m) {
      function g () { w && w(), _ && _.abort() } function b (t, e, i, r, a) { y(T) && n.cancel(T), w = _ = null, t(e, i, r, a) } if (s = s || t.url(), ji(a) === 'jsonp') var x = r.createCallback(s), w = o(s, x, function (t, e) { const n = t === 200 && r.getResponse(x); b(c, t, n, '', e), r.removeCallback(x) }); else { var _ = e(a, s); _.open(a, s, !0), i(u, function (t, e) { y(t) && _.setRequestHeader(e, t) }), _.onload = function () { const t = _.statusText || ''; const e = 'response' in _ ? _.response : _.responseText; let n = _.status === 1223 ? 204 : _.status; n === 0 && (n = e ? 200 : Ln(s).protocol === 'file' ? 404 : 0), b(c, n, e, _.getAllResponseHeaders(), t) }; const $ = function () { b(c, -1, null, null, '') }; if (_.onerror = $, _.onabort = $, _.ontimeout = $, i(f, function (t, e) { _.addEventListener(e, t) }), i(m, function (t, e) { _.upload.addEventListener(e, t) }), p && (_.withCredentials = !0), d) try { _.responseType = d } catch (t) { if (d !== 'json') throw t }_.send(v(l) ? null : l) } if (h > 0) var T = n(g, h); else D(h) && h.then(g)
    }
  } function ze () { let t = '{{'; let e = '}}'; this.startSymbol = function (e) { return e ? (t = e, this) : t }, this.endSymbol = function (t) { return t ? (e = t, this) : e }, this.$get = ['$parse', '$exceptionHandler', '$sce', function (n, i, r) { function a (t) { return '\\\\\\' + t } function o (n) { return n.replace(p, t).replace(d, e) } function s (t, e, n, i) { var r = t.$watch(function (t) { return r(), i(t) }, e, n); return r } function l (a, l, p, d) { function f (t) { try { return t = P(t), d && !y(t) ? t : mt(t) } catch (t) { i(fa.interr(a, t)) } } if (!a.length || a.indexOf(t) === -1) { let g; if (!l) { g = m(o(a)), g.exp = a, g.expressions = [], g.$$watchDelegate = s } return g }d = !!d; for (var b, x, w, _ = 0, $ = [], S = [], M = a.length, C = [], E = []; _ < M;) { if ((b = a.indexOf(t, _)) === -1 || (x = a.indexOf(e, b + u)) === -1) { _ !== M && C.push(o(a.substring(_))); break }_ !== b && C.push(o(a.substring(_, b))), w = a.substring(b + u, x), $.push(w), S.push(n(w, f)), _ = x + h, E.push(C.length), C.push('') } if (p && C.length > 1 && fa.throwNoconcat(a), !l || $.length) { const A = function (t) { for (let e = 0, n = $.length; e < n; e++) { if (d && v(t[e])) return; C[E[e]] = t[e] } return C.join('') }; var P = function (t) { return p ? r.getTrusted(p, t) : r.valueOf(t) }; return c(function (t) { let e = 0; const n = $.length; const r = new Array(n); try { for (;e < n; e++)r[e] = S[e](t); return A(r) } catch (t) { i(fa.interr(a, t)) } }, { exp: a, expressions: $, $$watchDelegate: function (t, e) { let n; return t.$watchGroup(S, function (i, r) { const a = A(i); T(e) && e.call(this, a, i !== r ? n : a, t), n = a }) } }) } } var u = t.length; var h = e.length; var p = new RegExp(t.replace(/./g, a), 'g'); var d = new RegExp(e.replace(/./g, a), 'g'); return l.startSymbol = function () { return t }, l.endSymbol = function () { return e }, l }] } function Be () { this.$get = ['$rootScope', '$window', '$q', '$$q', '$browser', function (t, e, n, i, r) { function a (a, s, l, c) { function u () { h ? a.apply(null, p) : a(m) } var h = arguments.length > 4; var p = h ? V(arguments, 4) : []; const d = e.setInterval; const f = e.clearInterval; var m = 0; const g = y(c) && !c; const v = (g ? i : n).defer(); const b = v.promise; return l = y(l) ? l : 0, b.$$intervalId = d(function () { g ? r.defer(u) : t.$evalAsync(u), v.notify(m++), l > 0 && m >= l && (v.resolve(m), f(b.$$intervalId), delete o[b.$$intervalId]), g || t.$apply() }, s), o[b.$$intervalId] = v, b } var o = {}; return a.cancel = function (t) { return !!(t && t.$$intervalId in o) && (o[t.$$intervalId].promise.catch(d), o[t.$$intervalId].reject('canceled'), e.clearInterval(t.$$intervalId), delete o[t.$$intervalId], !0) }, a }] } function je (t) { for (var e = t.split('/'), n = e.length; n--;)e[n] = et(e[n]); return e.join('/') } function Ve (t, e) { const n = Ln(t); e.$$protocol = n.protocol, e.$$host = n.hostname, e.$$port = h(n.port) || va[n.protocol] || null } function Ge (t, e) { if (ba.test(t)) throw ya('badpath', 'Invalid url "{0}".', t); const n = t.charAt(0) !== '/'; n && (t = '/' + t); const i = Ln(t); e.$$path = decodeURIComponent(n && i.pathname.charAt(0) === '/' ? i.pathname.substring(1) : i.pathname), e.$$search = Q(i.search), e.$$hash = decodeURIComponent(i.hash), e.$$path && e.$$path.charAt(0) !== '/' && (e.$$path = '/' + e.$$path) } function He (t, e) { return t.slice(0, e.length) === e } function We (t, e) { if (He(e, t)) return e.substr(t.length) } function qe (t) { const e = t.indexOf('#'); return e === -1 ? t : t.substr(0, e) } function Xe (t) { return t.replace(/(#.+)|#$/, '$1') } function Ye (t) { return t.substr(0, qe(t).lastIndexOf('/') + 1) } function Ze (t) { return t.substring(0, t.indexOf('/', t.indexOf('//') + 2)) } function Ke (t, e, n) { this.$$html5 = !0, n = n || '', Ve(t, this), this.$$parse = function (t) { const n = We(e, t); if (!w(n)) throw ya('ipthprfx', 'Invalid url "{0}", missing path prefix "{1}".', t, e); Ge(n, this), this.$$path || (this.$$path = '/'), this.$$compose() }, this.$$compose = function () { const t = tt(this.$$search); const n = this.$$hash ? '#' + et(this.$$hash) : ''; this.$$url = je(this.$$path) + (t ? '?' + t : '') + n, this.$$absUrl = e + this.$$url.substr(1), this.$$urlUpdatedByLocation = !0 }, this.$$parseLinkUrl = function (i, r) { if (r && r[0] === '#') return this.hash(r.slice(1)), !0; let a, o, s; return y(a = We(t, i)) ? (o = a, s = n && y(a = We(n, a)) ? e + (We('/', a) || a) : t + o) : y(a = We(e, i)) ? s = e + a : e === i + '/' && (s = e), s && this.$$parse(s), !!s } } function Je (t, e, n) { Ve(t, this), this.$$parse = function (i) { let r; const a = We(t, i) || We(e, i); v(a) || a.charAt(0) !== '#' ? this.$$html5 ? r = a : (r = '', v(a) && (t = i, this.replace())) : (r = We(n, a), v(r) && (r = a)), Ge(r, this), this.$$path = (function (t, e, n) { let i; const r = /^\/[A-Z]:(\/.*)/; return He(e, n) && (e = e.replace(n, '')), r.exec(e) ? t : (i = r.exec(t), i ? i[1] : t) }(this.$$path, r, t)), this.$$compose() }, this.$$compose = function () { const e = tt(this.$$search); const i = this.$$hash ? '#' + et(this.$$hash) : ''; this.$$url = je(this.$$path) + (e ? '?' + e : '') + i, this.$$absUrl = t + (this.$$url ? n + this.$$url : ''), this.$$urlUpdatedByLocation = !0 }, this.$$parseLinkUrl = function (e, n) { return qe(t) === qe(e) && (this.$$parse(e), !0) } } function Qe (t, e, n) { this.$$html5 = !0, Je.apply(this, arguments), this.$$parseLinkUrl = function (i, r) { if (r && r[0] === '#') return this.hash(r.slice(1)), !0; let a, o; return t === qe(i) ? a = i : (o = We(e, i)) ? a = t + n + o : e === i + '/' && (a = e), a && this.$$parse(a), !!a }, this.$$compose = function () { const e = tt(this.$$search); const i = this.$$hash ? '#' + et(this.$$hash) : ''; this.$$url = je(this.$$path) + (e ? '?' + e : '') + i, this.$$absUrl = t + n + this.$$url, this.$$urlUpdatedByLocation = !0 } } function tn (t) { return function () { return this[t] } } function en (t, e) { return function (n) { return v(n) ? this[t] : (this[t] = e(n), this.$$compose(), this) } } function nn () { let t = '!'; const e = { enabled: !1, requireBase: !0, rewriteLinks: !0 }; this.hashPrefix = function (e) { return y(e) ? (t = e, this) : t }, this.html5Mode = function (t) { return k(t) ? (e.enabled = t, this) : b(t) ? (k(t.enabled) && (e.enabled = t.enabled), k(t.requireBase) && (e.requireBase = t.requireBase), (k(t.rewriteLinks) || w(t.rewriteLinks)) && (e.rewriteLinks = t.rewriteLinks), this) : e }, this.$get = ['$rootScope', '$browser', '$sniffer', '$rootElement', '$window', function (n, i, r, a, o) { function s (t, e, n) { const r = c.url(); const a = c.$$state; try { i.url(t, e, n), c.$$state = i.state() } catch (t) { throw c.url(r), c.$$state = a, t } } function l (t, e) { n.$broadcast('$locationChangeSuccess', c.absUrl(), t, c.$$state, e) } let c; let u; let h; const p = i.baseHref(); const d = i.url(); if (e.enabled) { if (!p && e.requireBase) throw ya('nobase', '$location in HTML5 mode requires a <base> tag to be present!'); h = Ze(d) + (p || '/'), u = r.history ? Ke : Qe } else h = qe(d), u = Je; const f = Ye(h); c = new u(h, f, '#' + t), c.$$parseLinkUrl(d, d), c.$$state = i.state(); const m = /^\s*(javascript|mailto):/i; a.on('click', function (t) { const r = e.rewriteLinks; if (r && !t.ctrlKey && !t.metaKey && !t.shiftKey && t.which !== 2 && t.button !== 2) { for (var s = qi(t.target); N(s[0]) !== 'a';) if (s[0] === a[0] || !(s = s.parent())[0]) return; if (!w(r) || !v(s.attr(r))) { let l = s.prop('href'); const u = s.attr('href') || s.attr('xlink:href'); b(l) && l.toString() === '[object SVGAnimatedString]' && (l = Ln(l.animVal).href), m.test(l) || !l || s.attr('target') || t.isDefaultPrevented() || c.$$parseLinkUrl(l, u) && (t.preventDefault(), c.absUrl() !== i.url() && (n.$apply(), o.angular['ff-684208-preventDefault'] = !0)) } } }), Xe(c.absUrl()) !== Xe(d) && i.url(c.absUrl(), !0); let g = !0; return i.onUrlChange(function (t, e) { if (!He(t, f)) return void (o.location.href = t); n.$evalAsync(function () { let i; const r = c.absUrl(); const a = c.$$state; t = Xe(t), c.$$parse(t), c.$$state = e, i = n.$broadcast('$locationChangeStart', t, r, e, a).defaultPrevented, c.absUrl() === t && (i ? (c.$$parse(r), c.$$state = a, s(r, !1, a)) : (g = !1, l(r, a))) }), n.$$phase || n.$digest() }), n.$watch(function () { if (g || c.$$urlUpdatedByLocation) { c.$$urlUpdatedByLocation = !1; const t = Xe(i.url()); const e = Xe(c.absUrl()); const a = i.state(); const o = c.$$replace; const u = t !== e || c.$$html5 && r.history && a !== c.$$state; (g || u) && (g = !1, n.$evalAsync(function () { const e = c.absUrl(); const i = n.$broadcast('$locationChangeStart', e, t, c.$$state, a).defaultPrevented; c.absUrl() === e && (i ? (c.$$parse(t), c.$$state = a) : (u && s(e, o, a === c.$$state ? null : c.$$state), l(t, a))) })) }c.$$replace = !1 }), c }] } function rn () { let t = !0; const e = this; this.debugEnabled = function (e) { return y(e) ? (t = e, this) : t }, this.$get = ['$window', function (n) { function r (t) { return t instanceof Error && (t.stack ? t = t.message && t.stack.indexOf(t.message) === -1 ? 'Error: ' + t.message + '\n' + t.stack : t.stack : t.sourceURL && (t = t.message + '\n' + t.sourceURL + ':' + t.line)), t } function a (t) { const e = n.console || {}; const a = e[t] || e.log || d; let o = !1; try { o = !!a.apply } catch (t) {} return o ? function () { const t = []; return i(arguments, function (e) { t.push(r(e)) }), a.apply(e, t) } : function (t, e) { a(t, e == null ? '' : e) } } return { log: a('log'), info: a('info'), warn: a('warn'), error: a('error'), debug: (function () { const n = a('debug'); return function () { t && n.apply(e, arguments) } }()) } }] } function an (t) { return t + '' } function on (t, e) { return void 0 !== t ? t : e } function sn (t, e) { return void 0 === t ? e : void 0 === e ? t : t + e } function ln (t, e) { return !t(e).$stateful } function cn (t, e) { let n, r, a; switch (t.type) { case Ma.Program:n = !0, i(t.body, function (t) { cn(t.expression, e), n = n && t.expression.constant }), t.constant = n; break; case Ma.Literal:t.constant = !0, t.toWatch = []; break; case Ma.UnaryExpression:cn(t.argument, e), t.constant = t.argument.constant, t.toWatch = t.argument.toWatch; break; case Ma.BinaryExpression:cn(t.left, e), cn(t.right, e), t.constant = t.left.constant && t.right.constant, t.toWatch = t.left.toWatch.concat(t.right.toWatch); break; case Ma.LogicalExpression:cn(t.left, e), cn(t.right, e), t.constant = t.left.constant && t.right.constant, t.toWatch = t.constant ? [] : [t]; break; case Ma.ConditionalExpression:cn(t.test, e), cn(t.alternate, e), cn(t.consequent, e), t.constant = t.test.constant && t.alternate.constant && t.consequent.constant, t.toWatch = t.constant ? [] : [t]; break; case Ma.Identifier:t.constant = !1, t.toWatch = [t]; break; case Ma.MemberExpression:cn(t.object, e), t.computed && cn(t.property, e), t.constant = t.object.constant && (!t.computed || t.property.constant), t.toWatch = [t]; break; case Ma.CallExpression:a = !!t.filter && ln(e, t.callee.name), n = a, r = [], i(t.arguments, function (t) { cn(t, e), n = n && t.constant, t.constant || r.push.apply(r, t.toWatch) }), t.constant = n, t.toWatch = a ? r : [t]; break; case Ma.AssignmentExpression:cn(t.left, e), cn(t.right, e), t.constant = t.left.constant && t.right.constant, t.toWatch = [t]; break; case Ma.ArrayExpression:n = !0, r = [], i(t.elements, function (t) { cn(t, e), n = n && t.constant, t.constant || r.push.apply(r, t.toWatch) }), t.constant = n, t.toWatch = r; break; case Ma.ObjectExpression:n = !0, r = [], i(t.properties, function (t) { cn(t.value, e), n = n && t.value.constant && !t.computed, t.value.constant || r.push.apply(r, t.value.toWatch), t.computed && (cn(t.key, e), t.key.constant || r.push.apply(r, t.key.toWatch)) }), t.constant = n, t.toWatch = r; break; case Ma.ThisExpression:case Ma.LocalsExpression:t.constant = !1, t.toWatch = [] } } function un (t) { if (t.length === 1) { const e = t[0].expression; const n = e.toWatch; return n.length !== 1 ? n : n[0] !== e ? n : void 0 } } function hn (t) { return t.type === Ma.Identifier || t.type === Ma.MemberExpression } function pn (t) { if (t.body.length === 1 && hn(t.body[0].expression)) return { type: Ma.AssignmentExpression, left: t.body[0].expression, right: { type: Ma.NGValueParameter }, operator: '=' } } function dn (t) { return t.body.length === 0 || t.body.length === 1 && (t.body[0].expression.type === Ma.Literal || t.body[0].expression.type === Ma.ArrayExpression || t.body[0].expression.type === Ma.ObjectExpression) } function fn (t) { return t.constant } function mn (t, e) { this.astBuilder = t, this.$filter = e } function gn (t, e) { this.astBuilder = t, this.$filter = e } function vn (t) { return T(t.valueOf) ? t.valueOf() : _a.call(t) } function yn () { let t; let e; const n = ft(); const r = { true: !0, false: !1, null: null, undefined: void 0 }; this.addLiteral = function (t, e) { r[t] = e }, this.setIdentifierFns = function (n, i) { return t = n, e = i, this }, this.$get = ['$filter', function (a) { function o (t, e) { let i, r, o; switch (typeof t) { case 'string':if (t = t.trim(), o = t, !(i = n[o])) { t.charAt(0) === ':' && t.charAt(1) === ':' && (r = !0, t = t.substring(2)); const s = new Sa(m); i = new Ca(s, a, m).parse(t), i.constant ? i.$$watchDelegate = h : r ? i.$$watchDelegate = i.literal ? u : c : i.inputs && (i.$$watchDelegate = l), n[o] = i } return p(i, e); case 'function':return p(t, e); default:return p(d, e) } } function s (t, e, n) { return t == null || e == null ? t === e : !(typeof t === 'object' && !n && typeof (t = vn(t)) === 'object') && (t === e || t !== t && e !== e) } function l (t, e, n, i, r) { let a; let o = i.inputs; if (o.length === 1) { let l = s; return o = o[0], t.$watch(function (t) { const e = o(t); return s(e, l, i.literal) || (a = i(t, void 0, void 0, [e]), l = e && vn(e)), a }, e, n, r) } for (var c = [], u = [], h = 0, p = o.length; h < p; h++)c[h] = s, u[h] = null; return t.$watch(function (t) { for (var e = !1, n = 0, r = o.length; n < r; n++) { const l = o[n](t); (e || (e = !s(l, c[n], i.literal))) && (u[n] = l, c[n] = l && vn(l)) } return e && (a = i(t, void 0, void 0, u)), a }, e, n, r) } function c (t, e, n, i, r) { function a (t) { return i(t) } function o (t, n, i) { c = t, T(e) && e(t, n, i), y(t) && i.$$postDigest(function () { y(c) && s() }) } let s, c; return s = i.inputs ? l(t, o, n, i, r) : t.$watch(a, o, n) } function u (t, e, n, r) { function a (t) { let e = !0; return i(t, function (t) { y(t) || (e = !1) }), e } let o, s; return o = t.$watch(function (t) { return r(t) }, function (t, n, i) { s = t, T(e) && e(t, n, i), a(t) && i.$$postDigest(function () { a(s) && o() }) }, n) } function h (t, e, n, i) { var r = t.$watch(function (t) { return r(), i(t) }, e, n); return r } function p (t, e) { if (!e) return t; const n = t.$$watchDelegate; let i = !1; const r = n !== u && n !== c; const a = r ? function (n, r, a, o) { const s = i && o ? o[0] : t(n, r, a, o); return e(s, n, r) } : function (n, i, r, a) { const o = t(n, i, r, a); const s = e(o, n, i); return y(o) ? s : o }; return i = !t.inputs, t.$$watchDelegate && t.$$watchDelegate !== l ? (a.$$watchDelegate = t.$$watchDelegate, a.inputs = t.inputs) : e.$stateful || (a.$$watchDelegate = l, a.inputs = t.inputs ? t.inputs : [t]), a } const f = cr().noUnsafeEval; var m = { csp: f, literals: z(r), isIdentifierStart: T(t) && t, isIdentifierContinue: T(e) && e }; return o }] } function bn () { let t = !0; this.$get = ['$rootScope', '$exceptionHandler', function (e, n) { return wn(function (t) { e.$evalAsync(t) }, n, t) }], this.errorOnUnhandledRejections = function (e) { return y(e) ? (t = e, this) : t } } function xn () { let t = !0; this.$get = ['$browser', '$exceptionHandler', function (e, n) { return wn(function (t) { e.defer(t) }, n, t) }], this.errorOnUnhandledRejections = function (e) { return y(e) ? (t = e, this) : t } } function wn (t, n, r) { function a () { return new o() } function o () { const t = this.promise = new s(); this.resolve = function (e) { p(t, e) }, this.reject = function (e) { f(t, e) }, this.notify = function (e) { g(t, e) } } function s () { this.$$state = { status: 0 } } function l (e) { let n, i, a; a = e.pending, e.processScheduled = !1, e.pending = void 0; try { for (let o = 0, s = a.length; o < s; ++o) { e.pur = !0, i = a[o][0], n = a[o][e.status]; try { T(n) ? p(i, n(e.value)) : e.status === 1 ? p(i, e.value) : f(i, e.value) } catch (t) { f(i, t) } } } finally { --C, r && C === 0 && t(u) } } function u () { for (;!C && E.length;) { const t = E.shift(); if (!t.pur) { t.pur = !0; const e = 'Possibly unhandled rejection: ' + bt(t.value); t.value instanceof Error ? n(t.value, e) : n(e) } } } function h (e) { !r || e.pending || e.status !== 2 || e.pur || (C === 0 && E.length === 0 && t(u), E.push(e)), !e.processScheduled && e.pending && (e.processScheduled = !0, ++C, t(function () { l(e) })) } function p (t, e) { t.$$state.status || (e === t ? m(t, M('qcycle', "Expected promise to be resolved with value other than itself '{0}'", e)) : d(t, e)) } function d (t, e) { function n (e) { o || (o = !0, d(t, e)) } function i (e) { o || (o = !0, m(t, e)) } function r (e) { g(t, e) } let a; var o = !1; try { (b(e) || T(e)) && (a = e.then), T(a) ? (t.$$state.status = -1, a.call(e, n, i, r)) : (t.$$state.value = e, t.$$state.status = 1, h(t.$$state)) } catch (t) { i(t) } } function f (t, e) { t.$$state.status || m(t, e) } function m (t, e) { t.$$state.value = e, t.$$state.status = 2, h(t.$$state) } function g (e, i) { const r = e.$$state.pending; e.$$state.status <= 0 && r && r.length && t(function () { for (var t, e, a = 0, o = r.length; a < o; a++) { e = r[a][0], t = r[a][3]; try { g(e, T(t) ? t(i) : i) } catch (t) { n(t) } } }) } function y (t) { const e = new s(); return f(e, t), e } function x (t, e, n) { let i = null; try { T(n) && (i = n()) } catch (t) { return y(t) } return D(i) ? i.then(function () { return e(t) }, y) : e(t) } function w (t, e, n, i) { const r = new s(); return p(r, t), r.then(e, n, i) } function _ (t) { const e = new s(); let n = 0; const r = ar(t) ? [] : {}; return i(t, function (t, i) { n++, w(t).then(function (t) { r[i] = t, --n || p(e, r) }, function (t) { f(e, t) }) }), n === 0 && p(e, r), e } function $ (t) { const e = a(); return i(t, function (t) { w(t).then(e.resolve, e.reject) }), e.promise } function S (t) { function e (t) { p(i, t) } function n (t) { f(i, t) } if (!T(t)) throw M('norslvr', "Expected resolverFn, got '{0}'", t); var i = new s(); return t(e, n), i } var M = e('$q', TypeError); var C = 0; var E = []; c(s.prototype, { then: function (t, e, n) { if (v(t) && v(e) && v(n)) return this; const i = new s(); return this.$$state.pending = this.$$state.pending || [], this.$$state.pending.push([i, t, e, n]), this.$$state.status > 0 && h(this.$$state), i }, catch: function (t) { return this.then(null, t) }, finally: function (t, e) { return this.then(function (e) { return x(e, A, t) }, function (e) { return x(e, y, t) }, e) } }); var A = w; return S.prototype = s.prototype, S.defer = a, S.reject = y, S.when = w, S.resolve = A, S.all = _, S.race = $, S } function _n () { this.$get = ['$window', '$timeout', function (t, e) { const n = t.requestAnimationFrame || t.webkitRequestAnimationFrame; const i = t.cancelAnimationFrame || t.webkitCancelAnimationFrame || t.webkitCancelRequestAnimationFrame; const r = !!n; const a = r ? function (t) { const e = n(t); return function () { i(e) } } : function (t) { const n = e(t, 16.66, !1); return function () { e.cancel(n) } }; return a.supported = r, a }] } function $n () { function t (t) { function e () { this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null, this.$$listeners = {}, this.$$listenerCount = {}, this.$$watchersCount = 0, this.$id = o(), this.$$ChildScope = null } return e.prototype = t, e } let r = 10; const a = e('$rootScope'); let s = null; let l = null; this.digestTtl = function (t) { return arguments.length && (r = t), r }, this.$get = ['$exceptionHandler', '$parse', '$browser', function (e, c, u) { function h (t) { t.currentScope.$$destroyed = !0 } function p (t) { Wi === 9 && (t.$$childHead && p(t.$$childHead), t.$$nextSibling && p(t.$$nextSibling)), t.$parent = t.$$nextSibling = t.$$prevSibling = t.$$childHead = t.$$childTail = t.$root = t.$$watchers = null } function f () { this.$id = o(), this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null, this.$root = this, this.$$destroyed = !1, this.$$listeners = {}, this.$$listenerCount = {}, this.$$watchersCount = 0, this.$$isolateBindings = null } function m (t) { if (S.$$phase) throw a('inprog', '{0} already in progress', S.$$phase); S.$$phase = t } function g () { S.$$phase = null } function y (t, e) { do { t.$$watchersCount += e } while (t = t.$parent) } function x (t, e, n) { do { t.$$listenerCount[n] -= e, t.$$listenerCount[n] === 0 && delete t.$$listenerCount[n] } while (t = t.$parent) } function w () {} function _ () { for (;E.length;) try { E.shift()() } catch (t) { e(t) }l = null } function $ () { l === null && (l = u.defer(function () { S.$apply(_) })) }f.prototype = { constructor: f, $new: function (e, n) { let i; return n = n || this, e ? (i = new f(), i.$root = this.$root) : (this.$$ChildScope || (this.$$ChildScope = t(this)), i = new this.$$ChildScope()), i.$parent = n, i.$$prevSibling = n.$$childTail, n.$$childHead ? (n.$$childTail.$$nextSibling = i, n.$$childTail = i) : n.$$childHead = n.$$childTail = i, (e || n !== this) && i.$on('$destroy', h), i }, $watch: function (t, e, n, i) { const r = c(t); if (r.$$watchDelegate) return r.$$watchDelegate(this, e, n, r, t); const a = this; let o = a.$$watchers; const l = { fn: e, last: w, get: r, exp: i || t, eq: !!n }; return s = null, T(e) || (l.fn = d), o || (o = a.$$watchers = [], o.$$digestWatchIndex = -1), o.unshift(l), o.$$digestWatchIndex++, y(this, 1), function () { const t = U(o, l); t >= 0 && (y(a, -1), t < o.$$digestWatchIndex && o.$$digestWatchIndex--), s = null } }, $watchGroup: function (t, e) { function n () { l = !1, c ? (c = !1, e(a, a, s)) : e(a, r, s) } var r = new Array(t.length); var a = new Array(t.length); const o = []; var s = this; var l = !1; var c = !0; if (!t.length) { let u = !0; return s.$evalAsync(function () { u && e(a, a, s) }), function () { u = !1 } } return t.length === 1 ? this.$watch(t[0], function (t, n, i) { a[0] = t, r[0] = n, e(a, t === n ? a : r, i) }) : (i(t, function (t, e) { const i = s.$watch(t, function (t, i) { a[e] = t, r[e] = i, l || (l = !0, s.$evalAsync(n)) }); o.push(i) }), function () { for (;o.length;)o.shift()() }) }, $watchCollection: function (t, e) { function i (t) { a = t; let e, i, r, s; if (!v(a)) { if (b(a)) if (n(a)) { o !== d && (o = d, g = o.length = 0, h++), e = a.length, g !== e && (h++, o.length = g = e); for (let l = 0; l < e; l++)s = o[l], r = a[l], s !== s && r !== r || s === r || (h++, o[l] = r) } else { o !== f && (o = f = {}, g = 0, h++), e = 0; for (i in a)Bi.call(a, i) && (e++, r = a[i], s = o[i], i in o ? s !== s && r !== r || s === r || (h++, o[i] = r) : (g++, o[i] = r, h++)); if (g > e) { h++; for (i in o)Bi.call(a, i) || (g--, delete o[i]) } } else o !== a && (o = a, h++); return h } } function r () { if (m ? (m = !1, e(a, a, l)) : e(a, s, l), u) if (b(a)) if (n(a)) { s = new Array(a.length); for (let t = 0; t < a.length; t++)s[t] = a[t] } else { s = {}; for (const i in a)Bi.call(a, i) && (s[i] = a[i]) } else s = a }i.$stateful = !0; let a; let o; let s; var l = this; var u = e.length > 1; var h = 0; const p = c(t, i); var d = []; var f = {}; var m = !0; var g = 0; return this.$watch(p, r) }, $digest: function () { let t; let n; let i; let o; let c; let h; let p; let d; let f; let v; let y; let b = r; const x = this; const $ = []; m('$digest'), u.$$checkUrlChange(), this === S && l !== null && (u.defer.cancel(l), _()), s = null; do { p = !1, f = x; for (let E = 0; E < M.length; E++) { try { y = M[E], y.scope.$eval(y.expression, y.locals) } catch (t) { e(t) }s = null }M.length = 0; t:do { if (h = f.$$watchers) for (h.$$digestWatchIndex = h.length; h.$$digestWatchIndex--;) try { if (t = h[h.$$digestWatchIndex]) if (c = t.get, (n = c(f)) === (i = t.last) || (t.eq ? B(n, i) : rr(n) && rr(i))) { if (t === s) { p = !1; break t } } else p = !0, s = t, t.last = t.eq ? z(n, null) : n, o = t.fn, o(n, i === w ? n : i, f), b < 5 && (v = 4 - b, $[v] || ($[v] = []), $[v].push({ msg: T(t.exp) ? 'fn: ' + (t.exp.name || t.exp.toString()) : t.exp, newVal: n, oldVal: i })) } catch (t) { e(t) } if (!(d = f.$$watchersCount && f.$$childHead || f !== x && f.$$nextSibling)) for (;f !== x && !(d = f.$$nextSibling);)f = f.$parent } while (f = d); if ((p || M.length) && !b--) throw g(), a('infdig', '{0} $digest() iterations reached. Aborting!\nWatchers fired in the last 5 iterations: {1}', r, $) } while (p || M.length); for (g(); A < C.length;) try { C[A++]() } catch (t) { e(t) }C.length = A = 0, u.$$checkUrlChange() }, $destroy: function () { if (!this.$$destroyed) { const t = this.$parent; this.$broadcast('$destroy'), this.$$destroyed = !0, this === S && u.$$applicationDestroyed(), y(this, -this.$$watchersCount); for (const e in this.$$listenerCount)x(this, this.$$listenerCount[e], e); t && t.$$childHead === this && (t.$$childHead = this.$$nextSibling), t && t.$$childTail === this && (t.$$childTail = this.$$prevSibling), this.$$prevSibling && (this.$$prevSibling.$$nextSibling = this.$$nextSibling), this.$$nextSibling && (this.$$nextSibling.$$prevSibling = this.$$prevSibling), this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = d, this.$on = this.$watch = this.$watchGroup = function () { return d }, this.$$listeners = {}, this.$$nextSibling = null, p(this) } }, $eval: function (t, e) { return c(t)(this, e) }, $evalAsync: function (t, e) { S.$$phase || M.length || u.defer(function () { M.length && S.$digest() }), M.push({ scope: this, expression: c(t), locals: e }) }, $$postDigest: function (t) { C.push(t) }, $apply: function (t) { try { m('$apply'); try { return this.$eval(t) } finally { g() } } catch (t) { e(t) } finally { try { S.$digest() } catch (t) { throw e(t), t } } }, $applyAsync: function (t) { function e () { n.$eval(t) } var n = this; t && E.push(e), t = c(t), $() }, $on: function (t, e) { let n = this.$$listeners[t]; n || (this.$$listeners[t] = n = []), n.push(e); let i = this; do { i.$$listenerCount[t] || (i.$$listenerCount[t] = 0), i.$$listenerCount[t]++ } while (i = i.$parent); const r = this; return function () { const i = n.indexOf(e); i !== -1 && (n[i] = null, x(r, 1, t)) } }, $emit: function (t, n) { let i; let r; let a; const o = []; let s = this; let l = !1; var c = { name: t, targetScope: s, stopPropagation: function () { l = !0 }, preventDefault: function () { c.defaultPrevented = !0 }, defaultPrevented: !1 }; const u = j([c], arguments, 1); do { for (i = s.$$listeners[t] || o, c.currentScope = s, r = 0, a = i.length; r < a; r++) if (i[r]) try { i[r].apply(null, u) } catch (t) { e(t) } else i.splice(r, 1), r--, a--; if (l) return c.currentScope = null, c; s = s.$parent } while (s); return c.currentScope = null, c }, $broadcast: function (t, n) { const i = this; let r = i; let a = i; var o = { name: t, targetScope: i, preventDefault: function () { o.defaultPrevented = !0 }, defaultPrevented: !1 }; if (!i.$$listenerCount[t]) return o; for (var s, l, c, u = j([o], arguments, 1); r = a;) { for (o.currentScope = r, s = r.$$listeners[t] || [], l = 0, c = s.length; l < c; l++) if (s[l]) try { s[l].apply(null, u) } catch (t) { e(t) } else s.splice(l, 1), l--, c--; if (!(a = r.$$listenerCount[t] && r.$$childHead || r !== i && r.$$nextSibling)) for (;r !== i && !(a = r.$$nextSibling);)r = r.$parent } return o.currentScope = null, o } }; var S = new f(); var M = S.$$asyncQueue = []; var C = S.$$postDigestQueue = []; var E = S.$$applyAsyncQueue = []; var A = 0; return S }] } function Tn () { let t = /^\s*(https?|ftp|mailto|tel|file):/; let e = /^\s*((https?|ftp|file|blob):|data:image\/)/; this.aHrefSanitizationWhitelist = function (e) { return y(e) ? (t = e, this) : t }, this.imgSrcSanitizationWhitelist = function (t) { return y(t) ? (e = t, this) : e }, this.$get = function () { return function (n, i) { let r; const a = i ? e : t; return r = Ln(n).href, r === '' || r.match(a) ? n : 'unsafe:' + r } } } function Sn (t) { return t.replace(Pa, _t) } function Mn (t) { if (t === 'self') return t; if (w(t)) { if (t.indexOf('***') > -1) throw Ea('iwcard', 'Illegal sequence *** in string matcher.  String: {0}', t); return t = lr(t).replace(/\\\*\\\*/g, '.*').replace(/\\\*/g, '[^:/.?&;]*'), new RegExp('^' + t + '$') } if (S(t)) return new RegExp('^' + t.source + '$'); throw Ea('imatcher', 'Matchers may only be "self", string patterns or RegExp objects') } function Cn (t) { const e = []; return y(t) && i(t, function (t) { e.push(Mn(t)) }), e } function En () { this.SCE_CONTEXTS = Aa; let t = ['self']; let e = []; this.resourceUrlWhitelist = function (e) { return arguments.length && (t = Cn(e)), t }, this.resourceUrlBlacklist = function (t) { return arguments.length && (e = Cn(t)), e }, this.$get = ['$injector', function (n) { function i (t, e) { return t === 'self' ? In(e) : !!t.exec(e.href) } function r (n) { let r; let a; const o = Ln(n.toString()); let s = !1; for (r = 0, a = t.length; r < a; r++) if (i(t[r], o)) { s = !0; break } if (s) for (r = 0, a = e.length; r < a; r++) if (i(e[r], o)) { s = !1; break } return s } function a (t) { const e = function (t) { this.$$unwrapTrustedValue = function () { return t } }; return t && (e.prototype = new t()), e.prototype.valueOf = function () { return this.$$unwrapTrustedValue() }, e.prototype.toString = function () { return this.$$unwrapTrustedValue().toString() }, e } function o (t, e) { const n = h.hasOwnProperty(t) ? h[t] : null; if (!n) throw Ea('icontext', 'Attempted to trust a value in invalid context. Context: {0}; Value: {1}', t, e); if (e === null || v(e) || e === '') return e; if (typeof e !== 'string') throw Ea('itype', 'Attempted to trust a non-string value in a content requiring a string: Context: {0}', t); return new n(e) } function s (t) { return t instanceof u ? t.$$unwrapTrustedValue() : t } function l (t, e) { if (e === null || v(e) || e === '') return e; const n = h.hasOwnProperty(t) ? h[t] : null; if (n && e instanceof n) return e.$$unwrapTrustedValue(); if (t === Aa.RESOURCE_URL) { if (r(e)) return e; throw Ea('insecurl', 'Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}', e.toString()) } if (t === Aa.HTML) return c(e); throw Ea('unsafe', 'Attempting to use an unsafe value in a safe context.') } var c = function (t) { throw Ea('unsafe', 'Attempting to use an unsafe value in a safe context.') }; n.has('$sanitize') && (c = n.get('$sanitize')); var u = a(); var h = {}; return h[Aa.HTML] = a(u), h[Aa.CSS] = a(u), h[Aa.URL] = a(u), h[Aa.JS] = a(u), h[Aa.RESOURCE_URL] = a(h[Aa.URL]), { trustAs: o, getTrusted: l, valueOf: s } }] } function An () { let t = !0; this.enabled = function (e) { return arguments.length && (t = !!e), t }, this.$get = ['$parse', '$sceDelegate', function (e, n) { if (t && Wi < 8) throw Ea('iequirks', 'Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks mode.  You can fix this by adding the text <!doctype html> to the top of your HTML document.  See http://docs.angularjs.org/api/ng.$sce for more information.'); const r = vt(Aa); r.isEnabled = function () { return t }, r.trustAs = n.trustAs, r.getTrusted = n.getTrusted, r.valueOf = n.valueOf, t || (r.trustAs = r.getTrusted = function (t, e) { return e }, r.valueOf = f), r.parseAs = function (t, n) { const i = e(n); return i.literal && i.constant ? i : e(n, function (e) { return r.getTrusted(t, e) }) }; const a = r.parseAs; const o = r.getTrusted; const s = r.trustAs; return i(Aa, function (t, e) { const n = ji(e); r[Sn('parse_as_' + n)] = function (e) { return a(t, e) }, r[Sn('get_trusted_' + n)] = function (e) { return o(t, e) }, r[Sn('trust_as_' + n)] = function (e) { return s(t, e) } }), r }] } function Pn () { this.$get = ['$window', '$document', function (t, e) { const n = {}; const i = t.nw && t.nw.process; const r = !i && t.chrome && (t.chrome.app && t.chrome.app.runtime || !t.chrome.app && t.chrome.runtime && t.chrome.runtime.id); const a = !r && t.history && t.history.pushState; const o = h((/android (\d+)/.exec(ji((t.navigator || {}).userAgent)) || [])[1]); const s = /Boxee/i.test((t.navigator || {}).userAgent); const l = e[0] || {}; const c = l.body && l.body.style; let u = !1; let p = !1; return c && (u = !!('transition' in c || 'webkitTransition' in c), p = !!('animation' in c || 'webkitAnimation' in c)), { history: !(!a || o < 4 || s), hasEvent: function (t) { if (t === 'input' && Wi) return !1; if (v(n[t])) { const e = l.createElement('div'); n[t] = 'on' + t in e } return n[t] }, csp: cr(), transitions: u, animations: p, android: o } }] } function kn () { let t; this.httpOptions = function (e) { return e ? (t = e, this) : t }, this.$get = ['$exceptionHandler', '$templateCache', '$http', '$q', '$sce', function (e, n, i, r, a) { function o (s, l) { function u (t) { return l || (t = ka('tpload', 'Failed to load template: {0} (HTTP status: {1} {2})', s, t.status, t.statusText), e(t)), r.reject(t) }o.totalPendingRequests++, w(s) && !v(n.get(s)) || (s = a.getTrustedResourceUrl(s)); let h = i.defaults && i.defaults.transformResponse; return ar(h) ? h = h.filter(function (t) { return t !== Pe }) : h === Pe && (h = null), i.get(s, c({ cache: n, transformResponse: h }, t)).finally(function () { o.totalPendingRequests-- }).then(function (t) { return n.put(s, t.data), t.data }, u) } return o.totalPendingRequests = 0, o }] } function Dn () { this.$get = ['$rootScope', '$browser', '$location', function (t, e, n) { const r = {}; return r.findBindings = function (t, e, n) { const r = t.getElementsByClassName('ng-binding'); const a = []; return i(r, function (t) { const r = nr.element(t).data('$binding'); r && i(r, function (i) { if (n) { new RegExp('(^|\\s)' + lr(e) + '(\\s|\\||$)').test(i) && a.push(t) } else i.indexOf(e) !== -1 && a.push(t) }) }), a }, r.findModels = function (t, e, n) { for (let i = ['ng-', 'data-ng-', 'ng\\:'], r = 0; r < i.length; ++r) { const a = n ? '=' : '*='; const o = '[' + i[r] + 'model' + a + '"' + e + '"]'; const s = t.querySelectorAll(o); if (s.length) return s } }, r.getLocation = function () { return n.url() }, r.setLocation = function (e) { e !== n.url() && (n.url(e), t.$digest()) }, r.whenStable = function (t) { e.notifyWhenNoOutstandingRequests(t) }, r }] } function On () { this.$get = ['$rootScope', '$browser', '$q', '$$q', '$exceptionHandler', function (t, e, n, i, r) { function a (a, s, l) { T(a) || (l = s, s = a, a = d); let c; const u = V(arguments, 3); const h = y(l) && !l; const p = (h ? i : n).defer(); const f = p.promise; return c = e.defer(function () { try { p.resolve(a.apply(null, u)) } catch (t) { p.reject(t), r(t) } finally { delete o[f.$$timeoutId] }h || t.$apply() }, s), f.$$timeoutId = c, o[c] = p, f } var o = {}; return a.cancel = function (t) { return !!(t && t.$$timeoutId in o) && (o[t.$$timeoutId].promise.catch(d), o[t.$$timeoutId].reject('canceled'), delete o[t.$$timeoutId], e.defer.cancel(t.$$timeoutId)) }, a }] } function Ln (t) { let e = t; return Wi && (Da.setAttribute('href', e), e = Da.href), Da.setAttribute('href', e), { href: Da.href, protocol: Da.protocol ? Da.protocol.replace(/:$/, '') : '', host: Da.host, search: Da.search ? Da.search.replace(/^\?/, '') : '', hash: Da.hash ? Da.hash.replace(/^#/, '') : '', hostname: Da.hostname, port: Da.port, pathname: Da.pathname.charAt(0) === '/' ? Da.pathname : '/' + Da.pathname } } function In (t) { const e = w(t) ? Ln(t) : t; return e.protocol === Oa.protocol && e.host === Oa.host } function Rn () { this.$get = m(t) } function Nn (t) { function e (t) { try { return t.cookie || '' } catch (t) { return '' } } function n (t) { try { return decodeURIComponent(t) } catch (e) { return t } } const i = t[0] || {}; let r = {}; let a = ''; return function () { let t; let o; let s; let l; let c; const u = e(i); if (u !== a) for (a = u, t = a.split('; '), r = {}, s = 0; s < t.length; s++)o = t[s], (l = o.indexOf('=')) > 0 && (c = n(o.substring(0, l)), v(r[c]) && (r[c] = n(o.substring(l + 1)))); return r } } function Fn () { this.$get = Nn } function Un (t) { function e (r, a) { if (b(r)) { const o = {}; return i(r, function (t, n) { o[n] = e(n, t) }), o } return t.factory(r + n, a) } var n = 'Filter'; this.register = e, this.$get = ['$injector', function (t) { return function (e) { return t.get(e + n) } }], e('currency', Gn), e('date', ai), e('filter', zn), e('json', oi), e('limitTo', si), e('lowercase', za), e('number', Hn), e('orderBy', ci), e('uppercase', Ba) } function zn () { return function (t, i, r, a) { if (!n(t)) { if (t == null) return t; throw e('filter')('notarray', 'Expected array but received: {0}', t) }a = a || '$'; let o; let s; const l = Vn(i); switch (l) { case 'function':o = i; break; case 'boolean':case 'null':case 'number':case 'string':s = !0; case 'object':o = Bn(i, r, a, s); break; default:return t } return Array.prototype.filter.call(t, o) } } function Bn (t, e, n, i) { const r = b(t) && n in t; return !0 === e ? e = B : T(e) || (e = function (t, e) { return !v(t) && (t === null || e === null ? t === e : !(b(e) || b(t) && !g(t)) && (t = ji('' + t), e = ji('' + e), t.indexOf(e) !== -1)) }), function (a) { return r && !b(a) ? jn(a, t[n], e, n, !1) : jn(a, t, e, n, i) } } function jn (t, e, n, i, r, a) {
    const o = Vn(t); const s = Vn(e); if (s === 'string' && e.charAt(0) === '!') return !jn(t, e.substring(1), n, i, r); if (ar(t)) return t.some(function (t) { return jn(t, e, n, i, r) }); switch (o) {
      case 'object':var l; if (r) { for (l in t) if (l.charAt(0) !== '$' && jn(t[l], e, n, i, !0)) return !0; return !a && jn(t, e, n, i, !1) } if (s === 'object') { for (l in e) { const c = e[l]; if (!T(c) && !v(c)) { const u = l === i; if (!jn(u ? t : t[l], c, n, i, u, u)) return !1 } } return !0 } return n(t, e)
      case 'function':return !1; default:return n(t, e)
    }
  } function Vn (t) { return t === null ? 'null' : typeof t } function Gn (t) { const e = t.NUMBER_FORMATS; return function (t, n, i) { return v(n) && (n = e.CURRENCY_SYM), v(i) && (i = e.PATTERNS[1].maxFrac), t == null ? t : Xn(t, e.PATTERNS[1], e.GROUP_SEP, e.DECIMAL_SEP, i).replace(/\u00A4/g, n) } } function Hn (t) { const e = t.NUMBER_FORMATS; return function (t, n) { return t == null ? t : Xn(t, e.PATTERNS[0], e.GROUP_SEP, e.DECIMAL_SEP, n) } } function Wn (t) { let e; let n; let i; let r; let a; let o = 0; for ((n = t.indexOf(Ia)) > -1 && (t = t.replace(Ia, '')), (i = t.search(/e/i)) > 0 ? (n < 0 && (n = i), n += +t.slice(i + 1), t = t.substring(0, i)) : n < 0 && (n = t.length), i = 0; t.charAt(i) === Ra; i++);if (i === (a = t.length))e = [0], n = 1; else { for (a--; t.charAt(a) === Ra;)a--; for (n -= i, e = [], r = 0; i <= a; i++, r++)e[r] = +t.charAt(i) } return n > La && (e = e.splice(0, La - 1), o = n - 1, n = 1), { d: e, e: o, i: n } } function qn (t, e, n, i) { const r = t.d; let a = r.length - t.i; e = v(e) ? Math.min(Math.max(n, a), i) : +e; let o = e + t.i; const s = r[o]; if (o > 0) { r.splice(Math.max(t.i, o)); for (let l = o; l < r.length; l++)r[l] = 0 } else { a = Math.max(0, a), t.i = 1, r.length = Math.max(1, o = e + 1), r[0] = 0; for (let c = 1; c < o; c++)r[c] = 0 } if (s >= 5) if (o - 1 < 0) { for (let u = 0; u > o; u--)r.unshift(0), t.i++; r.unshift(1), t.i++ } else r[o - 1]++; for (;a < Math.max(0, e); a++)r.push(0); const h = r.reduceRight(function (t, e, n, i) { return e += t, i[n] = e % 10, Math.floor(e / 10) }, 0); h && (r.unshift(h), t.i++) } function Xn (t, e, n, i, r) { if (!w(t) && !_(t) || isNaN(t)) return ''; let a; const o = !isFinite(t); let s = !1; const l = Math.abs(t) + ''; let c = ''; if (o)c = ''; else { a = Wn(l), qn(a, r, e.minFrac, e.maxFrac); let u = a.d; let h = a.i; const p = a.e; let d = []; for (s = u.reduce(function (t, e) { return t && !e }, !0); h < 0;)u.unshift(0), h++; h > 0 ? d = u.splice(h, u.length) : (d = u, u = [0]); const f = []; for (u.length >= e.lgSize && f.unshift(u.splice(-e.lgSize, u.length).join('')); u.length > e.gSize;)f.unshift(u.splice(-e.gSize, u.length).join('')); u.length && f.unshift(u.join('')), c = f.join(n), d.length && (c += i + d.join('')), p && (c += 'e+' + p) } return t < 0 && !s ? e.negPre + c + e.negSuf : e.posPre + c + e.posSuf } function Yn (t, e, n, i) { let r = ''; for ((t < 0 || i && t <= 0) && (i ? t = 1 - t : (t = -t, r = '-')), t = '' + t; t.length < e;)t = Ra + t; return n && (t = t.substr(t.length - e)), r + t } function Zn (t, e, n, i, r) { return n = n || 0, function (a) { let o = a['get' + t](); return (n > 0 || o > -n) && (o += n), o === 0 && n === -12 && (o = 12), Yn(o, e, i, r) } } function Kn (t, e, n) { return function (i, r) { const a = i['get' + t](); return r[Vi((n ? 'STANDALONE' : '') + (e ? 'SHORT' : '') + t)][a] } } function Jn (t, e, n) { const i = -1 * n; let r = i >= 0 ? '+' : ''; return r += Yn(Math[i > 0 ? 'floor' : 'ceil'](i / 60), 2) + Yn(Math.abs(i % 60), 2) } function Qn (t) { const e = new Date(t, 0, 1).getDay(); return new Date(t, 0, (e <= 4 ? 5 : 12) - e) } function ti (t) { return new Date(t.getFullYear(), t.getMonth(), t.getDate() + (4 - t.getDay())) } function ei (t) { return function (e) { const n = Qn(e.getFullYear()); const i = ti(e); const r = +i - +n; return Yn(1 + Math.round(r / 6048e5), t) } } function ni (t, e) { return t.getHours() < 12 ? e.AMPMS[0] : e.AMPMS[1] } function ii (t, e) { return t.getFullYear() <= 0 ? e.ERAS[0] : e.ERAS[1] } function ri (t, e) { return t.getFullYear() <= 0 ? e.ERANAMES[0] : e.ERANAMES[1] } function ai (t) { function e (t) { let e; if (e = t.match(n)) { const i = new Date(0); let r = 0; let a = 0; const o = e[8] ? i.setUTCFullYear : i.setFullYear; const s = e[8] ? i.setUTCHours : i.setHours; e[9] && (r = h(e[9] + e[10]), a = h(e[9] + e[11])), o.call(i, h(e[1]), h(e[2]) - 1, h(e[3])); const l = h(e[4] || 0) - r; const c = h(e[5] || 0) - a; const u = h(e[6] || 0); const p = Math.round(1e3 * parseFloat('0.' + (e[7] || 0))); return s.call(i, l, c, u, p), i } return t } var n = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/; return function (n, r, a) { let o; let s; let l = ''; let c = []; if (r = r || 'mediumDate', r = t.DATETIME_FORMATS[r] || r, w(n) && (n = Ua.test(n) ? h(n) : e(n)), _(n) && (n = new Date(n)), !$(n) || !isFinite(n.getTime())) return n; for (;r;)s = Fa.exec(r), s ? (c = j(c, s, 1), r = c.pop()) : (c.push(r), r = null); let u = n.getTimezoneOffset(); return a && (u = X(a, u), n = Z(n, a, !0)), i(c, function (e) { o = Na[e], l += o ? o(n, t.DATETIME_FORMATS, u) : e === "''" ? "'" : e.replace(/(^'|'$)/g, '').replace(/''/g, "'") }), l } } function oi () { return function (t, e) { return v(e) && (e = 2), W(t, e) } } function si () { return function (t, e, i) { return e = Math.abs(Number(e)) === 1 / 0 ? Number(e) : h(e), rr(e) ? t : (_(t) && (t = t.toString()), n(t) ? (i = !i || isNaN(i) ? 0 : h(i), i = i < 0 ? Math.max(0, t.length + i) : i, e >= 0 ? li(t, i, i + e) : i === 0 ? li(t, e, t.length) : li(t, Math.max(0, i + e), i)) : t) } } function li (t, e, n) { return w(t) ? t.slice(e, n) : Zi.call(t, e, n) } function ci (t) { function i (e) { return e.map(function (e) { let n = 1; let i = f; if (T(e))i = e; else if (w(e) && (e.charAt(0) !== '+' && e.charAt(0) !== '-' || (n = e.charAt(0) === '-' ? -1 : 1, e = e.substring(1)), e !== '' && (i = t(e), i.constant))) { const r = i(); i = function (t) { return t[r] } } return { get: i, descending: n } }) } function r (t) { switch (typeof t) { case 'number':case 'boolean':case 'string':return !0; default:return !1 } } function a (t) { return T(t.valueOf) && (t = t.valueOf(), r(t)) ? t : (g(t) && (t = t.toString(), r(t)), t) } function o (t, e) { let n = typeof t; return t === null ? (n = 'string', t = 'null') : n === 'object' && (t = a(t)), { value: t, type: n, index: e } } function s (t, e) { let n = 0; const i = t.type; const r = e.type; if (i === r) { let a = t.value; let o = e.value; i === 'string' ? (a = a.toLowerCase(), o = o.toLowerCase()) : i === 'object' && (b(a) && (a = t.index), b(o) && (o = e.index)), a !== o && (n = a < o ? -1 : 1) } else n = i < r ? -1 : 1; return n } return function (t, r, a, l) { function c (t, e) { return { value: t, tieBreaker: { value: e, type: 'number', index: e }, predicateValues: h.map(function (n) { return o(n.get(t), e) }) } } function u (t, e) { for (let n = 0, i = h.length; n < i; n++) { const r = d(t.predicateValues[n], e.predicateValues[n]); if (r) return r * h[n].descending * p } return d(t.tieBreaker, e.tieBreaker) * p } if (t == null) return t; if (!n(t)) throw e('orderBy')('notarray', 'Expected array but received: {0}', t); ar(r) || (r = [r]), r.length === 0 && (r = ['+']); var h = i(r); var p = a ? -1 : 1; var d = T(l) ? l : s; const f = Array.prototype.map.call(t, c); return f.sort(u), t = f.map(function (t) { return t.value }) } } function ui (t) { return T(t) && (t = { link: t }), t.restrict = t.restrict || 'AC', m(t) } function hi (t, e) { t.$name = e } function pi (t, e, n, i, r) { this.$$controls = [], this.$error = {}, this.$$success = {}, this.$pending = void 0, this.$name = r(e.name || e.ngForm || '')(n), this.$dirty = !1, this.$pristine = !0, this.$valid = !0, this.$invalid = !1, this.$submitted = !1, this.$$parentForm = Ga, this.$$element = t, this.$$animate = i, di(this) } function di (t) { t.$$classCache = {}, t.$$classCache[Mo] = !(t.$$classCache[So] = t.$$element.hasClass(So)) } function fi (t) { function e (t, e, n, i) { t[e] || (t[e] = {}), o(t[e], n, i) } function n (t, e, n, i) { t[e] && s(t[e], n, i), mi(t[e]) && (t[e] = void 0) } function i (t, e, n) { n && !t.$$classCache[e] ? (t.$$animate.addClass(t.$$element, e), t.$$classCache[e] = !0) : !n && t.$$classCache[e] && (t.$$animate.removeClass(t.$$element, e), t.$$classCache[e] = !1) } function r (t, e, n) { e = e ? '-' + lt(e, '-') : '', i(t, So + e, !0 === n), i(t, Mo + e, !1 === n) } const a = t.clazz; var o = t.set; var s = t.unset; a.prototype.$setValidity = function (t, a, l) { v(a) ? e(this, '$pending', t, l) : n(this, '$pending', t, l), k(a) ? a ? (s(this.$error, t, l), o(this.$$success, t, l)) : (o(this.$error, t, l), s(this.$$success, t, l)) : (s(this.$error, t, l), s(this.$$success, t, l)), this.$pending ? (i(this, Ha, !0), this.$valid = this.$invalid = void 0, r(this, '', null)) : (i(this, Ha, !1), this.$valid = mi(this.$error), this.$invalid = !this.$valid, r(this, '', this.$valid)); let c; c = this.$pending && this.$pending[t] ? void 0 : !this.$error[t] && (!!this.$$success[t] || null), r(this, t, c), this.$$parentForm.$setValidity(t, c, this) } } function mi (t) { if (t) for (const e in t) if (t.hasOwnProperty(e)) return !1; return !0 } function gi (t) { t.$formatters.push(function (e) { return t.$isEmpty(e) ? e : e.toString() }) } function vi (t, e, n, i, r, a) { yi(t, e, n, i, r, a), gi(i) } function yi (t, e, n, i, r, a) { const o = ji(e[0].type); if (!r.android) { var s = !1; e.on('compositionstart', function () { s = !0 }), e.on('compositionend', function () { s = !1, c() }) } let l; var c = function (t) { if (l && (a.defer.cancel(l), l = null), !s) { let r = e.val(); const c = t && t.type; o === 'password' || n.ngTrim && n.ngTrim === 'false' || (r = sr(r)), (i.$viewValue !== r || r === '' && i.$$hasNativeValidators) && i.$setViewValue(r, c) } }; if (r.hasEvent('input'))e.on('input', c); else { const u = function (t, e, n) { l || (l = a.defer(function () { l = null, e && e.value === n || c(t) })) }; e.on('keydown', function (t) { const e = t.keyCode; e === 91 || e > 15 && e < 19 || e >= 37 && e <= 40 || u(t, this, this.value) }), r.hasEvent('paste') && e.on('paste cut', u) }e.on('change', c), io[o] && i.$$hasNativeValidators && o === n.type && e.on(no, function (t) { if (!l) { const e = this[zi]; const n = e.badInput; const i = e.typeMismatch; l = a.defer(function () { l = null, e.badInput === n && e.typeMismatch === i || c(t) }) } }), i.$render = function () { const t = i.$isEmpty(i.$viewValue) ? '' : i.$viewValue; e.val() !== t && e.val(t) } } function bi (t, e) { if ($(t)) return t; if (w(t)) { to.lastIndex = 0; const n = to.exec(t); if (n) { const i = +n[1]; const r = +n[2]; let a = 0; let o = 0; let s = 0; let l = 0; const c = Qn(i); const u = 7 * (r - 1); return e && (a = e.getHours(), o = e.getMinutes(), s = e.getSeconds(), l = e.getMilliseconds()), new Date(i, 0, c.getDate() + u, a, o, s, l) } } return NaN } function xi (t, e) { return function (n, r) { let a, o; if ($(n)) return n; if (w(n)) { if (n.charAt(0) === '"' && n.charAt(n.length - 1) === '"' && (n = n.substring(1, n.length - 1)), Ya.test(n)) return new Date(n); if (t.lastIndex = 0, a = t.exec(n)) return a.shift(), o = r ? { yyyy: r.getFullYear(), MM: r.getMonth() + 1, dd: r.getDate(), HH: r.getHours(), mm: r.getMinutes(), ss: r.getSeconds(), sss: r.getMilliseconds() / 1e3 } : { yyyy: 1970, MM: 1, dd: 1, HH: 0, mm: 0, ss: 0, sss: 0 }, i(a, function (t, n) { n < e.length && (o[e[n]] = +t) }), new Date(o.yyyy, o.MM - 1, o.dd, o.HH, o.mm, o.ss || 0, 1e3 * o.sss || 0) } return NaN } } function wi (t, e, n, i) { return function (r, a, o, s, l, c, u) { function h (t) { return t && !(t.getTime && t.getTime() !== t.getTime()) } function p (t) { return y(t) && !$(t) ? n(t) || void 0 : t }_i(r, a, o, s), yi(r, a, o, s, l, c); let d; const f = s && s.$options.getOption('timezone'); if (s.$$parserName = t, s.$parsers.push(function (t) { if (s.$isEmpty(t)) return null; if (e.test(t)) { let i = n(t, d); return f && (i = Z(i, f)), i } }), s.$formatters.push(function (t) { if (t && !$(t)) throw Ao('datefmt', 'Expected `{0}` to be a date', t); return h(t) ? (d = t, d && f && (d = Z(d, f, !0)), u('date')(t, i, f)) : (d = null, '') }), y(o.min) || o.ngMin) { let m; s.$validators.min = function (t) { return !h(t) || v(m) || n(t) >= m }, o.$observe('min', function (t) { m = p(t), s.$validate() }) } if (y(o.max) || o.ngMax) { let g; s.$validators.max = function (t) { return !h(t) || v(g) || n(t) <= g }, o.$observe('max', function (t) { g = p(t), s.$validate() }) } } } function _i (t, e, n, i) { const r = e[0]; (i.$$hasNativeValidators = b(r.validity)) && i.$parsers.push(function (t) { const n = e.prop(zi) || {}; return n.badInput || n.typeMismatch ? void 0 : t }) } function $i (t) { t.$$parserName = 'number', t.$parsers.push(function (e) { return t.$isEmpty(e) ? null : Ja.test(e) ? parseFloat(e) : void 0 }), t.$formatters.push(function (e) { if (!t.$isEmpty(e)) { if (!_(e)) throw Ao('numfmt', 'Expected `{0}` to be a number', e); e = e.toString() } return e }) } function Ti (t) { return y(t) && !_(t) && (t = parseFloat(t)), rr(t) ? void 0 : t } function Si (t) { return (0 | t) === t } function Mi (t) { const e = t.toString(); const n = e.indexOf('.'); if (n === -1) { if (t > -1 && t < 1) { const i = /e-(\d+)$/.exec(e); if (i) return Number(i[1]) } return 0 } return e.length - n - 1 } function Ci (t, e, n) { let i = Number(t); const r = !Si(i); const a = !Si(e); const o = !Si(n); if (r || a || o) { const s = r ? Mi(i) : 0; const l = a ? Mi(e) : 0; const c = o ? Mi(n) : 0; const u = Math.max(s, l, c); const h = Math.pow(10, u); i *= h, e *= h, n *= h, r && (i = Math.round(i)), a && (e = Math.round(e)), o && (n = Math.round(n)) } return (i - e) % n == 0 } function Ei (t, e, n, i, r, a) { _i(t, e, n, i), $i(i), yi(t, e, n, i, r, a); let o, s; if ((y(n.min) || n.ngMin) && (i.$validators.min = function (t) { return i.$isEmpty(t) || v(o) || t >= o }, n.$observe('min', function (t) { o = Ti(t), i.$validate() })), (y(n.max) || n.ngMax) && (i.$validators.max = function (t) { return i.$isEmpty(t) || v(s) || t <= s }, n.$observe('max', function (t) { s = Ti(t), i.$validate() })), y(n.step) || n.ngStep) { let l; i.$validators.step = function (t, e) { return i.$isEmpty(e) || v(l) || Ci(e, o || 0, l) }, n.$observe('step', function (t) { l = Ti(t), i.$validate() }) } } function Ai (t, e, n, i, r, a) { function o (t, i) { e.attr(t, n[t]), n.$observe(t, i) } function s (t) { if (h = Ti(t), !rr(i.$modelValue)) if (u) { let n = e.val(); h > n && (n = h, e.val(n)), i.$setViewValue(n) } else i.$validate() } function l (t) { if (p = Ti(t), !rr(i.$modelValue)) if (u) { let n = e.val(); p < n && (e.val(p), n = p < h ? h : p), i.$setViewValue(n) } else i.$validate() } function c (t) { d = Ti(t), rr(i.$modelValue) || (u && i.$viewValue !== e.val() ? i.$setViewValue(e.val()) : i.$validate()) }_i(t, e, n, i), $i(i), yi(t, e, n, i, r, a); var u = i.$$hasNativeValidators && e[0].type === 'range'; var h = u ? 0 : void 0; var p = u ? 100 : void 0; var d = u ? 1 : void 0; const f = e[0].validity; const m = y(n.min); const g = y(n.max); const b = y(n.step); const x = i.$render; i.$render = u && y(f.rangeUnderflow) && y(f.rangeOverflow) ? function () { x(), i.$setViewValue(e.val()) } : x, m && (i.$validators.min = u ? function () { return !0 } : function (t, e) { return i.$isEmpty(e) || v(h) || e >= h }, o('min', s)), g && (i.$validators.max = u ? function () { return !0 } : function (t, e) { return i.$isEmpty(e) || v(p) || e <= p }, o('max', l)), b && (i.$validators.step = u ? function () { return !f.stepMismatch } : function (t, e) { return i.$isEmpty(e) || v(d) || Ci(e, h || 0, d) }, o('step', c)) } function Pi (t, e, n, i, r, a) { yi(t, e, n, i, r, a), gi(i), i.$$parserName = 'url', i.$validators.url = function (t, e) { const n = t || e; return i.$isEmpty(n) || Za.test(n) } } function ki (t, e, n, i, r, a) { yi(t, e, n, i, r, a), gi(i), i.$$parserName = 'email', i.$validators.email = function (t, e) { const n = t || e; return i.$isEmpty(n) || Ka.test(n) } } function Di (t, e, n, i) { const r = !n.ngTrim || sr(n.ngTrim) !== 'false'; v(n.name) && e.attr('name', o()); const a = function (t) { let a; e[0].checked && (a = n.value, r && (a = sr(a)), i.$setViewValue(a, t && t.type)) }; e.on('click', a), i.$render = function () { let t = n.value; r && (t = sr(t)), e[0].checked = t === i.$viewValue }, n.$observe('value', i.$render) } function Oi (t, e, n, i, r) { let a; if (y(i)) { if (a = t(i), !a.constant) throw Ao('constexpr', 'Expected constant expression for `{0}`, but saw `{1}`.', n, i); return a(e) } return r } function Li (t, e, n, i, r, a, o, s) { const l = Oi(s, t, 'ngTrueValue', n.ngTrueValue, !0); const c = Oi(s, t, 'ngFalseValue', n.ngFalseValue, !1); const u = function (t) { i.$setViewValue(e[0].checked, t && t.type) }; e.on('click', u), i.$render = function () { e[0].checked = i.$viewValue }, i.$isEmpty = function (t) { return !1 === t }, i.$formatters.push(function (t) { return B(t, l) }), i.$parsers.push(function (t) { return t ? l : c }) } function Ii (t, e) { function n (t, e) { if (!t || !t.length) return []; if (!e || !e.length) return t; const n = []; t:for (let i = 0; i < t.length; i++) { for (var r = t[i], a = 0; a < e.length; a++) if (r === e[a]) continue t; n.push(r) } return n } function r (t) { return t && t.split(' ') } function a (t) { let e = t; return ar(t) ? e = t.map(a).join(' ') : b(t) && (e = Object.keys(t).filter(function (e) { return t[e] }).join(' ')), e } function o (t) { let e = t; if (ar(t))e = t.map(o); else if (b(t)) { let n = !1; e = Object.keys(t).filter(function (e) { const i = t[e]; return !n && v(i) && (n = !0), i }), n && e.push(void 0) } return e }t = 'ngClass' + t; let s; return ['$parse', function (l) { return { restrict: 'AC', link: function (c, u, h) { function p (t) { t = m(r(t), 1), h.$addClass(t) } function d (t) { t = m(r(t), -1), h.$removeClass(t) } function f (t, e) { const i = r(t); const a = r(e); const o = n(i, a); const s = n(a, i); const l = m(o, -1); const c = m(s, 1); h.$addClass(c), h.$removeClass(l) } function m (t, e) { const n = []; return i(t, function (t) { (e > 0 || S[t]) && (S[t] = (S[t] || 0) + e, S[t] === +(e > 0) && n.push(t)) }), n.join(' ') } function g (t) { t === e ? p(b) : d(b), M = t } function v (t) { const e = a(t); e !== b && y(e) } function y (t) { M === e && f(b, t), b = t } let b; const x = h[t].trim(); const w = x.charAt(0) === ':' && x.charAt(1) === ':'; const _ = w ? o : a; const $ = l(x, _); const T = w ? v : y; var S = u.data('$classCounts'); var M = !0; S || (S = ft(), u.data('$classCounts', S)), t !== 'ngClass' && (s || (s = l('$index', function (t) { return 1 & t })), c.$watch(s, g)), c.$watch($, T, w) } } }] } function Ri (t, e, n, i, r, a, o, s, l) { this.$viewValue = Number.NaN, this.$modelValue = Number.NaN, this.$$rawModelValue = void 0, this.$validators = {}, this.$asyncValidators = {}, this.$parsers = [], this.$formatters = [], this.$viewChangeListeners = [], this.$untouched = !0, this.$touched = !1, this.$pristine = !0, this.$dirty = !1, this.$valid = !0, this.$invalid = !1, this.$error = {}, this.$$success = {}, this.$pending = void 0, this.$name = l(n.name || '', !1)(t), this.$$parentForm = Ga, this.$options = Po, this.$$parsedNgModel = r(n.ngModel), this.$$parsedNgModelAssign = this.$$parsedNgModel.assign, this.$$ngModelGet = this.$$parsedNgModel, this.$$ngModelSet = this.$$parsedNgModelAssign, this.$$pendingDebounce = null, this.$$parserValid = void 0, this.$$currentValidationRunId = 0, this.$$scope = t, this.$$attr = n, this.$$element = i, this.$$animate = a, this.$$timeout = o, this.$$parse = r, this.$$q = s, this.$$exceptionHandler = e, di(this), Ni(this) } function Ni (t) { t.$$scope.$watch(function () { const e = t.$$ngModelGet(t.$$scope); if (e !== t.$modelValue && (t.$modelValue === t.$modelValue || e === e)) { t.$modelValue = t.$$rawModelValue = e, t.$$parserValid = void 0; for (var n = t.$formatters, i = n.length, r = e; i--;)r = n[i](r); t.$viewValue !== r && (t.$$updateEmptyClasses(r), t.$viewValue = t.$$lastCommittedViewValue = r, t.$render(), t.$$runValidators(t.$modelValue, t.$viewValue, d)) } return e }) } function Fi (t) { this.$$options = t } function Ui (t, e) { i(e, function (e, n) { y(t[n]) || (t[n] = e) }) } var zi = 'validity'; var Bi = Object.prototype.hasOwnProperty; var ji = function (t) { return w(t) ? t.toLowerCase() : t }; var Vi = function (t) { return w(t) ? t.toUpperCase() : t }; const Gi = function (t) { return w(t) ? t.replace(/[A-Z]/g, function (t) { return String.fromCharCode(32 | t.charCodeAt(0)) }) : t }; const Hi = function (t) { return w(t) ? t.replace(/[a-z]/g, function (t) { return String.fromCharCode(-33 & t.charCodeAt(0)) }) : t }; 'I'.toLowerCase() !== 'i' && (ji = Gi, Vi = Hi); let Wi; let qi; let Xi; let Yi; var Zi = [].slice; var Ki = [].splice; const Ji = [].push; var Qi = Object.prototype.toString; var tr = Object.getPrototypeOf; var er = e('ng'); var nr = t.angular || (t.angular = {}); var ir = 0; Wi = t.document.documentMode; var rr = Number.isNaN || function (t) { return t !== t }; d.$inject = [], f.$inject = []; var ar = Array.isArray; var or = /^\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array]$/; var sr = function (t) { return w(t) ? t.trim() : t }; var lr = function (t) { return t.replace(/([-()[\]{}+?*.$^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08') }; var cr = function () { if (!y(cr.rules)) { const e = t.document.querySelector('[ng-csp]') || t.document.querySelector('[data-ng-csp]'); if (e) { const n = e.getAttribute('ng-csp') || e.getAttribute('data-ng-csp'); cr.rules = { noUnsafeEval: !n || n.indexOf('no-unsafe-eval') !== -1, noInlineStyle: !n || n.indexOf('no-inline-style') !== -1 } } else cr.rules = { noUnsafeEval: (function () { try { return new Function(''), !1 } catch (t) { return !0 } }()), noInlineStyle: !1 } } return cr.rules }; const ur = function () { if (y(ur.name_)) return ur.name_; let e; let n; let i; let r; const a = pr.length; for (n = 0; n < a; ++n) if (i = pr[n], e = t.document.querySelector('[' + i.replace(':', '\\:') + 'jq]')) { r = e.getAttribute(i + 'jq'); break } return ur.name_ = r }; var hr = /:/g; var pr = ['ng-', 'data-ng-', 'ng:', 'x-ng-']; var dr = (function (t) { const e = t.currentScript; const n = e && e.getAttribute('src'); if (!n) return !0; const i = t.createElement('a'); if (i.href = n, t.location.origin === i.origin) return !0; switch (i.protocol) { case 'http:':case 'https:':case 'ftp:':case 'blob:':case 'file:':case 'data:':return !0; default:return !1 } }(t.document)); var fr = /[A-Z]/g; let mr = !1; var gr = 1; var vr = 3; var yr = 8; var br = 9; var xr = 11; const wr = { full: '1.6.2', major: 1, minor: 6, dot: 2, codeName: 'llamacorn-lovehug' }; kt.expando = 'ng339'; var _r = kt.cache = {}; var $r = 1; kt._data = function (t) { return this.cache[t[this.expando]] || {} }; var Tr = /-([a-z])/g; var Sr = /^-ms-/; var Mr = { mouseleave: 'mouseout', mouseenter: 'mouseover' }; var Cr = e('jqLite'); var Er = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/; var Ar = /<|&#?\w+;/; var Pr = /<([\w:-]+)/; var kr = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi; var Dr = { option: [1, '<select multiple="multiple">', '</select>'], thead: [1, '<table>', '</table>'], col: [2, '<table><colgroup>', '</colgroup></table>'], tr: [2, '<table><tbody>', '</tbody></table>'], td: [3, '<table><tbody><tr>', '</tr></tbody></table>'], _default: [0, '', ''] }; Dr.optgroup = Dr.option, Dr.tbody = Dr.tfoot = Dr.colgroup = Dr.caption = Dr.thead, Dr.th = Dr.td; var Or = t.Node.prototype.contains || function (t) { return !!(16 & this.compareDocumentPosition(t)) }; var Lr = kt.prototype = { ready: qt, toString: function () { const t = []; return i(this, function (e) { t.push('' + e) }), '[' + t.join(', ') + ']' }, eq: function (t) { return qi(t >= 0 ? this[t] : this[this.length + t]) }, length: 0, push: Ji, sort: [].sort, splice: [].splice }; var Ir = {}; i('multiple,selected,checked,disabled,readOnly,required,open'.split(','), function (t) { Ir[ji(t)] = t }); var Rr = {}; i('input,select,option,textarea,button,form,details'.split(','), function (t) { Rr[t] = !0 }); var Nr = { ngMinlength: 'minlength', ngMaxlength: 'maxlength', ngMin: 'min', ngMax: 'max', ngPattern: 'pattern', ngStep: 'step' }; i({ data: Nt, removeData: It, hasData: Mt, cleanData: Ct }, function (t, e) { kt[e] = t }), i({ data: Nt, inheritedData: Vt, scope: function (t) { return qi.data(t, '$scope') || Vt(t.parentNode || t, ['$isolateScope', '$scope']) }, isolateScope: function (t) { return qi.data(t, '$isolateScope') || qi.data(t, '$isolateScopeNoTemplate') }, controller: jt, injector: function (t) { return Vt(t, '$injector') }, removeAttr: function (t, e) { t.removeAttribute(e) }, hasClass: Ft, css: function (t, e, n) { if (e = wt(e), !y(n)) return t.style[e]; t.style[e] = n }, attr: function (t, e, n) { let i; const r = t.nodeType; if (r !== vr && r !== 2 && r !== yr && t.getAttribute) { const a = ji(e); const o = Ir[a]; if (!y(n)) return i = t.getAttribute(e), o && i !== null && (i = a), i === null ? void 0 : i; n === null || !1 === n && o ? t.removeAttribute(e) : t.setAttribute(e, o ? a : n) } }, prop: function (t, e, n) { if (!y(n)) return t[e]; t[e] = n }, text: (function () { function t (t, e) { if (v(e)) { const n = t.nodeType; return n === gr || n === vr ? t.textContent : '' }t.textContent = e } return t.$dv = '', t }()), val: function (t, e) { if (v(e)) { if (t.multiple && N(t) === 'select') { const n = []; return i(t.options, function (t) { t.selected && n.push(t.value || t.text) }), n } return t.value }t.value = e }, html: function (t, e) { if (v(e)) return t.innerHTML; Ot(t, !0), t.innerHTML = e }, empty: Gt }, function (t, e) { kt.prototype[e] = function (e, n) { let i; let r; const a = this.length; if (t !== Gt && v(t.length === 2 && t !== Ft && t !== jt ? e : n)) { if (b(e)) { for (i = 0; i < a; i++) if (t === Nt)t(this[i], e); else for (r in e)t(this[i], r, e[r]); return this } for (var o = t.$dv, s = v(o) ? Math.min(a, 1) : a, l = 0; l < s; l++) { const c = t(this[l], e, n); o = o ? o + c : c } return o } for (i = 0; i < a; i++)t(this[i], e, n); return this } }), i({ removeData: It, on: function (t, e, n, i) { if (y(i)) throw Cr('onargs', 'jqLite#on() does not support the `selector` or `eventData` parameters'); if (St(t)) { const r = Rt(t, !0); const a = r.events; let o = r.handle; o || (o = r.handle = Zt(t, a)); for (let s = e.indexOf(' ') >= 0 ? e.split(' ') : [e], l = s.length, c = function (e, i, r) { let s = a[e]; s || (s = a[e] = [], s.specialHandlerWrapper = i, e === '$destroy' || r || t.addEventListener(e, o)), s.push(n) }; l--;)e = s[l], Mr[e] ? (c(Mr[e], Jt), c(e, void 0, !0)) : c(e) } }, off: Lt, one: function (t, e, n) { t = qi(t), t.on(e, function i () { t.off(e, n), t.off(e, i) }), t.on(e, n) }, replaceWith: function (t, e) { let n; const r = t.parentNode; Ot(t), i(new kt(e), function (e) { n ? r.insertBefore(e, n.nextSibling) : r.replaceChild(e, t), n = e }) }, children: function (t) { const e = []; return i(t.childNodes, function (t) { t.nodeType === gr && e.push(t) }), e }, contents: function (t) { return t.contentDocument || t.childNodes || [] }, append: function (t, e) { const n = t.nodeType; if (n === gr || n === xr) { e = new kt(e); for (let i = 0, r = e.length; i < r; i++) { const a = e[i]; t.appendChild(a) } } }, prepend: function (t, e) { if (t.nodeType === gr) { const n = t.firstChild; i(new kt(e), function (e) { t.insertBefore(e, n) }) } }, wrap: function (t, e) { Pt(t, qi(e).eq(0).clone()[0]) }, remove: Ht, detach: function (t) { Ht(t, !0) }, after: function (t, e) { let n = t; const i = t.parentNode; if (i) { e = new kt(e); for (let r = 0, a = e.length; r < a; r++) { const o = e[r]; i.insertBefore(o, n.nextSibling), n = o } } }, addClass: zt, removeClass: Ut, toggleClass: function (t, e, n) { e && i(e.split(' '), function (e) { let i = n; v(i) && (i = !Ft(t, e)), (i ? zt : Ut)(t, e) }) }, parent: function (t) { const e = t.parentNode; return e && e.nodeType !== xr ? e : null }, next: function (t) { return t.nextElementSibling }, find: function (t, e) { return t.getElementsByTagName ? t.getElementsByTagName(e) : [] }, clone: Dt, triggerHandler: function (t, e, n) { let r; let a; let o; const s = e.type || e; const l = Rt(t); const u = l && l.events; const h = u && u[s]; h && (r = { preventDefault: function () { this.defaultPrevented = !0 }, isDefaultPrevented: function () { return !0 === this.defaultPrevented }, stopImmediatePropagation: function () { this.immediatePropagationStopped = !0 }, isImmediatePropagationStopped: function () { return !0 === this.immediatePropagationStopped }, stopPropagation: d, type: s, target: t }, e.type && (r = c(r, e)), a = vt(h), o = n ? [r].concat(n) : [r], i(a, function (e) { r.isImmediatePropagationStopped() || e.apply(t, o) })) } }, function (t, e) { kt.prototype[e] = function (e, n, i) { for (var r, a = 0, o = this.length; a < o; a++)v(r) ? (r = t(this[a], e, n, i), y(r) && (r = qi(r))) : Bt(r, t(this[a], e, n, i)); return y(r) ? r : this } }), kt.prototype.bind = kt.prototype.on, kt.prototype.unbind = kt.prototype.off; const Fr = Object.create(null); ee.prototype = { _idx: function (t) { return t === this._lastKey ? this._lastIndex : (this._lastKey = t, this._lastIndex = this._keys.indexOf(t), this._lastIndex) }, _transformKey: function (t) { return rr(t) ? Fr : t }, get: function (t) { t = this._transformKey(t); const e = this._idx(t); if (e !== -1) return this._values[e] }, set: function (t, e) { t = this._transformKey(t); let n = this._idx(t); n === -1 && (n = this._lastIndex = this._keys.length), this._keys[n] = t, this._values[n] = e }, delete: function (t) { t = this._transformKey(t); const e = this._idx(t); return e !== -1 && (this._keys.splice(e, 1), this._values.splice(e, 1), this._lastKey = NaN, this._lastIndex = -1, !0) } }; var Ur = ee; const zr = [function () { this.$get = [function () { return Ur }] }]; var Br = /^([^(]+?)=>/; var jr = /^[^(]*\(\s*([^)]*)\)/m; var Vr = /,/; var Gr = /^\s*(_?)(\S+?)\1\s*$/; var Hr = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm; var Wr = e('$injector'); oe.$$annotate = ae; const qr = e('$animate'); var Xr = 1; const Yr = function () { this.$get = d }; const Zr = function () { const t = new Ur(); const e = []; this.$get = ['$$AnimateRunner', '$rootScope', function (n, r) { function a (t, e, n) { let r = !1; return e && (e = w(e) ? e.split(' ') : ar(e) ? e : [], i(e, function (e) { e && (r = !0, t[e] = n) })), r } function o () { i(e, function (e) { const n = t.get(e); if (n) { const r = ue(e.attr('class')); let a = ''; let o = ''; i(n, function (t, e) { t !== !!r[e] && (t ? a += (a.length ? ' ' : '') + e : o += (o.length ? ' ' : '') + e) }), i(e, function (t) { a && zt(t, a), o && Ut(t, o) }), t.delete(e) } }), e.length = 0 } function s (n, i, s) { const l = t.get(n) || {}; const c = a(l, i, !0); const u = a(l, s, !1); (c || u) && (t.set(n, l), e.push(n), e.length === 1 && r.$$postDigest(o)) } return { enabled: d, on: d, off: d, pin: d, push: function (t, e, i, r) { r && r(), i = i || {}, i.from && t.css(i.from), i.to && t.css(i.to), (i.addClass || i.removeClass) && s(t, i.addClass, i.removeClass); const a = new n(); return a.complete(), a } } }] }; const Kr = ['$provide', function (t) { const e = this; this.$$registeredAnimations = Object.create(null), this.register = function (n, i) { if (n && n.charAt(0) !== '.') throw qr('notcsel', "Expecting class selector starting with '.' got '{0}'.", n); const r = n + '-animation'; e.$$registeredAnimations[n.substr(1)] = r, t.factory(r, i) }, this.classNameFilter = function (t) { if (arguments.length === 1 && (this.$$classNameFilter = t instanceof RegExp ? t : null, this.$$classNameFilter)) { if (new RegExp('(\\s+|\\/)ng-animate(\\s+|\\/)').test(this.$$classNameFilter.toString())) throw qr('nongcls', '$animateProvider.classNameFilter(regex) prohibits accepting a regex value which matches/contains the "{0}" CSS class.', 'ng-animate') } return this.$$classNameFilter }, this.$get = ['$$animateQueue', function (t) { function e (t, e, n) { if (n) { const i = ce(n); !i || i.parentNode || i.previousElementSibling || (n = null) }n ? n.after(t) : e.prepend(t) } return { on: t.on, off: t.off, pin: t.pin, enabled: t.enabled, cancel: function (t) { t.end && t.end() }, enter: function (n, i, r, a) { return i = i && qi(i), r = r && qi(r), i = i || r.parent(), e(n, i, r), t.push(n, 'enter', he(a)) }, move: function (n, i, r, a) { return i = i && qi(i), r = r && qi(r), i = i || r.parent(), e(n, i, r), t.push(n, 'move', he(a)) }, leave: function (e, n) { return t.push(e, 'leave', he(n), function () { e.remove() }) }, addClass: function (e, n, i) { return i = he(i), i.addClass = le(i.addclass, n), t.push(e, 'addClass', i) }, removeClass: function (e, n, i) { return i = he(i), i.removeClass = le(i.removeClass, n), t.push(e, 'removeClass', i) }, setClass: function (e, n, i, r) { return r = he(r), r.addClass = le(r.addClass, n), r.removeClass = le(r.removeClass, i), t.push(e, 'setClass', r) }, animate: function (e, n, i, r, a) { return a = he(a), a.from = a.from ? c(a.from, n) : n, a.to = a.to ? c(a.to, i) : i, r = r || 'ng-inline-animate', a.tempClasses = le(a.tempClasses, r), t.push(e, 'animate', a) } } }] }]; const Jr = function () { this.$get = ['$$rAF', function (t) { function e (e) { n.push(e), n.length > 1 || t(function () { for (let t = 0; t < n.length; t++)n[t](); n = [] }) } var n = []; return function () { let t = !1; return e(function () { t = !0 }), function (n) { t ? n() : e(n) } } }] }; const Qr = function () { this.$get = ['$q', '$sniffer', '$$animateAsyncRun', '$$isDocumentHidden', '$timeout', function (t, e, n, r, a) { function o (t) { this.setHost(t); const e = n(); const i = function (t) { a(t, 0, !1) }; this._doneCallbacks = [], this._tick = function (t) { r() ? i(t) : e(t) }, this._state = 0 } return o.chain = function (t, e) { function n () { if (i === t.length) return void e(!0); t[i](function (t) { if (!1 === t) return void e(!1); i++, n() }) } var i = 0; n() }, o.all = function (t, e) { function n (n) { a = a && n, ++r === t.length && e(a) } var r = 0; var a = !0; i(t, function (t) { t.done(n) }) }, o.prototype = { setHost: function (t) { this.host = t || {} }, done: function (t) { this._state === 2 ? t() : this._doneCallbacks.push(t) }, progress: d, getPromise: function () { if (!this.promise) { const e = this; this.promise = t(function (t, n) { e.done(function (e) { !1 === e ? n() : t() }) }) } return this.promise }, then: function (t, e) { return this.getPromise().then(t, e) }, catch: function (t) { return this.getPromise().catch(t) }, finally: function (t) { return this.getPromise().finally(t) }, pause: function () { this.host.pause && this.host.pause() }, resume: function () { this.host.resume && this.host.resume() }, end: function () { this.host.end && this.host.end(), this._resolve(!0) }, cancel: function () { this.host.cancel && this.host.cancel(), this._resolve(!1) }, complete: function (t) { const e = this; e._state === 0 && (e._state = 1, e._tick(function () { e._resolve(t) })) }, _resolve: function (t) { this._state !== 2 && (i(this._doneCallbacks, function (e) { e(t) }), this._doneCallbacks.length = 0, this._state = 2) } }, o }] }; const ta = function () { this.$get = ['$$rAF', '$q', '$$AnimateRunner', function (t, e, n) { return function (e, i) { function r () { return t(function () { a(), s || l.complete(), s = !0 }), l } function a () { o.addClass && (e.addClass(o.addClass), o.addClass = null), o.removeClass && (e.removeClass(o.removeClass), o.removeClass = null), o.to && (e.css(o.to), o.to = null) } var o = i || {}; o.$$prepared || (o = z(o)), o.cleanupStyles && (o.from = o.to = null), o.from && (e.css(o.from), o.from = null); let s; var l = new n(); return { start: r, end: r } } }] }; var ea = e('$compile'); var na = new ge(); ve.$inject = ['$provide', '$$sanitizeUriProvider'], ye.prototype.isFirstChange = function () { return this.previousValue === na }; var ia = /^((?:x|data)[:\-_])/i; var ra = /[:\-_]+(.)/g; var aa = e('$controller'); var oa = /^(\S+)(\s+as\s+([\w$]+))?$/; const sa = function () { this.$get = ['$document', function (t) { return function (e) { return e ? !e.nodeType && e instanceof qi && (e = e[0]) : e = t[0].body, e.offsetWidth + 1 } }] }; var la = 'application/json'; var ca = { 'Content-Type': la + ';charset=utf-8' }; var ua = /^\[|^\{(?!\{)/; var ha = { '[': /]$/, '{': /}$/ }; var pa = /^\)]\}',?\n/; var da = e('$http'); var fa = nr.$interpolateMinErr = e('$interpolate'); fa.throwNoconcat = function (t) { throw fa('noconcat', 'Error while interpolating: {0}\nStrict Contextual Escaping disallows interpolations that concatenate multiple expressions when a trusted value is required.  See http://docs.angularjs.org/api/ng.$sce', t) }, fa.interr = function (t, e) { return fa('interr', "Can't interpolate: {0}\n{1}", t, e.toString()) }; const ma = function () { this.$get = ['$window', function (t) { function e (t) { const e = function (t) { e.data = t, e.called = !0 }; return e.id = t, e } const n = t.angular.callbacks; const i = {}; return { createCallback: function (t) { const r = '_' + (n.$$counter++).toString(36); const a = 'angular.callbacks.' + r; const o = e(r); return i[a] = n[r] = o, a }, wasCalled: function (t) { return i[t].called }, getResponse: function (t) { return i[t].data }, removeCallback: function (t) { const e = i[t]; delete n[e.id], delete i[t] } } }] }; const ga = /^([^?#]*)(\?([^#]*))?(#(.*))?$/; var va = { http: 80, https: 443, ftp: 21 }; var ya = e('$location'); var ba = /^\s*[\\/]{2,}/; const xa = { $$absUrl: '', $$html5: !1, $$replace: !1, absUrl: tn('$$absUrl'), url: function (t) { if (v(t)) return this.$$url; const e = ga.exec(t); return (e[1] || t === '') && this.path(decodeURIComponent(e[1])), (e[2] || e[1] || t === '') && this.search(e[3] || ''), this.hash(e[5] || ''), this }, protocol: tn('$$protocol'), host: tn('$$host'), port: tn('$$port'), path: en('$$path', function (t) { return t = t !== null ? t.toString() : '', t.charAt(0) === '/' ? t : '/' + t }), search: function (t, e) { switch (arguments.length) { case 0:return this.$$search; case 1:if (w(t) || _(t))t = t.toString(), this.$$search = Q(t); else { if (!b(t)) throw ya('isrcharg', 'The first argument of the `$location#search()` call must be a string or an object.'); t = z(t, {}), i(t, function (e, n) { e == null && delete t[n] }), this.$$search = t } break; default:v(e) || e === null ? delete this.$$search[t] : this.$$search[t] = e } return this.$$compose(), this }, hash: en('$$hash', function (t) { return t !== null ? t.toString() : '' }), replace: function () { return this.$$replace = !0, this } }; i([Qe, Je, Ke], function (t) { t.prototype = Object.create(xa), t.prototype.state = function (e) { if (!arguments.length) return this.$$state; if (t !== Ke || !this.$$html5) throw ya('nostate', 'History API state support is available only in HTML5 mode and only in browsers supporting HTML5 History API'); return this.$$state = v(e) ? null : e, this.$$urlUpdatedByLocation = !0, this } }); const wa = e('$parse'); var _a = {}.constructor.prototype.valueOf; const $a = ft(); i('+ - * / % === !== == != < > <= >= && || ! = |'.split(' '), function (t) { $a[t] = !0 }); const Ta = { n: '\n', f: '\f', r: '\r', t: '\t', v: '\v', "'": "'", '"': '"' }; var Sa = function (t) { this.options = t }; Sa.prototype = {
    constructor: Sa,
    lex: function (t) {
      for (this.text = t, this.index = 0, this.tokens = []; this.index < this.text.length;) {
        const e = this.text.charAt(this.index); if (e === '"' || e === "'") this.readString(e); else if (this.isNumber(e) || e === '.' && this.isNumber(this.peek())) this.readNumber(); else if (this.isIdentifierStart(this.peekMultichar())) this.readIdent(); else if (this.is(e, '(){}[].,;:?')) {
          this.tokens.push({ index: this.index, text: e }),
          this.index++
        } else if (this.isWhitespace(e)) this.index++; else { const n = e + this.peek(); const i = n + this.peek(2); const r = $a[e]; const a = $a[n]; const o = $a[i]; if (r || a || o) { const s = o ? i : a ? n : e; this.tokens.push({ index: this.index, text: s, operator: !0 }), this.index += s.length } else this.throwError('Unexpected next character ', this.index, this.index + 1) }
      } return this.tokens
    },
    is: function (t, e) { return e.indexOf(t) !== -1 },
    peek: function (t) { const e = t || 1; return this.index + e < this.text.length && this.text.charAt(this.index + e) },
    isNumber: function (t) { return t >= '0' && t <= '9' && typeof t === 'string' },
    isWhitespace: function (t) { return t === ' ' || t === '\r' || t === '\t' || t === '\n' || t === '\v' || t === '' },
    isIdentifierStart: function (t) { return this.options.isIdentifierStart ? this.options.isIdentifierStart(t, this.codePointAt(t)) : this.isValidIdentifierStart(t) },
    isValidIdentifierStart: function (t) { return t >= 'a' && t <= 'z' || t >= 'A' && t <= 'Z' || t === '_' || t === '$' },
    isIdentifierContinue: function (t) { return this.options.isIdentifierContinue ? this.options.isIdentifierContinue(t, this.codePointAt(t)) : this.isValidIdentifierContinue(t) },
    isValidIdentifierContinue: function (t, e) { return this.isValidIdentifierStart(t, e) || this.isNumber(t) },
    codePointAt: function (t) { return t.length === 1 ? t.charCodeAt(0) : (t.charCodeAt(0) << 10) + t.charCodeAt(1) - 56613888 },
    peekMultichar: function () { const t = this.text.charAt(this.index); const e = this.peek(); if (!e) return t; const n = t.charCodeAt(0); const i = e.charCodeAt(0); return n >= 55296 && n <= 56319 && i >= 56320 && i <= 57343 ? t + e : t },
    isExpOperator: function (t) { return t === '-' || t === '+' || this.isNumber(t) },
    throwError: function (t, e, n) { n = n || this.index; const i = y(e) ? 's ' + e + '-' + this.index + ' [' + this.text.substring(e, n) + ']' : ' ' + n; throw wa('lexerr', 'Lexer Error: {0} at column{1} in expression [{2}].', t, i, this.text) },
    readNumber: function () { for (var t = '', e = this.index; this.index < this.text.length;) { const n = ji(this.text.charAt(this.index)); if (n === '.' || this.isNumber(n))t += n; else { const i = this.peek(); if (n === 'e' && this.isExpOperator(i))t += n; else if (this.isExpOperator(n) && i && this.isNumber(i) && t.charAt(t.length - 1) === 'e')t += n; else { if (!this.isExpOperator(n) || i && this.isNumber(i) || t.charAt(t.length - 1) !== 'e') break; this.throwError('Invalid exponent') } } this.index++ } this.tokens.push({ index: e, text: t, constant: !0, value: Number(t) }) },
    readIdent: function () { const t = this.index; for (this.index += this.peekMultichar().length; this.index < this.text.length;) { const e = this.peekMultichar(); if (!this.isIdentifierContinue(e)) break; this.index += e.length } this.tokens.push({ index: t, text: this.text.slice(t, this.index), identifier: !0 }) },
    readString: function (t) { const e = this.index; this.index++; for (let n = '', i = t, r = !1; this.index < this.text.length;) { const a = this.text.charAt(this.index); if (i += a, r) { if (a === 'u') { const o = this.text.substring(this.index + 1, this.index + 5); o.match(/[\da-f]{4}/i) || this.throwError('Invalid unicode escape [\\u' + o + ']'), this.index += 4, n += String.fromCharCode(parseInt(o, 16)) } else { n += Ta[a] || a }r = !1 } else if (a === '\\')r = !0; else { if (a === t) return this.index++, void this.tokens.push({ index: e, text: i, constant: !0, value: n }); n += a } this.index++ } this.throwError('Unterminated quote', e) }
  }; var Ma = function (t, e) { this.lexer = t, this.options = e }; Ma.Program = 'Program', Ma.ExpressionStatement = 'ExpressionStatement', Ma.AssignmentExpression = 'AssignmentExpression', Ma.ConditionalExpression = 'ConditionalExpression', Ma.LogicalExpression = 'LogicalExpression', Ma.BinaryExpression = 'BinaryExpression', Ma.UnaryExpression = 'UnaryExpression', Ma.CallExpression = 'CallExpression', Ma.MemberExpression = 'MemberExpression', Ma.Identifier = 'Identifier', Ma.Literal = 'Literal', Ma.ArrayExpression = 'ArrayExpression', Ma.Property = 'Property', Ma.ObjectExpression = 'ObjectExpression', Ma.ThisExpression = 'ThisExpression', Ma.LocalsExpression = 'LocalsExpression', Ma.NGValueParameter = 'NGValueParameter', Ma.prototype = { ast: function (t) { this.text = t, this.tokens = this.lexer.lex(t); const e = this.program(); return this.tokens.length !== 0 && this.throwError('is an unexpected token', this.tokens[0]), e }, program: function () { for (let t = []; ;) if (this.tokens.length > 0 && !this.peek('}', ')', ';', ']') && t.push(this.expressionStatement()), !this.expect(';')) return { type: Ma.Program, body: t } }, expressionStatement: function () { return { type: Ma.ExpressionStatement, expression: this.filterChain() } }, filterChain: function () { for (var t = this.expression(); this.expect('|');)t = this.filter(t); return t }, expression: function () { return this.assignment() }, assignment: function () { let t = this.ternary(); if (this.expect('=')) { if (!hn(t)) throw wa('lval', 'Trying to assign a value to a non l-value'); t = { type: Ma.AssignmentExpression, left: t, right: this.assignment(), operator: '=' } } return t }, ternary: function () { let t; let e; const n = this.logicalOR(); return this.expect('?') && (t = this.expression(), this.consume(':')) ? (e = this.expression(), { type: Ma.ConditionalExpression, test: n, alternate: t, consequent: e }) : n }, logicalOR: function () { for (var t = this.logicalAND(); this.expect('||');)t = { type: Ma.LogicalExpression, operator: '||', left: t, right: this.logicalAND() }; return t }, logicalAND: function () { for (var t = this.equality(); this.expect('&&');)t = { type: Ma.LogicalExpression, operator: '&&', left: t, right: this.equality() }; return t }, equality: function () { for (var t, e = this.relational(); t = this.expect('==', '!=', '===', '!==');)e = { type: Ma.BinaryExpression, operator: t.text, left: e, right: this.relational() }; return e }, relational: function () { for (var t, e = this.additive(); t = this.expect('<', '>', '<=', '>=');)e = { type: Ma.BinaryExpression, operator: t.text, left: e, right: this.additive() }; return e }, additive: function () { for (var t, e = this.multiplicative(); t = this.expect('+', '-');)e = { type: Ma.BinaryExpression, operator: t.text, left: e, right: this.multiplicative() }; return e }, multiplicative: function () { for (var t, e = this.unary(); t = this.expect('*', '/', '%');)e = { type: Ma.BinaryExpression, operator: t.text, left: e, right: this.unary() }; return e }, unary: function () { let t; return (t = this.expect('+', '-', '!')) ? { type: Ma.UnaryExpression, operator: t.text, prefix: !0, argument: this.unary() } : this.primary() }, primary: function () { let t; this.expect('(') ? (t = this.filterChain(), this.consume(')')) : this.expect('[') ? t = this.arrayDeclaration() : this.expect('{') ? t = this.object() : this.selfReferential.hasOwnProperty(this.peek().text) ? t = z(this.selfReferential[this.consume().text]) : this.options.literals.hasOwnProperty(this.peek().text) ? t = { type: Ma.Literal, value: this.options.literals[this.consume().text] } : this.peek().identifier ? t = this.identifier() : this.peek().constant ? t = this.constant() : this.throwError('not a primary expression', this.peek()); for (var e; e = this.expect('(', '[', '.');)e.text === '(' ? (t = { type: Ma.CallExpression, callee: t, arguments: this.parseArguments() }, this.consume(')')) : e.text === '[' ? (t = { type: Ma.MemberExpression, object: t, property: this.expression(), computed: !0 }, this.consume(']')) : e.text === '.' ? t = { type: Ma.MemberExpression, object: t, property: this.identifier(), computed: !1 } : this.throwError('IMPOSSIBLE'); return t }, filter: function (t) { for (var e = [t], n = { type: Ma.CallExpression, callee: this.identifier(), arguments: e, filter: !0 }; this.expect(':');)e.push(this.expression()); return n }, parseArguments: function () { const t = []; if (this.peekToken().text !== ')') do { t.push(this.filterChain()) } while (this.expect(',')); return t }, identifier: function () { const t = this.consume(); return t.identifier || this.throwError('is not a valid identifier', t), { type: Ma.Identifier, name: t.text } }, constant: function () { return { type: Ma.Literal, value: this.consume().value } }, arrayDeclaration: function () { const t = []; if (this.peekToken().text !== ']') do { if (this.peek(']')) break; t.push(this.expression()) } while (this.expect(',')); return this.consume(']'), { type: Ma.ArrayExpression, elements: t } }, object: function () { let t; const e = []; if (this.peekToken().text !== '}') do { if (this.peek('}')) break; t = { type: Ma.Property, kind: 'init' }, this.peek().constant ? (t.key = this.constant(), t.computed = !1, this.consume(':'), t.value = this.expression()) : this.peek().identifier ? (t.key = this.identifier(), t.computed = !1, this.peek(':') ? (this.consume(':'), t.value = this.expression()) : t.value = t.key) : this.peek('[') ? (this.consume('['), t.key = this.expression(), this.consume(']'), t.computed = !0, this.consume(':'), t.value = this.expression()) : this.throwError('invalid key', this.peek()), e.push(t) } while (this.expect(',')); return this.consume('}'), { type: Ma.ObjectExpression, properties: e } }, throwError: function (t, e) { throw wa('syntax', "Syntax Error: Token '{0}' {1} at column {2} of the expression [{3}] starting at [{4}].", e.text, t, e.index + 1, this.text, this.text.substring(e.index)) }, consume: function (t) { if (this.tokens.length === 0) throw wa('ueoe', 'Unexpected end of expression: {0}', this.text); const e = this.expect(t); return e || this.throwError('is unexpected, expecting [' + t + ']', this.peek()), e }, peekToken: function () { if (this.tokens.length === 0) throw wa('ueoe', 'Unexpected end of expression: {0}', this.text); return this.tokens[0] }, peek: function (t, e, n, i) { return this.peekAhead(0, t, e, n, i) }, peekAhead: function (t, e, n, i, r) { if (this.tokens.length > t) { const a = this.tokens[t]; const o = a.text; if (o === e || o === n || o === i || o === r || !e && !n && !i && !r) return a } return !1 }, expect: function (t, e, n, i) { const r = this.peek(t, e, n, i); return !!r && (this.tokens.shift(), r) }, selfReferential: { this: { type: Ma.ThisExpression }, $locals: { type: Ma.LocalsExpression } } }, mn.prototype = { compile: function (t) { const e = this; const n = this.astBuilder.ast(t); this.state = { nextId: 0, filters: {}, fn: { vars: [], body: [], own: {} }, assign: { vars: [], body: [], own: {} }, inputs: [] }, cn(n, e.$filter); let r; let a = ''; if (this.stage = 'assign', r = pn(n)) { this.state.computing = 'assign'; const o = this.nextId(); this.recurse(r, o), this.return_(o), a = 'fn.assign=' + this.generateFunction('assign', 's,v,l') } const s = un(n.body); e.stage = 'inputs', i(s, function (t, n) { const i = 'fn' + n; e.state[i] = { vars: [], body: [], own: {} }, e.state.computing = i; const r = e.nextId(); e.recurse(t, r), e.return_(r), e.state.inputs.push(i), t.watchId = n }), this.state.computing = 'fn', this.stage = 'main', this.recurse(n); const l = '"' + this.USE + ' ' + this.STRICT + '";\n' + this.filterPrefix() + 'var fn=' + this.generateFunction('fn', 's,l,a,i') + a + this.watchFns() + 'return fn;'; const c = new Function('$filter', 'getStringValue', 'ifDefined', 'plus', l)(this.$filter, an, on, sn); return this.state = this.stage = void 0, c.literal = dn(n), c.constant = fn(n), c }, USE: 'use', STRICT: 'strict', watchFns: function () { const t = []; const e = this.state.inputs; const n = this; return i(e, function (e) { t.push('var ' + e + '=' + n.generateFunction(e, 's')) }), e.length && t.push('fn.inputs=[' + e.join(',') + '];'), t.join('') }, generateFunction: function (t, e) { return 'function(' + e + '){' + this.varsPrefix(t) + this.body(t) + '};' }, filterPrefix: function () { const t = []; const e = this; return i(this.state.filters, function (n, i) { t.push(n + '=$filter(' + e.escape(i) + ')') }), t.length ? 'var ' + t.join(',') + ';' : '' }, varsPrefix: function (t) { return this.state[t].vars.length ? 'var ' + this.state[t].vars.join(',') + ';' : '' }, body: function (t) { return this.state[t].body.join('') }, recurse: function (t, e, n, r, a, o) { let s; let l; let c; let u; let h; const p = this; if (r = r || d, !o && y(t.watchId)) return e = e || this.nextId(), void this.if_('i', this.lazyAssign(e, this.computedMember('i', t.watchId)), this.lazyRecurse(t, e, n, r, a, !0)); switch (t.type) { case Ma.Program:i(t.body, function (e, n) { p.recurse(e.expression, void 0, void 0, function (t) { l = t }), n !== t.body.length - 1 ? p.current().body.push(l, ';') : p.return_(l) }); break; case Ma.Literal:u = this.escape(t.value), this.assign(e, u), r(e || u); break; case Ma.UnaryExpression:this.recurse(t.argument, void 0, void 0, function (t) { l = t }), u = t.operator + '(' + this.ifDefined(l, 0) + ')', this.assign(e, u), r(u); break; case Ma.BinaryExpression:this.recurse(t.left, void 0, void 0, function (t) { s = t }), this.recurse(t.right, void 0, void 0, function (t) { l = t }), u = t.operator === '+' ? this.plus(s, l) : t.operator === '-' ? this.ifDefined(s, 0) + t.operator + this.ifDefined(l, 0) : '(' + s + ')' + t.operator + '(' + l + ')', this.assign(e, u), r(u); break; case Ma.LogicalExpression:e = e || this.nextId(), p.recurse(t.left, e), p.if_(t.operator === '&&' ? e : p.not(e), p.lazyRecurse(t.right, e)), r(e); break; case Ma.ConditionalExpression:e = e || this.nextId(), p.recurse(t.test, e), p.if_(e, p.lazyRecurse(t.alternate, e), p.lazyRecurse(t.consequent, e)), r(e); break; case Ma.Identifier:e = e || this.nextId(), n && (n.context = p.stage === 'inputs' ? 's' : this.assign(this.nextId(), this.getHasOwnProperty('l', t.name) + '?l:s'), n.computed = !1, n.name = t.name), p.if_(p.stage === 'inputs' || p.not(p.getHasOwnProperty('l', t.name)), function () { p.if_(p.stage === 'inputs' || 's', function () { a && a !== 1 && p.if_(p.isNull(p.nonComputedMember('s', t.name)), p.lazyAssign(p.nonComputedMember('s', t.name), '{}')), p.assign(e, p.nonComputedMember('s', t.name)) }) }, e && p.lazyAssign(e, p.nonComputedMember('l', t.name))), r(e); break; case Ma.MemberExpression:s = n && (n.context = this.nextId()) || this.nextId(), e = e || this.nextId(), p.recurse(t.object, s, void 0, function () { p.if_(p.notNull(s), function () { t.computed ? (l = p.nextId(), p.recurse(t.property, l), p.getStringValue(l), a && a !== 1 && p.if_(p.not(p.computedMember(s, l)), p.lazyAssign(p.computedMember(s, l), '{}')), u = p.computedMember(s, l), p.assign(e, u), n && (n.computed = !0, n.name = l)) : (a && a !== 1 && p.if_(p.isNull(p.nonComputedMember(s, t.property.name)), p.lazyAssign(p.nonComputedMember(s, t.property.name), '{}')), u = p.nonComputedMember(s, t.property.name), p.assign(e, u), n && (n.computed = !1, n.name = t.property.name)) }, function () { p.assign(e, 'undefined') }), r(e) }, !!a); break; case Ma.CallExpression:e = e || this.nextId(), t.filter ? (l = p.filter(t.callee.name), c = [], i(t.arguments, function (t) { const e = p.nextId(); p.recurse(t, e), c.push(e) }), u = l + '(' + c.join(',') + ')', p.assign(e, u), r(e)) : (l = p.nextId(), s = {}, c = [], p.recurse(t.callee, l, s, function () { p.if_(p.notNull(l), function () { i(t.arguments, function (e) { p.recurse(e, t.constant ? void 0 : p.nextId(), void 0, function (t) { c.push(t) }) }), u = s.name ? p.member(s.context, s.name, s.computed) + '(' + c.join(',') + ')' : l + '(' + c.join(',') + ')', p.assign(e, u) }, function () { p.assign(e, 'undefined') }), r(e) })); break; case Ma.AssignmentExpression:l = this.nextId(), s = {}, this.recurse(t.left, void 0, s, function () { p.if_(p.notNull(s.context), function () { p.recurse(t.right, l), u = p.member(s.context, s.name, s.computed) + t.operator + l, p.assign(e, u), r(e || u) }) }, 1); break; case Ma.ArrayExpression:c = [], i(t.elements, function (e) { p.recurse(e, t.constant ? void 0 : p.nextId(), void 0, function (t) { c.push(t) }) }), u = '[' + c.join(',') + ']', this.assign(e, u), r(e || u); break; case Ma.ObjectExpression:c = [], h = !1, i(t.properties, function (t) { t.computed && (h = !0) }), h ? (e = e || this.nextId(), this.assign(e, '{}'), i(t.properties, function (t) { t.computed ? (s = p.nextId(), p.recurse(t.key, s)) : s = t.key.type === Ma.Identifier ? t.key.name : '' + t.key.value, l = p.nextId(), p.recurse(t.value, l), p.assign(p.member(e, s, t.computed), l) })) : (i(t.properties, function (e) { p.recurse(e.value, t.constant ? void 0 : p.nextId(), void 0, function (t) { c.push(p.escape(e.key.type === Ma.Identifier ? e.key.name : '' + e.key.value) + ':' + t) }) }), u = '{' + c.join(',') + '}', this.assign(e, u)), r(e || u); break; case Ma.ThisExpression:this.assign(e, 's'), r(e || 's'); break; case Ma.LocalsExpression:this.assign(e, 'l'), r(e || 'l'); break; case Ma.NGValueParameter:this.assign(e, 'v'), r(e || 'v') } }, getHasOwnProperty: function (t, e) { const n = t + '.' + e; const i = this.current().own; return i.hasOwnProperty(n) || (i[n] = this.nextId(!1, t + '&&(' + this.escape(e) + ' in ' + t + ')')), i[n] }, assign: function (t, e) { if (t) return this.current().body.push(t, '=', e, ';'), t }, filter: function (t) { return this.state.filters.hasOwnProperty(t) || (this.state.filters[t] = this.nextId(!0)), this.state.filters[t] }, ifDefined: function (t, e) { return 'ifDefined(' + t + ',' + this.escape(e) + ')' }, plus: function (t, e) { return 'plus(' + t + ',' + e + ')' }, return_: function (t) { this.current().body.push('return ', t, ';') }, if_: function (t, e, n) { if (!0 === t)e(); else { const i = this.current().body; i.push('if(', t, '){'), e(), i.push('}'), n && (i.push('else{'), n(), i.push('}')) } }, not: function (t) { return '!(' + t + ')' }, isNull: function (t) { return t + '==null' }, notNull: function (t) { return t + '!=null' }, nonComputedMember: function (t, e) { const n = /^[$_a-zA-Z][$_a-zA-Z0-9]*$/; return n.test(e) ? t + '.' + e : t + '["' + e.replace(/[^$_a-zA-Z0-9]/g, this.stringEscapeFn) + '"]' }, computedMember: function (t, e) { return t + '[' + e + ']' }, member: function (t, e, n) { return n ? this.computedMember(t, e) : this.nonComputedMember(t, e) }, getStringValue: function (t) { this.assign(t, 'getStringValue(' + t + ')') }, lazyRecurse: function (t, e, n, i, r, a) { const o = this; return function () { o.recurse(t, e, n, i, r, a) } }, lazyAssign: function (t, e) { const n = this; return function () { n.assign(t, e) } }, stringEscapeRegex: /[^ a-zA-Z0-9]/g, stringEscapeFn: function (t) { return '\\u' + ('0000' + t.charCodeAt(0).toString(16)).slice(-4) }, escape: function (t) { if (w(t)) return "'" + t.replace(this.stringEscapeRegex, this.stringEscapeFn) + "'"; if (_(t)) return t.toString(); if (!0 === t) return 'true'; if (!1 === t) return 'false'; if (t === null) return 'null'; if (void 0 === t) return 'undefined'; throw wa('esc', 'IMPOSSIBLE') }, nextId: function (t, e) { const n = 'v' + this.state.nextId++; return t || this.current().vars.push(n + (e ? '=' + e : '')), n }, current: function () { return this.state[this.state.computing] } }, gn.prototype = { compile: function (t) { const e = this; const n = this.astBuilder.ast(t); cn(n, e.$filter); let r, a; (r = pn(n)) && (a = this.recurse(r)); let o; const s = un(n.body); s && (o = [], i(s, function (t, n) { const i = e.recurse(t); t.input = i, o.push(i), t.watchId = n })); const l = []; i(n.body, function (t) { l.push(e.recurse(t.expression)) }); const c = n.body.length === 0 ? d : n.body.length === 1 ? l[0] : function (t, e) { let n; return i(l, function (i) { n = i(t, e) }), n }; return a && (c.assign = function (t, e, n) { return a(t, n, e) }), o && (c.inputs = o), c.literal = dn(n), c.constant = fn(n), c }, recurse: function (t, e, n) { let r; let a; let o; const s = this; if (t.input) return this.inputs(t.input, t.watchId); switch (t.type) { case Ma.Literal:return this.value(t.value, e); case Ma.UnaryExpression:return a = this.recurse(t.argument), this['unary' + t.operator](a, e); case Ma.BinaryExpression:case Ma.LogicalExpression:return r = this.recurse(t.left), a = this.recurse(t.right), this['binary' + t.operator](r, a, e); case Ma.ConditionalExpression:return this['ternary?:'](this.recurse(t.test), this.recurse(t.alternate), this.recurse(t.consequent), e); case Ma.Identifier:return s.identifier(t.name, e, n); case Ma.MemberExpression:return r = this.recurse(t.object, !1, !!n), t.computed || (a = t.property.name), t.computed && (a = this.recurse(t.property)), t.computed ? this.computedMember(r, a, e, n) : this.nonComputedMember(r, a, e, n); case Ma.CallExpression:return o = [], i(t.arguments, function (t) { o.push(s.recurse(t)) }), t.filter && (a = this.$filter(t.callee.name)), t.filter || (a = this.recurse(t.callee, !0)), t.filter ? function (t, n, i, r) { for (var s = [], l = 0; l < o.length; ++l)s.push(o[l](t, n, i, r)); const c = a.apply(void 0, s, r); return e ? { context: void 0, name: void 0, value: c } : c } : function (t, n, i, r) { let s; const l = a(t, n, i, r); if (l.value != null) { for (var c = [], u = 0; u < o.length; ++u)c.push(o[u](t, n, i, r)); s = l.value.apply(l.context, c) } return e ? { value: s } : s }; case Ma.AssignmentExpression:return r = this.recurse(t.left, !0, 1), a = this.recurse(t.right), function (t, n, i, o) { const s = r(t, n, i, o); const l = a(t, n, i, o); return s.context[s.name] = l, e ? { value: l } : l }; case Ma.ArrayExpression:return o = [], i(t.elements, function (t) { o.push(s.recurse(t)) }), function (t, n, i, r) { for (var a = [], s = 0; s < o.length; ++s)a.push(o[s](t, n, i, r)); return e ? { value: a } : a }; case Ma.ObjectExpression:return o = [], i(t.properties, function (t) { t.computed ? o.push({ key: s.recurse(t.key), computed: !0, value: s.recurse(t.value) }) : o.push({ key: t.key.type === Ma.Identifier ? t.key.name : '' + t.key.value, computed: !1, value: s.recurse(t.value) }) }), function (t, n, i, r) { for (var a = {}, s = 0; s < o.length; ++s)o[s].computed ? a[o[s].key(t, n, i, r)] = o[s].value(t, n, i, r) : a[o[s].key] = o[s].value(t, n, i, r); return e ? { value: a } : a }; case Ma.ThisExpression:return function (t) { return e ? { value: t } : t }; case Ma.LocalsExpression:return function (t, n) { return e ? { value: n } : n }; case Ma.NGValueParameter:return function (t, n, i) { return e ? { value: i } : i } } }, 'unary+': function (t, e) { return function (n, i, r, a) { let o = t(n, i, r, a); return o = y(o) ? +o : 0, e ? { value: o } : o } }, 'unary-': function (t, e) { return function (n, i, r, a) { let o = t(n, i, r, a); return o = y(o) ? -o : -0, e ? { value: o } : o } }, 'unary!': function (t, e) { return function (n, i, r, a) { const o = !t(n, i, r, a); return e ? { value: o } : o } }, 'binary+': function (t, e, n) { return function (i, r, a, o) { const s = t(i, r, a, o); const l = e(i, r, a, o); const c = sn(s, l); return n ? { value: c } : c } }, 'binary-': function (t, e, n) { return function (i, r, a, o) { const s = t(i, r, a, o); const l = e(i, r, a, o); const c = (y(s) ? s : 0) - (y(l) ? l : 0); return n ? { value: c } : c } }, 'binary*': function (t, e, n) { return function (i, r, a, o) { const s = t(i, r, a, o) * e(i, r, a, o); return n ? { value: s } : s } }, 'binary/': function (t, e, n) { return function (i, r, a, o) { const s = t(i, r, a, o) / e(i, r, a, o); return n ? { value: s } : s } }, 'binary%': function (t, e, n) { return function (i, r, a, o) { const s = t(i, r, a, o) % e(i, r, a, o); return n ? { value: s } : s } }, 'binary===': function (t, e, n) { return function (i, r, a, o) { const s = t(i, r, a, o) === e(i, r, a, o); return n ? { value: s } : s } }, 'binary!==': function (t, e, n) { return function (i, r, a, o) { const s = t(i, r, a, o) !== e(i, r, a, o); return n ? { value: s } : s } }, 'binary==': function (t, e, n) { return function (i, r, a, o) { const s = t(i, r, a, o) == e(i, r, a, o); return n ? { value: s } : s } }, 'binary!=': function (t, e, n) { return function (i, r, a, o) { const s = t(i, r, a, o) != e(i, r, a, o); return n ? { value: s } : s } }, 'binary<': function (t, e, n) { return function (i, r, a, o) { const s = t(i, r, a, o) < e(i, r, a, o); return n ? { value: s } : s } }, 'binary>': function (t, e, n) { return function (i, r, a, o) { const s = t(i, r, a, o) > e(i, r, a, o); return n ? { value: s } : s } }, 'binary<=': function (t, e, n) { return function (i, r, a, o) { const s = t(i, r, a, o) <= e(i, r, a, o); return n ? { value: s } : s } }, 'binary>=': function (t, e, n) { return function (i, r, a, o) { const s = t(i, r, a, o) >= e(i, r, a, o); return n ? { value: s } : s } }, 'binary&&': function (t, e, n) { return function (i, r, a, o) { const s = t(i, r, a, o) && e(i, r, a, o); return n ? { value: s } : s } }, 'binary||': function (t, e, n) { return function (i, r, a, o) { const s = t(i, r, a, o) || e(i, r, a, o); return n ? { value: s } : s } }, 'ternary?:': function (t, e, n, i) { return function (r, a, o, s) { const l = t(r, a, o, s) ? e(r, a, o, s) : n(r, a, o, s); return i ? { value: l } : l } }, value: function (t, e) { return function () { return e ? { context: void 0, name: void 0, value: t } : t } }, identifier: function (t, e, n) { return function (i, r, a, o) { const s = r && t in r ? r : i; n && n !== 1 && s && s[t] == null && (s[t] = {}); const l = s ? s[t] : void 0; return e ? { context: s, name: t, value: l } : l } }, computedMember: function (t, e, n, i) { return function (r, a, o, s) { let l; let c; const u = t(r, a, o, s); return u != null && (l = e(r, a, o, s), l = an(l), i && i !== 1 && u && !u[l] && (u[l] = {}), c = u[l]), n ? { context: u, name: l, value: c } : c } }, nonComputedMember: function (t, e, n, i) { return function (r, a, o, s) { const l = t(r, a, o, s); i && i !== 1 && l && l[e] == null && (l[e] = {}); const c = l != null ? l[e] : void 0; return n ? { context: l, name: e, value: c } : c } }, inputs: function (t, e) { return function (n, i, r, a) { return a ? a[e] : t(n, i, r) } } }; var Ca = function (t, e, n) { this.lexer = t, this.$filter = e, this.options = n, this.ast = new Ma(t, n), this.astCompiler = n.csp ? new gn(this.ast, e) : new mn(this.ast, e) }; Ca.prototype = { constructor: Ca, parse: function (t) { return this.astCompiler.compile(t) } }; var Ea = e('$sce'); var Aa = { HTML: 'html', CSS: 'css', URL: 'url', RESOURCE_URL: 'resourceUrl', JS: 'js' }; var Pa = /_([a-z])/g; var ka = e('$compile'); var Da = t.document.createElement('a'); var Oa = Ln(t.location.href); Nn.$inject = ['$document'], Un.$inject = ['$provide']; var La = 22; var Ia = '.'; var Ra = '0'; Gn.$inject = ['$locale'], Hn.$inject = ['$locale']; var Na = { yyyy: Zn('FullYear', 4, 0, !1, !0), yy: Zn('FullYear', 2, 0, !0, !0), y: Zn('FullYear', 1, 0, !1, !0), MMMM: Kn('Month'), MMM: Kn('Month', !0), MM: Zn('Month', 2, 1), M: Zn('Month', 1, 1), LLLL: Kn('Month', !1, !0), dd: Zn('Date', 2), d: Zn('Date', 1), HH: Zn('Hours', 2), H: Zn('Hours', 1), hh: Zn('Hours', 2, -12), h: Zn('Hours', 1, -12), mm: Zn('Minutes', 2), m: Zn('Minutes', 1), ss: Zn('Seconds', 2), s: Zn('Seconds', 1), sss: Zn('Milliseconds', 3), EEEE: Kn('Day'), EEE: Kn('Day', !0), a: ni, Z: Jn, ww: ei(2), w: ei(1), G: ii, GG: ii, GGG: ii, GGGG: ri }; var Fa = /((?:[^yMLdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|m+|s+|a|Z|G+|w+))(.*)/; var Ua = /^-?\d+$/; ai.$inject = ['$locale']; var za = m(ji); var Ba = m(Vi); ci.$inject = ['$parse']; const ja = m({ restrict: 'E', compile: function (t, e) { if (!e.href && !e.xlinkHref) return function (t, e) { if (e[0].nodeName.toLowerCase() === 'a') { const n = Qi.call(e.prop('href')) === '[object SVGAnimatedString]' ? 'xlink:href' : 'href'; e.on('click', function (t) { e.attr(n) || t.preventDefault() }) } } } }); const Va = {}; i(Ir, function (t, e) { function n (t, n, r) { t.$watch(r[i], function (t) { r.$set(e, !!t) }) } if (t !== 'multiple') { var i = be('ng-' + e); let r = n; t === 'checked' && (r = function (t, e, r) { r.ngModel !== r[i] && n(t, e, r) }), Va[i] = function () { return { restrict: 'A', priority: 100, link: r } } } }), i(Nr, function (t, e) { Va[e] = function () { return { priority: 100, link: function (t, n, i) { if (e === 'ngPattern' && i.ngPattern.charAt(0) === '/') { const r = i.ngPattern.match(/^\/(.+)\/([a-z]*)$/); if (r) return void i.$set('ngPattern', new RegExp(r[1], r[2])) }t.$watch(i[e], function (t) { i.$set(e, t) }) } } } }), i(['src', 'srcset', 'href'], function (t) { const e = be('ng-' + t); Va[e] = function () { return { priority: 99, link: function (n, i, r) { let a = t; let o = t; t === 'href' && Qi.call(i.prop('href')) === '[object SVGAnimatedString]' && (o = 'xlinkHref', r.$attr[o] = 'xlink:href', a = null), r.$observe(e, function (e) { if (!e) return void (t === 'href' && r.$set(o, null)); r.$set(o, e), Wi && a && i.prop(a, r[o]) }) } } } }); var Ga = { $addControl: d, $$renameControl: hi, $removeControl: d, $setValidity: d, $setDirty: d, $setPristine: d, $setSubmitted: d }; var Ha = 'ng-pending'; pi.$inject = ['$element', '$attrs', '$scope', '$animate', '$interpolate'], pi.prototype = { $rollbackViewValue: function () { i(this.$$controls, function (t) { t.$rollbackViewValue() }) }, $commitViewValue: function () { i(this.$$controls, function (t) { t.$commitViewValue() }) }, $addControl: function (t) { ht(t.$name, 'input'), this.$$controls.push(t), t.$name && (this[t.$name] = t), t.$$parentForm = this }, $$renameControl: function (t, e) { const n = t.$name; this[n] === t && delete this[n], this[e] = t, t.$name = e }, $removeControl: function (t) { t.$name && this[t.$name] === t && delete this[t.$name], i(this.$pending, function (e, n) { this.$setValidity(n, null, t) }, this), i(this.$error, function (e, n) { this.$setValidity(n, null, t) }, this), i(this.$$success, function (e, n) { this.$setValidity(n, null, t) }, this), U(this.$$controls, t), t.$$parentForm = Ga }, $setDirty: function () { this.$$animate.removeClass(this.$$element, Co), this.$$animate.addClass(this.$$element, Eo), this.$dirty = !0, this.$pristine = !1, this.$$parentForm.$setDirty() }, $setPristine: function () { this.$$animate.setClass(this.$$element, Co, Eo + ' ng-submitted'), this.$dirty = !1, this.$pristine = !0, this.$submitted = !1, i(this.$$controls, function (t) { t.$setPristine() }) }, $setUntouched: function () { i(this.$$controls, function (t) { t.$setUntouched() }) }, $setSubmitted: function () { this.$$animate.addClass(this.$$element, 'ng-submitted'), this.$submitted = !0, this.$$parentForm.$setSubmitted() } }, fi({ clazz: pi, set: function (t, e, n) { const i = t[e]; if (i) { i.indexOf(n) === -1 && i.push(n) } else t[e] = [n] }, unset: function (t, e, n) { const i = t[e]; i && (U(i, n), i.length === 0 && delete t[e]) } }); const Wa = function (t) { return ['$timeout', '$parse', function (e, n) { function i (t) { return t === '' ? n('this[""]').assign : n(t).assign || d } return { name: 'form', restrict: t ? 'EAC' : 'E', require: ['form', '^^?form'], controller: pi, compile: function (n, r) { n.addClass(Co).addClass(So); const a = r.name ? 'name' : !(!t || !r.ngForm) && 'ngForm'; return { pre: function (t, n, r, o) { const s = o[0]; if (!('action' in r)) { const l = function (e) { t.$apply(function () { s.$commitViewValue(), s.$setSubmitted() }), e.preventDefault() }; n[0].addEventListener('submit', l), n.on('$destroy', function () { e(function () { n[0].removeEventListener('submit', l) }, 0, !1) }) }(o[1] || s.$$parentForm).$addControl(s); let u = a ? i(s.$name) : d; a && (u(t, s), r.$observe(a, function (e) { s.$name !== e && (u(t, void 0), s.$$parentForm.$$renameControl(s, e), (u = i(s.$name))(t, s)) })), n.on('$destroy', function () { s.$$parentForm.$removeControl(s), u(t, void 0), c(s, Ga) }) } } } } }] }; const qa = Wa(); const Xa = Wa(!0); var Ya = /^\d{4,}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+(?:[+-][0-2]\d:[0-5]\d|Z)$/; var Za = /^[a-z][a-z\d.+-]*:\/*(?:[^:@]+(?::[^@]+)?@)?(?:[^\s:\/?#]+|\[[a-f\d:]+])(?::\d+)?(?:\/[^?#]*)?(?:\?[^#]*)?(?:#.*)?$/i; var Ka = /^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+\/0-9=?A-Z^_`a-z{|}~]+(\.[-!#$%&'*+\/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/; var Ja = /^\s*(-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/; const Qa = /^(\d{4,})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/; var to = /^(\d{4,})-W(\d\d)$/; const eo = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/; var no = 'keydown wheel mousedown'; var io = ft(); i('date,datetime-local,month,time,week'.split(','), function (t) { io[t] = !0 }); const ro = { text: vi, date: wi('date', /^(\d{4,})-(\d{2})-(\d{2})$/, xi(/^(\d{4,})-(\d{2})-(\d{2})$/, ['yyyy', 'MM', 'dd']), 'yyyy-MM-dd'), 'datetime-local': wi('datetimelocal', Qa, xi(Qa, ['yyyy', 'MM', 'dd', 'HH', 'mm', 'ss', 'sss']), 'yyyy-MM-ddTHH:mm:ss.sss'), time: wi('time', eo, xi(eo, ['HH', 'mm', 'ss', 'sss']), 'HH:mm:ss.sss'), week: wi('week', to, bi, 'yyyy-Www'), month: wi('month', /^(\d{4,})-(\d\d)$/, xi(/^(\d{4,})-(\d\d)$/, ['yyyy', 'MM']), 'yyyy-MM'), number: Ei, url: Pi, email: ki, radio: Di, range: Ai, checkbox: Li, hidden: d, button: d, submit: d, reset: d, file: d }; const ao = ['$browser', '$sniffer', '$filter', '$parse', function (t, e, n, i) { return { restrict: 'E', require: ['?ngModel'], link: { pre: function (r, a, o, s) { s[0] && (ro[ji(o.type)] || ro.text)(r, a, o, s[0], e, t, n, i) } } } }]; const oo = /^(true|false|\d+)$/; const so = function () { function t (t, e, n) { const i = y(n) ? n : Wi === 9 ? '' : null; t.prop('value', i), e.$set('value', n) } return { restrict: 'A', priority: 100, compile: function (e, n) { return oo.test(n.ngValue) ? function (e, n, i) { t(n, i, e.$eval(i.ngValue)) } : function (e, n, i) { e.$watch(i.ngValue, function (e) { t(n, i, e) }) } } } }; const lo = ['$compile', function (t) { return { restrict: 'AC', compile: function (e) { return t.$$addBindingClass(e), function (e, n, i) { t.$$addBindingInfo(n, i.ngBind), n = n[0], e.$watch(i.ngBind, function (t) { n.textContent = mt(t) }) } } } }]; const co = ['$interpolate', '$compile', function (t, e) { return { compile: function (n) { return e.$$addBindingClass(n), function (n, i, r) { const a = t(i.attr(r.$attr.ngBindTemplate)); e.$$addBindingInfo(i, a.expressions), i = i[0], r.$observe('ngBindTemplate', function (t) { i.textContent = v(t) ? '' : t }) } } } }]; const uo = ['$sce', '$parse', '$compile', function (t, e, n) { return { restrict: 'A', compile: function (i, r) { const a = e(r.ngBindHtml); const o = e(r.ngBindHtml, function (e) { return t.valueOf(e) }); return n.$$addBindingClass(i), function (e, i, r) { n.$$addBindingInfo(i, r.ngBindHtml), e.$watch(o, function () { const n = a(e); i.html(t.getTrustedHtml(n) || '') }) } } } }]; const ho = m({ restrict: 'A', require: 'ngModel', link: function (t, e, n, i) { i.$viewChangeListeners.push(function () { t.$eval(n.ngChange) }) } }); const po = Ii('', !0); const fo = Ii('Odd', 0); const mo = Ii('Even', 1); const go = ui({ compile: function (t, e) { e.$set('ngCloak', void 0), t.removeClass('ng-cloak') } }); const vo = [function () { return { restrict: 'A', scope: !0, controller: '@', priority: 500 } }]; const yo = {}; const bo = { blur: !0, focus: !0 }; i('click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste'.split(' '), function (t) { const e = be('ng-' + t); yo[e] = ['$parse', '$rootScope', function (n, i) { return { restrict: 'A', compile: function (r, a) { const o = n(a[e]); return function (e, n) { n.on(t, function (n) { const r = function () { o(e, { $event: n }) }; bo[t] && i.$$phase ? e.$evalAsync(r) : e.$apply(r) }) } } } }] }); const xo = ['$animate', '$compile', function (t, e) { return { multiElement: !0, transclude: 'element', priority: 600, terminal: !0, restrict: 'A', $$tlb: !0, link: function (n, i, r, a, o) { let s, l, c; n.$watch(r.ngIf, function (n) { n ? l || o(function (n, a) { l = a, n[n.length++] = e.$$createComment('end ngIf', r.ngIf), s = { clone: n }, t.enter(n, i.parent(), i) }) : (c && (c.remove(), c = null), l && (l.$destroy(), l = null), s && (c = dt(s.clone), t.leave(c).done(function (t) { !1 !== t && (c = null) }), s = null)) }) } } }]; const wo = ['$templateRequest', '$anchorScroll', '$animate', function (t, e, n) { return { restrict: 'ECA', priority: 400, terminal: !0, transclude: 'element', controller: nr.noop, compile: function (i, r) { const a = r.ngInclude || r.src; const o = r.onload || ''; const s = r.autoscroll; return function (i, r, l, c, u) { let h; let p; let d; let f = 0; const m = function () { p && (p.remove(), p = null), h && (h.$destroy(), h = null), d && (n.leave(d).done(function (t) { !1 !== t && (p = null) }), p = d, d = null) }; i.$watch(a, function (a) { const l = function (t) { !1 === t || !y(s) || s && !i.$eval(s) || e() }; const p = ++f; a ? (t(a, !0).then(function (t) { if (!i.$$destroyed && p === f) { const e = i.$new(); c.template = t; const s = u(e, function (t) { m(), n.enter(t, null, r).done(l) }); h = e, d = s, h.$emit('$includeContentLoaded', a), i.$eval(o) } }, function () { i.$$destroyed || p === f && (m(), i.$emit('$includeContentError', a)) }), i.$emit('$includeContentRequested', a)) : (m(), c.template = null) }) } } } }]; const _o = ['$compile', function (e) { return { restrict: 'ECA', priority: -400, require: 'ngInclude', link: function (n, i, r, a) { if (Qi.call(i[0]).match(/SVG/)) return i.empty(), void e(Et(a.template, t.document).childNodes)(n, function (t) { i.append(t) }, { futureParentElement: i }); i.html(a.template), e(i.contents())(n) } } }]; const $o = ui({ priority: 450, compile: function () { return { pre: function (t, e, n) { t.$eval(n.ngInit) } } } }); const To = function () {
    return { restrict: 'A', priority: 100, require: 'ngModel', link: function (t, e, n, r) { const a = n.ngList || ', '; const o = n.ngTrim !== 'false'; const s = o ? sr(a) : a; const l = function (t) { if (!v(t)) { const e = []; return t && i(t.split(s), function (t) { t && e.push(o ? sr(t) : t) }), e } }; r.$parsers.push(l), r.$formatters.push(function (t) { if (ar(t)) return t.join(a) }), r.$isEmpty = function (t) { return !t || !t.length } } }
  }; var So = 'ng-valid'; var Mo = 'ng-invalid'; var Co = 'ng-pristine'; var Eo = 'ng-dirty'; var Ao = e('ngModel'); Ri.$inject = ['$scope', '$exceptionHandler', '$attrs', '$element', '$parse', '$animate', '$timeout', '$q', '$interpolate'], Ri.prototype = { $$initGetterSetters: function () { if (this.$options.getOption('getterSetter')) { const t = this.$$parse(this.$$attr.ngModel + '()'); const e = this.$$parse(this.$$attr.ngModel + '($$$p)'); this.$$ngModelGet = function (e) { let n = this.$$parsedNgModel(e); return T(n) && (n = t(e)), n }, this.$$ngModelSet = function (t, n) { T(this.$$parsedNgModel(t)) ? e(t, { $$$p: n }) : this.$$parsedNgModelAssign(t, n) } } else if (!this.$$parsedNgModel.assign) throw Ao('nonassign', "Expression '{0}' is non-assignable. Element: {1}", this.$$attr.ngModel, K(this.$$element)) }, $render: d, $isEmpty: function (t) { return v(t) || t === '' || t === null || t !== t }, $$updateEmptyClasses: function (t) { this.$isEmpty(t) ? (this.$$animate.removeClass(this.$$element, 'ng-not-empty'), this.$$animate.addClass(this.$$element, 'ng-empty')) : (this.$$animate.removeClass(this.$$element, 'ng-empty'), this.$$animate.addClass(this.$$element, 'ng-not-empty')) }, $setPristine: function () { this.$dirty = !1, this.$pristine = !0, this.$$animate.removeClass(this.$$element, Eo), this.$$animate.addClass(this.$$element, Co) }, $setDirty: function () { this.$dirty = !0, this.$pristine = !1, this.$$animate.removeClass(this.$$element, Co), this.$$animate.addClass(this.$$element, Eo), this.$$parentForm.$setDirty() }, $setUntouched: function () { this.$touched = !1, this.$untouched = !0, this.$$animate.setClass(this.$$element, 'ng-untouched', 'ng-touched') }, $setTouched: function () { this.$touched = !0, this.$untouched = !1, this.$$animate.setClass(this.$$element, 'ng-touched', 'ng-untouched') }, $rollbackViewValue: function () { this.$$timeout.cancel(this.$$pendingDebounce), this.$viewValue = this.$$lastCommittedViewValue, this.$render() }, $validate: function () { if (!rr(this.$modelValue)) { const t = this.$$lastCommittedViewValue; const e = this.$$rawModelValue; const n = this.$valid; const i = this.$modelValue; const r = this.$options.getOption('allowInvalid'); const a = this; this.$$runValidators(e, t, function (t) { r || n === t || (a.$modelValue = t ? e : void 0, a.$modelValue !== i && a.$$writeModelToScope()) }) } }, $$runValidators: function (t, e, n) { function r (t, e) { o === s.$$currentValidationRunId && s.$setValidity(t, e) } function a (t) { o === s.$$currentValidationRunId && n(t) } this.$$currentValidationRunId++; var o = this.$$currentValidationRunId; var s = this; return (function () { const t = s.$$parserName || 'parse'; return v(s.$$parserValid) ? (r(t, null), !0) : (s.$$parserValid || (i(s.$validators, function (t, e) { r(e, null) }), i(s.$asyncValidators, function (t, e) { r(e, null) })), r(t, s.$$parserValid), s.$$parserValid) }()) && (function () { let n = !0; return i(s.$validators, function (i, a) { const o = Boolean(i(t, e)); n = n && o, r(a, o) }), !!n || (i(s.$asyncValidators, function (t, e) { r(e, null) }), !1) }()) ? void (function () { const n = []; let o = !0; i(s.$asyncValidators, function (i, a) { const s = i(t, e); if (!D(s)) throw Ao('nopromise', "Expected asynchronous validator to return a promise but got '{0}' instead.", s); r(a, void 0), n.push(s.then(function () { r(a, !0) }, function () { o = !1, r(a, !1) })) }), n.length ? s.$$q.all(n).then(function () { a(o) }, d) : a(!0) }()) : void a(!1) }, $commitViewValue: function () { const t = this.$viewValue; this.$$timeout.cancel(this.$$pendingDebounce), (this.$$lastCommittedViewValue !== t || t === '' && this.$$hasNativeValidators) && (this.$$updateEmptyClasses(t), this.$$lastCommittedViewValue = t, this.$pristine && this.$setDirty(), this.$$parseAndValidate()) }, $$parseAndValidate: function () { function t () { i.$modelValue !== a && i.$$writeModelToScope() } const e = this.$$lastCommittedViewValue; let n = e; var i = this; if (this.$$parserValid = !v(n) || void 0, this.$$parserValid) for (let r = 0; r < this.$parsers.length; r++) if (n = this.$parsers[r](n), v(n)) { this.$$parserValid = !1; break }rr(this.$modelValue) && (this.$modelValue = this.$$ngModelGet(this.$$scope)); var a = this.$modelValue; const o = this.$options.getOption('allowInvalid'); this.$$rawModelValue = n, o && (this.$modelValue = n, t()), this.$$runValidators(n, this.$$lastCommittedViewValue, function (e) { o || (i.$modelValue = e ? n : void 0, t()) }) }, $$writeModelToScope: function () { this.$$ngModelSet(this.$$scope, this.$modelValue), i(this.$viewChangeListeners, function (t) { try { t() } catch (t) { this.$$exceptionHandler(t) } }, this) }, $setViewValue: function (t, e) { this.$viewValue = t, this.$options.getOption('updateOnDefault') && this.$$debounceViewValueCommit(e) }, $$debounceViewValueCommit: function (t) { let e = this.$options.getOption('debounce'); _(e[t]) ? e = e[t] : _(e.default) && (e = e.default), this.$$timeout.cancel(this.$$pendingDebounce); const n = this; e > 0 ? this.$$pendingDebounce = this.$$timeout(function () { n.$commitViewValue() }, e) : this.$$scope.$root.$$phase ? this.$commitViewValue() : this.$$scope.$apply(function () { n.$commitViewValue() }) }, $overrideModelOptions: function (t) { this.$options = this.$options.createChild(t) } }, fi({ clazz: Ri, set: function (t, e) { t[e] = !0 }, unset: function (t, e) { delete t[e] } }); let Po; const ko = ['$rootScope', function (t) { return { restrict: 'A', require: ['ngModel', '^?form', '^?ngModelOptions'], controller: Ri, priority: 1, compile: function (e) { return e.addClass(Co).addClass('ng-untouched').addClass(So), { pre: function (t, e, n, i) { const r = i[0]; const a = i[1] || r.$$parentForm; const o = i[2]; o && (r.$options = o.$options), r.$$initGetterSetters(), a.$addControl(r), n.$observe('name', function (t) { r.$name !== t && r.$$parentForm.$$renameControl(r, t) }), t.$on('$destroy', function () { r.$$parentForm.$removeControl(r) }) }, post: function (e, n, i, r) { function a () { o.$setTouched() } var o = r[0]; o.$options.getOption('updateOn') && n.on(o.$options.getOption('updateOn'), function (t) { o.$$debounceViewValueCommit(t && t.type) }), n.on('blur', function () { o.$touched || (t.$$phase ? e.$evalAsync(a) : e.$apply(a)) }) } } } } }]; Fi.prototype = { getOption: function (t) { return this.$$options[t] }, createChild: function (t) { let e = !1; return t = c({}, t), i(t, function (n, i) { n === '$inherit' ? i === '*' ? e = !0 : (t[i] = this.$$options[i], i === 'updateOn' && (t.updateOnDefault = this.$$options.updateOnDefault)) : i === 'updateOn' && (t.updateOnDefault = !1, t[i] = sr(n.replace(/(\s+|^)default(\s+|$)/, function () { return t.updateOnDefault = !0, ' ' }))) }, this), e && (delete t['*'], Ui(t, this.$$options)), Ui(t, Po.$$options), new Fi(t) } }, Po = new Fi({ updateOn: '', updateOnDefault: !0, debounce: 0, getterSetter: !1, allowInvalid: !1, timezone: null }); const Do = function () { function t (t, e) { this.$$attrs = t, this.$$scope = e } return t.$inject = ['$attrs', '$scope'], t.prototype = { $onInit: function () { const t = this.parentCtrl ? this.parentCtrl.$options : Po; const e = this.$$scope.$eval(this.$$attrs.ngModelOptions); this.$options = t.createChild(e) } }, { restrict: 'A', priority: 10, require: { parentCtrl: '?^^ngModelOptions' }, bindToController: !0, controller: t } }; const Oo = ui({ terminal: !0, priority: 1e3 }); const Lo = e('ngOptions'); const Io = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([$\w][$\w]*)|(?:\(\s*([$\w][$\w]*)\s*,\s*([$\w][$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/; const Ro = ['$compile', '$document', '$parse', function (e, r, a) { function o (t, e, i) { function r (t, e, n, i, r) { this.selectValue = t, this.viewValue = e, this.label = n, this.group = i, this.disabled = r } function o (t) { let e; if (!c && n(t))e = t; else { e = []; for (const i in t)t.hasOwnProperty(i) && i.charAt(0) !== '$' && e.push(i) } return e } const s = t.match(Io); if (!s) throw Lo('iexp', "Expected expression in form of '_select_ (as _label_)? for (_key_,)?_value_ in _collection_' but got '{0}'. Element: {1}", t, K(e)); const l = s[5] || s[7]; var c = s[6]; const u = / as /.test(s[0]) && s[1]; const h = s[9]; const p = a(s[2] ? s[1] : l); const d = u && a(u); const f = d || p; const m = h && a(h); const g = h ? function (t, e) { return m(i, e) } : function (t) { return te(t) }; const v = function (t, e) { return g(t, $(t, e)) }; const y = a(s[2] || s[1]); const b = a(s[3] || ''); const x = a(s[4] || ''); const w = a(s[8]); const _ = {}; var $ = c ? function (t, e) { return _[c] = e, _[l] = t, _ } : function (t) { return _[l] = t, _ }; return { trackBy: h, getTrackByValue: v, getWatchables: a(w, function (t) { const e = []; t = t || []; for (let n = o(t), r = n.length, a = 0; a < r; a++) { const l = t === n ? a : n[a]; const c = t[l]; const u = $(c, l); const h = g(c, u); if (e.push(h), s[2] || s[1]) { const p = y(i, u); e.push(p) } if (s[4]) { const d = x(i, u); e.push(d) } } return e }), getOptions: function () { for (var t = [], e = {}, n = w(i) || [], a = o(n), s = a.length, l = 0; l < s; l++) { const c = n === a ? l : a[l]; const u = n[c]; const p = $(u, c); const d = f(i, p); const m = g(d, p); const _ = y(i, p); const T = b(i, p); const S = x(i, p); const M = new r(m, d, _, T, S); t.push(M), e[m] = M } return { items: t, selectValueMap: e, getOptionFromViewValue: function (t) { return e[v(t)] }, getViewValueFromOption: function (t) { return h ? z(t.viewValue) : t.viewValue } } } } } function s (t, n, a, s) { function u (t, e) { const n = l.cloneNode(!1); e.appendChild(n), p(t, n) } function h (t) { const e = _.getOptionFromViewValue(t); const n = e && e.element; return n && !n.selected && (n.selected = !0), e } function p (t, e) { t.element = e, e.disabled = t.disabled, t.label !== e.label && (e.label = t.label, e.textContent = t.label), e.value = t.selectValue } function d () { const t = _ && f.readValue(); if (_) for (let e = _.items.length - 1; e >= 0; e--) { const i = _.items[e]; Ht(y(i.group) ? i.element.parentNode : i.element) }_ = $.getOptions(); const r = {}; if (w && n.prepend(f.emptyOption), _.items.forEach(function (t) { let e; y(t.group) ? (e = r[t.group], e || (e = c.cloneNode(!1), T.appendChild(e), e.label = t.group === null ? 'null' : t.group, r[t.group] = e), u(t, e)) : u(t, T) }), n[0].appendChild(T), m.$render(), !m.$isEmpty(t)) { const a = f.readValue(); ($.trackBy || g ? B(t, a) : t === a) || (m.$setViewValue(a), m.$render()) } } for (var f = s[0], m = s[1], g = a.multiple, v = 0, b = n.children(), x = b.length; v < x; v++) if (b[v].value === '') { f.hasEmptyOption = !0, f.emptyOption = b.eq(v); break } var w = !!f.emptyOption; qi(l.cloneNode(!1)).val('?'); let _; var $ = o(a.ngOptions, n, t); var T = r[0].createDocumentFragment(); f.generateUnknownOptionValue = function (t) { return '?' }, g ? (f.writeValue = function (t) { const e = t && t.map(h) || []; _.items.forEach(function (t) { t.element.selected && !F(e, t) && (t.element.selected = !1) }) }, f.readValue = function () { const t = n.val() || []; const e = []; return i(t, function (t) { const n = _.selectValueMap[t]; n && !n.disabled && e.push(_.getViewValueFromOption(n)) }), e }, $.trackBy && t.$watchCollection(function () { if (ar(m.$viewValue)) return m.$viewValue.map(function (t) { return $.getTrackByValue(t) }) }, function () { m.$render() })) : (f.writeValue = function (t) { const e = _.selectValueMap[n.val()]; const i = _.getOptionFromViewValue(t); e && e.element.removeAttribute('selected'), i ? (n[0].value !== i.selectValue && (f.removeUnknownOption(), f.unselectEmptyOption(), n[0].value = i.selectValue, i.element.selected = !0), i.element.setAttribute('selected', 'selected')) : w ? f.selectEmptyOption() : f.unknownOption.parent().length ? f.updateUnknownOption(t) : f.renderUnknownOption(t) }, f.readValue = function () { const t = _.selectValueMap[n.val()]; return t && !t.disabled ? (f.unselectEmptyOption(), f.removeUnknownOption(), _.getViewValueFromOption(t)) : null }, $.trackBy && t.$watch(function () { return $.getTrackByValue(m.$viewValue) }, function () { m.$render() })), w && (f.emptyOption.remove(), e(f.emptyOption)(t), f.emptyOption[0].nodeType === yr ? (f.hasEmptyOption = !1, f.registerOption = function (t, e) { e.val() === '' && (f.hasEmptyOption = !0, f.emptyOption = e, f.emptyOption.removeClass('ng-scope'), m.$render(), e.on('$destroy', function () { f.hasEmptyOption = !1, f.emptyOption = void 0 })) }) : f.emptyOption.removeClass('ng-scope')), n.empty(), d(), t.$watchCollection($.getWatchables, d) } var l = t.document.createElement('option'); var c = t.document.createElement('optgroup'); return { restrict: 'A', terminal: !0, require: ['select', 'ngModel'], link: { pre: function (t, e, n, i) { i[0].registerOption = d }, post: s } } }]; const No = ['$locale', '$interpolate', '$log', function (t, e, n) { const r = /^when(Minus)?(.+)$/; return { link: function (a, o, s) { function l (t) { o.text(t || '') } let c; const u = s.count; const h = s.$attr.when && o.attr(s.$attr.when); const p = s.offset || 0; const f = a.$eval(h) || {}; const m = {}; const g = e.startSymbol(); const y = e.endSymbol(); const b = g + u + '-' + p + y; let x = nr.noop; i(s, function (t, e) { const n = r.exec(e); if (n) { const i = (n[1] ? '-' : '') + ji(n[2]); f[i] = o.attr(s.$attr[e]) } }), i(f, function (t, n) { m[n] = e(t.replace(/{}/g, b)) }), a.$watch(u, function (e) { let i = parseFloat(e); const r = rr(i); if (r || i in f || (i = t.pluralCat(i - p)), !(i === c || r && rr(c))) { x(); const o = m[i]; v(o) ? (e != null && n.debug("ngPluralize: no rule defined for '" + i + "' in " + h), x = d, l()) : x = a.$watch(o, l), c = i } }) } } }]; const Fo = ['$parse', '$animate', '$compile', function (t, r, a) { const o = e('ngRepeat'); const s = function (t, e, n, i, r, a, o) { t[n] = i, r && (t[r] = a), t.$index = e, t.$first = e === 0, t.$last = e === o - 1, t.$middle = !(t.$first || t.$last), t.$odd = !(t.$even = (1 & e) == 0) }; const l = function (t) { return t.clone[0] }; const c = function (t) { return t.clone[t.clone.length - 1] }; return { restrict: 'A', multiElement: !0, transclude: 'element', priority: 1e3, terminal: !0, $$tlb: !0, compile: function (e, u) { const h = u.ngRepeat; const p = a.$$createComment('end ngRepeat', h); let d = h.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/); if (!d) throw o('iexp', "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", h); const f = d[1]; const m = d[2]; const g = d[3]; const v = d[4]; if (!(d = f.match(/^(?:(\s*[$\w]+)|\(\s*([$\w]+)\s*,\s*([$\w]+)\s*\))$/))) throw o('iidexp', "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.", f); const y = d[3] || d[1]; const b = d[2]; if (g && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(g) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(g))) throw o('badident', "alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.", g); let x; let w; let _; let $; const T = { $id: te }; return v ? x = t(v) : (_ = function (t, e) { return te(e) }, $ = function (t) { return t }), function (t, e, a, u, d) { x && (w = function (e, n, i) { return b && (T[b] = e), T[y] = n, T.$index = i, x(t, T) }); let f = ft(); t.$watchCollection(m, function (a) { let u; let m; let v; let x; let T; let S; let M; let C; let E; let A; let P; let k; let D = e[0]; const O = ft(); if (g && (t[g] = a), n(a))E = a, C = w || _; else { C = w || $, E = []; for (const L in a)Bi.call(a, L) && L.charAt(0) !== '$' && E.push(L) } for (x = E.length, P = new Array(x), u = 0; u < x; u++) if (T = a === E ? u : E[u], S = a[T], M = C(T, S, u), f[M])A = f[M], delete f[M], O[M] = A, P[u] = A; else { if (O[M]) throw i(P, function (t) { t && t.scope && (f[t.id] = t) }), o('dupes', "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}", h, M, S); P[u] = { id: M, scope: void 0, clone: void 0 }, O[M] = !0 } for (const I in f) { if (A = f[I], k = dt(A.clone), r.leave(k), k[0].parentNode) for (u = 0, m = k.length; u < m; u++)k[u].$$NG_REMOVED = !0; A.scope.$destroy() } for (u = 0; u < x; u++) if (T = a === E ? u : E[u], S = a[T], A = P[u], A.scope) { v = D; do { v = v.nextSibling } while (v && v.$$NG_REMOVED); l(A) !== v && r.move(dt(A.clone), null, D), D = c(A), s(A.scope, u, y, S, b, T, x) } else d(function (t, e) { A.scope = e; const n = p.cloneNode(!1); t[t.length++] = n, r.enter(t, null, D), D = n, A.clone = t, O[A.id] = A, s(A.scope, u, y, S, b, T, x) }); f = O }) } } } }]; const Uo = ['$animate', function (t) { return { restrict: 'A', multiElement: !0, link: function (e, n, i) { e.$watch(i.ngShow, function (e) { t[e ? 'removeClass' : 'addClass'](n, 'ng-hide', { tempClasses: 'ng-hide-animate' }) }) } } }]; const zo = ['$animate', function (t) { return { restrict: 'A', multiElement: !0, link: function (e, n, i) { e.$watch(i.ngHide, function (e) { t[e ? 'addClass' : 'removeClass'](n, 'ng-hide', { tempClasses: 'ng-hide-animate' }) }) } } }]; const Bo = ui(function (t, e, n) { t.$watch(n.ngStyle, function (t, n) { n && t !== n && i(n, function (t, n) { e.css(n, '') }), t && e.css(t) }, !0) }); const jo = ['$animate', '$compile', function (t, e) { return { require: 'ngSwitch', controller: ['$scope', function () { this.cases = {} }], link: function (n, r, a, o) { const s = a.ngSwitch || a.on; let l = []; const c = []; const u = []; const h = []; const p = function (t, e) { return function (n) { !1 !== n && t.splice(e, 1) } }; n.$watch(s, function (n) { for (var r, a; u.length;)t.cancel(u.pop()); for (r = 0, a = h.length; r < a; ++r) { const s = dt(c[r].clone); h[r].$destroy(); (u[r] = t.leave(s)).done(p(u, r)) }c.length = 0, h.length = 0, (l = o.cases['!' + n] || o.cases['?']) && i(l, function (n) { n.transclude(function (i, r) { h.push(r); const a = n.element; i[i.length++] = e.$$createComment('end ngSwitchWhen'); const o = { clone: i }; c.push(o), t.enter(i, a.parent(), a) }) }) }) } } }]; const Vo = ui({ transclude: 'element', priority: 1200, require: '^ngSwitch', multiElement: !0, link: function (t, e, n, r, a) { i(n.ngSwitchWhen.split(n.ngSwitchWhenSeparator).sort().filter(function (t, e, n) { return n[e - 1] !== t }), function (t) { r.cases['!' + t] = r.cases['!' + t] || [], r.cases['!' + t].push({ transclude: a, element: e }) }) } }); const Go = ui({ transclude: 'element', priority: 1200, require: '^ngSwitch', multiElement: !0, link: function (t, e, n, i, r) { i.cases['?'] = i.cases['?'] || [], i.cases['?'].push({ transclude: r, element: e }) } }); const Ho = e('ngTransclude'); const Wo = ['$compile', function (t) { return { restrict: 'EAC', terminal: !0, compile: function (e) { const n = t(e.contents()); return e.empty(), function (t, e, i, r, a) { function o (t, n) { t.length && l(t) ? e.append(t) : (s(), n.$destroy()) } function s () { n(t, function (t) { e.append(t) }) } function l (t) { for (let e = 0, n = t.length; e < n; e++) { const i = t[e]; if (i.nodeType !== vr || i.nodeValue.trim()) return !0 } } if (!a) throw Ho('orphan', 'Illegal use of ngTransclude directive in the template! No parent directive that requires a transclusion found. Element: {0}', K(e)); i.ngTransclude === i.$attr.ngTransclude && (i.ngTransclude = ''); const c = i.ngTransclude || i.ngTranscludeSlot; a(o, null, c), c && !a.isSlotFilled(c) && s() } } } }]; const qo = ['$templateCache', function (t) { return { restrict: 'E', terminal: !0, compile: function (e, n) { if (n.type === 'text/ng-template') { const i = n.id; const r = e[0].text; t.put(i, r) } } } }]; const Xo = { $setViewValue: d, $render: d }; const Yo = ['$element', '$scope', function (e, n) { function i () { l || (l = !0, n.$$postDigest(function () { l = !1, o.ngModelCtrl.$render() })) } function r (t) { c || (c = !0, n.$$postDigest(function () { n.$$destroyed || (c = !1, o.ngModelCtrl.$setViewValue(o.readValue()), t && o.ngModelCtrl.$render()) })) } function a (t) { t.prop('selected', !0), t.attr('selected', !0) } var o = this; const s = new Ur(); o.selectValueMap = {}, o.ngModelCtrl = Xo, o.multiple = !1, o.unknownOption = qi(t.document.createElement('option')), o.hasEmptyOption = !1, o.emptyOption = void 0, o.renderUnknownOption = function (t) { const n = o.generateUnknownOptionValue(t); o.unknownOption.val(n), e.prepend(o.unknownOption), a(o.unknownOption), e.val(n) }, o.updateUnknownOption = function (t) { const n = o.generateUnknownOptionValue(t); o.unknownOption.val(n), a(o.unknownOption), e.val(n) }, o.generateUnknownOptionValue = function (t) { return '? ' + te(t) + ' ?' }, o.removeUnknownOption = function () { o.unknownOption.parent() && o.unknownOption.remove() }, o.selectEmptyOption = function () { o.emptyOption && (e.val(''), a(o.emptyOption)) }, o.unselectEmptyOption = function () { o.hasEmptyOption && o.emptyOption.removeAttr('selected') }, n.$on('$destroy', function () { o.renderUnknownOption = d }), o.readValue = function () { const t = e.val(); const n = t in o.selectValueMap ? o.selectValueMap[t] : t; return o.hasOption(n) ? n : null }, o.writeValue = function (t) { const n = e[0].options[e[0].selectedIndex]; if (n && n.removeAttribute('selected'), o.hasOption(t)) { o.removeUnknownOption(); const i = te(t); e.val(i in o.selectValueMap ? i : t); const r = e[0].options[e[0].selectedIndex]; a(qi(r)) } else t == null && o.emptyOption ? (o.removeUnknownOption(), o.selectEmptyOption()) : o.unknownOption.parent().length ? o.updateUnknownOption(t) : o.renderUnknownOption(t) }, o.addOption = function (t, e) { if (e[0].nodeType !== yr) { ht(t, '"option value"'), t === '' && (o.hasEmptyOption = !0, o.emptyOption = e); const n = s.get(t) || 0; s.set(t, n + 1), i() } }, o.removeOption = function (t) { const e = s.get(t); e && (e === 1 ? (s.delete(t), t === '' && (o.hasEmptyOption = !1, o.emptyOption = void 0)) : s.set(t, e - 1)) }, o.hasOption = function (t) { return !!s.get(t) }; var l = !1; var c = !1; o.registerOption = function (t, e, n, a, s) { if (n.$attr.ngValue) { var l; let c = NaN; n.$observe('value', function (t) { let n; const i = e.prop('selected'); y(c) && (o.removeOption(l), delete o.selectValueMap[c], n = !0), c = te(t), l = t, o.selectValueMap[c] = t, o.addOption(t, e), e.attr('value', c), n && i && r() }) } else a ? n.$observe('value', function (t) { o.readValue(); let n; const i = e.prop('selected'); y(l) && (o.removeOption(l), n = !0), l = t, o.addOption(t, e), n && i && r() }) : s ? t.$watch(s, function (t, i) { n.$set('value', t); const a = e.prop('selected'); i !== t && o.removeOption(i), o.addOption(t, e), i && a && r() }) : o.addOption(n.value, e); n.$observe('disabled', function (t) { (t === 'true' || t && e.prop('selected')) && (o.multiple ? r(!0) : (o.ngModelCtrl.$setViewValue(null), o.ngModelCtrl.$render())) }), e.on('$destroy', function () { const t = o.readValue(); const e = n.value; o.removeOption(e), i(), (o.multiple && t && t.indexOf(e) !== -1 || t === e) && r(!0) }) } }]; const Zo = function () { function t (t, e, n, r) { const a = r[0]; const o = r[1]; if (!o) return void (a.registerOption = d); if (a.ngModelCtrl = o, e.on('change', function () { a.removeUnknownOption(), t.$apply(function () { o.$setViewValue(a.readValue()) }) }), n.multiple) { a.multiple = !0, a.readValue = function () { const t = []; return i(e.find('option'), function (e) { if (e.selected && !e.disabled) { const n = e.value; t.push(n in a.selectValueMap ? a.selectValueMap[n] : n) } }), t }, a.writeValue = function (t) { i(e.find('option'), function (e) { e.selected = !!t && (F(t, e.value) || F(t, a.selectValueMap[e.value])) }) }; let s; let l = NaN; t.$watch(function () { l !== o.$viewValue || B(s, o.$viewValue) || (s = vt(o.$viewValue), o.$render()), l = o.$viewValue }), o.$isEmpty = function (t) { return !t || t.length === 0 } } } function e (t, e, n, i) { const r = i[1]; if (r) { const a = i[0]; r.$render = function () { a.writeValue(r.$viewValue) } } } return { restrict: 'E', require: ['select', '?ngModel'], controller: Yo, priority: 1, link: { pre: t, post: e } } }; const Ko = ['$interpolate', function (t) { return { restrict: 'E', priority: 100, compile: function (e, n) { let i, r; return y(n.ngValue) || (y(n.value) ? i = t(n.value, !0) : (r = t(e.text(), !0)) || n.$set('value', e.text())), function (t, e, n) { const a = e.parent(); const o = a.data('$selectController') || a.parent().data('$selectController'); o && o.registerOption(t, e, n, i, r) } } } }]; const Jo = function () { return { restrict: 'A', require: '?ngModel', link: function (t, e, n, i) { i && (n.required = !0, i.$validators.required = function (t, e) { return !n.required || !i.$isEmpty(e) }, n.$observe('required', function () { i.$validate() })) } } }; const Qo = function () { return { restrict: 'A', require: '?ngModel', link: function (t, n, i, r) { if (r) { let a; const o = i.ngPattern || i.pattern; i.$observe('pattern', function (t) { if (w(t) && t.length > 0 && (t = new RegExp('^' + t + '$')), t && !t.test) throw e('ngPattern')('noregexp', 'Expected {0} to be a RegExp but was {1}. Element: {2}', o, t, K(n)); a = t || void 0, r.$validate() }), r.$validators.pattern = function (t, e) { return r.$isEmpty(e) || v(a) || a.test(e) } } } } }; const ts = function () { return { restrict: 'A', require: '?ngModel', link: function (t, e, n, i) { if (i) { let r = -1; n.$observe('maxlength', function (t) { const e = h(t); r = rr(e) ? -1 : e, i.$validate() }), i.$validators.maxlength = function (t, e) { return r < 0 || i.$isEmpty(e) || e.length <= r } } } } }; const es = function () { return { restrict: 'A', require: '?ngModel', link: function (t, e, n, i) { if (i) { let r = 0; n.$observe('minlength', function (t) { r = h(t) || 0, i.$validate() }), i.$validators.minlength = function (t, e) { return i.$isEmpty(e) || e.length >= r } } } } }; if (t.angular.bootstrap) return void t.console; !(function () { let e; if (!mr) { const n = ur(); Xi = v(n) ? t.jQuery : n ? t[n] : void 0, Xi && Xi.fn.on ? (qi = Xi, c(Xi.fn, { scope: Lr.scope, isolateScope: Lr.isolateScope, controller: Lr.controller, injector: Lr.injector, inheritedData: Lr.inheritedData }), e = Xi.cleanData, Xi.cleanData = function (t) { for (var n, i, r = 0; (i = t[r]) != null; r++)(n = Xi._data(i, 'events')) && n.$destroy && Xi(i).triggerHandler('$destroy'); e(t) }) : qi = kt, nr.element = qi, mr = !0 } }()), (function (n) { c(n, { bootstrap: at, copy: z, extend: c, merge: u, equals: B, element: qi, forEach: i, injector: oe, noop: d, bind: G, toJson: W, fromJson: q, identity: f, isUndefined: v, isDefined: y, isString: w, isFunction: T, isObject: b, isNumber: _, isElement: I, isArray: ar, version: wr, isDate: $, lowercase: ji, uppercase: Vi, callbacks: { $$counter: 0 }, getTestability: st, reloadWithDebugInfo: ot, $$minErr: e, $$csp: cr, $$encodeUriSegment: et, $$encodeUriQuery: nt, $$stringify: mt }), (Yi = gt(t))('ng', ['ngLocale'], ['$provide', function (t) { t.provider({ $$sanitizeUri: Tn }), t.provider('$compile', ve).directive({ a: ja, input: ao, textarea: ao, form: qa, script: qo, select: Zo, option: Ko, ngBind: lo, ngBindHtml: uo, ngBindTemplate: co, ngClass: po, ngClassEven: mo, ngClassOdd: fo, ngCloak: go, ngController: vo, ngForm: Xa, ngHide: zo, ngIf: xo, ngInclude: wo, ngInit: $o, ngNonBindable: Oo, ngPluralize: No, ngRepeat: Fo, ngShow: Uo, ngStyle: Bo, ngSwitch: jo, ngSwitchWhen: Vo, ngSwitchDefault: Go, ngOptions: Ro, ngTransclude: Wo, ngModel: ko, ngList: To, ngChange: ho, pattern: Qo, ngPattern: Qo, required: Jo, ngRequired: Jo, minlength: es, ngMinlength: es, maxlength: ts, ngMaxlength: ts, ngValue: so, ngModelOptions: Do }).directive({ ngInclude: _o }).directive(Va).directive(yo), t.provider({ $anchorScroll: se, $animate: Kr, $animateCss: ta, $$animateJs: Yr, $$animateQueue: Zr, $$AnimateRunner: Qr, $$animateAsyncRun: Jr, $browser: de, $cacheFactory: fe, $controller: $e, $document: Te, $$isDocumentHidden: Se, $exceptionHandler: Me, $filter: Un, $$forceReflow: sa, $interpolate: ze, $interval: Be, $http: Re, $httpParamSerializer: Ee, $httpParamSerializerJQLike: Ae, $httpBackend: Fe, $xhrFactory: Ne, $jsonpCallbacks: ma, $location: nn, $log: rn, $parse: yn, $rootScope: $n, $q: bn, $$q: xn, $sce: An, $sceDelegate: En, $sniffer: Pn, $templateCache: me, $templateRequest: kn, $$testability: Dn, $timeout: On, $window: Rn, $$rAF: _n, $$jqLite: Qt, $$Map: zr, $$cookieReader: Fn }) }]) }(nr)), nr.module('ngLocale', [], ['$provide', function (t) { function e (t) { t += ''; const e = t.indexOf('.'); return e == -1 ? 0 : t.length - e - 1 } function n (t, n) { let i = n; void 0 === i && (i = Math.min(e(t), 3)); const r = Math.pow(10, i); return { v: i, f: (t * r | 0) % r } } const i = { ZERO: 'zero', ONE: 'one', TWO: 'two', FEW: 'few', MANY: 'many', OTHER: 'other' }; t.value('$locale', { DATETIME_FORMATS: { AMPMS: ['AM', 'PM'], DAY: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'], ERANAMES: ['Before Christ', 'Anno Domini'], ERAS: ['BC', 'AD'], FIRSTDAYOFWEEK: 6, MONTH: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'], SHORTDAY: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'], SHORTMONTH: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'], STANDALONEMONTH: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'], WEEKENDRANGE: [5, 6], fullDate: 'EEEE, MMMM d, y', longDate: 'MMMM d, y', medium: 'MMM d, y h:mm:ss a', mediumDate: 'MMM d, y', mediumTime: 'h:mm:ss a', short: 'M/d/yy h:mm a', shortDate: 'M/d/yy', shortTime: 'h:mm a' }, NUMBER_FORMATS: { CURRENCY_SYM: '$', DECIMAL_SEP: '.', GROUP_SEP: ',', PATTERNS: [{ gSize: 3, lgSize: 3, maxFrac: 3, minFrac: 0, minInt: 1, negPre: '-', negSuf: '', posPre: '', posSuf: '' }, { gSize: 3, lgSize: 3, maxFrac: 2, minFrac: 2, minInt: 1, negPre: '-', negSuf: '', posPre: '', posSuf: '' }] }, id: 'en-us', localeID: 'en_US', pluralCat: function (t, e) { const r = 0 | t; const a = n(t, e); return r == 1 && a.v == 0 ? i.ONE : i.OTHER } }) }]), qi(function () { rt(t.document, at) })
}(window)), !window.angular.$$csp().noInlineStyle && window.angular.element(document.head).prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>'), typeof module !== 'undefined' && typeof exports !== 'undefined' && module.exports === exports && (module.exports = 'ui.router'), (function (t, e, n) {
  'use strict'; function i (t, e) { return H(new (H(function () {}, { prototype: t }))(), e) } function r (t) { return G(arguments, function (e) { e !== t && G(e, function (e, n) { t.hasOwnProperty(n) || (t[n] = e) }) }), t } function a (t, e) { const n = []; for (const i in t.path) { if (t.path[i] !== e.path[i]) break; n.push(t.path[i]) } return n } function o (t) { if (Object.keys) return Object.keys(t); const e = []; return G(t, function (t, n) { e.push(n) }), e } function s (t, e) { if (Array.prototype.indexOf) return t.indexOf(e, Number(arguments[2]) || 0); const n = t.length >>> 0; let i = Number(arguments[2]) || 0; for (i = i < 0 ? Math.ceil(i) : Math.floor(i), i < 0 && (i += n); i < n; i++) if (i in t && t[i] === e) return i; return -1 } function l (t, e, n, i) { let r; const l = a(n, i); const c = {}; const u = []; for (const h in l) if (l[h] && l[h].params && (r = o(l[h].params), r.length)) for (const p in r)s(u, r[p]) >= 0 || (u.push(r[p]), c[r[p]] = t[r[p]]); return H({}, c, e) } function c (t, e, n) { if (!n) { n = []; for (const i in t)n.push(i) } for (let r = 0; r < n.length; r++) { const a = n[r]; if (t[a] != e[a]) return !1 } return !0 } function u (t, e) { const n = {}; return G(t, function (t) { n[t] = e[t] }), n } function h (t) { const e = {}; const n = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1)); return G(n, function (n) { n in t && (e[n] = t[n]) }), e } function p (t) { const e = {}; const n = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1)); for (const i in t)s(n, i) == -1 && (e[i] = t[i]); return e } function d (t, e) { const n = V(t); const i = n ? [] : {}; return G(t, function (t, r) { e(t, r) && (i[n ? i.length : r] = t) }), i } function f (t, e) { const n = V(t) ? [] : {}; return G(t, function (t, i) { n[i] = e(t, i) }), n } function m (t) { return t.then(n, function () {}) && t } function g (t, e) { const i = 1; const a = 2; const l = {}; const c = []; const u = l; const h = H(t.when(l), { $$promises: l, $$values: l }); this.study = function (l) { function d (t, n) { if (b[n] !== a) { if (y.push(n), b[n] === i) throw y.splice(0, s(y, n)), new Error('Cyclic dependency: ' + y.join(' -> ')); if (b[n] = i, B(t))v.push(n, [function () { return e.get(t) }], c); else { const r = e.annotate(t); G(r, function (t) { t !== n && l.hasOwnProperty(t) && d(l[t], t) }), v.push(n, t, r) }y.pop(), b[n] = a } } function f (t) { return j(t) && t.then && t.$$promises } if (!j(l)) throw new Error("'invocables' must be an object"); const g = o(l || {}); var v = []; var y = []; var b = {}; return G(l, d), l = y = b = null, function (i, a, o) { function s () { --x || (w || r(b, a.$$values), d.$$values = b, d.$$promises = d.$$promises || !0, delete d.$$inheritedValues, c.resolve(b)) } function l (t) { d.$$failure = t, c.reject(t) } if (f(i) && o === n && (o = a, a = i, i = null), i) { if (!j(i)) throw new Error("'locals' must be an object") } else i = u; if (a) { if (!f(a)) throw new Error("'parent' must be a promise returned by $resolve.resolve()") } else a = h; var c = t.defer(); var d = m(c.promise); const y = d.$$promises = {}; var b = H({}, i); var x = 1 + v.length / 3; var w = !1; if (m(d), U(a.$$failure)) return l(a.$$failure), d; a.$$inheritedValues && r(b, p(a.$$inheritedValues, g)), H(y, a.$$promises), a.$$values ? (w = r(b, p(a.$$values, g)), d.$$inheritedValues = p(a.$$values, g), s()) : (a.$$inheritedValues && (d.$$inheritedValues = p(a.$$inheritedValues, g)), a.then(s, l)); for (let _ = 0, $ = v.length; _ < $; _ += 3)i.hasOwnProperty(v[_]) ? s() : (function (n, r, a) { function c (t) { h.reject(t), l(t) } function u () { if (!U(d.$$failure)) try { h.resolve(e.invoke(r, o, b)), h.promise.then(function (t) { b[n] = t, s() }, c) } catch (t) { c(t) } } var h = t.defer(); let p = 0; G(a, function (t) { y.hasOwnProperty(t) && !i.hasOwnProperty(t) && (p++, y[t].then(function (e) { b[t] = e, --p || u() }, c)) }), p || u(), y[n] = m(h.promise) }(v[_], v[_ + 1], v[_ + 2])); return d } }, this.resolve = function (t, e, n, i) { return this.study(t)(e, n, i) } } function v () { let t = e.version.minor < 3; this.shouldUnsafelyUseHttp = function (e) { t = !!e }, this.$get = ['$http', '$templateCache', '$injector', function (e, n, i) { return new y(e, n, i, t) }] } function y (t, e, n, i) { this.fromConfig = function (t, e, n) { return U(t.template) ? this.fromString(t.template, e) : U(t.templateUrl) ? this.fromUrl(t.templateUrl, e) : U(t.templateProvider) ? this.fromProvider(t.templateProvider, e, n) : null }, this.fromString = function (t, e) { return z(t) ? t(e) : t }, this.fromUrl = function (r, a) { return z(r) && (r = r(a)), r == null ? null : i ? t.get(r, { cache: e, headers: { Accept: 'text/html' } }).then(function (t) { return t.data }) : n.get('$templateRequest')(r) }, this.fromProvider = function (t, e, i) { return n.invoke(t, null, i || { params: e }) } } function b (t, e, r) { function a (e, n, i, r) { if (g.push(e), f[e]) return f[e]; if (!/^\w+([-.]+\w+)*(?:\[\])?$/.test(e)) throw new Error("Invalid parameter name '" + e + "' in pattern '" + t + "'"); if (m[e]) throw new Error("Duplicate parameter name '" + e + "' in pattern '" + t + "'"); return m[e] = new X.Param(e, n, i, r), m[e] } function o (t, e, n, i) { let r = ['', '']; let a = t.replace(/[\\\[\]\^$*+?.()|{}]/g, '\\$&'); if (!e) return a; switch (n) { case !1:r = ['(', ')' + (i ? '?' : '')]; break; case !0:a = a.replace(/\/$/, ''), r = ['(?:/(', ')|/)?']; break; default:r = ['(' + n + '|', ')?'] } return a + r[0] + e + r[1] } function s (r, a) { let o, s, l, c, u; return o = r[2] || r[3], u = e.params[o], l = t.substring(p, r.index), s = a ? r[4] : r[4] || (r[1] == '*' ? '.*' : null), s && (c = X.type(s) || i(X.type('string'), { pattern: new RegExp(s, e.caseInsensitive ? 'i' : n) })), { id: o, regexp: s, segment: l, type: c, cfg: u } }e = H({ params: {} }, j(e) ? e : {}); let l; const c = /([:*])([\w\[\]]+)|\{([\w\[\]]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g; const u = /([:]?)([\w\[\].-]+)|\{([\w\[\].-]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g; let h = '^'; var p = 0; const d = this.segments = []; var f = r ? r.params : {}; var m = this.params = r ? r.params.$$new() : new X.ParamSet(); var g = []; this.source = t; for (var v, y, b; (l = c.exec(t)) && (v = s(l, !1), !(v.segment.indexOf('?') >= 0));)y = a(v.id, v.type, v.cfg, 'path'), h += o(v.segment, y.type.pattern.source, y.squash, y.isOptional), d.push(v.segment), p = c.lastIndex; b = t.substring(p); const x = b.indexOf('?'); if (x >= 0) { const w = this.sourceSearch = b.substring(x); if (b = b.substring(0, x), this.sourcePath = t.substring(0, p + x), w.length > 0) for (p = 0; l = u.exec(w);)v = s(l, !0), y = a(v.id, v.type, v.cfg, 'search'), p = c.lastIndex } else this.sourcePath = t, this.sourceSearch = ''; h += o(b) + (!1 === e.strict ? '/?' : '') + '$', d.push(b), this.regexp = new RegExp(h, e.caseInsensitive ? 'i' : n), this.prefix = d[0], this.$$paramNames = g } function x (t) { H(this, t) } function w () {
    function t (t) { return t != null ? t.toString().replace(/(~|\/)/g, function (t) { return { '~': '~~', '/': '~2F' }[t] }) : t } function r (t) { return t != null ? t.toString().replace(/(~~|~2F)/g, function (t) { return { '~~': '~', '~2F': '/' }[t] }) : t } function a () { return { strict: m, caseInsensitive: p } } function l (t) { return z(t) || V(t) && z(t[t.length - 1]) } function c () { for (;_.length;) { const t = _.shift(); if (t.pattern) throw new Error("You cannot override a type's .pattern at runtime."); e.extend(v[t.name], h.invoke(t.def)) } }
    function u (t) { H(this, t || {}) }X = this; let h; var p = !1; var m = !0; let g = !1; var v = {}; let y = !0; var _ = []; const $ = { string: { encode: t, decode: r, is: function (t) { return t == null || !U(t) || typeof t === 'string' }, pattern: /[^\/]*/ }, int: { encode: t, decode: function (t) { return parseInt(t, 10) }, is: function (t) { return t !== n && t !== null && this.decode(t.toString()) === t }, pattern: /\d+/ }, bool: { encode: function (t) { return t ? 1 : 0 }, decode: function (t) { return parseInt(t, 10) !== 0 }, is: function (t) { return !0 === t || !1 === t }, pattern: /0|1/ }, date: { encode: function (t) { return this.is(t) ? [t.getFullYear(), ('0' + (t.getMonth() + 1)).slice(-2), ('0' + t.getDate()).slice(-2)].join('-') : n }, decode: function (t) { if (this.is(t)) return t; const e = this.capture.exec(t); return e ? new Date(e[1], e[2] - 1, e[3]) : n }, is: function (t) { return t instanceof Date && !isNaN(t.valueOf()) }, equals: function (t, e) { return this.is(t) && this.is(e) && t.toISOString() === e.toISOString() }, pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/, capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/ }, json: { encode: e.toJson, decode: e.fromJson, is: e.isObject, equals: e.equals, pattern: /[^\/]*/ }, any: { encode: e.identity, decode: e.identity, equals: e.equals, pattern: /.*/ } }; w.$$getDefaultValue = function (t) { if (!l(t.value)) return t.value; if (!h) throw new Error('Injectable functions cannot be called at configuration time'); return h.invoke(t.value) }, this.caseInsensitive = function (t) { return U(t) && (p = t), p }, this.strictMode = function (t) { return U(t) && (m = t), m }, this.defaultSquashPolicy = function (t) { if (!U(t)) return g; if (!0 !== t && !1 !== t && !B(t)) throw new Error('Invalid squash policy: ' + t + '. Valid policies: false, true, arbitrary-string'); return g = t, t }, this.compile = function (t, e) { return new b(t, H(a(), e)) }, this.isMatcher = function (t) { if (!j(t)) return !1; let e = !0; return G(b.prototype, function (n, i) { z(n) && (e = e && U(t[i]) && z(t[i])) }), e }, this.type = function (t, e, n) { if (!U(e)) return v[t]; if (v.hasOwnProperty(t)) throw new Error("A type named '" + t + "' has already been defined."); return v[t] = new x(H({ name: t }, e)), n && (_.push({ name: t, def: n }), y || c()), this }, G($, function (t, e) { v[e] = new x(H({ name: e }, t)) }), v = i(v, {}), this.$get = ['$injector', function (t) { return h = t, y = !1, c(), G($, function (t, e) { v[e] || (v[e] = new x(t)) }), this }], this.Param = function (t, i, r, a) { function c () { if (!h) throw new Error('Injectable functions cannot be called at configuration time'); const t = h.invoke(r.$$fn); if (t !== null && t !== n && !m.type.is(t)) throw new Error('Default value (' + t + ") for parameter '" + m.id + "' is not an instance of Type (" + m.type.name + ')'); return t } function u (t) { function e (t) { return function (e) { return e.from === t } } return t = (function (t) { const n = f(d(m.replace, e(t)), function (t) { return t.to }); return n.length ? n[0] : t }(t)), U(t) ? m.type.$normalize(t) : c() } function p () { return '{Param:' + t + ' ' + i + " squash: '" + w + "' optional: " + b + '}' } var m = this; r = (function (t) { const e = j(t) ? o(t) : []; return s(e, 'value') === -1 && s(e, 'type') === -1 && s(e, 'squash') === -1 && s(e, 'array') === -1 && (t = { value: t }), t.$$fn = l(t.value) ? t.value : function () { return t.value }, t }(r)), i = (function (n, i, r) { if (n.type && i) throw new Error("Param '" + t + "' has two type configurations."); return i || (n.type ? e.isString(n.type) ? v[n.type] : n.type instanceof x ? n.type : new x(n.type) : r === 'config' ? v.any : v.string) }(r, i, a)); const y = (function () { const e = { array: a === 'search' && 'auto' }; const n = t.match(/\[\]$/) ? { array: !0 } : {}; return H(e, n, r).array }()); i = y ? i.$asArray(y, a === 'search') : i, i.name !== 'string' || y || a !== 'path' || r.value !== n || (r.value = ''); var b = r.value !== n; var w = (function (t, e) { const n = t.squash; if (!e || !1 === n) return !1; if (!U(n) || n == null) return g; if (!0 === n || B(n)) return n; throw new Error("Invalid squash policy: '" + n + "'. Valid policies: false, true, or arbitrary string") }(r, b)); const _ = (function (t, e, i, r) { let a; let o; const l = [{ from: '', to: i || e ? n : '' }, { from: null, to: i || e ? n : '' }]; return a = V(t.replace) ? t.replace : [], B(r) && a.push({ from: r, to: n }), o = f(a, function (t) { return t.from }), d(l, function (t) { return s(o, t.from) === -1 }).concat(a) }(r, y, b, w)); H(this, { id: t, type: i, location: a, array: y, squash: w, replace: _, isOptional: b, value: u, dynamic: n, config: r, toString: p }) }, u.prototype = { $$new: function () { return i(this, H(new u(), { $$parent: this })) }, $$keys: function () { for (var t = [], e = [], n = this, i = o(u.prototype); n;)e.push(n), n = n.$$parent; return e.reverse(), G(e, function (e) { G(o(e), function (e) { s(t, e) === -1 && s(i, e) === -1 && t.push(e) }) }), t }, $$values: function (t) { const e = {}; const n = this; return G(n.$$keys(), function (i) { e[i] = n[i].value(t && t[i]) }), e }, $$equals: function (t, e) { let n = !0; const i = this; return G(i.$$keys(), function (r) { const a = t && t[r]; const o = e && e[r]; i[r].type.equals(a, o) || (n = !1) }), n }, $$validates: function (t) { let i; let r; let a; let o; let s; const l = this.$$keys(); for (i = 0; i < l.length && (r = this[l[i]], (a = t[l[i]]) !== n && a !== null || !r.isOptional); i++) { if (o = r.type.$normalize(a), !r.type.is(o)) return !1; if (s = r.type.encode(o), e.isString(s) && !r.type.pattern.exec(s)) return !1 } return !0 }, $$parent: n }, this.ParamSet = u
  } function _ (t, i) { function r (t) { const e = /^\^((?:\\[^a-zA-Z0-9]|[^\\\[\]\^$*+?.()|{}]+)*)/.exec(t.source); return e != null ? e[1].replace(/\\(.)/g, '$1') : '' } function a (t, e) { return t.replace(/\$(\$|\d{1,2})/, function (t, n) { return e[n === '$' ? 0 : Number(n)] }) } function o (t, e, n) { if (!n) return !1; const i = t.invoke(e, e, { $match: n }); return !U(i) || i } function s (i, r, a, o, s) { function p (t, e, n) { return g === '/' ? t : e ? g.slice(0, -1) + t : n ? g.slice(1) + t : t } function d (t) { function e (t) { const e = t(a, i); return !!e && (B(e) && i.replace().url(e), !0) } if (!t || !t.defaultPrevented) { m && i.url(); m = n; let r; const o = c.length; for (r = 0; r < o; r++) if (e(c[r])) return; u && e(u) } } function f () { return l = l || r.$on('$locationChangeSuccess', d) } let m; var g = o.baseHref(); let v = i.url(); return h || f(), { sync: function () { d() }, listen: function () { return f() }, update: function (t) { if (t) return void (v = i.url()); i.url() !== v && (i.url(v), i.replace()) }, push: function (t, e, r) { let a = t.format(e || {}); a !== null && e && e['#'] && (a += '#' + e['#']), i.url(a), m = r && r.$$avoidResync ? i.url() : n, r && r.replace && i.replace() }, href: function (n, r, a) { if (!n.validates(r)) return null; let o = t.html5Mode(); e.isObject(o) && (o = o.enabled), o = o && s.history; let l = n.format(r); if (a = a || {}, o || l === null || (l = '#' + t.hashPrefix() + l), l !== null && r && r['#'] && (l += '#' + r['#']), l = p(l, o, a.absolute), !a.absolute || !l) return l; const c = !o && l ? '/' : ''; let u = i.port(); return u = u === 80 || u === 443 ? '' : ':' + u, [i.protocol(), '://', i.host(), u, c, l].join('') } } } let l; var c = []; var u = null; var h = !1; this.rule = function (t) { if (!z(t)) throw new Error("'rule' must be a function"); return c.push(t), this }, this.otherwise = function (t) { if (B(t)) { const e = t; t = function () { return e } } else if (!z(t)) throw new Error("'rule' must be a function"); return u = t, this }, this.when = function (t, e) { let n; const s = B(e); if (B(t) && (t = i.compile(t)), !s && !z(e) && !V(e)) throw new Error("invalid 'handler' in when()"); const l = { matcher: function (t, e) { return s && (n = i.compile(e), e = ['$match', function (t) { return n.format(t) }]), H(function (n, i) { return o(n, e, t.exec(i.path(), i.search())) }, { prefix: B(t.prefix) ? t.prefix : '' }) }, regex: function (t, e) { if (t.global || t.sticky) throw new Error('when() RegExp must not be global or sticky'); return s && (n = e, e = ['$match', function (t) { return a(n, t) }]), H(function (n, i) { return o(n, e, t.exec(i.path())) }, { prefix: r(t) }) } }; const c = { matcher: i.isMatcher(t), regex: t instanceof RegExp }; for (const u in c) if (c[u]) return this.rule(l[u](t, e)); throw new Error("invalid 'what' in when()") }, this.deferIntercept = function (t) { t === n && (t = !0), h = t }, this.$get = s, s.$inject = ['$location', '$rootScope', '$injector', '$browser', '$sniffer'] } function $ (t, r) { function a (t) { return t.indexOf('.') === 0 || t.indexOf('^') === 0 } function p (t, e) { if (!t) return n; const i = B(t); let r = i ? t : t.name; if (a(r)) { if (!e) throw new Error("No reference point given for path '" + r + "'"); e = p(e); for (var o = r.split('.'), s = 0, l = o.length, c = e; s < l; s++) if (o[s] !== '' || s !== 0) { if (o[s] !== '^') break; if (!c.parent) throw new Error("Path '" + r + "' not valid for state '" + e.name + "'"); c = c.parent } else c = e; o = o.slice(s).join('.'), r = c.name + (c.name && o ? '.' : '') + o } const u = M[r]; return !u || !i && (i || u !== t && u.self !== t) ? n : u } function d (t, e) { C[t] || (C[t] = []), C[t].push(e) } function g (t) { for (let e = C[t] || []; e.length;)v(e.shift()) } function v (e) { e = i(e, { self: e, resolve: e.resolve || {}, toString: function () { return this.name } }); const n = e.name; if (!B(n) || n.indexOf('@') >= 0) throw new Error('State must have a valid name'); if (M.hasOwnProperty(n)) throw new Error("State '" + n + "' is already defined"); const r = n.indexOf('.') !== -1 ? n.substring(0, n.lastIndexOf('.')) : B(e.parent) ? e.parent : j(e.parent) && B(e.parent.name) ? e.parent.name : ''; if (r && !M[r]) return d(r, e.self); for (const a in A)z(A[a]) && (e[a] = A[a](e, A.$delegates[a])); return M[n] = e, !e[E] && e.url && t.when(e.url, ['$match', '$stateParams', function (t, n) { S.$current.navigable == e && c(t, n) || S.transitionTo(e, t, { inherit: !0, location: !1 }) }]), g(n), e } function y (t) { return t.indexOf('*') > -1 } function b (t) { for (var e = t.split('.'), n = S.$current.name.split('.'), i = 0, r = e.length; i < r; i++)e[i] === '*' && (n[i] = '*'); return e[0] === '**' && (n = n.slice(s(n, e[1])), n.unshift('**')), e[e.length - 1] === '**' && (n.splice(s(n, e[e.length - 2]) + 1, Number.MAX_VALUE), n.push('**')), e.length == n.length && n.join('') === e.join('') } function x (t, e) { return B(t) && !U(e) ? A[t] : z(e) && B(t) ? (A[t] && !A.$delegates[t] && (A.$delegates[t] = A[t]), A[t] = e, this) : this } function w (t, e) { return j(t) ? e = t : e.name = t, v(e), this } function _ (t, r, a, s, c, h, d, g, v) { function x (e, n, i, a) { const o = t.$broadcast('$stateNotFound', e, n, i); if (o.defaultPrevented) return d.update(), P; if (!o.retry) return null; if (a.$retry) return d.update(), k; const s = S.transition = r.when(o.retry); return s.then(function () { return s !== S.transition ? (t.$broadcast('$stateChangeCancel', e.to, e.toParams, n, i), C) : (e.options.$retry = !0, S.transitionTo(e.to, e.toParams, e.options)) }, function () { return P }), d.update(), s } function w (t, n, i, o, l, h) { function p () { const n = []; return G(t.views, function (i, r) { const o = i.resolve && i.resolve !== t.resolve ? i.resolve : {}; o.$template = [function () { return a.load(r, { view: i, locals: l.globals, params: d, notify: h.notify }) || '' }], n.push(c.resolve(o, l.globals, l.resolve, t).then(function (n) { if (z(i.controllerProvider) || V(i.controllerProvider)) { const a = e.extend({}, o, l.globals); n.$$controller = s.invoke(i.controllerProvider, null, a) } else n.$$controller = i.controller; n.$$state = t, n.$$controllerAs = i.controllerAs, n.$$resolveAs = i.resolveAs, l[r] = n })) }), r.all(n).then(function () { return l.globals }) } var d = i ? n : u(t.params.$$keys(), n); const f = { $stateParams: d }; l.resolve = c.resolve(t.resolve, f, l.resolve, t); const m = [l.resolve.then(function (t) { l.globals = t })]; return o && m.push(o), r.all(m).then(p).then(function (t) { return l }) } const _ = new Error('transition superseded'); var C = m(r.reject(_)); const A = m(r.reject(new Error('transition prevented'))); var P = m(r.reject(new Error('transition aborted'))); var k = m(r.reject(new Error('transition failed'))); return T.locals = { resolve: null, globals: { $stateParams: {} } }, S = { params: {}, current: T.self, $current: T, transition: null }, S.reload = function (t) { return S.transitionTo(S.current, h, { reload: t || !0, inherit: !1, notify: !0 }) }, S.go = function (t, e, n) { return S.transitionTo(t, e, H({ inherit: !0, relative: S.$current }, n)) }, S.transitionTo = function (e, n, a) { n = n || {}, a = H({ location: !0, inherit: !1, relative: null, notify: !0, reload: !1, $retry: !1 }, a || {}); let o; const c = S.$current; const f = S.params; const g = c.path; let v = p(e, a.relative); const y = n['#']; if (!U(v)) { const b = { to: e, toParams: n, options: a }; const M = x(b, c.self, f, a); if (M) return M; if (e = b.to, n = b.toParams, a = b.options, v = p(e, a.relative), !U(v)) { if (!a.relative) throw new Error("No such state '" + e + "'"); throw new Error("Could not resolve '" + e + "' from state '" + a.relative + "'") } } if (v[E]) throw new Error("Cannot transition to abstract state '" + e + "'"); if (a.inherit && (n = l(h, n || {}, S.$current, v)), !v.params.$$validates(n)) return k; n = v.params.$$values(n), e = v; const P = e.path; let D = 0; let O = P[D]; let L = T.locals; const I = []; if (a.reload) { if (B(a.reload) || j(a.reload)) { if (j(a.reload) && !a.reload.name) throw new Error('Invalid reload state object'); const R = !0 === a.reload ? g[0] : p(a.reload); if (a.reload && !R) throw new Error("No such reload state '" + (B(a.reload) ? a.reload : a.reload.name) + "'"); for (;O && O === g[D] && O !== R;)L = I[D] = O.locals, D++, O = P[D] } } else for (;O && O === g[D] && O.ownParams.$$equals(n, f);)L = I[D] = O.locals, D++, O = P[D]; if ($(e, n, c, f, L, a)) return y && (n['#'] = y), S.params = n, W(S.params, h), W(u(e.params.$$keys(), h), e.locals.globals.$stateParams), a.location && e.navigable && e.navigable.url && (d.push(e.navigable.url, n, { $$avoidResync: !0, replace: a.location === 'replace' }), d.update(!0)), S.transition = null, r.when(S.current); if (n = u(e.params.$$keys(), n || {}), y && (n['#'] = y), a.notify && t.$broadcast('$stateChangeStart', e.self, n, c.self, f, a).defaultPrevented) return t.$broadcast('$stateChangeCancel', e.self, n, c.self, f), S.transition == null && d.update(), A; for (var N = r.when(L), F = D; F < P.length; F++, O = P[F])L = I[F] = i(L), N = w(O, n, O === e, N, L, a); var z = S.transition = N.then(function () { let i, r, o; if (S.transition !== z) return t.$broadcast('$stateChangeCancel', e.self, n, c.self, f), C; for (i = g.length - 1; i >= D; i--)o = g[i], o.self.onExit && s.invoke(o.self.onExit, o.self, o.locals.globals), o.locals = null; for (i = D; i < P.length; i++)r = P[i], r.locals = I[i], r.self.onEnter && s.invoke(r.self.onEnter, r.self, r.locals.globals); return S.transition !== z ? (t.$broadcast('$stateChangeCancel', e.self, n, c.self, f), C) : (S.$current = e, S.current = e.self, S.params = n, W(S.params, h), S.transition = null, a.location && e.navigable && d.push(e.navigable.url, e.navigable.locals.globals.$stateParams, { $$avoidResync: !0, replace: a.location === 'replace' }), a.notify && t.$broadcast('$stateChangeSuccess', e.self, n, c.self, f), d.update(!0), S.current) }).then(null, function (i) { return i === _ ? C : S.transition !== z ? (t.$broadcast('$stateChangeCancel', e.self, n, c.self, f), C) : (S.transition = null, o = t.$broadcast('$stateChangeError', e.self, n, c.self, f, i), o.defaultPrevented || d.update(), r.reject(i)) }); return m(z), z }, S.is = function (t, e, i) { i = H({ relative: S.$current }, i || {}); const r = p(t, i.relative); return U(r) ? S.$current === r && (!e || o(e).reduce(function (t, n) { const i = r.params[n]; return t && !i || i.type.equals(h[n], e[n]) }, !0)) : n }, S.includes = function (t, e, i) { if (i = H({ relative: S.$current }, i || {}), B(t) && y(t)) { if (!b(t)) return !1; t = S.$current.name } const r = p(t, i.relative); if (!U(r)) return n; if (!U(S.$current.includes[r.name])) return !1; if (!e) return !0; for (let a = o(e), s = 0; s < a.length; s++) { const l = a[s]; const c = r.params[l]; if (c && !c.type.equals(h[l], e[l])) return !1 } return o(e).reduce(function (t, n) { const i = r.params[n]; return t && !i || i.type.equals(h[n], e[n]) }, !0) }, S.href = function (t, e, i) { i = H({ lossy: !0, inherit: !0, absolute: !1, relative: S.$current }, i || {}); const r = p(t, i.relative); if (!U(r)) return null; i.inherit && (e = l(h, e || {}, S.$current, r)); const a = r && i.lossy ? r.navigable : r; return a && a.url !== n && a.url !== null ? d.href(a.url, u(r.params.$$keys().concat('#'), e || {}), { absolute: i.absolute }) : null }, S.get = function (t, e) { if (arguments.length === 0) return f(o(M), function (t) { return M[t].self }); const n = p(t, e || S.$current); return n && n.self ? n.self : null }, S } function $ (t, e, n, i, r, a) { if (!a.reload && t === n && (r === n.locals || !1 === t.self.reloadOnSearch && (function (t, e, n) { function i (e) { return t.params[e].location != 'search' } const r = t.params.$$keys().filter(i); const a = h.apply({}, [t.params].concat(r)); return new X.ParamSet(a).$$equals(e, n) }(n, i, e)))) return !0 } let T; let S; var M = {}; var C = {}; var E = 'abstract'; var A = { parent: function (t) { if (U(t.parent) && t.parent) return p(t.parent); const e = /^(.+)\.[^.]+$/.exec(t.name); return e ? p(e[1]) : T }, data: function (t) { return t.parent && t.parent.data && (t.data = t.self.data = i(t.parent.data, t.data)), t.data }, url: function (t) { const e = t.url; const n = { params: t.params || {} }; if (B(e)) return e.charAt(0) == '^' ? r.compile(e.substring(1), n) : (t.parent.navigable || T).url.concat(e, n); if (!e || r.isMatcher(e)) return e; throw new Error("Invalid url '" + e + "' in state '" + t + "'") }, navigable: function (t) { return t.url ? t : t.parent ? t.parent.navigable : null }, ownParams: function (t) { const e = t.url && t.url.params || new X.ParamSet(); return G(t.params || {}, function (t, n) { e[n] || (e[n] = new X.Param(n, null, t, 'config')) }), e }, params: function (t) { const e = h(t.ownParams, t.ownParams.$$keys()); return t.parent && t.parent.params ? H(t.parent.params.$$new(), e) : new X.ParamSet() }, views: function (t) { const e = {}; return G(U(t.views) ? t.views : { '': t }, function (n, i) { i.indexOf('@') < 0 && (i += '@' + t.parent.name), n.resolveAs = n.resolveAs || t.resolveAs || '$resolve', e[i] = n }), e }, path: function (t) { return t.parent ? t.parent.path.concat(t) : [] }, includes: function (t) { const e = t.parent ? H({}, t.parent.includes) : {}; return e[t.name] = !0, e }, $delegates: {} }; T = v({ name: '', url: '^', views: null, abstract: !0 }), T.navigable = null, this.decorator = x, this.state = w, this.$get = _, _.$inject = ['$rootScope', '$q', '$view', '$injector', '$resolve', '$stateParams', '$urlRouter', '$location', '$urlMatcherFactory'] } function T () { function t (t, e) { return { load: function (t, n) { let i; return n = H({ template: null, controller: null, view: null, locals: null, notify: !0, async: !0, params: {} }, n), n.view && (i = e.fromConfig(n.view, n.params, n.locals)), i } } } this.$get = t, t.$inject = ['$rootScope', '$templateFactory'] } function S () { let t = !1; this.useAnchorScroll = function () { t = !0 }, this.$get = ['$anchorScroll', '$timeout', function (e, n) { return t ? e : function (t) { return n(function () { t[0].scrollIntoView() }, 0, !1) } }] } function M (t, n, i, r, a) { function o (t, n) { if (c) return { enter: function (t, n, i) { e.version.minor > 2 ? c.enter(t, null, n).then(i) : c.enter(t, null, n, i) }, leave: function (t, n) { e.version.minor > 2 ? c.leave(t).then(n) : c.leave(t, n) } }; if (l) { const i = l && l(n, t); return { enter: function (t, e, n) { i.enter(t, null, e), n() }, leave: function (t, e) { i.leave(t), e() } } } return (function () { return { enter: function (t, e, n) { e.after(t), n() }, leave: function (t, e) { t.remove(), e() } } }()) } const s = (function () { return n.has ? function (t) { return n.has(t) ? n.get(t) : null } : function (t) { try { return n.get(t) } catch (t) { return null } } }()); var l = s('$animator'); var c = s('$animate'); return { restrict: 'ECA', terminal: !0, priority: 400, transclude: 'element', compile: function (n, s, l) { return function (n, s, c) { function u () { if (p && (p.remove(), p = null), f && (f.$destroy(), f = null), d) { const t = d.data('$uiViewAnim'); y.leave(d, function () { t.$$animLeave.resolve(), p = null }), p = d, d = null } } function h (o) { let h; const p = E(n, c, s, r); const b = p && t.$current && t.$current.locals[p]; if (o || b !== m) { h = n.$new(), m = t.$current.locals[p], h.$emit('$viewContentLoading', p); const x = l(h, function (t) { const r = a.defer(); const o = a.defer(); const l = { $animEnter: r.promise, $animLeave: o.promise, $$animLeave: o }; t.data('$uiViewAnim', l), y.enter(t, s, function () { r.resolve(), f && f.$emit('$viewContentAnimationEnded'), (e.isDefined(v) && !v || n.$eval(v)) && i(t) }), u() }); d = x, f = h, f.$emit('$viewContentLoaded', p), f.$eval(g) } } let p; let d; let f; let m; var g = c.onload || ''; var v = c.autoscroll; var y = o(c, n); s.inheritedData('$uiView'); n.$on('$stateChangeSuccess', function () { h(!1) }), h(!0) } } } } function C (t, n, i, r) { return { restrict: 'ECA', priority: -400, compile: function (a) { const o = a.html(); return a.empty ? a.empty() : a[0].innerHTML = null, function (a, s, l) { const c = i.$current; const u = E(a, l, s, r); const h = c && c.locals[u]; if (!h) return s.html(o), void t(s.contents())(a); s.data('$uiView', { name: u, state: h.$$state }), s.html(h.$template ? h.$template : o); const p = e.extend({}, h); a[h.$$resolveAs] = p; const d = t(s.contents()); if (h.$$controller) { h.$scope = a, h.$element = s; const f = n(h.$$controller, h); h.$$controllerAs && (a[h.$$controllerAs] = f, a[h.$$controllerAs][h.$$resolveAs] = p), z(f.$onInit) && f.$onInit(), s.data('$ngControllerController', f), s.children().data('$ngControllerController', f) }d(a) } } } } function E (t, e, n, i) { const r = i(e.uiView || e.name || '')(t); const a = n.inheritedData('$uiView'); return r.indexOf('@') >= 0 ? r : r + '@' + (a ? a.state.name : '') } function A (t, e) { let n; const i = t.match(/^\s*({[^}]*})\s*$/); if (i && (t = e + '(' + i[1] + ')'), !(n = t.replace(/\n/g, ' ').match(/^([^(]+?)\s*(\((.*)\))?$/)) || n.length !== 4) throw new Error("Invalid state ref '" + t + "'"); return { state: n[1], paramExpr: n[3] || null } } function P (t) { const e = t.parent().inheritedData('$uiView'); if (e && e.state && e.state.name) return e.state } function k (t) { const e = Object.prototype.toString.call(t.prop('href')) === '[object SVGAnimatedString]'; const n = t[0].nodeName === 'FORM'; return { attr: n ? 'action' : e ? 'xlink:href' : 'href', isAnchor: t.prop('tagName').toUpperCase() === 'A', clickable: !n } } function D (t, e, n, i, r) { return function (a) { const o = a.which || a.button; const s = r(); if (!(o > 1 || a.ctrlKey || a.metaKey || a.shiftKey || t.attr('target'))) { const l = n(function () { e.go(s.state, s.params, s.options) }); a.preventDefault(); let c = i.isAnchor && !s.href ? 1 : 0; a.preventDefault = function () { c-- <= 0 && n.cancel(l) } } } } function O (t, e) { return { relative: P(t) || e.$current, inherit: !0 } } function L (t, n) { return { restrict: 'A', require: ['?^uiSrefActive', '?^uiSrefActiveEq'], link: function (i, r, a, o) { let s; const l = A(a.uiSref, t.current.name); const c = { state: l.state, href: null, params: null }; const u = k(r); const h = o[1] || o[0]; let p = null; c.options = H(O(r, t), a.uiSrefOpts ? i.$eval(a.uiSrefOpts) : {}); const d = function (n) { n && (c.params = e.copy(n)), c.href = t.href(l.state, c.params, c.options), p && p(), h && (p = h.$$addStateInfo(l.state, c.params)), c.href !== null && a.$set(u.attr, c.href) }; l.paramExpr && (i.$watch(l.paramExpr, function (t) { t !== c.params && d(t) }, !0), c.params = e.copy(i.$eval(l.paramExpr))), d(), u.clickable && (s = D(r, t, n, u, function () { return c }), r[r.on ? 'on' : 'bind']('click', s), i.$on('$destroy', function () { r[r.off ? 'off' : 'unbind']('click', s) })) } } } function I (t, e) { return { restrict: 'A', require: ['?^uiSrefActive', '?^uiSrefActiveEq'], link: function (n, i, r, a) { function o (e) { p.state = e[0], p.params = e[1], p.options = e[2], p.href = t.href(p.state, p.params, p.options), d && d(), c && (d = c.$$addStateInfo(p.state, p.params)), p.href && r.$set(l.attr, p.href) } let s; var l = k(i); var c = a[1] || a[0]; const u = [r.uiState, r.uiStateParams || null, r.uiStateOpts || null]; const h = '[' + u.map(function (t) { return t || 'null' }).join(', ') + ']'; var p = { state: null, params: null, options: null, href: null }; var d = null; n.$watch(h, o, !0), o(n.$eval(h)), l.clickable && (s = D(i, t, e, l, function () { return p }), i[i.on ? 'on' : 'bind']('click', s), n.$on('$destroy', function () { i[i.off ? 'off' : 'unbind']('click', s) })) } } } function R (t, e, n) { return { restrict: 'A', controller: ['$scope', '$element', '$attrs', '$timeout', function (e, i, r, a) { function o (e, n, r) { const a = t.get(e, P(i)); const o = s(e, n); const l = { state: a || { name: e }, params: n, hash: o }; return m.push(l), g[o] = r, function () { const t = m.indexOf(l); t !== -1 && m.splice(t, 1) } } function s (t, n) { if (!B(t)) throw new Error('state should be a string'); return j(n) ? t + q(n) : (n = e.$eval(n), j(n) ? t + q(n) : t) } function l () { for (let t = 0; t < m.length; t++)h(m[t].state, m[t].params) ? c(i, g[m[t].hash]) : u(i, g[m[t].hash]), p(m[t].state, m[t].params) ? c(i, d) : u(i, d) } function c (t, e) { a(function () { t.addClass(e) }) } function u (t, e) { t.removeClass(e) } function h (e, n) { return t.includes(e.name, n) } function p (e, n) { return t.is(e.name, n) } let d; let f; var m = []; var g = {}; d = n(r.uiSrefActiveEq || '', !1)(e); try { f = e.$eval(r.uiSrefActive) } catch (t) {}f = f || n(r.uiSrefActive || '', !1)(e), j(f) && G(f, function (n, i) { if (B(n)) { const r = A(n, t.current.name); o(r.state, e.$eval(r.paramExpr), i) } }), this.$$addStateInfo = function (t, e) { if (!(j(f) && m.length > 0)) { const n = o(t, e, f); return l(), n } }, e.$on('$stateChangeSuccess', l), l() }] } } function N (t) { const e = function (e, n) { return t.is(e, n) }; return e.$stateful = !0, e } function F (t) { const e = function (e, n, i) { return t.includes(e, n, i) }; return e.$stateful = !0, e } var U = e.isDefined; var z = e.isFunction; var B = e.isString; var j = e.isObject; var V = e.isArray; var G = e.forEach; var H = e.extend; var W = e.copy; var q = e.toJson; e.module('ui.router.util', ['ng']), e.module('ui.router.router', ['ui.router.util']), e.module('ui.router.state', ['ui.router.router', 'ui.router.util']), e.module('ui.router', ['ui.router.state']), e.module('ui.router.compat', ['ui.router']), g.$inject = ['$q', '$injector'], e.module('ui.router.util').service('$resolve', g), e.module('ui.router.util').provider('$templateFactory', v); let X; b.prototype.concat = function (t, e) { const n = { caseInsensitive: X.caseInsensitive(), strict: X.strictMode(), squash: X.defaultSquashPolicy() }; return new b(this.sourcePath + t + this.sourceSearch, H(n, e), this) }, b.prototype.toString = function () { return this.source }, b.prototype.exec = function (t, e) { const n = this.regexp.exec(t); if (!n) return null; e = e || {}; let i; let r; let a; const o = this.parameters(); const s = o.length; const l = this.segments.length - 1; const c = {}; if (l !== n.length - 1) throw new Error("Unbalanced capture group in route '" + this.source + "'"); let u, h; for (i = 0; i < l; i++) { for (a = o[i], u = this.params[a], h = n[i + 1], r = 0; r < u.replace.length; r++)u.replace[r].from === h && (h = u.replace[r].to); h && !0 === u.array && (h = (function (t) { function e (t) { return t.split('').reverse().join('') } function n (t) { return t.replace(/\\-/g, '-') } return f(f(e(t).split(/-(?!\\)/), e), n).reverse() }(h))), U(h) && (h = u.type.decode(h)), c[a] = u.value(h) } for (;i < s; i++) { for (a = o[i], c[a] = this.params[a].value(e[a]), u = this.params[a], h = e[a], r = 0; r < u.replace.length; r++)u.replace[r].from === h && (h = u.replace[r].to); U(h) && (h = u.type.decode(h)), c[a] = u.value(h) } return c }, b.prototype.parameters = function (t) { return U(t) ? this.params[t] || null : this.$$paramNames }, b.prototype.validates = function (t) { return this.params.$$validates(t) }, b.prototype.format = function (t) { function e (t) { return encodeURIComponent(t).replace(/-/g, function (t) { return '%5C%' + t.charCodeAt(0).toString(16).toUpperCase() }) }t = t || {}; const n = this.segments; const i = this.parameters(); const r = this.params; if (!this.validates(t)) return null; let a; let o = !1; const s = n.length - 1; const l = i.length; let c = n[0]; for (a = 0; a < l; a++) { const u = a < s; const h = i[a]; const p = r[h]; const d = p.value(t[h]); const m = p.isOptional && p.type.equals(p.value(), d); const g = !!m && p.squash; let v = p.type.encode(d); if (u) { const y = n[a + 1]; const b = a + 1 === s; if (!1 === g)v != null && (V(v) ? c += f(v, e).join('-') : c += encodeURIComponent(v)), c += y; else if (!0 === g) { const x = c.match(/\/$/) ? /\/?(.*)/ : /(.*)/; c += y.match(x)[1] } else B(g) && (c += g + y); b && !0 === p.squash && c.slice(-1) === '/' && (c = c.slice(0, -1)) } else { if (v == null || m && !1 !== g) continue; if (V(v) || (v = [v]), v.length === 0) continue; v = f(v, encodeURIComponent).join('&' + h + '='), c += (o ? '&' : '?') + h + '=' + v, o = !0 } } return c }, x.prototype.is = function (t, e) { return !0 }, x.prototype.encode = function (t, e) { return t }, x.prototype.decode = function (t, e) { return t }, x.prototype.equals = function (t, e) { return t == e }, x.prototype.$subPattern = function () { const t = this.pattern.toString(); return t.substr(1, t.length - 2) }, x.prototype.pattern = /.*/, x.prototype.toString = function () { return '{Type:' + this.name + '}' }, x.prototype.$normalize = function (t) { return this.is(t) ? t : this.decode(t) }, x.prototype.$asArray = function (t, e) { function i (t, e) { function i (t, e) { return function () { return t[e].apply(t, arguments) } } function r (t) { return V(t) ? t : U(t) ? [t] : [] } function a (t) { switch (t.length) { case 0:return n; case 1:return e === 'auto' ? t[0] : t; default:return t } } function o (t) { return !t } function s (t, e) { return function (n) { if (V(n) && n.length === 0) return n; n = r(n); const i = f(n, t); return !0 === e ? d(i, o).length === 0 : a(i) } } this.encode = s(i(t, 'encode')), this.decode = s(i(t, 'decode')), this.is = s(i(t, 'is'), !0), this.equals = (function (t) { return function (e, n) { const i = r(e); const a = r(n); if (i.length !== a.length) return !1; for (let o = 0; o < i.length; o++) if (!t(i[o], a[o])) return !1; return !0 } }(i(t, 'equals'))), this.pattern = t.pattern, this.$normalize = s(i(t, '$normalize')), this.name = t.name, this.$arrayMode = e } if (!t) return this; if (t === 'auto' && !e) throw new Error("'auto' array mode is for query parameters only"); return new i(this, t) }, e.module('ui.router.util').provider('$urlMatcherFactory', w), e.module('ui.router.util').run(['$urlMatcherFactory', function (t) {}]), _.$inject = ['$locationProvider', '$urlMatcherFactoryProvider'], e.module('ui.router.router').provider('$urlRouter', _), $.$inject = ['$urlRouterProvider', '$urlMatcherFactoryProvider'], e.module('ui.router.state').factory('$stateParams', function () { return {} }).constant('$state.runtime', { autoinject: !0 }).provider('$state', $).run(['$injector', function (t) { t.get('$state.runtime').autoinject && t.get('$state') }]), T.$inject = [], e.module('ui.router.state').provider('$view', T), e.module('ui.router.state').provider('$uiViewScroll', S), M.$inject = ['$state', '$injector', '$uiViewScroll', '$interpolate', '$q'], C.$inject = ['$compile', '$controller', '$state', '$interpolate'], e.module('ui.router.state').directive('uiView', M), e.module('ui.router.state').directive('uiView', C), L.$inject = ['$state', '$timeout'], I.$inject = ['$state', '$timeout'], R.$inject = ['$state', '$stateParams', '$interpolate'], e.module('ui.router.state').directive('uiSref', L).directive('uiSrefActive', R).directive('uiSrefActiveEq', R).directive('uiState', I), N.$inject = ['$state'], F.$inject = ['$state'], e.module('ui.router.state').filter('isState', N).filter('includedByState', F)
}(window, window.angular)), (function (t, e) { typeof exports === 'object' && typeof module !== 'undefined' ? e(exports) : typeof define === 'function' && define.amd ? define(['exports'], e) : e(t.THREE = t.THREE || {}) }(this, function (t) {
  function e () {} function n (t, e) { this.x = t || 0, this.y = e || 0 } function i (t, e, r, a, o, s, l, c, u, h) { Object.defineProperty(this, 'id', { value: cr++ }), this.uuid = lr.generateUUID(), this.name = '', this.image = void 0 !== t ? t : i.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== e ? e : i.DEFAULT_MAPPING, this.wrapS = void 0 !== r ? r : 1001, this.wrapT = void 0 !== a ? a : 1001, this.magFilter = void 0 !== o ? o : 1006, this.minFilter = void 0 !== s ? s : 1008, this.anisotropy = void 0 !== u ? u : 1, this.format = void 0 !== l ? l : 1023, this.type = void 0 !== c ? c : 1009, this.offset = new n(0, 0), this.repeat = new n(1, 1), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== h ? h : 3e3, this.version = 0, this.onUpdate = null } function r (t, e, n, i) { this.x = t || 0, this.y = e || 0, this.z = n || 0, this.w = void 0 !== i ? i : 1 } function a (t, e, n) { this.uuid = lr.generateUUID(), this.width = t, this.height = e, this.scissor = new r(0, 0, t, e), this.scissorTest = !1, this.viewport = new r(0, 0, t, e), n = n || {}, void 0 === n.minFilter && (n.minFilter = 1006), this.texture = new i(void 0, void 0, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 === n.stencilBuffer || n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null } function o (t, e, n) { a.call(this, t, e, n), this.activeMipMapLevel = this.activeCubeFace = 0 } function s (t, e, n, i) { this._x = t || 0, this._y = e || 0, this._z = n || 0, this._w = void 0 !== i ? i : 1 } function l (t, e, n) { this.x = t || 0, this.y = e || 0, this.z = n || 0 } function c () { this.elements = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]), arguments.length } function u (t, e, n, r, a, o, s, l, c, u) { t = void 0 !== t ? t : [], i.call(this, t, void 0 !== e ? e : 301, n, r, a, o, s, l, c, u), this.flipY = !1 } function h (t, e, n) { let i = t[0]; if (i <= 0 || i > 0) return t; let r = e * n; let a = pr[r]; if (void 0 === a && (a = new Float32Array(r), pr[r] = a), e !== 0) for (i.toArray(a, 0), i = 1, r = 0; i !== e; ++i)r += n, t[i].toArray(a, r); return a } function p (t, e) { let n = dr[e]; void 0 === n && (n = new Int32Array(e), dr[e] = n); for (let i = 0; i !== e; ++i)n[i] = t.allocTextureUnit(); return n } function d (t, e) { t.uniform1f(this.addr, e) } function f (t, e) { t.uniform1i(this.addr, e) } function m (t, e) { void 0 === e.x ? t.uniform2fv(this.addr, e) : t.uniform2f(this.addr, e.x, e.y) } function g (t, e) { void 0 !== e.x ? t.uniform3f(this.addr, e.x, e.y, e.z) : void 0 !== e.r ? t.uniform3f(this.addr, e.r, e.g, e.b) : t.uniform3fv(this.addr, e) } function v (t, e) { void 0 === e.x ? t.uniform4fv(this.addr, e) : t.uniform4f(this.addr, e.x, e.y, e.z, e.w) } function y (t, e) { t.uniformMatrix2fv(this.addr, !1, e.elements || e) } function b (t, e) { t.uniformMatrix3fv(this.addr, !1, e.elements || e) } function x (t, e) { t.uniformMatrix4fv(this.addr, !1, e.elements || e) } function w (t, e, n) { const i = n.allocTextureUnit(); t.uniform1i(this.addr, i), n.setTexture2D(e || ur, i) } function _ (t, e, n) { const i = n.allocTextureUnit(); t.uniform1i(this.addr, i), n.setTextureCube(e || hr, i) } function $ (t, e) { t.uniform2iv(this.addr, e) } function T (t, e) { t.uniform3iv(this.addr, e) } function S (t, e) { t.uniform4iv(this.addr, e) } function M (t) { switch (t) { case 5126:return d; case 35664:return m; case 35665:return g; case 35666:return v; case 35674:return y; case 35675:return b; case 35676:return x; case 35678:return w; case 35680:return _; case 5124:case 35670:return f; case 35667:case 35671:return $; case 35668:case 35672:return T; case 35669:case 35673:return S } } function C (t, e) { t.uniform1fv(this.addr, e) } function E (t, e) { t.uniform1iv(this.addr, e) } function A (t, e) { t.uniform2fv(this.addr, h(e, this.size, 2)) } function P (t, e) { t.uniform3fv(this.addr, h(e, this.size, 3)) } function k (t, e) { t.uniform4fv(this.addr, h(e, this.size, 4)) } function D (t, e) { t.uniformMatrix2fv(this.addr, !1, h(e, this.size, 4)) } function O (t, e) { t.uniformMatrix3fv(this.addr, !1, h(e, this.size, 9)) } function L (t, e) { t.uniformMatrix4fv(this.addr, !1, h(e, this.size, 16)) } function I (t, e, n) { const i = e.length; const r = p(n, i); for (t.uniform1iv(this.addr, r), t = 0; t !== i; ++t)n.setTexture2D(e[t] || ur, r[t]) } function R (t, e, n) { const i = e.length; const r = p(n, i); for (t.uniform1iv(this.addr, r), t = 0; t !== i; ++t)n.setTextureCube(e[t] || hr, r[t]) } function N (t) { switch (t) { case 5126:return C; case 35664:return A; case 35665:return P; case 35666:return k; case 35674:return D; case 35675:return O; case 35676:return L; case 35678:return I; case 35680:return R; case 5124:case 35670:return E; case 35667:case 35671:return $; case 35668:case 35672:return T; case 35669:case 35673:return S } } function F (t, e, n) { this.id = t, this.addr = n, this.setValue = M(e.type) } function U (t, e, n) { this.id = t, this.addr = n, this.size = e.size, this.setValue = N(e.type) } function z (t) { this.id = t, this.seq = [], this.map = {} } function B (t, e, n) {
    this.seq = [], this.map = {}, this.renderer = n, n = t.getProgramParameter(e, t.ACTIVE_UNIFORMS)
    for (let i = 0; i < n; ++i) { let r = t.getActiveUniform(e, i); const a = t.getUniformLocation(e, r.name); let o = this; let s = r.name; const l = s.length; for (fr.lastIndex = 0; ;) { const c = fr.exec(s); const u = fr.lastIndex; let h = c[1]; let p = c[3]; if (c[2] === ']' && (h |= 0), void 0 === p || p === '[' && u + 2 === l) { s = o, r = void 0 === p ? new F(h, r, a) : new U(h, r, a), s.seq.push(r), s.map[r.id] = r; break }p = o.map[h], void 0 === p && (p = new z(h), h = o, o = p, h.seq.push(o), h.map[o.id] = o), o = p } }
  } function j (t, e, n) { return void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n) } function V (t, e, n, r, a, o, s, l, c, u, h, p) { i.call(this, null, o, s, l, c, u, r, a, h, p), this.image = { data: t, width: e, height: n }, this.magFilter = void 0 !== c ? c : 1003, this.minFilter = void 0 !== u ? u : 1003, this.flipY = this.generateMipmaps = !1, this.unpackAlignment = 1 } function G (t, e) { this.min = void 0 !== t ? t : new n(1 / 0, 1 / 0), this.max = void 0 !== e ? e : new n(-1 / 0, -1 / 0) } function H (t, e) { let i; let r; let a; let o; let s; let c; let u; let h; let p; let d; let f; let m; let g; let v; let y; let b; const x = t.context; const w = t.state; this.render = function (_, $, T) { if (e.length !== 0) { _ = new l(); const S = T.w / T.z; const M = 0.5 * T.z; const C = 0.5 * T.w; var E = 16 / T.w; const A = new n(E * S, E); const P = new l(1, 1, 0); const k = new n(1, 1); const D = new G(); if (D.min.set(T.x, T.y), D.max.set(T.x + (T.z - 16), T.y + (T.w - 16)), void 0 === v) { var E = new Float32Array([-1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1]); var O = new Uint16Array([0, 1, 2, 0, 2, 3]); f = x.createBuffer(), m = x.createBuffer(), x.bindBuffer(x.ARRAY_BUFFER, f), x.bufferData(x.ARRAY_BUFFER, E, x.STATIC_DRAW), x.bindBuffer(x.ELEMENT_ARRAY_BUFFER, m), x.bufferData(x.ELEMENT_ARRAY_BUFFER, O, x.STATIC_DRAW), y = x.createTexture(), b = x.createTexture(), w.bindTexture(x.TEXTURE_2D, y), x.texImage2D(x.TEXTURE_2D, 0, x.RGB, 16, 16, 0, x.RGB, x.UNSIGNED_BYTE, null), x.texParameteri(x.TEXTURE_2D, x.TEXTURE_WRAP_S, x.CLAMP_TO_EDGE), x.texParameteri(x.TEXTURE_2D, x.TEXTURE_WRAP_T, x.CLAMP_TO_EDGE), x.texParameteri(x.TEXTURE_2D, x.TEXTURE_MAG_FILTER, x.NEAREST), x.texParameteri(x.TEXTURE_2D, x.TEXTURE_MIN_FILTER, x.NEAREST), w.bindTexture(x.TEXTURE_2D, b), x.texImage2D(x.TEXTURE_2D, 0, x.RGBA, 16, 16, 0, x.RGBA, x.UNSIGNED_BYTE, null), x.texParameteri(x.TEXTURE_2D, x.TEXTURE_WRAP_S, x.CLAMP_TO_EDGE), x.texParameteri(x.TEXTURE_2D, x.TEXTURE_WRAP_T, x.CLAMP_TO_EDGE), x.texParameteri(x.TEXTURE_2D, x.TEXTURE_MAG_FILTER, x.NEAREST), x.texParameteri(x.TEXTURE_2D, x.TEXTURE_MIN_FILTER, x.NEAREST); var E = g = { vertexShader: 'uniform lowp int renderType;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nuniform sampler2D occlusionMap;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nvUV = uv;\nvec2 pos = position;\nif ( renderType == 2 ) {\nvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\nvVisibility =        visibility.r / 9.0;\nvVisibility *= 1.0 - visibility.g / 9.0;\nvVisibility *=       visibility.b / 9.0;\nvVisibility *= 1.0 - visibility.a / 9.0;\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n}\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}', fragmentShader: 'uniform lowp int renderType;\nuniform sampler2D map;\nuniform float opacity;\nuniform vec3 color;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nif ( renderType == 0 ) {\ngl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\n} else if ( renderType == 1 ) {\ngl_FragColor = texture2D( map, vUV );\n} else {\nvec4 texture = texture2D( map, vUV );\ntexture.a *= opacity * vVisibility;\ngl_FragColor = texture;\ngl_FragColor.rgb *= color;\n}\n}' }; var O = x.createProgram(); var L = x.createShader(x.FRAGMENT_SHADER); var I = x.createShader(x.VERTEX_SHADER); var R = 'precision ' + t.getPrecision() + ' float;\n'; x.shaderSource(L, R + E.fragmentShader), x.shaderSource(I, R + E.vertexShader), x.compileShader(L), x.compileShader(I), x.attachShader(O, L), x.attachShader(O, I), x.linkProgram(O), v = O, p = x.getAttribLocation(v, 'position'), d = x.getAttribLocation(v, 'uv'), i = x.getUniformLocation(v, 'renderType'), r = x.getUniformLocation(v, 'map'), a = x.getUniformLocation(v, 'occlusionMap'), o = x.getUniformLocation(v, 'opacity'), s = x.getUniformLocation(v, 'color'), c = x.getUniformLocation(v, 'scale'), u = x.getUniformLocation(v, 'rotation'), h = x.getUniformLocation(v, 'screenPosition') } for (x.useProgram(v), w.initAttributes(), w.enableAttribute(p), w.enableAttribute(d), w.disableUnusedAttributes(), x.uniform1i(a, 0), x.uniform1i(r, 1), x.bindBuffer(x.ARRAY_BUFFER, f), x.vertexAttribPointer(p, 2, x.FLOAT, !1, 16, 0), x.vertexAttribPointer(d, 2, x.FLOAT, !1, 16, 8), x.bindBuffer(x.ELEMENT_ARRAY_BUFFER, m), w.disable(x.CULL_FACE), w.setDepthWrite(!1), O = 0, L = e.length; O < L; O++) if (E = 16 / T.w, A.set(E * S, E), I = e[O], _.set(I.matrixWorld.elements[12], I.matrixWorld.elements[13], I.matrixWorld.elements[14]), _.applyMatrix4($.matrixWorldInverse), _.applyMatrix4($.projectionMatrix), P.copy(_), k.x = T.x + P.x * M + M - 8, k.y = T.y + P.y * C + C - 8, !0 === D.containsPoint(k)) { w.activeTexture(x.TEXTURE0), w.bindTexture(x.TEXTURE_2D, null), w.activeTexture(x.TEXTURE1), w.bindTexture(x.TEXTURE_2D, y), x.copyTexImage2D(x.TEXTURE_2D, 0, x.RGB, k.x, k.y, 16, 16, 0), x.uniform1i(i, 0), x.uniform2f(c, A.x, A.y), x.uniform3f(h, P.x, P.y, P.z), w.disable(x.BLEND), w.enable(x.DEPTH_TEST), x.drawElements(x.TRIANGLES, 6, x.UNSIGNED_SHORT, 0), w.activeTexture(x.TEXTURE0), w.bindTexture(x.TEXTURE_2D, b), x.copyTexImage2D(x.TEXTURE_2D, 0, x.RGBA, k.x, k.y, 16, 16, 0), x.uniform1i(i, 1), w.disable(x.DEPTH_TEST), w.activeTexture(x.TEXTURE1), w.bindTexture(x.TEXTURE_2D, y), x.drawElements(x.TRIANGLES, 6, x.UNSIGNED_SHORT, 0), I.positionScreen.copy(P), I.customUpdateCallback ? I.customUpdateCallback(I) : I.updateLensFlares(), x.uniform1i(i, 2), w.enable(x.BLEND); for (var R = 0, N = I.lensFlares.length; R < N; R++) { const F = I.lensFlares[R]; F.opacity > 0.001 && F.scale > 0.001 && (P.x = F.x, P.y = F.y, P.z = F.z, E = F.size * F.scale / T.w, A.x = E * S, A.y = E, x.uniform3f(h, P.x, P.y, P.z), x.uniform2f(c, A.x, A.y), x.uniform1f(u, F.rotation), x.uniform1f(o, F.opacity), x.uniform3f(s, F.color.r, F.color.g, F.color.b), w.setBlending(F.blending, F.blendEquation, F.blendSrc, F.blendDst), t.setTexture2D(F.texture, 1), x.drawElements(x.TRIANGLES, 6, x.UNSIGNED_SHORT, 0)) } }w.enable(x.CULL_FACE), w.enable(x.DEPTH_TEST), w.setDepthWrite(!0), t.resetGLState() } } } function W (t, e) { function n (t, e) { return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : e.id - t.id } let r; let a; let o; let c; let u; let h; let p; let d; let f; let m; let g; let v; let y; let b; let x; let w; let _; let $; let T; let S; let M; const C = t.context; const E = t.state; const A = new l(); const P = new s(); const k = new l(); this.render = function (s, l) { if (e.length !== 0) { if (void 0 === S) { var D = new Float32Array([-0.5, -0.5, 0, 0, 0.5, -0.5, 1, 0, 0.5, 0.5, 1, 1, -0.5, 0.5, 0, 1]); var O = new Uint16Array([0, 1, 2, 0, 2, 3]); $ = C.createBuffer(), T = C.createBuffer(), C.bindBuffer(C.ARRAY_BUFFER, $), C.bufferData(C.ARRAY_BUFFER, D, C.STATIC_DRAW), C.bindBuffer(C.ELEMENT_ARRAY_BUFFER, T), C.bufferData(C.ELEMENT_ARRAY_BUFFER, O, C.STATIC_DRAW); var D = C.createProgram(); var O = C.createShader(C.VERTEX_SHADER); var L = C.createShader(C.FRAGMENT_SHADER); C.shaderSource(O, ['precision ' + t.getPrecision() + ' float;', 'uniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float rotation;\nuniform vec2 scale;\nuniform vec2 uvOffset;\nuniform vec2 uvScale;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\nvUV = uvOffset + uv * uvScale;\nvec2 alignedPosition = position * scale;\nvec2 rotatedPosition;\nrotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\nrotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\nvec4 finalPosition;\nfinalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\nfinalPosition.xy += rotatedPosition;\nfinalPosition = projectionMatrix * finalPosition;\ngl_Position = finalPosition;\n}'].join('\n')), C.shaderSource(L, ['precision ' + t.getPrecision() + ' float;', 'uniform vec3 color;\nuniform sampler2D map;\nuniform float opacity;\nuniform int fogType;\nuniform vec3 fogColor;\nuniform float fogDensity;\nuniform float fogNear;\nuniform float fogFar;\nuniform float alphaTest;\nvarying vec2 vUV;\nvoid main() {\nvec4 texture = texture2D( map, vUV );\nif ( texture.a < alphaTest ) discard;\ngl_FragColor = vec4( color * texture.xyz, texture.a * opacity );\nif ( fogType > 0 ) {\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\nfloat fogFactor = 0.0;\nif ( fogType == 1 ) {\nfogFactor = smoothstep( fogNear, fogFar, depth );\n} else {\nconst float LOG2 = 1.442695;\nfogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\nfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n}\ngl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n}\n}'].join('\n')), C.compileShader(O), C.compileShader(L), C.attachShader(D, O), C.attachShader(D, L), C.linkProgram(D), S = D, w = C.getAttribLocation(S, 'position'), _ = C.getAttribLocation(S, 'uv'), r = C.getUniformLocation(S, 'uvOffset'), a = C.getUniformLocation(S, 'uvScale'), o = C.getUniformLocation(S, 'rotation'), c = C.getUniformLocation(S, 'scale'), u = C.getUniformLocation(S, 'color'), h = C.getUniformLocation(S, 'map'), p = C.getUniformLocation(S, 'opacity'), d = C.getUniformLocation(S, 'modelViewMatrix'), f = C.getUniformLocation(S, 'projectionMatrix'), m = C.getUniformLocation(S, 'fogType'), g = C.getUniformLocation(S, 'fogDensity'), v = C.getUniformLocation(S, 'fogNear'), y = C.getUniformLocation(S, 'fogFar'), b = C.getUniformLocation(S, 'fogColor'), x = C.getUniformLocation(S, 'alphaTest'), D = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas'), D.width = 8, D.height = 8, O = D.getContext('2d'), O.fillStyle = 'white', O.fillRect(0, 0, 8, 8), M = new i(D), M.needsUpdate = !0 }C.useProgram(S), E.initAttributes(), E.enableAttribute(w), E.enableAttribute(_), E.disableUnusedAttributes(), E.disable(C.CULL_FACE), E.enable(C.BLEND), C.bindBuffer(C.ARRAY_BUFFER, $), C.vertexAttribPointer(w, 2, C.FLOAT, !1, 16, 0), C.vertexAttribPointer(_, 2, C.FLOAT, !1, 16, 8), C.bindBuffer(C.ELEMENT_ARRAY_BUFFER, T), C.uniformMatrix4fv(f, !1, l.projectionMatrix.elements), E.activeTexture(C.TEXTURE0), C.uniform1i(h, 0), O = D = 0, (L = s.fog) ? (C.uniform3f(b, L.color.r, L.color.g, L.color.b), L.isFog ? (C.uniform1f(v, L.near), C.uniform1f(y, L.far), C.uniform1i(m, 1), O = D = 1) : L.isFogExp2 && (C.uniform1f(g, L.density), C.uniform1i(m, 2), O = D = 2)) : (C.uniform1i(m, 0), O = D = 0); for (var L = 0, I = e.length; L < I; L++) { var R = e[L]; R.modelViewMatrix.multiplyMatrices(l.matrixWorldInverse, R.matrixWorld), R.z = -R.modelViewMatrix.elements[14] }e.sort(n); for (var N = [], L = 0, I = e.length; L < I; L++) { var R = e[L]; const F = R.material; !1 !== F.visible && (C.uniform1f(x, F.alphaTest), C.uniformMatrix4fv(d, !1, R.modelViewMatrix.elements), R.matrixWorld.decompose(A, P, k), N[0] = k.x, N[1] = k.y, R = 0, s.fog && F.fog && (R = O), D !== R && (C.uniform1i(m, R), D = R), F.map !== null ? (C.uniform2f(r, F.map.offset.x, F.map.offset.y), C.uniform2f(a, F.map.repeat.x, F.map.repeat.y)) : (C.uniform2f(r, 0, 0), C.uniform2f(a, 1, 1)), C.uniform1f(p, F.opacity), C.uniform3f(u, F.color.r, F.color.g, F.color.b), C.uniform1f(o, F.rotation), C.uniform2fv(c, N), E.setBlending(F.blending, F.blendEquation, F.blendSrc, F.blendDst), E.setDepthTest(F.depthTest), E.setDepthWrite(F.depthWrite), F.map ? t.setTexture2D(F.map, 0) : t.setTexture2D(M, 0), C.drawElements(C.TRIANGLES, 6, C.UNSIGNED_SHORT, 0)) }E.enable(C.CULL_FACE), t.resetGLState() } } } function q () { Object.defineProperty(this, 'id', { value: xr++ }), this.uuid = lr.generateUUID(), this.name = '', this.type = 'Material', this.lights = this.fog = !0, this.blending = 1, this.side = 0, this.shading = 2, this.vertexColors = 0, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = 100, this.blendEquationAlpha = this.blendDstAlpha = this.blendSrcAlpha = null, this.depthFunc = 3, this.depthWrite = this.depthTest = !0, this.clippingPlanes = null, this.clipShadows = this.clipIntersection = !1, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.alphaTest = this.polygonOffsetUnits = this.polygonOffsetFactor = 0, this.premultipliedAlpha = !1, this.overdraw = 0, this._needsUpdate = this.visible = !0 } function X (t) { q.call(this), this.type = 'ShaderMaterial', this.defines = {}, this.uniforms = {}, this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}', this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}', this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.morphNormals = this.morphTargets = this.skinning = this.clipping = this.lights = this.fog = !1, this.extensions = { derivatives: !1, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1 }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, void 0 !== t && (t.attributes, this.setValues(t)) } function Y (t) { q.call(this), this.type = 'MeshDepthMaterial', this.depthPacking = 3200, this.morphTargets = this.skinning = !1, this.displacementMap = this.alphaMap = this.map = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.lights = this.fog = !1, this.setValues(t) } function Z (t, e) { this.min = void 0 !== t ? t : new l(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== e ? e : new l(-1 / 0, -1 / 0, -1 / 0) } function K (t, e) { this.center = void 0 !== t ? t : new l(), this.radius = void 0 !== e ? e : 0 } function J () { this.elements = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]), arguments.length } function Q (t, e) { this.normal = void 0 !== t ? t : new l(1, 0, 0), this.constant = void 0 !== e ? e : 0 } function tt (t, e, n, i, r, a) { this.planes = [void 0 !== t ? t : new Q(), void 0 !== e ? e : new Q(), void 0 !== n ? n : new Q(), void 0 !== i ? i : new Q(), void 0 !== r ? r : new Q(), void 0 !== a ? a : new Q()] } function et (t, e, i, o) { function s (e, n, i, r) { let a; let o = e.geometry; a = w; let s = e.customDepthMaterial; return i && (a = _, s = e.customDistanceMaterial), s ? a = s : (s = !1, n.morphTargets && (o && o.isBufferGeometry ? s = o.morphAttributes && o.morphAttributes.position && o.morphAttributes.position.length > 0 : o && o.isGeometry && (s = o.morphTargets && o.morphTargets.length > 0)), e = e.isSkinnedMesh && n.skinning, o = 0, s && (o |= 1), e && (o |= 2), a = a[o]), t.localClippingEnabled && !0 === n.clipShadows && n.clippingPlanes.length !== 0 && (o = a.uuid, s = n.uuid, e = $[o], void 0 === e && (e = {}, $[o] = e), o = e[s], void 0 === o && (o = a.clone(), e[s] = o), a = o), a.visible = n.visible, a.wireframe = n.wireframe, s = n.side, D.renderSingleSided && s == 2 && (s = 0), D.renderReverseSided && (s === 0 ? s = 1 : s === 1 && (s = 0)), a.side = s, a.clipShadows = n.clipShadows, a.clippingPlanes = n.clippingPlanes, a.wireframeLinewidth = n.wireframeLinewidth, a.linewidth = n.linewidth, i && void 0 !== a.uniforms.lightPos && a.uniforms.lightPos.value.copy(r), a } function u (t, e, n) { if (!1 !== t.visible) { (t.layers.mask & e.layers.mask) != 0 && (t.isMesh || t.isLine || t.isPoints) && t.castShadow && (!1 === t.frustumCulled || !0 === d.intersectsObject(t)) && !0 === t.material.visible && (t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), x.push(t)), t = t.children; for (let i = 0, r = t.length; i < r; i++)u(t[i], e, n) } } const h = t.context; const p = t.state; var d = new tt(); const f = new c(); const m = e.shadows; const g = new n(); const v = new n(o.maxTextureSize, o.maxTextureSize); const y = new l(); const b = new l(); var x = []; var w = Array(4); var _ = Array(4); var $ = {}; const T = [new l(1, 0, 0), new l(-1, 0, 0), new l(0, 0, 1), new l(0, 0, -1), new l(0, 1, 0), new l(0, -1, 0)]; const S = [new l(0, 1, 0), new l(0, 1, 0), new l(0, 1, 0), new l(0, 1, 0), new l(0, 0, 1), new l(0, 0, -1)]; const M = [new r(), new r(), new r(), new r(), new r(), new r()]; e = new Y(), e.depthPacking = 3201, e.clipping = !0, o = br.distanceRGBA; for (let C = mr.clone(o.uniforms), E = 0; E !== 4; ++E) { let A = (1 & E) != 0; const P = (2 & E) != 0; const k = e.clone(); k.morphTargets = A, k.skinning = P, w[E] = k, A = new X({ defines: { USE_SHADOWMAP: '' }, uniforms: C, vertexShader: o.vertexShader, fragmentShader: o.fragmentShader, morphTargets: A, skinning: P, clipping: !0 }), _[E] = A } var D = this; this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.renderSingleSided = this.renderReverseSided = !0, this.render = function (e, n) { if (!1 !== D.enabled && (!1 !== D.autoUpdate || !1 !== D.needsUpdate) && m.length !== 0) { p.buffers.color.setClear(1, 1, 1, 1), p.disable(h.BLEND), p.setDepthTest(!0), p.setScissorTest(!1); for (var r, o, l = 0, c = m.length; l < c; l++) { const w = m[l]; let _ = w.shadow; if (void 0 === _);else { const $ = _.camera; if (g.copy(_.mapSize), g.min(v), w && w.isPointLight) { r = 6, o = !0; var C = g.x; var E = g.y; M[0].set(2 * C, E, C, E), M[1].set(0, E, C, E), M[2].set(3 * C, E, C, E), M[3].set(C, E, C, E), M[4].set(3 * C, 0, C, E), M[5].set(C, 0, C, E), g.x *= 4, g.y *= 2 } else r = 1, o = !1; for (_.map === null && (_.map = new a(g.x, g.y, { minFilter: 1003, magFilter: 1003, format: 1023 }), $.updateProjectionMatrix()), _.isSpotLightShadow && _.update(w), _ && _.isRectAreaLightShadow && _.update(w), C = _.map, _ = _.matrix, b.setFromMatrixPosition(w.matrixWorld), $.position.copy(b), t.setRenderTarget(C), t.clear(), C = 0; C < r; C++) { o ? (y.copy($.position), y.add(T[C]), $.up.copy(S[C]), $.lookAt(y), p.viewport(M[C])) : (y.setFromMatrixPosition(w.target.matrixWorld), $.lookAt(y)), $.updateMatrixWorld(), $.matrixWorldInverse.getInverse($.matrixWorld), _.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), _.multiply($.projectionMatrix), _.multiply($.matrixWorldInverse), f.multiplyMatrices($.projectionMatrix, $.matrixWorldInverse), d.setFromMatrix(f), x.length = 0, u(e, n, $); for (var E = 0, A = x.length; E < A; E++) { const P = x[E]; const k = i.update(P); var O = P.material; if (O && O.isMultiMaterial) for (var L = k.groups, O = O.materials, I = 0, R = L.length; I < R; I++) { const N = L[I]; var F = O[N.materialIndex]; !0 === F.visible && (F = s(P, F, o, b), t.renderBufferDirect($, null, k, F, P, N)) } else F = s(P, O, o, b), t.renderBufferDirect($, null, k, F, P, null) } } } }r = t.getClearColor(), o = t.getClearAlpha(), t.setClearColor(r, o), D.needsUpdate = !1 } } } function nt (t, e) { this.origin = void 0 !== t ? t : new l(), this.direction = void 0 !== e ? e : new l() } function it (t, e, n, i) { this._x = t || 0, this._y = e || 0, this._z = n || 0, this._order = i || it.DefaultOrder } function rt () { this.mask = 1 } function at () { Object.defineProperty(this, 'id', { value: wr++ }), this.uuid = lr.generateUUID(), this.name = '', this.type = 'Object3D', this.parent = null, this.children = [], this.up = at.DefaultUp.clone(); const t = new l(); const e = new it(); const n = new s(); const i = new l(1, 1, 1); e.onChange(function () { n.setFromEuler(e, !1) }), n.onChange(function () { e.setFromQuaternion(n, void 0, !1) }), Object.defineProperties(this, { position: { enumerable: !0, value: t }, rotation: { enumerable: !0, value: e }, quaternion: { enumerable: !0, value: n }, scale: { enumerable: !0, value: i }, modelViewMatrix: { value: new c() }, normalMatrix: { value: new J() } }), this.matrix = new c(), this.matrixWorld = new c(), this.matrixAutoUpdate = at.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new rt(), this.visible = !0, this.receiveShadow = this.castShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {}, this.onBeforeRender = function () {}, this.onAfterRender = function () {} } function ot (t, e) { this.start = void 0 !== t ? t : new l(), this.end = void 0 !== e ? e : new l() } function st (t, e, n) { this.a = void 0 !== t ? t : new l(), this.b = void 0 !== e ? e : new l(), this.c = void 0 !== n ? n : new l() } function lt (t, e, n, i, r, a) { this.a = t, this.b = e, this.c = n, this.normal = i && i.isVector3 ? i : new l(), this.vertexNormals = Array.isArray(i) ? i : [], this.color = r && r.isColor ? r : new j(), this.vertexColors = Array.isArray(r) ? r : [], this.materialIndex = void 0 !== a ? a : 0 } function ct (t) { q.call(this), this.type = 'MeshBasicMaterial', this.color = new j(16777215), this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.envMap = this.alphaMap = this.specularMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = 'round', this.lights = this.morphTargets = this.skinning = !1, this.setValues(t) } function ut (t, e, n) { if (Array.isArray(t)) throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.'); this.uuid = lr.generateUUID(), this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === n, this.dynamic = !1, this.updateRange = { offset: 0, count: -1 }, this.onUploadCallback = function () {}, this.version = 0 } function ht (t, e) { ut.call(this, new Int8Array(t), e) } function pt (t, e) { ut.call(this, new Uint8Array(t), e) } function dt (t, e) { ut.call(this, new Uint8ClampedArray(t), e) } function ft (t, e) { ut.call(this, new Int16Array(t), e) } function mt (t, e) { ut.call(this, new Uint16Array(t), e) } function gt (t, e) { ut.call(this, new Int32Array(t), e) } function vt (t, e) { ut.call(this, new Uint32Array(t), e) } function yt (t, e) { ut.call(this, new Float32Array(t), e) } function bt (t, e) { ut.call(this, new Float64Array(t), e) } function xt () { this.indices = [], this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingSphere = this.boundingBox = null, this.groupsNeedUpdate = this.uvsNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.verticesNeedUpdate = !1 } function wt (t) { for (var e = t.length, n = -1 / 0; e--;)t[e] > n && (n = t[e]); return n } function _t () { Object.defineProperty(this, 'id', { value: _r++ }), this.uuid = lr.generateUUID(), this.name = '', this.type = 'Geometry', this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingSphere = this.boundingBox = null, this.groupsNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.verticesNeedUpdate = this.elementsNeedUpdate = !1 } function $t () { Object.defineProperty(this, 'id', { value: _r++ }), this.uuid = lr.generateUUID(), this.name = '', this.type = 'BufferGeometry', this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingSphere = this.boundingBox = null, this.drawRange = { start: 0, count: 1 / 0 } } function Tt (t, e) { at.call(this), this.type = 'Mesh', this.geometry = void 0 !== t ? t : new $t(), this.material = void 0 !== e ? e : new ct({ color: 16777215 * Math.random() }), this.drawMode = 0, this.updateMorphTargets() } function St (t, e, n, i, r, a) { _t.call(this), this.type = 'BoxGeometry', this.parameters = { width: t, height: e, depth: n, widthSegments: i, heightSegments: r, depthSegments: a }, this.fromBufferGeometry(new Mt(t, e, n, i, r, a)), this.mergeVertices() } function Mt (t, e, n, i, r, a) { function o (t, e, n, i, r, a, o, m, g, v, y) { const b = a / g; const x = o / v; const w = a / 2; const _ = o / 2; const $ = m / 2; o = g + 1; let T; let S; const M = v + 1; let C = a = 0; const E = new l(); for (S = 0; S < M; S++) { const A = S * x - _; for (T = 0; T < o; T++)E[t] = (T * b - w) * i, E[e] = A * r, E[n] = $, u.push(E.x, E.y, E.z), E[t] = 0, E[e] = 0, E[n] = m > 0 ? 1 : -1, h.push(E.x, E.y, E.z), p.push(T / g), p.push(1 - S / v), a += 1 } for (S = 0; S < v; S++) for (T = 0; T < g; T++)t = d + T + o * (S + 1), e = d + (T + 1) + o * (S + 1), n = d + (T + 1) + o * S, c.push(d + T + o * S, t, n), c.push(t, e, n), C += 6; s.addGroup(f, C, y), f += C, d += a }$t.call(this), this.type = 'BoxBufferGeometry', this.parameters = { width: t, height: e, depth: n, widthSegments: i, heightSegments: r, depthSegments: a }; var s = this; i = Math.floor(i) || 1, r = Math.floor(r) || 1, a = Math.floor(a) || 1; var c = []; var u = []; var h = []; var p = []; var d = 0; var f = 0; o('z', 'y', 'x', -1, -1, n, e, t, a, r, 0), o('z', 'y', 'x', 1, -1, n, e, -t, a, r, 1), o('x', 'z', 'y', 1, 1, t, n, e, i, a, 2), o('x', 'z', 'y', 1, -1, t, n, -e, i, a, 3), o('x', 'y', 'z', 1, -1, t, e, n, i, r, 4), o('x', 'y', 'z', -1, -1, t, e, -n, i, r, 5), this.setIndex(c), this.addAttribute('position', new yt(u, 3)), this.addAttribute('normal', new yt(h, 3)), this.addAttribute('uv', new yt(p, 2)) } function Ct (t, e, n, i) { _t.call(this), this.type = 'PlaneGeometry', this.parameters = { width: t, height: e, widthSegments: n, heightSegments: i }, this.fromBufferGeometry(new Et(t, e, n, i)) } function Et (t, e, n, i) { $t.call(this), this.type = 'PlaneBufferGeometry', this.parameters = { width: t, height: e, widthSegments: n, heightSegments: i }; let r = t / 2; let a = e / 2; n = Math.floor(n) || 1, i = Math.floor(i) || 1; const o = n + 1; let s = i + 1; const l = t / n; const c = e / i; const u = []; const h = []; const p = []; const d = []; for (t = 0; t < s; t++) { const f = t * c - a; for (e = 0; e < o; e++)h.push(e * l - r, -f, 0), p.push(0, 0, 1), d.push(e / n), d.push(1 - t / i) } for (t = 0; t < i; t++) for (e = 0; e < n; e++)r = e + o * (t + 1), a = e + 1 + o * (t + 1), s = e + 1 + o * t, u.push(e + o * t, r, s), u.push(r, a, s); this.setIndex(u), this.addAttribute('position', new yt(h, 3)), this.addAttribute('normal', new yt(p, 3)), this.addAttribute('uv', new yt(d, 2)) } function At () { at.call(this), this.type = 'Camera', this.matrixWorldInverse = new c(), this.projectionMatrix = new c() } function Pt (t, e, n, i) { At.call(this), this.type = 'PerspectiveCamera', this.fov = void 0 !== t ? t : 50, this.zoom = 1, this.near = void 0 !== n ? n : 0.1, this.far = void 0 !== i ? i : 2e3, this.focus = 10, this.aspect = void 0 !== e ? e : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix() } function kt (t, e, n, i, r, a) { At.call(this), this.type = 'OrthographicCamera', this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = n, this.bottom = i, this.near = void 0 !== r ? r : 0.1, this.far = void 0 !== a ? a : 2e3, this.updateProjectionMatrix() } function Dt (t, e, n) { let i, r, a; return { setMode: function (t) { i = t }, setIndex: function (n) { n.array instanceof Uint32Array && e.get('OES_element_index_uint') ? (r = t.UNSIGNED_INT, a = 4) : n.array instanceof Uint16Array ? (r = t.UNSIGNED_SHORT, a = 2) : (r = t.UNSIGNED_BYTE, a = 1) }, render: function (e, o) { t.drawElements(i, o, r, e * a), n.calls++, n.vertices += o, i === t.TRIANGLES && (n.faces += o / 3) }, renderInstances: function (o, s, l) { const c = e.get('ANGLE_instanced_arrays'); c === null || (c.drawElementsInstancedANGLE(i, l, r, s * a, o.maxInstancedCount), n.calls++, n.vertices += l * o.maxInstancedCount, i === t.TRIANGLES && (n.faces += o.maxInstancedCount * l / 3)) } } } function Ot (t, e, n) { let i; return { setMode: function (t) { i = t }, render: function (e, r) { t.drawArrays(i, e, r), n.calls++, n.vertices += r, i === t.TRIANGLES && (n.faces += r / 3) }, renderInstances: function (r) { const a = e.get('ANGLE_instanced_arrays'); if (a === null);else { var o = r.attributes.position; var o = o.isInterleavedBufferAttribute ? o.data.count : o.count; a.drawArraysInstancedANGLE(i, 0, o, r.maxInstancedCount), n.calls++, n.vertices += o * r.maxInstancedCount, i === t.TRIANGLES && (n.faces += r.maxInstancedCount * o / 3) } } } } function Lt () { const t = {}; return { get: function (e) { if (void 0 !== t[e.id]) return t[e.id]; let i; switch (e.type) { case 'DirectionalLight':i = { direction: new l(), color: new j(), shadow: !1, shadowBias: 0, shadowRadius: 1, shadowMapSize: new n() }; break; case 'SpotLight':i = { position: new l(), direction: new l(), color: new j(), distance: 0, coneCos: 0, penumbraCos: 0, decay: 0, shadow: !1, shadowBias: 0, shadowRadius: 1, shadowMapSize: new n() }; break; case 'PointLight':i = { position: new l(), color: new j(), distance: 0, decay: 0, shadow: !1, shadowBias: 0, shadowRadius: 1, shadowMapSize: new n() }; break; case 'HemisphereLight':i = { direction: new l(), skyColor: new j(), groundColor: new j() }; break; case 'RectAreaLight':i = { color: new j(), position: new l(), halfWidth: new l(), halfHeight: new l() } } return t[e.id] = i } } } function It (t, e, n) { const i = t.createShader(e); return t.shaderSource(i, n), t.compileShader(i), t.getShaderParameter(i, t.COMPILE_STATUS), t.getShaderInfoLog(i), i } function Rt (t) { switch (t) { case 3e3:return ['Linear', '( value )']; case 3001:return ['sRGB', '( value )']; case 3002:return ['RGBE', '( value )']; case 3004:return ['RGBM', '( value, 7.0 )']; case 3005:return ['RGBM', '( value, 16.0 )']; case 3006:return ['RGBD', '( value, 256.0 )']; case 3007:return ['Gamma', '( value, float( GAMMA_FACTOR ) )']; default:throw Error('unsupported encoding: ' + t) } } function Nt (t, e) { const n = Rt(e); return 'vec4 ' + t + '( vec4 value ) { return ' + n[0] + 'ToLinear' + n[1] + '; }' } function Ft (t, e) { const n = Rt(e); return 'vec4 ' + t + '( vec4 value ) { return LinearTo' + n[0] + n[1] + '; }' } function Ut (t, e) { let n; switch (e) { case 1:n = 'Linear'; break; case 2:n = 'Reinhard'; break; case 3:n = 'Uncharted2'; break; case 4:n = 'OptimizedCineon'; break; default:throw Error('unsupported toneMapping: ' + e) } return 'vec3 ' + t + '( vec3 color ) { return ' + n + 'ToneMapping( color ); }' } function zt (t, e, n) { return t = t || {}, [t.derivatives || e.envMapCubeUV || e.bumpMap || e.normalMap || e.flatShading ? '#extension GL_OES_standard_derivatives : enable' : '', (t.fragDepth || e.logarithmicDepthBuffer) && n.get('EXT_frag_depth') ? '#extension GL_EXT_frag_depth : enable' : '', t.drawBuffers && n.get('WEBGL_draw_buffers') ? '#extension GL_EXT_draw_buffers : require' : '', (t.shaderTextureLOD || e.envMap) && n.get('EXT_shader_texture_lod') ? '#extension GL_EXT_shader_texture_lod : enable' : ''].filter(jt).join('\n') } function Bt (t) { let e; const n = []; for (e in t) { const i = t[e]; !1 !== i && n.push('#define ' + e + ' ' + i) } return n.join('\n') } function jt (t) { return t !== '' } function Vt (t, e) { return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights) } function Gt (t) { return t.replace(/#include +<([\w\d.]+)>/g, function (t, e) { const n = gr[e]; if (void 0 === n) throw Error('Can not resolve #include <' + e + '>'); return Gt(n) }) } function Ht (t) { return t.replace(/for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, function (t, e, n, i) { for (t = '', e = parseInt(e); e < parseInt(n); e++)t += i.replace(/\[ i \]/g, '[ ' + e + ' ]'); return t }) } function Wt (t, e, n, i) {
    const r = t.context; var a = n.extensions; let o = n.defines; let s = n.__webglShader.vertexShader; let l = n.__webglShader.fragmentShader; let c = 'SHADOWMAP_TYPE_BASIC'; i.shadowMapType === 1 ? c = 'SHADOWMAP_TYPE_PCF' : i.shadowMapType === 2 && (c = 'SHADOWMAP_TYPE_PCF_SOFT'); let u = 'ENVMAP_TYPE_CUBE'; let h = 'ENVMAP_MODE_REFLECTION'; let p = 'ENVMAP_BLENDING_MULTIPLY'; if (i.envMap) { switch (n.envMap.mapping) { case 301:case 302:u = 'ENVMAP_TYPE_CUBE'; break; case 306:case 307:u = 'ENVMAP_TYPE_CUBE_UV'; break; case 303:case 304:u = 'ENVMAP_TYPE_EQUIREC'; break; case 305:u = 'ENVMAP_TYPE_SPHERE' } switch (n.envMap.mapping) { case 302:case 304:h = 'ENVMAP_MODE_REFRACTION' } switch (n.combine) { case 0:p = 'ENVMAP_BLENDING_MULTIPLY'; break; case 1:p = 'ENVMAP_BLENDING_MIX'; break; case 2:p = 'ENVMAP_BLENDING_ADD' } } let d = t.gammaFactor > 0 ? t.gammaFactor : 1; var a = zt(a, i, t.extensions); const f = Bt(o); const m = r.createProgram(); n.isRawShaderMaterial
      ? (o = [f, '\n'].filter(jt).join('\n'), c = [a, f, '\n'].filter(jt).join('\n'))
      : (o = ['precision ' + i.precision + ' float;', 'precision ' + i.precision + ' int;', '#define SHADER_NAME ' + n.__webglShader.name, f, i.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '', '#define GAMMA_FACTOR ' + d, '#define MAX_BONES ' + i.maxBones, i.useFog && i.fog ? '#define USE_FOG' : '', i.useFog && i.fogExp ? '#define FOG_EXP2' : '', i.map ? '#define USE_MAP' : '', i.envMap ? '#define USE_ENVMAP' : '', i.envMap ? '#define ' + h : '', i.lightMap ? '#define USE_LIGHTMAP' : '', i.aoMap ? '#define USE_AOMAP' : '', i.emissiveMap ? '#define USE_EMISSIVEMAP' : '', i.bumpMap ? '#define USE_BUMPMAP' : '', i.normalMap ? '#define USE_NORMALMAP' : '', i.displacementMap && i.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '', i.specularMap ? '#define USE_SPECULARMAP' : '', i.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', i.metalnessMap ? '#define USE_METALNESSMAP' : '', i.alphaMap ? '#define USE_ALPHAMAP' : '', i.vertexColors ? '#define USE_COLOR' : '', i.flatShading ? '#define FLAT_SHADED' : '', i.skinning ? '#define USE_SKINNING' : '', i.useVertexTexture ? '#define BONE_TEXTURE' : '', i.morphTargets ? '#define USE_MORPHTARGETS' : '', i.morphNormals && !1 === i.flatShading ? '#define USE_MORPHNORMALS' : '', i.doubleSided ? '#define DOUBLE_SIDED' : '', i.flipSided ? '#define FLIP_SIDED' : '', '#define NUM_CLIPPING_PLANES ' + i.numClippingPlanes, i.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', i.shadowMapEnabled ? '#define ' + c : '', i.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '', i.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', i.logarithmicDepthBuffer && t.extensions.get('EXT_frag_depth') ? '#define USE_LOGDEPTHBUF_EXT' : '', 'uniform mat4 modelMatrix;', 'uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', 'uniform mat4 viewMatrix;', 'uniform mat3 normalMatrix;', 'uniform vec3 cameraPosition;', 'attribute vec3 position;', 'attribute vec3 normal;', 'attribute vec2 uv;', '#ifdef USE_COLOR', '\tattribute vec3 color;', '#endif', '#ifdef USE_MORPHTARGETS', '\tattribute vec3 morphTarget0;', '\tattribute vec3 morphTarget1;', '\tattribute vec3 morphTarget2;', '\tattribute vec3 morphTarget3;', '\t#ifdef USE_MORPHNORMALS', '\t\tattribute vec3 morphNormal0;', '\t\tattribute vec3 morphNormal1;', '\t\tattribute vec3 morphNormal2;', '\t\tattribute vec3 morphNormal3;', '\t#else', '\t\tattribute vec3 morphTarget4;', '\t\tattribute vec3 morphTarget5;', '\t\tattribute vec3 morphTarget6;', '\t\tattribute vec3 morphTarget7;', '\t#endif', '#endif', '#ifdef USE_SKINNING', '\tattribute vec4 skinIndex;', '\tattribute vec4 skinWeight;', '#endif', '\n'].filter(jt).join('\n'),
        c = [a, 'precision ' + i.precision + ' float;', 'precision ' + i.precision + ' int;', '#define SHADER_NAME ' + n.__webglShader.name, f, i.alphaTest ? '#define ALPHATEST ' + i.alphaTest : '', '#define GAMMA_FACTOR ' + d, i.useFog && i.fog ? '#define USE_FOG' : '', i.useFog && i.fogExp ? '#define FOG_EXP2' : '', i.map ? '#define USE_MAP' : '', i.envMap ? '#define USE_ENVMAP' : '', i.envMap ? '#define ' + u : '', i.envMap ? '#define ' + h : '', i.envMap ? '#define ' + p : '', i.lightMap ? '#define USE_LIGHTMAP' : '', i.aoMap ? '#define USE_AOMAP' : '', i.emissiveMap ? '#define USE_EMISSIVEMAP' : '', i.bumpMap ? '#define USE_BUMPMAP' : '', i.normalMap ? '#define USE_NORMALMAP' : '', i.specularMap ? '#define USE_SPECULARMAP' : '', i.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', i.metalnessMap ? '#define USE_METALNESSMAP' : '', i.alphaMap ? '#define USE_ALPHAMAP' : '', i.vertexColors ? '#define USE_COLOR' : '', i.gradientMap ? '#define USE_GRADIENTMAP' : '', i.flatShading ? '#define FLAT_SHADED' : '', i.doubleSided ? '#define DOUBLE_SIDED' : '', i.flipSided ? '#define FLIP_SIDED' : '', '#define NUM_CLIPPING_PLANES ' + i.numClippingPlanes, '#define UNION_CLIPPING_PLANES ' + (i.numClippingPlanes - i.numClipIntersection), i.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', i.shadowMapEnabled ? '#define ' + c : '', i.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '', i.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '', i.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', i.logarithmicDepthBuffer && t.extensions.get('EXT_frag_depth') ? '#define USE_LOGDEPTHBUF_EXT' : '', i.envMap && t.extensions.get('EXT_shader_texture_lod') ? '#define TEXTURE_LOD_EXT' : '', 'uniform mat4 viewMatrix;', 'uniform vec3 cameraPosition;', i.toneMapping !== 0 ? '#define TONE_MAPPING' : '', i.toneMapping !== 0 ? gr.tonemapping_pars_fragment : '', i.toneMapping !== 0 ? Ut('toneMapping', i.toneMapping) : '', i.outputEncoding || i.mapEncoding || i.envMapEncoding || i.emissiveMapEncoding ? gr.encodings_pars_fragment : '', i.mapEncoding ? Nt('mapTexelToLinear', i.mapEncoding) : '', i.envMapEncoding ? Nt('envMapTexelToLinear', i.envMapEncoding) : '', i.emissiveMapEncoding ? Nt('emissiveMapTexelToLinear', i.emissiveMapEncoding) : '', i.outputEncoding ? Ft('linearToOutputTexel', i.outputEncoding) : '', i.depthPacking ? '#define DEPTH_PACKING ' + n.depthPacking : '', '\n'].filter(jt).join('\n')), s = Gt(s, i), s = Vt(s, i), l = Gt(l, i), l = Vt(l, i), n.isShaderMaterial || (s = Ht(s), l = Ht(l)), l = c + l, s = It(r, r.VERTEX_SHADER, o + s), l = It(r, r.FRAGMENT_SHADER, l), r.attachShader(m, s), r.attachShader(m, l), void 0 !== n.index0AttributeName ? r.bindAttribLocation(m, 0, n.index0AttributeName) : !0 === i.morphTargets && r.bindAttribLocation(m, 0, 'position'), r.linkProgram(m), i = r.getProgramInfoLog(m), u = r.getShaderInfoLog(s), h = r.getShaderInfoLog(l), d = p = !0, !1 === r.getProgramParameter(m, r.LINK_STATUS) ? p = !1 : i !== '' || u !== '' && h !== '' || (d = !1), d && (this.diagnostics = { runnable: p, material: n, programLog: i, vertexShader: { log: u, prefix: o }, fragmentShader: { log: h, prefix: c } }), r.deleteShader(s), r.deleteShader(l); let g; this.getUniforms = function () { return void 0 === g && (g = new B(r, m, t)), g }; let v; return this.getAttributes = function () { if (void 0 === v) { for (var t = {}, e = r.getProgramParameter(m, r.ACTIVE_ATTRIBUTES), n = 0; n < e; n++) { const i = r.getActiveAttrib(m, n).name; t[i] = r.getAttribLocation(m, i) }v = t } return v }, this.destroy = function () { r.deleteProgram(m), this.program = void 0 }, Object.defineProperties(this, { uniforms: { get: function () { return this.getUniforms() } }, attributes: { get: function () { return this.getAttributes() } } }), this.id = $r++, this.code = e, this.usedTimes = 1, this.program = m, this.vertexShader = s, this.fragmentShader = l, this
  } function qt (t, e) { function n (t, e) { let n; return t ? t.isTexture ? n = t.encoding : t.isWebGLRenderTarget && (n = t.texture.encoding) : n = 3e3, n === 3e3 && e && (n = 3007), n } const i = []; const r = { MeshDepthMaterial: 'depth', MeshNormalMaterial: 'normal', MeshBasicMaterial: 'basic', MeshLambertMaterial: 'lambert', MeshPhongMaterial: 'phong', MeshToonMaterial: 'phong', MeshStandardMaterial: 'physical', MeshPhysicalMaterial: 'physical', LineBasicMaterial: 'basic', LineDashedMaterial: 'dashed', PointsMaterial: 'points' }; const a = 'precision supportsVertexTextures map mapEncoding envMap envMapMode envMapEncoding lightMap aoMap emissiveMap emissiveMapEncoding bumpMap normalMap displacementMap specularMap roughnessMap metalnessMap gradientMap alphaMap combine vertexColors fog useFog fogExp flatShading sizeAttenuation logarithmicDepthBuffer skinning maxBones useVertexTexture morphTargets morphNormals maxMorphTargets maxMorphNormals premultipliedAlpha numDirLights numPointLights numSpotLights numHemiLights numRectAreaLights shadowMapEnabled shadowMapType toneMapping physicallyCorrectLights alphaTest doubleSided flipSided numClippingPlanes numClipIntersection depthPacking'.split(' '); this.getParameters = function (i, a, o, s, l, c) { let u; const h = r[i.type]; e.floatVertexTextures && c && c.skeleton && c.skeleton.useVertexTexture ? u = 1024 : (u = Math.floor((e.maxVertexUniforms - 20) / 4), void 0 !== c && c && c.isSkinnedMesh && (u = Math.min(c.skeleton.bones.length, u), c.skeleton.bones.length)); let p = t.getPrecision(); i.precision !== null && (p = e.getMaxPrecision(i.precision), i.precision); const d = t.getCurrentRenderTarget(); return { shaderID: h, precision: p, supportsVertexTextures: e.vertexTextures, outputEncoding: n(d ? d.texture : null, t.gammaOutput), map: !!i.map, mapEncoding: n(i.map, t.gammaInput), envMap: !!i.envMap, envMapMode: i.envMap && i.envMap.mapping, envMapEncoding: n(i.envMap, t.gammaInput), envMapCubeUV: !!i.envMap && (i.envMap.mapping === 306 || i.envMap.mapping === 307), lightMap: !!i.lightMap, aoMap: !!i.aoMap, emissiveMap: !!i.emissiveMap, emissiveMapEncoding: n(i.emissiveMap, t.gammaInput), bumpMap: !!i.bumpMap, normalMap: !!i.normalMap, displacementMap: !!i.displacementMap, roughnessMap: !!i.roughnessMap, metalnessMap: !!i.metalnessMap, specularMap: !!i.specularMap, alphaMap: !!i.alphaMap, gradientMap: !!i.gradientMap, combine: i.combine, vertexColors: i.vertexColors, fog: !!o, useFog: i.fog, fogExp: o && o.isFogExp2, flatShading: i.shading === 1, sizeAttenuation: i.sizeAttenuation, logarithmicDepthBuffer: e.logarithmicDepthBuffer, skinning: i.skinning, maxBones: u, useVertexTexture: e.floatVertexTextures && c && c.skeleton && c.skeleton.useVertexTexture, morphTargets: i.morphTargets, morphNormals: i.morphNormals, maxMorphTargets: t.maxMorphTargets, maxMorphNormals: t.maxMorphNormals, numDirLights: a.directional.length, numPointLights: a.point.length, numSpotLights: a.spot.length, numRectAreaLights: a.rectArea.length, numHemiLights: a.hemi.length, numClippingPlanes: s, numClipIntersection: l, shadowMapEnabled: t.shadowMap.enabled && c.receiveShadow && a.shadows.length > 0, shadowMapType: t.shadowMap.type, toneMapping: t.toneMapping, physicallyCorrectLights: t.physicallyCorrectLights, premultipliedAlpha: i.premultipliedAlpha, alphaTest: i.alphaTest, doubleSided: i.side === 2, flipSided: i.side === 1, depthPacking: void 0 !== i.depthPacking && i.depthPacking } }, this.getProgramCode = function (t, e) { const n = []; if (e.shaderID ? n.push(e.shaderID) : (n.push(t.fragmentShader), n.push(t.vertexShader)), void 0 !== t.defines) for (var i in t.defines)n.push(i), n.push(t.defines[i]); for (i = 0; i < a.length; i++)n.push(e[a[i]]); return n.join() }, this.acquireProgram = function (e, n, r) { for (var a, o = 0, s = i.length; o < s; o++) { const l = i[o]; if (l.code === r) { a = l, ++a.usedTimes; break } } return void 0 === a && (a = new Wt(t, r, e, n), i.push(a)), a }, this.releaseProgram = function (t) { if (--t.usedTimes == 0) { const e = i.indexOf(t); i[e] = i[i.length - 1], i.pop(), t.destroy() } }, this.programs = i } function Xt (t, e, n) { function i (t) { let o = t.target; t = a[o.id], t.index !== null && r(t.index); let s; const l = t.attributes; for (s in l)r(l[s]); o.removeEventListener('dispose', i), delete a[o.id], s = e.get(o), s.wireframe && r(s.wireframe), e.delete(o), o = e.get(t), o.wireframe && r(o.wireframe), e.delete(t), n.memory.geometries-- } function r (n) { let i; void 0 !== (i = n.isInterleavedBufferAttribute ? e.get(n.data).__webglBuffer : e.get(n).__webglBuffer) && (t.deleteBuffer(i), n.isInterleavedBufferAttribute ? e.delete(n.data) : e.delete(n)) } var a = {}; return { get: function (t) { const e = t.geometry; if (void 0 !== a[e.id]) return a[e.id]; e.addEventListener('dispose', i); let r; return e.isBufferGeometry ? r = e : e.isGeometry && (void 0 === e._bufferGeometry && (e._bufferGeometry = (new $t()).setFromObject(t)), r = e._bufferGeometry), a[e.id] = r, n.memory.geometries++, r } } } function Yt (t, e, n) { function i (n, i) { const r = n.isInterleavedBufferAttribute ? n.data : n; const a = e.get(r); if (void 0 === a.__webglBuffer) { a.__webglBuffer = t.createBuffer(), t.bindBuffer(i, a.__webglBuffer), t.bufferData(i, r.array, r.dynamic ? t.DYNAMIC_DRAW : t.STATIC_DRAW); let o = t.FLOAT; const s = r.array; s instanceof Float32Array ? o = t.FLOAT : s instanceof Float64Array || (s instanceof Uint16Array ? o = t.UNSIGNED_SHORT : s instanceof Int16Array ? o = t.SHORT : s instanceof Uint32Array ? o = t.UNSIGNED_INT : s instanceof Int32Array ? o = t.INT : s instanceof Int8Array ? o = t.BYTE : s instanceof Uint8Array && (o = t.UNSIGNED_BYTE)), a.bytesPerElement = s.BYTES_PER_ELEMENT, a.type = o, a.version = r.version, r.onUploadCallback() } else a.version !== r.version && (t.bindBuffer(i, a.__webglBuffer), !1 === r.dynamic ? t.bufferData(i, r.array, t.STATIC_DRAW) : r.updateRange.count === -1 ? t.bufferSubData(i, 0, r.array) : r.updateRange.count === 0 || (t.bufferSubData(i, r.updateRange.offset * r.array.BYTES_PER_ELEMENT, r.array.subarray(r.updateRange.offset, r.updateRange.offset + r.updateRange.count)), r.updateRange.count = 0), a.version = r.version) } const r = new Xt(t, e, n); return { getAttributeBuffer: function (t) { return t.isInterleavedBufferAttribute ? e.get(t.data).__webglBuffer : e.get(t).__webglBuffer }, getAttributeProperties: function (t) { return t.isInterleavedBufferAttribute ? e.get(t.data) : e.get(t) }, getWireframeAttribute: function (n) { const r = e.get(n); if (void 0 !== r.wireframe) return r.wireframe; let a = []; let o = n.index; if (n = n.attributes, o !== null) { o = o.array, n = 0; for (var s = o.length; n < s; n += 3) { var l = o[n + 0]; var c = o[n + 1]; var u = o[n + 2]; a.push(l, c, c, u, u, l) } } else for (o = n.position.array, n = 0, s = o.length / 3 - 1; n < s; n += 3)l = n + 0, c = n + 1, u = n + 2, a.push(l, c, c, u, u, l); return a = new (wt(a) > 65535 ? vt : mt)(a, 1), i(a, t.ELEMENT_ARRAY_BUFFER), r.wireframe = a }, update: function (e) { const n = r.get(e); e.geometry.isGeometry && n.updateFromObject(e), e = n.index; var a = n.attributes; e !== null && i(e, t.ELEMENT_ARRAY_BUFFER); for (var o in a)i(a[o], t.ARRAY_BUFFER); e = n.morphAttributes; for (o in e) for (var a = e[o], s = 0, l = a.length; s < l; s++)i(a[s], t.ARRAY_BUFFER); return n } } } function Zt (t, e, n, i, r, a, o) { function s (t, e) { if (t.width > e || t.height > e) { const n = e / Math.max(t.width, t.height); const i = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas'); return i.width = Math.floor(t.width * n), i.height = Math.floor(t.height * n), i.getContext('2d').drawImage(t, 0, 0, t.width, t.height, 0, 0, i.width, i.height), i } return t } function l (t) { return lr.isPowerOfTwo(t.width) && lr.isPowerOfTwo(t.height) } function c (e) { return e === 1003 || e === 1004 || e === 1005 ? t.NEAREST : t.LINEAR } function u (e) { e = e.target, e.removeEventListener('dispose', u); t: { const n = i.get(e); if (e.image && n.__image__webglTextureCube)t.deleteTexture(n.__image__webglTextureCube); else { if (void 0 === n.__webglInit) break t; t.deleteTexture(n.__webglTexture) }i.delete(e) }g.textures-- } function h (e) { e = e.target, e.removeEventListener('dispose', h); const n = i.get(e); let r = i.get(e.texture); if (e) { if (void 0 !== r.__webglTexture && t.deleteTexture(r.__webglTexture), e.depthTexture && e.depthTexture.dispose(), e.isWebGLRenderTargetCube) for (r = 0; r < 6; r++)t.deleteFramebuffer(n.__webglFramebuffer[r]), n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer[r]); else t.deleteFramebuffer(n.__webglFramebuffer), n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer); i.delete(e.texture), i.delete(e) }g.textures-- } function p (e, o) { const c = i.get(e); if (e.version > 0 && c.__version !== e.version) { var h = e.image; if (void 0 === h);else if (!1 !== h.complete) { void 0 === c.__webglInit && (c.__webglInit = !0, e.addEventListener('dispose', u), c.__webglTexture = t.createTexture(), g.textures++), n.activeTexture(t.TEXTURE0 + o), n.bindTexture(t.TEXTURE_2D, c.__webglTexture), t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, e.flipY), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.premultiplyAlpha), t.pixelStorei(t.UNPACK_ALIGNMENT, e.unpackAlignment); let p = s(e.image, r.maxTextureSize); if ((e.wrapS !== 1001 || e.wrapT !== 1001 || e.minFilter !== 1003 && e.minFilter !== 1006) && !1 === l(p)) if ((h = p) instanceof HTMLImageElement || h instanceof HTMLCanvasElement) { var f = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas'); f.width = lr.nearestPowerOfTwo(h.width), f.height = lr.nearestPowerOfTwo(h.height), f.getContext('2d').drawImage(h, 0, 0, f.width, f.height), p = f } else p = h; var h = l(p); var f = a(e.format); let m = a(e.type); d(t.TEXTURE_2D, e, h); let y = e.mipmaps; if (e.isDepthTexture) { if (y = t.DEPTH_COMPONENT, e.type === 1015) { if (!v) throw Error('Float Depth Texture only supported in WebGL2.0'); y = t.DEPTH_COMPONENT32F } else v && (y = t.DEPTH_COMPONENT16); e.format === 1026 && y === t.DEPTH_COMPONENT && e.type !== 1012 && e.type !== 1014 && (e.type = 1012, m = a(e.type)), e.format === 1027 && (y = t.DEPTH_STENCIL, e.type !== 1020 && (e.type = 1020, m = a(e.type))), n.texImage2D(t.TEXTURE_2D, 0, y, p.width, p.height, 0, f, m, null) } else if (e.isDataTexture) if (y.length > 0 && h) { for (var b = 0, x = y.length; b < x; b++)p = y[b], n.texImage2D(t.TEXTURE_2D, b, f, p.width, p.height, 0, f, m, p.data); e.generateMipmaps = !1 } else n.texImage2D(t.TEXTURE_2D, 0, f, p.width, p.height, 0, f, m, p.data); else if (e.isCompressedTexture) for (b = 0, x = y.length; b < x; b++)p = y[b], e.format !== 1023 && e.format !== 1022 ? n.getCompressedTextureFormats().indexOf(f) > -1 && n.compressedTexImage2D(t.TEXTURE_2D, b, f, p.width, p.height, 0, p.data) : n.texImage2D(t.TEXTURE_2D, b, f, p.width, p.height, 0, f, m, p.data); else if (y.length > 0 && h) { for (b = 0, x = y.length; b < x; b++)p = y[b], n.texImage2D(t.TEXTURE_2D, b, f, f, m, p); e.generateMipmaps = !1 } else n.texImage2D(t.TEXTURE_2D, 0, f, f, m, p); return e.generateMipmaps && h && t.generateMipmap(t.TEXTURE_2D), c.__version = e.version, void (e.onUpdate && e.onUpdate(e)) } }n.activeTexture(t.TEXTURE0 + o), n.bindTexture(t.TEXTURE_2D, c.__webglTexture) } function d (n, o, s) { s ? (t.texParameteri(n, t.TEXTURE_WRAP_S, a(o.wrapS)), t.texParameteri(n, t.TEXTURE_WRAP_T, a(o.wrapT)), t.texParameteri(n, t.TEXTURE_MAG_FILTER, a(o.magFilter)), t.texParameteri(n, t.TEXTURE_MIN_FILTER, a(o.minFilter))) : (t.texParameteri(n, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(n, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), o.wrapS === 1001 && o.wrapT, t.texParameteri(n, t.TEXTURE_MAG_FILTER, c(o.magFilter)), t.texParameteri(n, t.TEXTURE_MIN_FILTER, c(o.minFilter)), o.minFilter !== 1003 && o.minFilter), !(s = e.get('EXT_texture_filter_anisotropic')) || o.type === 1015 && e.get('OES_texture_float_linear') === null || o.type === 1016 && e.get('OES_texture_half_float_linear') === null || !(o.anisotropy > 1 || i.get(o).__currentAnisotropy) || (t.texParameterf(n, s.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(o.anisotropy, r.getMaxAnisotropy())), i.get(o).__currentAnisotropy = o.anisotropy) } function f (e, r, o, s) { const l = a(r.texture.format); const c = a(r.texture.type); n.texImage2D(s, 0, l, r.width, r.height, 0, l, c, null), t.bindFramebuffer(t.FRAMEBUFFER, e), t.framebufferTexture2D(t.FRAMEBUFFER, o, s, i.get(r.texture).__webglTexture, 0), t.bindFramebuffer(t.FRAMEBUFFER, null) } function m (e, n) { t.bindRenderbuffer(t.RENDERBUFFER, e), n.depthBuffer && !n.stencilBuffer ? (t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_COMPONENT16, n.width, n.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, e)) : n.depthBuffer && n.stencilBuffer ? (t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_STENCIL, n.width, n.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, e)) : t.renderbufferStorage(t.RENDERBUFFER, t.RGBA4, n.width, n.height), t.bindRenderbuffer(t.RENDERBUFFER, null) } var g = o.memory; var v = typeof WebGL2RenderingContext !== 'undefined' && t instanceof WebGL2RenderingContext; this.setTexture2D = p, this.setTextureCube = function (e, o) { const c = i.get(e); if (e.image.length === 6) if (e.version > 0 && c.__version !== e.version) { c.__image__webglTextureCube || (e.addEventListener('dispose', u), c.__image__webglTextureCube = t.createTexture(), g.textures++), n.activeTexture(t.TEXTURE0 + o), n.bindTexture(t.TEXTURE_CUBE_MAP, c.__image__webglTextureCube), t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, e.flipY); for (var h = e && e.isCompressedTexture, p = e.image[0] && e.image[0].isDataTexture, f = [], m = 0; m < 6; m++)f[m] = h || p ? p ? e.image[m].image : e.image[m] : s(e.image[m], r.maxCubemapSize); const v = l(f[0]); const y = a(e.format); const b = a(e.type); for (d(t.TEXTURE_CUBE_MAP, e, v), m = 0; m < 6; m++) if (h) for (var x, w = f[m].mipmaps, _ = 0, $ = w.length; _ < $; _++)x = w[_], e.format !== 1023 && e.format !== 1022 ? n.getCompressedTextureFormats().indexOf(y) > -1 && n.compressedTexImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + m, _, y, x.width, x.height, 0, x.data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + m, _, y, x.width, x.height, 0, y, b, x.data); else p ? n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + m, 0, y, f[m].width, f[m].height, 0, y, b, f[m].data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + m, 0, y, y, b, f[m]); e.generateMipmaps && v && t.generateMipmap(t.TEXTURE_CUBE_MAP), c.__version = e.version, e.onUpdate && e.onUpdate(e) } else n.activeTexture(t.TEXTURE0 + o), n.bindTexture(t.TEXTURE_CUBE_MAP, c.__image__webglTextureCube) }, this.setTextureCubeDynamic = function (e, r) { n.activeTexture(t.TEXTURE0 + r), n.bindTexture(t.TEXTURE_CUBE_MAP, i.get(e).__webglTexture) }, this.setupRenderTarget = function (e) { let r = i.get(e); let a = i.get(e.texture); e.addEventListener('dispose', h), a.__webglTexture = t.createTexture(), g.textures++; const o = !0 === e.isWebGLRenderTargetCube; const s = l(e); if (o) { r.__webglFramebuffer = []; for (var c = 0; c < 6; c++)r.__webglFramebuffer[c] = t.createFramebuffer() } else r.__webglFramebuffer = t.createFramebuffer(); if (o) { for (n.bindTexture(t.TEXTURE_CUBE_MAP, a.__webglTexture), d(t.TEXTURE_CUBE_MAP, e.texture, s), c = 0; c < 6; c++)f(r.__webglFramebuffer[c], e, t.COLOR_ATTACHMENT0, t.TEXTURE_CUBE_MAP_POSITIVE_X + c); e.texture.generateMipmaps && s && t.generateMipmap(t.TEXTURE_CUBE_MAP), n.bindTexture(t.TEXTURE_CUBE_MAP, null) } else n.bindTexture(t.TEXTURE_2D, a.__webglTexture), d(t.TEXTURE_2D, e.texture, s), f(r.__webglFramebuffer, e, t.COLOR_ATTACHMENT0, t.TEXTURE_2D), e.texture.generateMipmaps && s && t.generateMipmap(t.TEXTURE_2D), n.bindTexture(t.TEXTURE_2D, null); if (e.depthBuffer) { if (r = i.get(e), a = !0 === e.isWebGLRenderTargetCube, e.depthTexture) { if (a) throw Error('target.depthTexture not supported in Cube render targets'); if (e && e.isWebGLRenderTargetCube) throw Error('Depth Texture with cube render targets is not supported!'); if (t.bindFramebuffer(t.FRAMEBUFFER, r.__webglFramebuffer), !e.depthTexture || !e.depthTexture.isDepthTexture) throw Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture'); if (i.get(e.depthTexture).__webglTexture && e.depthTexture.image.width === e.width && e.depthTexture.image.height === e.height || (e.depthTexture.image.width = e.width, e.depthTexture.image.height = e.height, e.depthTexture.needsUpdate = !0), p(e.depthTexture, 0), r = i.get(e.depthTexture).__webglTexture, e.depthTexture.format === 1026)t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, r, 0); else { if (e.depthTexture.format !== 1027) throw Error('Unknown depthTexture format'); t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.TEXTURE_2D, r, 0) } } else if (a) for (r.__webglDepthbuffer = [], a = 0; a < 6; a++)t.bindFramebuffer(t.FRAMEBUFFER, r.__webglFramebuffer[a]), r.__webglDepthbuffer[a] = t.createRenderbuffer(), m(r.__webglDepthbuffer[a], e); else t.bindFramebuffer(t.FRAMEBUFFER, r.__webglFramebuffer), r.__webglDepthbuffer = t.createRenderbuffer(), m(r.__webglDepthbuffer, e); t.bindFramebuffer(t.FRAMEBUFFER, null) } }, this.updateRenderTargetMipmap = function (e) { let r = e.texture; r.generateMipmaps && l(e) && r.minFilter !== 1003 && r.minFilter !== 1006 && (e = e && e.isWebGLRenderTargetCube ? t.TEXTURE_CUBE_MAP : t.TEXTURE_2D, r = i.get(r).__webglTexture, n.bindTexture(e, r), t.generateMipmap(e), n.bindTexture(e, null)) } } function Kt () { let t = {}; return { get: function (e) { e = e.uuid; let n = t[e]; return void 0 === n && (n = {}, t[e] = n), n }, delete: function (e) { delete t[e.uuid] }, clear: function () { t = {} } } } function Jt (t, e, n) { function i (e, n, i) { const r = new Uint8Array(4); const a = t.createTexture(); for (t.bindTexture(e, a), t.texParameteri(e, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(e, t.TEXTURE_MAG_FILTER, t.NEAREST), e = 0; e < i; e++)t.texImage2D(n + e, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, r); return a } function a (e) { !0 !== b[e] && (t.enable(e), b[e] = !0) } function o (e) { !1 !== b[e] && (t.disable(e), b[e] = !1) } function s (e, i, r, s, l, c, u, h) { e !== 0 ? a(t.BLEND) : o(t.BLEND), e === w && h === E || (e === 2 ? h ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD), t.blendFuncSeparate(t.ONE, t.ONE, t.ONE, t.ONE)) : (t.blendEquation(t.FUNC_ADD), t.blendFunc(t.SRC_ALPHA, t.ONE)) : e === 3 ? h ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD), t.blendFuncSeparate(t.ZERO, t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ONE_MINUS_SRC_ALPHA)) : (t.blendEquation(t.FUNC_ADD), t.blendFunc(t.ZERO, t.ONE_MINUS_SRC_COLOR)) : e === 4 ? h ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD), t.blendFuncSeparate(t.ZERO, t.SRC_COLOR, t.ZERO, t.SRC_ALPHA)) : (t.blendEquation(t.FUNC_ADD), t.blendFunc(t.ZERO, t.SRC_COLOR)) : h ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD), t.blendFuncSeparate(t.ONE, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA)) : (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD), t.blendFuncSeparate(t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA)), w = e, E = h), e === 5 ? (l = l || i, c = c || r, u = u || s, i === _ && l === S || (t.blendEquationSeparate(n(i), n(l)), _ = i, S = l), r === $ && s === T && c === M && u === C || (t.blendFuncSeparate(n(r), n(s), n(c), n(u)), $ = r, T = s, M = c, C = u)) : C = M = S = T = $ = _ = null } function l (t) { d.setFunc(t) } function c (e) { A !== e && (e ? t.frontFace(t.CW) : t.frontFace(t.CCW), A = e) } function u (e) { e !== 0 ? (a(t.CULL_FACE), e !== P && (e === 1 ? t.cullFace(t.BACK) : e === 2 ? t.cullFace(t.FRONT) : t.cullFace(t.FRONT_AND_BACK))) : o(t.CULL_FACE), P = e } function h (e) { void 0 === e && (e = t.TEXTURE0 + I - 1), N !== e && (t.activeTexture(e), N = e) } const p = new function () { let e = !1; const n = new r(); let i = null; const a = new r(); return { setMask: function (n) { i === n || e || (t.colorMask(n, n, n, n), i = n) }, setLocked: function (t) { e = t }, setClear: function (e, i, r, o, s) { !0 === s && (e *= o, i *= o, r *= o), n.set(e, i, r, o), !1 === a.equals(n) && (t.clearColor(e, i, r, o), a.copy(n)) }, reset: function () { e = !1, i = null, a.set(0, 0, 0, 1) } } }(); var d = new function () { let e = !1; let n = null; let i = null; let r = null; return { setTest: function (e) { e ? a(t.DEPTH_TEST) : o(t.DEPTH_TEST) }, setMask: function (i) { n === i || e || (t.depthMask(i), n = i) }, setFunc: function (e) { if (i !== e) { if (e) switch (e) { case 0:t.depthFunc(t.NEVER); break; case 1:t.depthFunc(t.ALWAYS); break; case 2:t.depthFunc(t.LESS); break; case 3:t.depthFunc(t.LEQUAL); break; case 4:t.depthFunc(t.EQUAL); break; case 5:t.depthFunc(t.GEQUAL); break; case 6:t.depthFunc(t.GREATER); break; case 7:t.depthFunc(t.NOTEQUAL); break; default:t.depthFunc(t.LEQUAL) } else t.depthFunc(t.LEQUAL); i = e } }, setLocked: function (t) { e = t }, setClear: function (e) { r !== e && (t.clearDepth(e), r = e) }, reset: function () { e = !1, r = i = n = null } } }(); const f = new function () { let e = !1; let n = null; let i = null; let r = null; let s = null; let l = null; let c = null; let u = null; let h = null; return { setTest: function (e) { e ? a(t.STENCIL_TEST) : o(t.STENCIL_TEST) }, setMask: function (i) { n === i || e || (t.stencilMask(i), n = i) }, setFunc: function (e, n, a) { i === e && r === n && s === a || (t.stencilFunc(e, n, a), i = e, r = n, s = a) }, setOp: function (e, n, i) { l === e && c === n && u === i || (t.stencilOp(e, n, i), l = e, c = n, u = i) }, setLocked: function (t) { e = t }, setClear: function (e) { h !== e && (t.clearStencil(e), h = e) }, reset: function () { e = !1, h = u = c = l = s = r = i = n = null } } }(); var m = t.getParameter(t.MAX_VERTEX_ATTRIBS); const g = new Uint8Array(m); const v = new Uint8Array(m); const y = new Uint8Array(m); var b = {}; let x = null; var w = null; var _ = null; var $ = null; var T = null; var S = null; var M = null; var C = null; var E = !1; var A = null; var P = null; let k = null; let D = null; let O = null; let L = null; var I = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS); var m = parseFloat(/^WebGL\ ([0-9])/.exec(t.getParameter(t.VERSION))[1]); const R = parseFloat(m) >= 1; var N = null; let F = {}; const U = new r(); const z = new r(); const B = {}; return B[t.TEXTURE_2D] = i(t.TEXTURE_2D, t.TEXTURE_2D, 1), B[t.TEXTURE_CUBE_MAP] = i(t.TEXTURE_CUBE_MAP, t.TEXTURE_CUBE_MAP_POSITIVE_X, 6), { buffers: { color: p, depth: d, stencil: f }, init: function () { p.setClear(0, 0, 0, 1), d.setClear(1), f.setClear(0), a(t.DEPTH_TEST), l(3), c(!1), u(1), a(t.CULL_FACE), a(t.BLEND), s(1) }, initAttributes: function () { for (let t = 0, e = g.length; t < e; t++)g[t] = 0 }, enableAttribute: function (n) { g[n] = 1, v[n] === 0 && (t.enableVertexAttribArray(n), v[n] = 1), y[n] !== 0 && (e.get('ANGLE_instanced_arrays').vertexAttribDivisorANGLE(n, 0), y[n] = 0) }, enableAttributeAndDivisor: function (e, n, i) { g[e] = 1, v[e] === 0 && (t.enableVertexAttribArray(e), v[e] = 1), y[e] !== n && (i.vertexAttribDivisorANGLE(e, n), y[e] = n) }, disableUnusedAttributes: function () { for (let e = 0, n = v.length; e !== n; ++e)v[e] !== g[e] && (t.disableVertexAttribArray(e), v[e] = 0) }, enable: a, disable: o, getCompressedTextureFormats: function () { if (x === null && (x = [], e.get('WEBGL_compressed_texture_pvrtc') || e.get('WEBGL_compressed_texture_s3tc') || e.get('WEBGL_compressed_texture_etc1'))) for (let n = t.getParameter(t.COMPRESSED_TEXTURE_FORMATS), i = 0; i < n.length; i++)x.push(n[i]); return x }, setBlending: s, setColorWrite: function (t) { p.setMask(t) }, setDepthTest: function (t) { d.setTest(t) }, setDepthWrite: function (t) { d.setMask(t) }, setDepthFunc: l, setStencilTest: function (t) { f.setTest(t) }, setStencilWrite: function (t) { f.setMask(t) }, setStencilFunc: function (t, e, n) { f.setFunc(t, e, n) }, setStencilOp: function (t, e, n) { f.setOp(t, e, n) }, setFlipSided: c, setCullFace: u, setLineWidth: function (e) { e !== k && (R && t.lineWidth(e), k = e) }, setPolygonOffset: function (e, n, i) { e ? (a(t.POLYGON_OFFSET_FILL), (D !== n || O !== i) && (t.polygonOffset(n, i), D = n, O = i)) : o(t.POLYGON_OFFSET_FILL) }, getScissorTest: function () { return L }, setScissorTest: function (e) { (L = e) ? a(t.SCISSOR_TEST) : o(t.SCISSOR_TEST) }, activeTexture: h, bindTexture: function (e, n) { N === null && h(); let i = F[N]; void 0 === i && (i = { type: void 0, texture: void 0 }, F[N] = i), i.type === e && i.texture === n || (t.bindTexture(e, n || B[e]), i.type = e, i.texture = n) }, compressedTexImage2D: function () { try { t.compressedTexImage2D.apply(t, arguments) } catch (t) {} }, texImage2D: function () { try { t.texImage2D.apply(t, arguments) } catch (t) {} }, scissor: function (e) { !1 === U.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), U.copy(e)) }, viewport: function (e) { !1 === z.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), z.copy(e)) }, reset: function () { for (let e = 0; e < v.length; e++)v[e] === 1 && (t.disableVertexAttribArray(e), v[e] = 0); b = {}, N = x = null, F = {}, P = A = w = null, p.reset(), d.reset(), f.reset() } } } function Qt (t, e, n) { function i (e) { if (e === 'highp') { if (t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT).precision > 0) return 'highp'; e = 'mediump' } return e === 'mediump' && t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT).precision > 0 ? 'mediump' : 'lowp' } let r; let a = void 0 !== n.precision ? n.precision : 'highp'; var o = i(a); o !== a && (a = o), n = !0 === n.logarithmicDepthBuffer && !!e.get('EXT_frag_depth'); var o = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS); const s = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS); const l = t.getParameter(t.MAX_TEXTURE_SIZE); const c = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE); const u = t.getParameter(t.MAX_VERTEX_ATTRIBS); const h = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS); const p = t.getParameter(t.MAX_VARYING_VECTORS); const d = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS); const f = s > 0; const m = !!e.get('OES_texture_float'); return { getMaxAnisotropy: function () { if (void 0 !== r) return r; const n = e.get('EXT_texture_filter_anisotropic'); return r = n !== null ? t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0 }, getMaxPrecision: i, precision: a, logarithmicDepthBuffer: n, maxTextures: o, maxVertexTextures: s, maxTextureSize: l, maxCubemapSize: c, maxAttributes: u, maxVertexUniforms: h, maxVaryings: p, maxFragmentUniforms: d, vertexTextures: f, floatFragmentTextures: m, floatVertexTextures: f && m } } function te (t) { const e = {}; return { get: function (n) { if (void 0 !== e[n]) return e[n]; let i; switch (n) { case 'WEBGL_depth_texture':i = t.getExtension('WEBGL_depth_texture') || t.getExtension('MOZ_WEBGL_depth_texture') || t.getExtension('WEBKIT_WEBGL_depth_texture'); break; case 'EXT_texture_filter_anisotropic':i = t.getExtension('EXT_texture_filter_anisotropic') || t.getExtension('MOZ_EXT_texture_filter_anisotropic') || t.getExtension('WEBKIT_EXT_texture_filter_anisotropic'); break; case 'WEBGL_compressed_texture_s3tc':i = t.getExtension('WEBGL_compressed_texture_s3tc') || t.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || t.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc'); break; case 'WEBGL_compressed_texture_pvrtc':i = t.getExtension('WEBGL_compressed_texture_pvrtc') || t.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc'); break; case 'WEBGL_compressed_texture_etc1':i = t.getExtension('WEBGL_compressed_texture_etc1'); break; default:i = t.getExtension(n) } return e[n] = i } } } function ee () { function t () { c.value !== i && (c.value = i, c.needsUpdate = r > 0), n.numPlanes = r, n.numIntersection = 0 } function e (t, e, i, r) { const a = t !== null ? t.length : 0; let o = null; if (a !== 0) { if (o = c.value, !0 !== r || o === null) for (r = i + 4 * a, e = e.matrixWorldInverse, l.getNormalMatrix(e), (o === null || o.length < r) && (o = new Float32Array(r)), r = 0; r !== a; ++r, i += 4)s.copy(t[r]).applyMatrix4(e, l), s.normal.toArray(o, i), o[i + 3] = s.constant; c.value = o, c.needsUpdate = !0 } return n.numPlanes = a, o } var n = this; var i = null; var r = 0; let a = !1; let o = !1; var s = new Q(); var l = new J(); var c = { value: null, needsUpdate: !1 }; this.uniform = c, this.numIntersection = this.numPlanes = 0, this.init = function (t, n, o) { const s = t.length !== 0 || n || r !== 0 || a; return a = n, i = e(t, o, 0), r = t.length, s }, this.beginShadows = function () { o = !0, e(null) }, this.endShadows = function () { o = !1, t() }, this.setState = function (n, s, l, u, h, p) { if (!a || n === null || n.length === 0 || o && !l)o ? e(null) : t(); else { l = o ? 0 : r; const d = 4 * l; let f = h.clippingState || null; for (c.value = f, f = e(n, u, d, p), n = 0; n !== d; ++n)f[n] = i[n]; h.clippingState = f, this.numIntersection = s ? this.numPlanes : 0, this.numPlanes += l } } } function ne (t) {
    function e () { At.init(), At.scissor(Y.copy(st).multiplyScalar(ot)), At.viewport(J.copy(ut).multiplyScalar(ot)), At.buffers.color.setClear(nt.r, nt.g, nt.b, it, C) } function n () { q = F = null, G = '', V = -1, At.reset() } function i (t) { t.preventDefault(), n(), e(), It.clear() } function a (t) { t = t.target, t.removeEventListener('dispose', a), o(t), It.delete(t) } function o (t) { const e = It.get(t).program; t.program = void 0, void 0 !== e && Ft.releaseProgram(e) } function s (t, e) { return Math.abs(e[0]) - Math.abs(t[0]) } function u (t, e) { return t.object.renderOrder !== e.object.renderOrder ? t.object.renderOrder - e.object.renderOrder : t.material.program && e.material.program && t.material.program !== e.material.program ? t.material.program.id - e.material.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id } function h (t, e) { return t.object.renderOrder !== e.object.renderOrder ? t.object.renderOrder - e.object.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id } function p (t, e, n, i, r) { let a; n.transparent ? (i = D, a = ++O) : (i = P, a = ++k), a = i[a], void 0 !== a ? (a.id = t.id, a.object = t, a.geometry = e, a.material = n, a.z = vt.z, a.group = r) : (a = { id: t.id, object: t, geometry: e, material: n, z: vt.z, group: r }, i.push(a)) } function d (t) { if (!ht.intersectsSphere(t)) return !1; const e = pt.numPlanes; if (e === 0) return !0; const n = N.clippingPlanes; const i = t.center; t = -t.radius; let r = 0; do { if (n[r].distanceToPoint(i) < t) return !1 } while (++r !== e); return !0 } function f (t, e) { if (!1 !== t.visible) { if ((t.layers.mask & e.layers.mask) != 0) if (t.isLight)A.push(t); else if (t.isSprite) { var n; (n = !1 === t.frustumCulled) || (mt.center.set(0, 0, 0), mt.radius = 0.7071067811865476, mt.applyMatrix4(t.matrixWorld), n = !0 === d(mt)), n && I.push(t) } else if (t.isLensFlare)R.push(t); else if (t.isImmediateRenderObject)!0 === N.sortObjects && (vt.setFromMatrixPosition(t.matrixWorld), vt.applyMatrix4(gt)), p(t, null, t.material, vt.z, null); else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.update(), (n = !1 === t.frustumCulled) || (n = t.geometry, n.boundingSphere === null && n.computeBoundingSphere(), mt.copy(n.boundingSphere).applyMatrix4(t.matrixWorld), n = !0 === d(mt)), n)) { var i = t.material; if (!0 === i.visible) if (!0 === N.sortObjects && (vt.setFromMatrixPosition(t.matrixWorld), vt.applyMatrix4(gt)), n = Nt.update(t), i.isMultiMaterial) for (var r = n.groups, a = i.materials, i = 0, o = r.length; i < o; i++) { const s = r[i]; const l = a[s.materialIndex]; !0 === l.visible && p(t, n, l, vt.z, s) } else p(t, n, i, vt.z, null) } for (n = t.children, i = 0, o = n.length; i < o; i++)f(n[i], e) } } function m (t, e, n, i) { for (let r = 0, a = t.length; r < a; r++) { var o = t[r]; const s = o.object; const l = o.geometry; var c = void 0 === i ? o.material : i; var o = o.group; if (s.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, s.matrixWorld), s.normalMatrix.getNormalMatrix(s.modelViewMatrix), s.onBeforeRender(N, e, n, l, c, o), s.isImmediateRenderObject) { g(c); var u = v(n, e.fog, c, s); G = '', s.render(function (t) { N.renderBufferImmediate(t, u, c) }) } else N.renderBufferDirect(n, e.fog, l, c, s, o); s.onAfterRender(N, e, n, l, c, o) } } function g (t) { t.side === 2 ? At.disable(_t.CULL_FACE) : At.enable(_t.CULL_FACE), At.setFlipSided(t.side === 1), !0 === t.transparent ? At.setBlending(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha) : At.setBlending(0), At.setDepthFunc(t.depthFunc), At.setDepthTest(t.depthTest), At.setDepthWrite(t.depthWrite), At.setColorWrite(t.colorWrite), At.setPolygonOffset(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits) } function v (t, e, n, i) {
      Q = 0; const r = It.get(n)
      if (dt && (ft || t !== q) && pt.setState(n.clippingPlanes, n.clipIntersection, n.clipShadows, t, r, t === q && n.id === V), !1 === n.needsUpdate && (void 0 === r.program ? n.needsUpdate = !0 : n.fog && r.fog !== e ? n.needsUpdate = !0 : n.lights && r.lightsHash !== xt.hash ? n.needsUpdate = !0 : void 0 === r.numClippingPlanes || r.numClippingPlanes === pt.numPlanes && r.numIntersection === pt.numIntersection || (n.needsUpdate = !0)), n.needsUpdate) { t: { var s = It.get(n); var l = Ft.getParameters(n, xt, e, pt.numPlanes, pt.numIntersection, i); var c = Ft.getProgramCode(n, l); var u = s.program; var h = !0; if (void 0 === u)n.addEventListener('dispose', a); else if (u.code !== c)o(n); else { if (void 0 !== l.shaderID) break t; h = !1 } if (h && (l.shaderID ? (u = br[l.shaderID], s.__webglShader = { name: n.type, uniforms: mr.clone(u.uniforms), vertexShader: u.vertexShader, fragmentShader: u.fragmentShader }) : s.__webglShader = { name: n.type, uniforms: n.uniforms, vertexShader: n.vertexShader, fragmentShader: n.fragmentShader }, n.__webglShader = s.__webglShader, u = Ft.acquireProgram(n, l, c), s.program = u, n.program = u), l = u.getAttributes(), n.morphTargets) for (c = n.numSupportedMorphTargets = 0; c < N.maxMorphTargets; c++)l['morphTarget' + c] >= 0 && n.numSupportedMorphTargets++; if (n.morphNormals) for (c = n.numSupportedMorphNormals = 0; c < N.maxMorphNormals; c++)l['morphNormal' + c] >= 0 && n.numSupportedMorphNormals++; l = s.__webglShader.uniforms, (n.isShaderMaterial || n.isRawShaderMaterial) && !0 !== n.clipping || (s.numClippingPlanes = pt.numPlanes, s.numIntersection = pt.numIntersection, l.clippingPlanes = pt.uniform), s.fog = e, s.lightsHash = xt.hash, n.lights && (l.ambientLightColor.value = xt.ambient, l.directionalLights.value = xt.directional, l.spotLights.value = xt.spot, l.rectAreaLights.value = xt.rectArea, l.pointLights.value = xt.point, l.hemisphereLights.value = xt.hemi, l.directionalShadowMap.value = xt.directionalShadowMap, l.directionalShadowMatrix.value = xt.directionalShadowMatrix, l.spotShadowMap.value = xt.spotShadowMap, l.spotShadowMatrix.value = xt.spotShadowMatrix, l.pointShadowMap.value = xt.pointShadowMap, l.pointShadowMatrix.value = xt.pointShadowMatrix), c = s.program.getUniforms(), l = B.seqWithValue(c.seq, l), s.uniformsList = l }n.needsUpdate = !1 } let p = !1; var h = u = !1; var s = r.program; var l = s.getUniforms(); var c = r.__webglShader.uniforms; if (s.id !== F && (_t.useProgram(s.program), F = s.id, h = u = p = !0), n.id !== V && (V = n.id, u = !0), (p || t !== q) && (l.set(_t, t, 'projectionMatrix'), Ct.logarithmicDepthBuffer && l.setValue(_t, 'logDepthBufFC', 2 / (Math.log(t.far + 1) / Math.LN2)), t !== q && (q = t, h = u = !0), (n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshStandardMaterial || n.envMap) && void 0 !== (p = l.map.cameraPosition) && p.setValue(_t, vt.setFromMatrixPosition(t.matrixWorld)), (n.isMeshPhongMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.skinning) && l.setValue(_t, 'viewMatrix', t.matrixWorldInverse), l.set(_t, N, 'toneMappingExposure'), l.set(_t, N, 'toneMappingWhitePoint')), n.skinning && (l.setOptional(_t, i, 'bindMatrix'), l.setOptional(_t, i, 'bindMatrixInverse'), t = i.skeleton) && (Ct.floatVertexTextures && t.useVertexTexture ? (l.set(_t, t, 'boneTexture'), l.set(_t, t, 'boneTextureWidth'), l.set(_t, t, 'boneTextureHeight')) : l.setOptional(_t, t, 'boneMatrices')), u) { if (n.lights && (t = h, c.ambientLightColor.needsUpdate = t, c.directionalLights.needsUpdate = t, c.pointLights.needsUpdate = t, c.spotLights.needsUpdate = t, c.rectAreaLights.needsUpdate = t, c.hemisphereLights.needsUpdate = t), e && n.fog && (c.fogColor.value = e.color, e.isFog ? (c.fogNear.value = e.near, c.fogFar.value = e.far) : e.isFogExp2 && (c.fogDensity.value = e.density)), n.isMeshBasicMaterial || n.isMeshLambertMaterial || n.isMeshPhongMaterial || n.isMeshStandardMaterial || n.isMeshNormalMaterial || n.isMeshDepthMaterial) { c.opacity.value = n.opacity, c.diffuse.value = n.color, n.emissive && c.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity), c.map.value = n.map, c.specularMap.value = n.specularMap, c.alphaMap.value = n.alphaMap, n.lightMap && (c.lightMap.value = n.lightMap, c.lightMapIntensity.value = n.lightMapIntensity), n.aoMap && (c.aoMap.value = n.aoMap, c.aoMapIntensity.value = n.aoMapIntensity); var d; n.map ? d = n.map : n.specularMap ? d = n.specularMap : n.displacementMap ? d = n.displacementMap : n.normalMap ? d = n.normalMap : n.bumpMap ? d = n.bumpMap : n.roughnessMap ? d = n.roughnessMap : n.metalnessMap ? d = n.metalnessMap : n.alphaMap ? d = n.alphaMap : n.emissiveMap && (d = n.emissiveMap), void 0 !== d && (d.isWebGLRenderTarget && (d = d.texture), e = d.offset, d = d.repeat, c.offsetRepeat.value.set(e.x, e.y, d.x, d.y)), c.envMap.value = n.envMap, c.flipEnvMap.value = n.envMap && n.envMap.isCubeTexture ? -1 : 1, c.reflectivity.value = n.reflectivity, c.refractionRatio.value = n.refractionRatio }n.isLineBasicMaterial ? (c.diffuse.value = n.color, c.opacity.value = n.opacity) : n.isLineDashedMaterial ? (c.diffuse.value = n.color, c.opacity.value = n.opacity, c.dashSize.value = n.dashSize, c.totalSize.value = n.dashSize + n.gapSize, c.scale.value = n.scale) : n.isPointsMaterial ? (c.diffuse.value = n.color, c.opacity.value = n.opacity, c.size.value = n.size * ot, c.scale.value = 0.5 * at, c.map.value = n.map, n.map !== null && (d = n.map.offset, n = n.map.repeat, c.offsetRepeat.value.set(d.x, d.y, n.x, n.y))) : n.isMeshLambertMaterial ? n.emissiveMap && (c.emissiveMap.value = n.emissiveMap) : n.isMeshToonMaterial ? (y(c, n), n.gradientMap && (c.gradientMap.value = n.gradientMap)) : n.isMeshPhongMaterial ? y(c, n) : n.isMeshPhysicalMaterial ? (c.clearCoat.value = n.clearCoat, c.clearCoatRoughness.value = n.clearCoatRoughness, b(c, n)) : n.isMeshStandardMaterial ? b(c, n) : n.isMeshDepthMaterial ? n.displacementMap && (c.displacementMap.value = n.displacementMap, c.displacementScale.value = n.displacementScale, c.displacementBias.value = n.displacementBias) : n.isMeshNormalMaterial && (n.bumpMap && (c.bumpMap.value = n.bumpMap, c.bumpScale.value = n.bumpScale), n.normalMap && (c.normalMap.value = n.normalMap, c.normalScale.value.copy(n.normalScale)), n.displacementMap && (c.displacementMap.value = n.displacementMap, c.displacementScale.value = n.displacementScale, c.displacementBias.value = n.displacementBias)), void 0 !== c.ltcMat && (c.ltcMat.value = THREE.UniformsLib.LTC_MAT_TEXTURE), void 0 !== c.ltcMag && (c.ltcMag.value = THREE.UniformsLib.LTC_MAG_TEXTURE), B.upload(_t, r.uniformsList, c, N) } return l.set(_t, i, 'modelViewMatrix'), l.set(_t, i, 'normalMatrix'), l.setValue(_t, 'modelMatrix', i.matrixWorld), s
    } function y (t, e) { t.specular.value = e.specular, t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale)), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias) } function b (t, e) { t.roughness.value = e.roughness, t.metalness.value = e.metalness, e.roughnessMap && (t.roughnessMap.value = e.roughnessMap), e.metalnessMap && (t.metalnessMap.value = e.metalnessMap), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale)), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias), e.envMap && (t.envMapIntensity.value = e.envMapIntensity) } function x (t) { let e; if (t === 1e3) return _t.REPEAT; if (t === 1001) return _t.CLAMP_TO_EDGE; if (t === 1002) return _t.MIRRORED_REPEAT; if (t === 1003) return _t.NEAREST; if (t === 1004) return _t.NEAREST_MIPMAP_NEAREST; if (t === 1005) return _t.NEAREST_MIPMAP_LINEAR; if (t === 1006) return _t.LINEAR; if (t === 1007) return _t.LINEAR_MIPMAP_NEAREST; if (t === 1008) return _t.LINEAR_MIPMAP_LINEAR; if (t === 1009) return _t.UNSIGNED_BYTE; if (t === 1017) return _t.UNSIGNED_SHORT_4_4_4_4; if (t === 1018) return _t.UNSIGNED_SHORT_5_5_5_1; if (t === 1019) return _t.UNSIGNED_SHORT_5_6_5; if (t === 1010) return _t.BYTE; if (t === 1011) return _t.SHORT; if (t === 1012) return _t.UNSIGNED_SHORT; if (t === 1013) return _t.INT; if (t === 1014) return _t.UNSIGNED_INT; if (t === 1015) return _t.FLOAT; if (t === 1016 && (e = St.get('OES_texture_half_float')) !== null) return e.HALF_FLOAT_OES; if (t === 1021) return _t.ALPHA; if (t === 1022) return _t.RGB; if (t === 1023) return _t.RGBA; if (t === 1024) return _t.LUMINANCE; if (t === 1025) return _t.LUMINANCE_ALPHA; if (t === 1026) return _t.DEPTH_COMPONENT; if (t === 1027) return _t.DEPTH_STENCIL; if (t === 100) return _t.FUNC_ADD; if (t === 101) return _t.FUNC_SUBTRACT; if (t === 102) return _t.FUNC_REVERSE_SUBTRACT; if (t === 200) return _t.ZERO; if (t === 201) return _t.ONE; if (t === 202) return _t.SRC_COLOR; if (t === 203) return _t.ONE_MINUS_SRC_COLOR; if (t === 204) return _t.SRC_ALPHA; if (t === 205) return _t.ONE_MINUS_SRC_ALPHA; if (t === 206) return _t.DST_ALPHA; if (t === 207) return _t.ONE_MINUS_DST_ALPHA; if (t === 208) return _t.DST_COLOR; if (t === 209) return _t.ONE_MINUS_DST_COLOR; if (t === 210) return _t.SRC_ALPHA_SATURATE; if ((t === 2001 || t === 2002 || t === 2003 || t === 2004) && (e = St.get('WEBGL_compressed_texture_s3tc')) !== null) { if (t === 2001) return e.COMPRESSED_RGB_S3TC_DXT1_EXT; if (t === 2002) return e.COMPRESSED_RGBA_S3TC_DXT1_EXT; if (t === 2003) return e.COMPRESSED_RGBA_S3TC_DXT3_EXT; if (t === 2004) return e.COMPRESSED_RGBA_S3TC_DXT5_EXT } if ((t === 2100 || t === 2101 || t === 2102 || t === 2103) && (e = St.get('WEBGL_compressed_texture_pvrtc')) !== null) { if (t === 2100) return e.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; if (t === 2101) return e.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; if (t === 2102) return e.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; if (t === 2103) return e.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG } if (t === 2151 && (e = St.get('WEBGL_compressed_texture_etc1')) !== null) return e.COMPRESSED_RGB_ETC1_WEBGL; if ((t === 103 || t === 104) && (e = St.get('EXT_blend_minmax')) !== null) { if (t === 103) return e.MIN_EXT; if (t === 104) return e.MAX_EXT } return t === 1020 && (e = St.get('WEBGL_depth_texture')) !== null ? e.UNSIGNED_INT_24_8_WEBGL : 0 }t = t || {}; const w = void 0 !== t.canvas ? t.canvas : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas'); const _ = void 0 !== t.context ? t.context : null; let $ = void 0 !== t.alpha && t.alpha; const T = void 0 === t.depth || t.depth; const S = void 0 === t.stencil || t.stencil; const M = void 0 !== t.antialias && t.antialias; var C = void 0 === t.premultipliedAlpha || t.premultipliedAlpha; const E = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer; var A = []; var P = []; var k = -1; var D = []; var O = -1; const L = new Float32Array(8); var I = []; var R = []; this.domElement = w, this.context = null, this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.physicallyCorrectLights = this.gammaOutput = this.gammaInput = !1, this.toneMappingWhitePoint = this.toneMappingExposure = this.toneMapping = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4; var N = this; var F = null; let U = null; let z = null; var V = -1; var G = ''; var q = null; var Y = new r(); let Z = null; var J = new r(); var Q = 0; var nt = new j(0); var it = 0; let rt = w.width; var at = w.height; var ot = 1; var st = new r(0, 0, rt, at); let lt = !1; var ut = new r(0, 0, rt, at); var ht = new tt(); var pt = new ee(); var dt = !1; var ft = !1; var mt = new K(); var gt = new c(); var vt = new l(); const yt = new c(); const bt = new c(); var xt = { hash: '', ambient: [0, 0, 0], directional: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotShadowMap: [], spotShadowMatrix: [], rectArea: [], point: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [], shadows: [] }; const wt = { calls: 0, vertices: 0, faces: 0, points: 0 }; this.info = { render: wt, memory: { geometries: 0, textures: 0 }, programs: null }; let _t; try { if ($ = { alpha: $, depth: T, stencil: S, antialias: M, premultipliedAlpha: C, preserveDrawingBuffer: E }, (_t = _ || w.getContext('webgl', $) || w.getContext('experimental-webgl', $)) === null) { if (w.getContext('webgl') !== null) throw 'Error creating WebGL context with your selected attributes.'; throw 'Error creating WebGL context.' } void 0 === _t.getShaderPrecisionFormat && (_t.getShaderPrecisionFormat = function () { return { rangeMin: 1, rangeMax: 1, precision: 1 } }), w.addEventListener('webglcontextlost', i, !1) } catch (t) {} var St = new te(_t); St.get('WEBGL_depth_texture'), St.get('OES_texture_float'), St.get('OES_texture_float_linear'), St.get('OES_texture_half_float'), St.get('OES_texture_half_float_linear'), St.get('OES_standard_derivatives'), St.get('ANGLE_instanced_arrays'), St.get('OES_element_index_uint') && ($t.MaxIndex = 4294967296); var Ct = new Qt(_t, St, t); var At = new Jt(_t, St, x); var It = new Kt(); const Rt = new Zt(_t, St, At, It, Ct, x, this.info); var Nt = new Yt(_t, It, this.info); var Ft = new qt(this, Ct); const Ut = new Lt(); this.info.programs = Ft.programs; let zt; let Bt; let jt; let Vt; const Gt = new Ot(_t, St, wt); const Ht = new Dt(_t, St, wt); e(), this.context = _t, this.capabilities = Ct, this.extensions = St, this.properties = It, this.state = At; const Wt = new et(this, xt, Nt, Ct); this.shadowMap = Wt; const Xt = new W(this, I); const ne = new H(this, R); this.getContext = function () { return _t }, this.getContextAttributes = function () { return _t.getContextAttributes() }, this.forceContextLoss = function () { St.get('WEBGL_lose_context').loseContext() }, this.getMaxAnisotropy = function () { return Ct.getMaxAnisotropy() }, this.getPrecision = function () { return Ct.precision }, this.getPixelRatio = function () { return ot }, this.setPixelRatio = function (t) { void 0 !== t && (ot = t, this.setSize(ut.z, ut.w, !1)) }, this.getSize = function () { return { width: rt, height: at } }, this.setSize = function (t, e, n) { rt = t, at = e, w.width = t * ot, w.height = e * ot, !1 !== n && (w.style.width = t + 'px', w.style.height = e + 'px'), this.setViewport(0, 0, t, e) }, this.setViewport = function (t, e, n, i) { At.viewport(ut.set(t, e, n, i)) }, this.setScissor = function (t, e, n, i) { At.scissor(st.set(t, e, n, i)) }, this.setScissorTest = function (t) { At.setScissorTest(lt = t) }, this.getClearColor = function () { return nt }, this.setClearColor = function (t, e) { nt.set(t), it = void 0 !== e ? e : 1, At.buffers.color.setClear(nt.r, nt.g, nt.b, it, C) }, this.getClearAlpha = function () { return it }, this.setClearAlpha = function (t) { it = t, At.buffers.color.setClear(nt.r, nt.g, nt.b, it, C) }, this.clear = function (t, e, n) { let i = 0; (void 0 === t || t) && (i |= _t.COLOR_BUFFER_BIT), (void 0 === e || e) && (i |= _t.DEPTH_BUFFER_BIT), (void 0 === n || n) && (i |= _t.STENCIL_BUFFER_BIT), _t.clear(i) }, this.clearColor = function () { this.clear(!0, !1, !1) }, this.clearDepth = function () { this.clear(!1, !0, !1) }, this.clearStencil = function () { this.clear(!1, !1, !0) }, this.clearTarget = function (t, e, n, i) { this.setRenderTarget(t), this.clear(e, n, i) }, this.resetGLState = n, this.dispose = function () { D = [], O = -1, P = [], k = -1, w.removeEventListener('webglcontextlost', i, !1) }, this.renderBufferImmediate = function (t, e, n) { At.initAttributes(); const i = It.get(t); if (t.hasPositions && !i.position && (i.position = _t.createBuffer()), t.hasNormals && !i.normal && (i.normal = _t.createBuffer()), t.hasUvs && !i.uv && (i.uv = _t.createBuffer()), t.hasColors && !i.color && (i.color = _t.createBuffer()), e = e.getAttributes(), t.hasPositions && (_t.bindBuffer(_t.ARRAY_BUFFER, i.position), _t.bufferData(_t.ARRAY_BUFFER, t.positionArray, _t.DYNAMIC_DRAW), At.enableAttribute(e.position), _t.vertexAttribPointer(e.position, 3, _t.FLOAT, !1, 0, 0)), t.hasNormals) { if (_t.bindBuffer(_t.ARRAY_BUFFER, i.normal), !n.isMeshPhongMaterial && !n.isMeshStandardMaterial && !n.isMeshNormalMaterial && n.shading === 1) for (let r = 0, a = 3 * t.count; r < a; r += 9) { const o = t.normalArray; const s = (o[r + 0] + o[r + 3] + o[r + 6]) / 3; const l = (o[r + 1] + o[r + 4] + o[r + 7]) / 3; const c = (o[r + 2] + o[r + 5] + o[r + 8]) / 3; o[r + 0] = s, o[r + 1] = l, o[r + 2] = c, o[r + 3] = s, o[r + 4] = l, o[r + 5] = c, o[r + 6] = s, o[r + 7] = l, o[r + 8] = c }_t.bufferData(_t.ARRAY_BUFFER, t.normalArray, _t.DYNAMIC_DRAW), At.enableAttribute(e.normal), _t.vertexAttribPointer(e.normal, 3, _t.FLOAT, !1, 0, 0) }t.hasUvs && n.map && (_t.bindBuffer(_t.ARRAY_BUFFER, i.uv), _t.bufferData(_t.ARRAY_BUFFER, t.uvArray, _t.DYNAMIC_DRAW), At.enableAttribute(e.uv), _t.vertexAttribPointer(e.uv, 2, _t.FLOAT, !1, 0, 0)), t.hasColors && n.vertexColors !== 0 && (_t.bindBuffer(_t.ARRAY_BUFFER, i.color), _t.bufferData(_t.ARRAY_BUFFER, t.colorArray, _t.DYNAMIC_DRAW), At.enableAttribute(e.color), _t.vertexAttribPointer(e.color, 3, _t.FLOAT, !1, 0, 0)), At.disableUnusedAttributes(), _t.drawArrays(_t.TRIANGLES, 0, t.count), t.count = 0 }, this.renderBufferDirect = function (t, e, n, i, r, a) { g(i); var o = v(t, e, i, r); var l = !1; if (t = n.id + '_' + o.id + '_' + i.wireframe, t !== G && (G = t, l = !0), void 0 !== (e = r.morphTargetInfluences)) { var c = []; t = 0; for (var u = e.length; t < u; t++)l = e[t], c.push([l, t]); c.sort(s), c.length > 8 && (c.length = 8); var h = n.morphAttributes; for (t = 0, u = c.length; t < u; t++)l = c[t], L[t] = l[0], l[0] !== 0 ? (e = l[1], !0 === i.morphTargets && h.position && n.addAttribute('morphTarget' + t, h.position[e]), !0 === i.morphNormals && h.normal && n.addAttribute('morphNormal' + t, h.normal[e])) : (!0 === i.morphTargets && n.removeAttribute('morphTarget' + t), !0 === i.morphNormals && n.removeAttribute('morphNormal' + t)); for (t = c.length, e = L.length; t < e; t++)L[t] = 0; o.getUniforms().setValue(_t, 'morphTargetInfluences', L), l = !0 } if (e = n.index, u = n.attributes.position, c = 1, !0 === i.wireframe && (e = Nt.getWireframeAttribute(n), c = 2), e !== null ? (t = Ht, t.setIndex(e)) : t = Gt, l) { var p; var l = void 0; if (!n || !n.isInstancedBufferGeometry || (p = St.get('ANGLE_instanced_arrays')) !== null) { void 0 === l && (l = 0), At.initAttributes(); var d; var h = n.attributes; var o = o.getAttributes(); const f = i.defaultAttributeValues; for (d in o) { const m = o[d]; if (m >= 0) { var y = h[d]; if (void 0 !== y) { var b = y.normalized; const x = y.itemSize; var w = Nt.getAttributeProperties(y); const _ = w.__webglBuffer; const $ = w.type; var w = w.bytesPerElement; if (y.isInterleavedBufferAttribute) { const T = y.data; const S = T.stride; var y = y.offset; T && T.isInstancedInterleavedBuffer ? (At.enableAttributeAndDivisor(m, T.meshPerAttribute, p), void 0 === n.maxInstancedCount && (n.maxInstancedCount = T.meshPerAttribute * T.count)) : At.enableAttribute(m), _t.bindBuffer(_t.ARRAY_BUFFER, _), _t.vertexAttribPointer(m, x, $, b, S * w, (l * S + y) * w) } else y.isInstancedBufferAttribute ? (At.enableAttributeAndDivisor(m, y.meshPerAttribute, p), void 0 === n.maxInstancedCount && (n.maxInstancedCount = y.meshPerAttribute * y.count)) : At.enableAttribute(m), _t.bindBuffer(_t.ARRAY_BUFFER, _), _t.vertexAttribPointer(m, x, $, b, 0, l * x * w) } else if (void 0 !== f && void 0 !== (b = f[d])) switch (b.length) { case 2:_t.vertexAttrib2fv(m, b); break; case 3:_t.vertexAttrib3fv(m, b); break; case 4:_t.vertexAttrib4fv(m, b); break; default:_t.vertexAttrib1fv(m, b) } } }At.disableUnusedAttributes() }e !== null && _t.bindBuffer(_t.ELEMENT_ARRAY_BUFFER, Nt.getAttributeBuffer(e)) } if (p = 0, e !== null ? p = e.count : void 0 !== u && (p = u.count), e = n.drawRange.start * c, u = a !== null ? a.start * c : 0, d = Math.max(e, u), (a = Math.max(0, Math.min(p, e + n.drawRange.count * c, u + (a !== null ? a.count * c : 1 / 0)) - 1 - d + 1)) !== 0) { if (r.isMesh) if (!0 === i.wireframe)At.setLineWidth(i.wireframeLinewidth * (U === null ? ot : 1)), t.setMode(_t.LINES); else switch (r.drawMode) { case 0:t.setMode(_t.TRIANGLES); break; case 1:t.setMode(_t.TRIANGLE_STRIP); break; case 2:t.setMode(_t.TRIANGLE_FAN) } else r.isLine ? (i = i.linewidth, void 0 === i && (i = 1), At.setLineWidth(i * (U === null ? ot : 1)), r.isLineSegments ? t.setMode(_t.LINES) : t.setMode(_t.LINE_STRIP)) : r.isPoints && t.setMode(_t.POINTS); n && n.isInstancedBufferGeometry ? n.maxInstancedCount > 0 && t.renderInstances(n, d, a) : t.render(d, a) } }, this.render = function (t, e, n, i) { if (void 0 !== e && !0 !== e.isCamera);else { G = '', V = -1, q = null, !0 === t.autoUpdate && t.updateMatrixWorld(), e.parent === null && e.updateMatrixWorld(), e.matrixWorldInverse.getInverse(e.matrixWorld), gt.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), ht.setFromMatrix(gt), A.length = 0, O = k = -1, I.length = 0, R.length = 0, ft = this.localClippingEnabled, dt = pt.init(this.clippingPlanes, ft, e), f(t, e), P.length = k + 1, D.length = O + 1, !0 === N.sortObjects && (P.sort(u), D.sort(h)), dt && pt.beginShadows(); for (var r = A, a = 0, o = 0, s = r.length; o < s; o++) { var l = r[o]; l.castShadow && (xt.shadows[a++] = l) }xt.shadows.length = a, Wt.render(t, e); for (var p, d, g, v, r = A, y = l = 0, b = 0, x = e.matrixWorldInverse, w = 0, _ = 0, $ = 0, T = 0, S = 0, a = 0, o = r.length; a < o; a++) if (s = r[a], p = s.color, d = s.intensity, g = s.distance, v = s.shadow && s.shadow.map ? s.shadow.map.texture : null, s.isAmbientLight)l += p.r * d, y += p.g * d, b += p.b * d; else if (s.isDirectionalLight) { var M = Ut.get(s); M.color.copy(s.color).multiplyScalar(s.intensity), M.direction.setFromMatrixPosition(s.matrixWorld), vt.setFromMatrixPosition(s.target.matrixWorld), M.direction.sub(vt), M.direction.transformDirection(x), (M.shadow = s.castShadow) && (M.shadowBias = s.shadow.bias, M.shadowRadius = s.shadow.radius, M.shadowMapSize = s.shadow.mapSize), xt.directionalShadowMap[w] = v, xt.directionalShadowMatrix[w] = s.shadow.matrix, xt.directional[w++] = M } else s.isSpotLight ? (M = Ut.get(s), M.position.setFromMatrixPosition(s.matrixWorld), M.position.applyMatrix4(x), M.color.copy(p).multiplyScalar(d), M.distance = g, M.direction.setFromMatrixPosition(s.matrixWorld), vt.setFromMatrixPosition(s.target.matrixWorld), M.direction.sub(vt), M.direction.transformDirection(x), M.coneCos = Math.cos(s.angle), M.penumbraCos = Math.cos(s.angle * (1 - s.penumbra)), M.decay = s.distance === 0 ? 0 : s.decay, (M.shadow = s.castShadow) && (M.shadowBias = s.shadow.bias, M.shadowRadius = s.shadow.radius, M.shadowMapSize = s.shadow.mapSize), xt.spotShadowMap[$] = v, xt.spotShadowMatrix[$] = s.shadow.matrix, xt.spot[$++] = M) : s.isRectAreaLight ? (M = Ut.get(s), M.color.copy(p).multiplyScalar(d / (s.width * s.height)), M.position.setFromMatrixPosition(s.matrixWorld), M.position.applyMatrix4(x), bt.identity(), yt.copy(s.matrixWorld), yt.premultiply(x), bt.extractRotation(yt), M.halfWidth.set(0.5 * s.width, 0, 0), M.halfHeight.set(0, 0.5 * s.height, 0), M.halfWidth.applyMatrix4(bt), M.halfHeight.applyMatrix4(bt), xt.rectArea[T++] = M) : s.isPointLight ? (M = Ut.get(s), M.position.setFromMatrixPosition(s.matrixWorld), M.position.applyMatrix4(x), M.color.copy(s.color).multiplyScalar(s.intensity), M.distance = s.distance, M.decay = s.distance === 0 ? 0 : s.decay, (M.shadow = s.castShadow) && (M.shadowBias = s.shadow.bias, M.shadowRadius = s.shadow.radius, M.shadowMapSize = s.shadow.mapSize), xt.pointShadowMap[_] = v, void 0 === xt.pointShadowMatrix[_] && (xt.pointShadowMatrix[_] = new c()), vt.setFromMatrixPosition(s.matrixWorld).negate(), xt.pointShadowMatrix[_].identity().setPosition(vt), xt.point[_++] = M) : s.isHemisphereLight && (M = Ut.get(s), M.direction.setFromMatrixPosition(s.matrixWorld), M.direction.transformDirection(x), M.direction.normalize(), M.skyColor.copy(s.color).multiplyScalar(d), M.groundColor.copy(s.groundColor).multiplyScalar(d), xt.hemi[S++] = M); xt.ambient[0] = l, xt.ambient[1] = y, xt.ambient[2] = b, xt.directional.length = w, xt.spot.length = $, xt.rectArea.length = T, xt.point.length = _, xt.hemi.length = S, xt.hash = w + ',' + _ + ',' + $ + ',' + T + ',' + S + ',' + xt.shadows.length, dt && pt.endShadows(), wt.calls = 0, wt.vertices = 0, wt.faces = 0, wt.points = 0, void 0 === n && (n = null), this.setRenderTarget(n), r = t.background, r === null ? At.buffers.color.setClear(nt.r, nt.g, nt.b, it, C) : r && r.isColor && (At.buffers.color.setClear(r.r, r.g, r.b, 1, C), i = !0), (this.autoClear || i) && this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil), r && r.isCubeTexture ? (void 0 === jt && (jt = new Pt(), Vt = new Tt(new Mt(5, 5, 5), new X({ uniforms: br.cube.uniforms, vertexShader: br.cube.vertexShader, fragmentShader: br.cube.fragmentShader, side: 1, depthTest: !1, depthWrite: !1, fog: !1 }))), jt.projectionMatrix.copy(e.projectionMatrix), jt.matrixWorld.extractRotation(e.matrixWorld), jt.matrixWorldInverse.getInverse(jt.matrixWorld), Vt.material.uniforms.tCube.value = r, Vt.modelViewMatrix.multiplyMatrices(jt.matrixWorldInverse, Vt.matrixWorld), Nt.update(Vt), N.renderBufferDirect(jt, null, Vt.geometry, Vt.material, Vt, null)) : r && r.isTexture && (void 0 === zt && (zt = new kt(-1, 1, 1, -1, 0, 1), Bt = new Tt(new Et(2, 2), new ct({ depthTest: !1, depthWrite: !1, fog: !1 }))), Bt.material.map = r, Nt.update(Bt), N.renderBufferDirect(zt, null, Bt.geometry, Bt.material, Bt, null)), t.overrideMaterial ? (i = t.overrideMaterial, m(P, t, e, i), m(D, t, e, i)) : (At.setBlending(0), m(P, t, e), m(D, t, e)), Xt.render(t, e), ne.render(t, e, J), n && Rt.updateRenderTargetMipmap(n), At.setDepthTest(!0), At.setDepthWrite(!0), At.setColorWrite(!0) } }, this.setFaceCulling = function (t, e) { At.setCullFace(t), At.setFlipSided(e === 0) }, this.allocTextureUnit = function () { const t = Q; return Ct.maxTextures, Q += 1, t }, this.setTexture2D = (function () { let t = !1; return function (e, n) { e && e.isWebGLRenderTarget && (t || (t = !0), e = e.texture), Rt.setTexture2D(e, n) } }()), this.setTexture = (function () { let t = !1; return function (e, n) { t || (t = !0), Rt.setTexture2D(e, n) } }()), this.setTextureCube = (function () { let t = !1; return function (e, n) { e && e.isWebGLRenderTargetCube && (t || (t = !0), e = e.texture), e && e.isCubeTexture || Array.isArray(e.image) && e.image.length === 6 ? Rt.setTextureCube(e, n) : Rt.setTextureCubeDynamic(e, n) } }()), this.getCurrentRenderTarget = function () { return U }, this.setRenderTarget = function (t) { (U = t) && void 0 === It.get(t).__webglFramebuffer && Rt.setupRenderTarget(t); let e; let n = t && t.isWebGLRenderTargetCube; t ? (e = It.get(t), e = n ? e.__webglFramebuffer[t.activeCubeFace] : e.__webglFramebuffer, Y.copy(t.scissor), Z = t.scissorTest, J.copy(t.viewport)) : (e = null, Y.copy(st).multiplyScalar(ot), Z = lt, J.copy(ut).multiplyScalar(ot)), z !== e && (_t.bindFramebuffer(_t.FRAMEBUFFER, e), z = e), At.scissor(Y), At.setScissorTest(Z), At.viewport(J), n && (n = It.get(t.texture), _t.framebufferTexture2D(_t.FRAMEBUFFER, _t.COLOR_ATTACHMENT0, _t.TEXTURE_CUBE_MAP_POSITIVE_X + t.activeCubeFace, n.__webglTexture, t.activeMipMapLevel)) }, this.readRenderTargetPixels = function (t, e, n, i, r, a) { if (!1 === (t && t.isWebGLRenderTarget));else { const o = It.get(t).__webglFramebuffer; if (o) { let s = !1; o !== z && (_t.bindFramebuffer(_t.FRAMEBUFFER, o), s = !0); try { const l = t.texture; const c = l.format; const u = l.type; c !== 1023 && x(c) !== _t.getParameter(_t.IMPLEMENTATION_COLOR_READ_FORMAT) || (u === 1009 || x(u) === _t.getParameter(_t.IMPLEMENTATION_COLOR_READ_TYPE) || u === 1015 && (St.get('OES_texture_float') || St.get('WEBGL_color_buffer_float')) || u === 1016 && St.get('EXT_color_buffer_half_float')) && _t.checkFramebufferStatus(_t.FRAMEBUFFER) === _t.FRAMEBUFFER_COMPLETE && e >= 0 && e <= t.width - i && n >= 0 && n <= t.height - r && _t.readPixels(e, n, i, r, x(c), x(u), a) } finally { s && _t.bindFramebuffer(_t.FRAMEBUFFER, z) } } } }
  } function ie (t, e) { this.name = '', this.color = new j(t), this.density = void 0 !== e ? e : 25e-5 } function re (t, e, n) { this.name = '', this.color = new j(t), this.near = void 0 !== e ? e : 1, this.far = void 0 !== n ? n : 1e3 } function ae () { at.call(this), this.type = 'Scene', this.overrideMaterial = this.fog = this.background = null, this.autoUpdate = !0 } function oe (t, e, n, i, r) { at.call(this), this.lensFlares = [], this.positionScreen = new l(), this.customUpdateCallback = void 0, void 0 !== t && this.add(t, e, n, i, r) } function se (t) { q.call(this), this.type = 'SpriteMaterial', this.color = new j(16777215), this.map = null, this.rotation = 0, this.lights = this.fog = !1, this.setValues(t) } function le (t) { at.call(this), this.type = 'Sprite', this.material = void 0 !== t ? t : new se() } function ce () { at.call(this), this.type = 'LOD', Object.defineProperties(this, { levels: { enumerable: !0, value: [] } }) } function ue (t, e, n) { if (this.useVertexTexture = void 0 === n || n, this.identityMatrix = new c(), t = t || [], this.bones = t.slice(0), this.useVertexTexture ? (t = Math.sqrt(4 * this.bones.length), t = lr.nextPowerOfTwo(Math.ceil(t)), this.boneTextureHeight = this.boneTextureWidth = t = Math.max(t, 4), this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4), this.boneTexture = new V(this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, 1023, 1015)) : this.boneMatrices = new Float32Array(16 * this.bones.length), void 0 === e) this.calculateInverses(); else if (this.bones.length === e.length) this.boneInverses = e.slice(0); else for (this.boneInverses = [], e = 0, t = this.bones.length; e < t; e++) this.boneInverses.push(new c()) } function he () { at.call(this), this.type = 'Bone' } function pe (t, e, n) { if (Tt.call(this, t, e), this.type = 'SkinnedMesh', this.bindMode = 'attached', this.bindMatrix = new c(), this.bindMatrixInverse = new c(), t = [], this.geometry && void 0 !== this.geometry.bones) { for (var i, r = 0, a = this.geometry.bones.length; r < a; ++r)i = this.geometry.bones[r], e = new he(), t.push(e), e.name = i.name, e.position.fromArray(i.pos), e.quaternion.fromArray(i.rotq), void 0 !== i.scl && e.scale.fromArray(i.scl); for (r = 0, a = this.geometry.bones.length; r < a; ++r)i = this.geometry.bones[r], i.parent !== -1 && i.parent !== null && void 0 !== t[i.parent] ? t[i.parent].add(t[r]) : this.add(t[r]) } this.normalizeSkinWeights(), this.updateMatrixWorld(!0), this.bind(new ue(t, void 0, n), this.matrixWorld) } function de (t) { q.call(this), this.type = 'LineBasicMaterial', this.color = new j(16777215), this.linewidth = 1, this.linejoin = this.linecap = 'round', this.lights = !1, this.setValues(t) } function fe (t, e, n) { if (n === 1) return new me(t, e); at.call(this), this.type = 'Line', this.geometry = void 0 !== t ? t : new $t(), this.material = void 0 !== e ? e : new de({ color: 16777215 * Math.random() }) } function me (t, e) { fe.call(this, t, e), this.type = 'LineSegments' } function ge (t) { q.call(this), this.type = 'PointsMaterial', this.color = new j(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.lights = !1, this.setValues(t) } function ve (t, e) { at.call(this), this.type = 'Points', this.geometry = void 0 !== t ? t : new $t(), this.material = void 0 !== e ? e : new ge({ color: 16777215 * Math.random() }) } function ye () { at.call(this), this.type = 'Group' } function be (t, e, n, r, a, o, s, l, c) { function u () { requestAnimationFrame(u), t.readyState >= t.HAVE_CURRENT_DATA && (h.needsUpdate = !0) }i.call(this, t, e, n, r, a, o, s, l, c), this.generateMipmaps = !1; var h = this; u() } function xe (t, e, n, r, a, o, s, l, c, u, h, p) { i.call(this, null, o, s, l, c, u, r, a, h, p), this.image = { width: e, height: n }, this.mipmaps = t, this.generateMipmaps = this.flipY = !1 } function we (t, e, n, r, a, o, s, l, c) { i.call(this, t, e, n, r, a, o, s, l, c), this.needsUpdate = !0 } function _e (t, e, n, r, a, o, s, l, c, u) { if ((u = void 0 !== u ? u : 1026) !== 1026 && u !== 1027) throw Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat'); void 0 === n && u === 1026 && (n = 1012), void 0 === n && u === 1027 && (n = 1020), i.call(this, null, r, a, o, s, l, u, n, c), this.image = { width: t, height: e }, this.magFilter = void 0 !== s ? s : 1003, this.minFilter = void 0 !== l ? l : 1003, this.generateMipmaps = this.flipY = !1 } function $e (t) { function e (t, e) { return t - e }$t.call(this), this.type = 'WireframeGeometry'; let n; let i; let r; let a; let o; const s = []; const c = [0, 0]; let u = {}; var h = ['a', 'b', 'c']; if (t && t.isGeometry) { var p = t.faces; for (n = 0, r = p.length; n < r; n++) { var d = p[n]; for (i = 0; i < 3; i++)c[0] = d[h[i]], c[1] = d[h[(i + 1) % 3]], c.sort(e), o = c.toString(), void 0 === u[o] && (u[o] = { index1: c[0], index2: c[1] }) } for (o in u)n = u[o], h = t.vertices[n.index1], s.push(h.x, h.y, h.z), h = t.vertices[n.index2], s.push(h.x, h.y, h.z) } else if (t && t.isBufferGeometry) { let f; var h = new l(); if (t.index !== null) { for (p = t.attributes.position, d = t.index, f = t.groups, f.length === 0 && t.addGroup(0, d.count), t = 0, a = f.length; t < a; ++t) for (n = f[t], i = n.start, r = n.count, n = i, r = i + r; n < r; n += 3) for (i = 0; i < 3; i++)c[0] = d.getX(n + i), c[1] = d.getX(n + (i + 1) % 3), c.sort(e), o = c.toString(), void 0 === u[o] && (u[o] = { index1: c[0], index2: c[1] }); for (o in u)n = u[o], h.fromBufferAttribute(p, n.index1), s.push(h.x, h.y, h.z), h.fromBufferAttribute(p, n.index2), s.push(h.x, h.y, h.z) } else for (p = t.attributes.position, n = 0, r = p.count / 3; n < r; n++) for (i = 0; i < 3; i++)u = 3 * n + i, h.fromBufferAttribute(p, u), s.push(h.x, h.y, h.z), u = 3 * n + (i + 1) % 3, h.fromBufferAttribute(p, u), s.push(h.x, h.y, h.z) } this.addAttribute('position', new yt(s, 3)) } function Te (t, e, n) { _t.call(this), this.type = 'ParametricGeometry', this.parameters = { func: t, slices: e, stacks: n }, this.fromBufferGeometry(new Se(t, e, n)), this.mergeVertices() } function Se (t, e, n) { $t.call(this), this.type = 'ParametricBufferGeometry', this.parameters = { func: t, slices: e, stacks: n }; let i; let r; const a = []; const o = []; const s = []; const l = e + 1; for (i = 0; i <= n; i++) { var c = i / n; for (r = 0; r <= e; r++) { var u = r / e; const h = t(u, c); o.push(h.x, h.y, h.z), s.push(u, c) } } for (i = 0; i < n; i++) for (r = 0; r < e; r++)t = i * l + r + 1, c = (i + 1) * l + r + 1, u = (i + 1) * l + r, a.push(i * l + r, t, u), a.push(t, c, u); this.setIndex(a), this.addAttribute('position', new yt(o, 3)), this.addAttribute('uv', new yt(s, 2)), this.computeVertexNormals() } function Me (t, e, n, i) { _t.call(this), this.type = 'PolyhedronGeometry', this.parameters = { vertices: t, indices: e, radius: n, detail: i }, this.fromBufferGeometry(new Ce(t, e, n, i)), this.mergeVertices() } function Ce (t, e, i, r) {
    function a (t) { c.push(t.x, t.y, t.z) } function o (e, n) { const i = 3 * e; n.x = t[i + 0], n.y = t[i + 1], n.z = t[i + 2] } function s (t, e, n, i) { i < 0 && t.x === 1 && (u[e] = t.x - 1), n.x === 0 && n.z === 0 && (u[e] = i / 2 / Math.PI + 0.5) }$t.call(this), this.type = 'PolyhedronBufferGeometry', this.parameters = { vertices: t, indices: e, radius: i, detail: r }, i = i || 1; var c = []; var u = []; !(function (t) { for (let n = new l(), i = new l(), r = new l(), s = 0; s < e.length; s += 3) { o(e[s + 0], n), o(e[s + 1], i), o(e[s + 2], r); var c; var u; let h = n; const p = i; const d = r; const f = Math.pow(2, t); const m = []; for (c = 0; c <= f; c++) { m[c] = []; const g = h.clone().lerp(d, c / f); const v = p.clone().lerp(d, c / f); const y = f - c; for (u = 0; u <= y; u++)m[c][u] = u === 0 && c === f ? g : g.clone().lerp(v, u / y) } for (c = 0; c < f; c++) for (u = 0; u < 2 * (f - c) - 1; u++)h = Math.floor(u / 2), u % 2 == 0 ? (a(m[c][h + 1]), a(m[c + 1][h]), a(m[c][h])) : (a(m[c][h + 1]), a(m[c + 1][h + 1]), a(m[c + 1][h])) } }(r || 0)), (function (t) { for (let e = new l(), n = 0; n < c.length; n += 3)e.x = c[n + 0], e.y = c[n + 1], e.z = c[n + 2], e.normalize().multiplyScalar(t), c[n + 0] = e.x, c[n + 1] = e.y, c[n + 2] = e.z }(i)), (function () { for (var t = new l(), e = 0; e < c.length; e += 3)t.x = c[e + 0], t.y = c[e + 1], t.z = c[e + 2], u.push(Math.atan2(t.z, -t.x) / 2 / Math.PI + 0.5, 1 - (Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z)) / Math.PI + 0.5)); for (var t = new l(), e = new l(), i = new l(), r = new l(), a = new n(), o = new n(), h = new n(), p = 0, d = 0; p < c.length; p += 9, d += 6) { t.set(c[p + 0], c[p + 1], c[p + 2]), e.set(c[p + 3], c[p + 4], c[p + 5]), i.set(c[p + 6], c[p + 7], c[p + 8]), a.set(u[d + 0], u[d + 1]), o.set(u[d + 2], u[d + 3]), h.set(u[d + 4], u[d + 5]), r.copy(t).add(e).add(i).divideScalar(3); const f = Math.atan2(r.z, -r.x); s(a, d + 0, t, f), s(o, d + 2, e, f), s(h, d + 4, i, f) } for (t = 0; t < u.length; t += 6)e = u[t + 0], i = u[t + 2], r = u[t + 4], a = Math.min(e, i, r), Math.max(e, i, r) > 0.9 && a < 0.1 && (e < 0.2 && (u[t + 0] += 1), i < 0.2 && (u[t + 2] += 1), r < 0.2 && (u[t + 4] += 1)) }()),
    this.addAttribute('position', new yt(c, 3)), this.addAttribute('normal', new yt(c.slice(), 3)), this.addAttribute('uv', new yt(u, 2)), this.normalizeNormals()
  } function Ee (t, e) { _t.call(this), this.type = 'TetrahedronGeometry', this.parameters = { radius: t, detail: e }, this.fromBufferGeometry(new Ae(t, e)), this.mergeVertices() } function Ae (t, e) { Ce.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t, e), this.type = 'TetrahedronBufferGeometry', this.parameters = { radius: t, detail: e } } function Pe (t, e) { _t.call(this), this.type = 'OctahedronGeometry', this.parameters = { radius: t, detail: e }, this.fromBufferGeometry(new ke(t, e)), this.mergeVertices() } function ke (t, e) { Ce.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t, e), this.type = 'OctahedronBufferGeometry', this.parameters = { radius: t, detail: e } } function De (t, e) { _t.call(this), this.type = 'IcosahedronGeometry', this.parameters = { radius: t, detail: e }, this.fromBufferGeometry(new Oe(t, e)), this.mergeVertices() } function Oe (t, e) { const n = (1 + Math.sqrt(5)) / 2; Ce.call(this, [-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t, e), this.type = 'IcosahedronBufferGeometry', this.parameters = { radius: t, detail: e } } function Le (t, e) { _t.call(this), this.type = 'DodecahedronGeometry', this.parameters = { radius: t, detail: e }, this.fromBufferGeometry(new Ie(t, e)), this.mergeVertices() } function Ie (t, e) { const n = (1 + Math.sqrt(5)) / 2; const i = 1 / n; Ce.call(this, [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, 0, -n, 0, -i, n, 0, -i, -n, 0, i, n, 0, i], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], t, e), this.type = 'DodecahedronBufferGeometry', this.parameters = { radius: t, detail: e } } function Re (t, e, n, i, r, a) { _t.call(this), this.type = 'TubeGeometry', this.parameters = { path: t, tubularSegments: e, radius: n, radialSegments: i, closed: r }, t = new Ne(t, e, n, i, r), this.tangents = t.tangents, this.normals = t.normals, this.binormals = t.binormals, this.fromBufferGeometry(t), this.mergeVertices() } function Ne (t, e, i, r, a) { function o (n) { const a = t.getPointAt(n / e); const o = s.normals[n]; for (n = s.binormals[n], u = 0; u <= r; u++) { var l = u / r * Math.PI * 2; const c = Math.sin(l); var l = -Math.cos(l); p.x = l * o.x + c * n.x, p.y = l * o.y + c * n.y, p.z = l * o.z + c * n.z, p.normalize(), m.push(p.x, p.y, p.z), h.x = a.x + i * p.x, h.y = a.y + i * p.y, h.z = a.z + i * p.z, f.push(h.x, h.y, h.z) } }$t.call(this), this.type = 'TubeBufferGeometry', this.parameters = { path: t, tubularSegments: e, radius: i, radialSegments: r, closed: a }, e = e || 64, i = i || 1, r = r || 8, a = a || !1; var s = t.computeFrenetFrames(e, a); this.tangents = s.tangents, this.normals = s.normals, this.binormals = s.binormals; let c; let u; var h = new l(); var p = new l(); const d = new n(); var f = []; var m = []; const g = []; const v = []; for (c = 0; c < e; c++)o(c); for (o(!1 === a ? e : 0), c = 0; c <= e; c++) for (u = 0; u <= r; u++)d.x = c / e, d.y = u / r, g.push(d.x, d.y); !(function () { for (u = 1; u <= e; u++) for (c = 1; c <= r; c++) { const t = (r + 1) * u + (c - 1); const n = (r + 1) * u + c; const i = (r + 1) * (u - 1) + c; v.push((r + 1) * (u - 1) + (c - 1), t, i), v.push(t, n, i) } }()), this.setIndex(v), this.addAttribute('position', new yt(f, 3)), this.addAttribute('normal', new yt(m, 3)), this.addAttribute('uv', new yt(g, 2)) } function Fe (t, e, n, i, r, a, o) { _t.call(this), this.type = 'TorusKnotGeometry', this.parameters = { radius: t, tube: e, tubularSegments: n, radialSegments: i, p: r, q: a }, this.fromBufferGeometry(new Ue(t, e, n, i, r, a)), this.mergeVertices() } function Ue (t, e, i, r, a, o) { function s (t, e, n, i, r) { const a = Math.sin(t); e = n / e * t, n = Math.cos(e), r.x = i * (2 + n) * 0.5 * Math.cos(t), r.y = i * (2 + n) * a * 0.5, r.z = i * Math.sin(e) * 0.5 }$t.call(this), this.type = 'TorusKnotBufferGeometry', this.parameters = { radius: t, tube: e, tubularSegments: i, radialSegments: r, p: a, q: o }, t = t || 100, e = e || 40, i = Math.floor(i) || 64, r = Math.floor(r) || 8, a = a || 2, o = o || 3; let c; let u; const h = []; const p = []; const d = []; const f = []; const m = new l(); const g = new l(); new n(); const v = new l(); const y = new l(); const b = new l(); const x = new l(); const w = new l(); for (c = 0; c <= i; ++c) for (u = c / i * a * Math.PI * 2, s(u, a, o, t, v), s(u + 0.01, a, o, t, y), x.subVectors(y, v), w.addVectors(y, v), b.crossVectors(x, w), w.crossVectors(b, x), b.normalize(), w.normalize(), u = 0; u <= r; ++u) { var _ = u / r * Math.PI * 2; const $ = -e * Math.cos(_); var _ = e * Math.sin(_); m.x = v.x + ($ * w.x + _ * b.x), m.y = v.y + ($ * w.y + _ * b.y), m.z = v.z + ($ * w.z + _ * b.z), p.push(m.x, m.y, m.z), g.subVectors(m, v).normalize(), d.push(g.x, g.y, g.z), f.push(c / i), f.push(u / r) } for (u = 1; u <= i; u++) for (c = 1; c <= r; c++)t = (r + 1) * u + (c - 1), e = (r + 1) * u + c, a = (r + 1) * (u - 1) + c, h.push((r + 1) * (u - 1) + (c - 1), t, a), h.push(t, e, a); this.setIndex(h), this.addAttribute('position', new yt(p, 3)), this.addAttribute('normal', new yt(d, 3)), this.addAttribute('uv', new yt(f, 2)) } function ze (t, e, n, i, r) { _t.call(this), this.type = 'TorusGeometry', this.parameters = { radius: t, tube: e, radialSegments: n, tubularSegments: i, arc: r }, this.fromBufferGeometry(new Be(t, e, n, i, r)) } function Be (t, e, n, i, r) { $t.call(this), this.type = 'TorusBufferGeometry', this.parameters = { radius: t, tube: e, radialSegments: n, tubularSegments: i, arc: r }, t = t || 100, e = e || 40, n = Math.floor(n) || 8, i = Math.floor(i) || 6, r = r || 2 * Math.PI; let a; let o; const s = []; const c = []; const u = []; const h = []; const p = new l(); const d = new l(); const f = new l(); for (a = 0; a <= n; a++) for (o = 0; o <= i; o++) { const m = o / i * r; const g = a / n * Math.PI * 2; d.x = (t + e * Math.cos(g)) * Math.cos(m), d.y = (t + e * Math.cos(g)) * Math.sin(m), d.z = e * Math.sin(g), c.push(d.x, d.y, d.z), p.x = t * Math.cos(m), p.y = t * Math.sin(m), f.subVectors(d, p).normalize(), u.push(f.x, f.y, f.z), h.push(o / i), h.push(a / n) } for (a = 1; a <= n; a++) for (o = 1; o <= i; o++)t = (i + 1) * (a - 1) + o - 1, e = (i + 1) * (a - 1) + o, r = (i + 1) * a + o, s.push((i + 1) * a + o - 1, t, r), s.push(t, e, r); this.setIndex(s), this.addAttribute('position', new yt(c, 3)), this.addAttribute('normal', new yt(u, 3)), this.addAttribute('uv', new yt(h, 2)) } function je (t, e) { void 0 !== t && (_t.call(this), this.type = 'ExtrudeGeometry', t = Array.isArray(t) ? t : [t], this.addShapeList(t, e), this.computeFaceNormals()) } function Ve (t, e) { e = e || {}; let n = e.font; if (!1 === (n && n.isFont)) return new _t(); n = n.generateShapes(t, e.size, e.curveSegments), e.amount = void 0 !== e.height ? e.height : 50, void 0 === e.bevelThickness && (e.bevelThickness = 10), void 0 === e.bevelSize && (e.bevelSize = 8), void 0 === e.bevelEnabled && (e.bevelEnabled = !1), je.call(this, n, e), this.type = 'TextGeometry' } function Ge (t, e, n, i, r, a, o) { _t.call(this), this.type = 'SphereGeometry', this.parameters = { radius: t, widthSegments: e, heightSegments: n, phiStart: i, phiLength: r, thetaStart: a, thetaLength: o }, this.fromBufferGeometry(new He(t, e, n, i, r, a, o)) } function He (t, e, n, i, r, a, o) { $t.call(this), this.type = 'SphereBufferGeometry', this.parameters = { radius: t, widthSegments: e, heightSegments: n, phiStart: i, phiLength: r, thetaStart: a, thetaLength: o }, t = t || 50, e = Math.max(3, Math.floor(e) || 8), n = Math.max(2, Math.floor(n) || 6), i = void 0 !== i ? i : 0, r = void 0 !== r ? r : 2 * Math.PI, a = void 0 !== a ? a : 0, o = void 0 !== o ? o : Math.PI; let s; let c; const u = a + o; let h = 0; const p = []; const d = new l(); const f = new l(); const m = []; const g = []; const v = []; const y = []; for (c = 0; c <= n; c++) { const b = []; const x = c / n; for (s = 0; s <= e; s++) { const w = s / e; d.x = -t * Math.cos(i + w * r) * Math.sin(a + x * o), d.y = t * Math.cos(a + x * o), d.z = t * Math.sin(i + w * r) * Math.sin(a + x * o), g.push(d.x, d.y, d.z), f.set(d.x, d.y, d.z).normalize(), v.push(f.x, f.y, f.z), y.push(w, 1 - x), b.push(h++) }p.push(b) } for (c = 0; c < n; c++) for (s = 0; s < e; s++)t = p[c][s + 1], i = p[c][s], r = p[c + 1][s], o = p[c + 1][s + 1], (c !== 0 || a > 0) && m.push(t, i, o), (c !== n - 1 || u < Math.PI) && m.push(i, r, o); this.setIndex(m), this.addAttribute('position', new yt(g, 3)), this.addAttribute('normal', new yt(v, 3)), this.addAttribute('uv', new yt(y, 2)) } function We (t, e, n, i, r, a) { _t.call(this), this.type = 'RingGeometry', this.parameters = { innerRadius: t, outerRadius: e, thetaSegments: n, phiSegments: i, thetaStart: r, thetaLength: a }, this.fromBufferGeometry(new qe(t, e, n, i, r, a)) } function qe (t, e, i, r, a, o) { $t.call(this), this.type = 'RingBufferGeometry', this.parameters = { innerRadius: t, outerRadius: e, thetaSegments: i, phiSegments: r, thetaStart: a, thetaLength: o }, t = t || 20, e = e || 50, a = void 0 !== a ? a : 0, o = void 0 !== o ? o : 2 * Math.PI, i = void 0 !== i ? Math.max(3, i) : 8, r = void 0 !== r ? Math.max(1, r) : 1; let s; let c; const u = []; const h = []; const p = []; const d = []; let f = t; const m = (e - t) / r; const g = new l(); const v = new n(); for (s = 0; s <= r; s++) { for (c = 0; c <= i; c++)t = a + c / i * o, g.x = f * Math.cos(t), g.y = f * Math.sin(t), h.push(g.x, g.y, g.z), p.push(0, 0, 1), v.x = (g.x / e + 1) / 2, v.y = (g.y / e + 1) / 2, d.push(v.x, v.y); f += m } for (s = 0; s < r; s++) for (e = s * (i + 1), c = 0; c < i; c++)t = c + e, a = t + i + 1, o = t + i + 2, f = t + 1, u.push(t, a, f), u.push(a, o, f); this.setIndex(u), this.addAttribute('position', new yt(h, 3)), this.addAttribute('normal', new yt(p, 3)), this.addAttribute('uv', new yt(d, 2)) } function Xe (t, e, n, i) { _t.call(this), this.type = 'LatheGeometry', this.parameters = { points: t, segments: e, phiStart: n, phiLength: i }, this.fromBufferGeometry(new Ye(t, e, n, i)), this.mergeVertices() } function Ye (t, e, i, r) { $t.call(this), this.type = 'LatheBufferGeometry', this.parameters = { points: t, segments: e, phiStart: i, phiLength: r }, e = Math.floor(e) || 12, i = i || 0, r = r || 2 * Math.PI, r = lr.clamp(r, 0, 2 * Math.PI); let a; let o; let s = []; let c = []; let u = []; let h = 1 / e; let p = new l(); let d = new n(); for (a = 0; a <= e; a++) { o = i + a * h * r; const f = Math.sin(o); const m = Math.cos(o); for (o = 0; o <= t.length - 1; o++)p.x = t[o].x * f, p.y = t[o].y, p.z = t[o].x * m, c.push(p.x, p.y, p.z), d.x = a / e, d.y = o / (t.length - 1), u.push(d.x, d.y) } for (a = 0; a < e; a++) for (o = 0; o < t.length - 1; o++)i = o + a * t.length, h = i + t.length, p = i + t.length + 1, d = i + 1, s.push(i, h, d), s.push(h, p, d); if (this.setIndex(s), this.addAttribute('position', new yt(c, 3)), this.addAttribute('uv', new yt(u, 2)), this.computeVertexNormals(), r === 2 * Math.PI) for (r = this.attributes.normal.array, s = new l(), c = new l(), u = new l(), i = e * t.length * 3, o = a = 0; a < t.length; a++, o += 3)s.x = r[o + 0], s.y = r[o + 1], s.z = r[o + 2], c.x = r[i + o + 0], c.y = r[i + o + 1], c.z = r[i + o + 2], u.addVectors(s, c).normalize(), r[o + 0] = r[i + o + 0] = u.x, r[o + 1] = r[i + o + 1] = u.y, r[o + 2] = r[i + o + 2] = u.z } function Ze (t, e) { _t.call(this), this.type = 'ShapeGeometry', typeof e === 'object' && (e = e.curveSegments), this.parameters = { shapes: t, curveSegments: e }, this.fromBufferGeometry(new Ke(t, e)), this.mergeVertices() } function Ke (t, e) { function n (t) { let n; let s; const c = r.length / 3; t = t.extractPoints(e); let u = t.shape; const h = t.holes; if (!1 === Tr.isClockWise(u)) for (u = u.reverse(), t = 0, n = h.length; t < n; t++)s = h[t], !0 === Tr.isClockWise(s) && (h[t] = s.reverse()); const p = Tr.triangulateShape(u, h); for (t = 0, n = h.length; t < n; t++)s = h[t], u = u.concat(s); for (t = 0, n = u.length; t < n; t++)s = u[t], r.push(s.x, s.y, 0), a.push(0, 0, 1), o.push(s.x, s.y); for (t = 0, n = p.length; t < n; t++)u = p[t], i.push(u[0] + c, u[1] + c, u[2] + c), l += 3 }$t.call(this), this.type = 'ShapeBufferGeometry', this.parameters = { shapes: t, curveSegments: e }, e = e || 12; var i = []; var r = []; var a = []; var o = []; let s = 0; var l = 0; if (!1 === Array.isArray(t))n(t); else for (let c = 0; c < t.length; c++)n(t[c]), this.addGroup(s, l, c), s += l, l = 0; this.setIndex(i), this.addAttribute('position', new yt(r, 3)), this.addAttribute('normal', new yt(a, 3)), this.addAttribute('uv', new yt(o, 2)) } function Je (t, e) { function n (t, e) { return t - e }$t.call(this), this.type = 'EdgesGeometry', this.parameters = { thresholdAngle: e }; let i; let r; const a = []; const o = Math.cos(lr.DEG2RAD * (void 0 !== e ? e : 1)); let s = [0, 0]; const l = {}; let c = ['a', 'b', 'c']; t.isBufferGeometry ? (r = new _t(), r.fromBufferGeometry(t)) : r = t.clone(), r.mergeVertices(), r.computeFaceNormals(); const u = r.vertices; r = r.faces; for (let h = 0, p = r.length; h < p; h++) for (let d = r[h], f = 0; f < 3; f++)s[0] = d[c[f]], s[1] = d[c[(f + 1) % 3]], s.sort(n), i = s.toString(), void 0 === l[i] ? l[i] = { index1: s[0], index2: s[1], face1: h, face2: void 0 } : l[i].face2 = h; for (i in l)s = l[i], (void 0 === s.face2 || r[s.face1].normal.dot(r[s.face2].normal) <= o) && (c = u[s.index1], a.push(c.x, c.y, c.z), c = u[s.index2], a.push(c.x, c.y, c.z)); this.addAttribute('position', new yt(a, 3)) } function Qe (t, e, n, i, r, a, o, s) { _t.call(this), this.type = 'CylinderGeometry', this.parameters = { radiusTop: t, radiusBottom: e, height: n, radialSegments: i, heightSegments: r, openEnded: a, thetaStart: o, thetaLength: s }, this.fromBufferGeometry(new tn(t, e, n, i, r, a, o, s)), this.mergeVertices() } function tn (t, e, i, r, a, o, s, c) { function u (i) { let a; let o; let u; let v = new n(); let x = new l(); let w = 0; const _ = !0 === i ? t : e; const $ = !0 === i ? 1 : -1; for (o = g, a = 1; a <= r; a++)d.push(0, y * $, 0), f.push(0, $, 0), m.push(0.5, 0.5), g++; for (u = g, a = 0; a <= r; a++) { var T = a / r * c + s; const S = Math.cos(T); var T = Math.sin(T); x.x = _ * T, x.y = y * $, x.z = _ * S, d.push(x.x, x.y, x.z), f.push(0, $, 0), v.x = 0.5 * S + 0.5, v.y = 0.5 * T * $ + 0.5, m.push(v.x, v.y), g++ } for (a = 0; a < r; a++)v = o + a, x = u + a, !0 === i ? p.push(x, x + 1, v) : p.push(x + 1, x, v), w += 3; h.addGroup(b, w, !0 === i ? 1 : 2), b += w }$t.call(this), this.type = 'CylinderBufferGeometry', this.parameters = { radiusTop: t, radiusBottom: e, height: i, radialSegments: r, heightSegments: a, openEnded: o, thetaStart: s, thetaLength: c }; var h = this; t = void 0 !== t ? t : 20, e = void 0 !== e ? e : 20, i = void 0 !== i ? i : 100, r = Math.floor(r) || 8, a = Math.floor(a) || 1, o = void 0 !== o && o, s = void 0 !== s ? s : 0, c = void 0 !== c ? c : 2 * Math.PI; var p = []; var d = []; var f = []; var m = []; var g = 0; const v = []; var y = i / 2; var b = 0; !(function () { let n; let o; let u = new l(); let x = new l(); let w = 0; let _ = (e - t) / i; for (o = 0; o <= a; o++) { const $ = []; const T = o / a; const S = T * (e - t) + t; for (n = 0; n <= r; n++) { const M = n / r; var C = M * c + s; const E = Math.sin(C); var C = Math.cos(C); x.x = S * E, x.y = -T * i + y, x.z = S * C, d.push(x.x, x.y, x.z), u.set(E, _, C).normalize(), f.push(u.x, u.y, u.z), m.push(M, 1 - T), $.push(g++) }v.push($) } for (n = 0; n < r; n++) for (o = 0; o < a; o++)u = v[o + 1][n], x = v[o + 1][n + 1], _ = v[o][n + 1], p.push(v[o][n], u, _), p.push(u, x, _), w += 6; h.addGroup(b, w, 0), b += w }()), !1 === o && (t > 0 && u(!0), e > 0 && u(!1)), this.setIndex(p), this.addAttribute('position', new yt(d, 3)), this.addAttribute('normal', new yt(f, 3)), this.addAttribute('uv', new yt(m, 2)) } function en (t, e, n, i, r, a, o) { Qe.call(this, 0, t, e, n, i, r, a, o), this.type = 'ConeGeometry', this.parameters = { radius: t, height: e, radialSegments: n, heightSegments: i, openEnded: r, thetaStart: a, thetaLength: o } } function nn (t, e, n, i, r, a, o) { tn.call(this, 0, t, e, n, i, r, a, o), this.type = 'ConeBufferGeometry', this.parameters = { radius: t, height: e, radialSegments: n, heightSegments: i, openEnded: r, thetaStart: a, thetaLength: o } } function rn (t, e, n, i) { _t.call(this), this.type = 'CircleGeometry', this.parameters = { radius: t, segments: e, thetaStart: n, thetaLength: i }, this.fromBufferGeometry(new an(t, e, n, i)) } function an (t, e, i, r) { $t.call(this), this.type = 'CircleBufferGeometry', this.parameters = { radius: t, segments: e, thetaStart: i, thetaLength: r }, t = t || 50, e = void 0 !== e ? Math.max(3, e) : 8, i = void 0 !== i ? i : 0, r = void 0 !== r ? r : 2 * Math.PI; let a; let o; const s = []; const c = []; const u = []; const h = []; const p = new l(); const d = new n(); for (c.push(0, 0, 0), u.push(0, 0, 1), h.push(0.5, 0.5), o = 0, a = 3; o <= e; o++, a += 3) { const f = i + o / e * r; p.x = t * Math.cos(f), p.y = t * Math.sin(f), c.push(p.x, p.y, p.z), u.push(0, 0, 1), d.x = (c[a] / t + 1) / 2, d.y = (c[a + 1] / t + 1) / 2, h.push(d.x, d.y) } for (a = 1; a <= e; a++)s.push(a, a + 1, 0); this.setIndex(s), this.addAttribute('position', new yt(c, 3)), this.addAttribute('normal', new yt(u, 3)), this.addAttribute('uv', new yt(h, 2)) } function on () { X.call(this, { uniforms: mr.merge([yr.lights, { opacity: { value: 1 } }]), vertexShader: gr.shadow_vert, fragmentShader: gr.shadow_frag }), this.transparent = this.lights = !0, Object.defineProperties(this, { opacity: { enumerable: !0, get: function () { return this.uniforms.opacity.value }, set: function (t) { this.uniforms.opacity.value = t } } }) } function sn (t) { X.call(this, t), this.type = 'RawShaderMaterial' } function ln (t) { this.uuid = lr.generateUUID(), this.type = 'MultiMaterial', this.materials = Array.isArray(t) ? t : [], this.visible = !0 } function cn (t) { q.call(this), this.defines = { STANDARD: '' }, this.type = 'MeshStandardMaterial', this.color = new j(16777215), this.metalness = this.roughness = 0.5, this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new j(0), this.emissiveIntensity = 1, this.bumpMap = this.emissiveMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new n(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.envMap = this.alphaMap = this.metalnessMap = this.roughnessMap = null, this.envMapIntensity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = 'round', this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(t) } function un (t) { cn.call(this), this.defines = { PHYSICAL: '' }, this.type = 'MeshPhysicalMaterial', this.reflectivity = 0.5, this.clearCoatRoughness = this.clearCoat = 0, this.setValues(t) } function hn (t) { q.call(this), this.type = 'MeshPhongMaterial', this.color = new j(16777215), this.specular = new j(1118481), this.shininess = 30, this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new j(0), this.emissiveIntensity = 1, this.bumpMap = this.emissiveMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new n(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.envMap = this.alphaMap = this.specularMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = 'round', this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(t) } function pn (t) { hn.call(this), this.defines = { TOON: '' }, this.type = 'MeshToonMaterial', this.gradientMap = null, this.setValues(t) } function dn (t) { q.call(this, t), this.type = 'MeshNormalMaterial', this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new n(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.morphNormals = this.morphTargets = this.skinning = this.lights = this.fog = !1, this.setValues(t) } function fn (t) { q.call(this), this.type = 'MeshLambertMaterial', this.color = new j(16777215), this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new j(0), this.emissiveIntensity = 1, this.envMap = this.alphaMap = this.specularMap = this.emissiveMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = 'round', this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(t) } function mn (t) { q.call(this), this.type = 'LineDashedMaterial', this.color = new j(16777215), this.scale = this.linewidth = 1, this.dashSize = 3, this.gapSize = 1, this.lights = !1, this.setValues(t) } function gn (t, e, n) { const i = this; let r = !1; let a = 0; let o = 0; this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function (t) { o++, !1 === r && void 0 !== i.onStart && i.onStart(t, a, o), r = !0 }, this.itemEnd = function (t) { a++, void 0 !== i.onProgress && i.onProgress(t, a, o), a === o && (r = !1, void 0 !== i.onLoad) && i.onLoad() }, this.itemError = function (t) { void 0 !== i.onError && i.onError(t) } } function vn (t) { this.manager = void 0 !== t ? t : Er } function yn (t) { this.manager = void 0 !== t ? t : Er, this._parser = null } function bn (t) { this.manager = void 0 !== t ? t : Er, this._parser = null } function xn (t) { this.manager = void 0 !== t ? t : Er } function wn (t) { this.manager = void 0 !== t ? t : Er } function _n (t) { this.manager = void 0 !== t ? t : Er } function $n (t, e) { at.call(this), this.type = 'Light', this.color = new j(t), this.intensity = void 0 !== e ? e : 1, this.receiveShadow = void 0 } function Tn (t, e, n) { $n.call(this, t, n), this.type = 'HemisphereLight', this.castShadow = void 0, this.position.copy(at.DefaultUp), this.updateMatrix(), this.groundColor = new j(e) } function Sn (t) { this.camera = t, this.bias = 0, this.radius = 1, this.mapSize = new n(512, 512), this.map = null, this.matrix = new c() } function Mn () { Sn.call(this, new Pt(50, 1, 0.5, 500)) } function Cn (t, e, n, i, r, a) { $n.call(this, t, e), this.type = 'SpotLight', this.position.copy(at.DefaultUp), this.updateMatrix(), this.target = new at(), Object.defineProperty(this, 'power', { get: function () { return this.intensity * Math.PI }, set: function (t) { this.intensity = t / Math.PI } }), this.distance = void 0 !== n ? n : 0, this.angle = void 0 !== i ? i : Math.PI / 3, this.penumbra = void 0 !== r ? r : 0, this.decay = void 0 !== a ? a : 1, this.shadow = new Mn() } function En (t, e, n, i) { $n.call(this, t, e), this.type = 'PointLight', Object.defineProperty(this, 'power', { get: function () { return 4 * this.intensity * Math.PI }, set: function (t) { this.intensity = t / (4 * Math.PI) } }), this.distance = void 0 !== n ? n : 0, this.decay = void 0 !== i ? i : 1, this.shadow = new Sn(new Pt(90, 1, 0.5, 500)) } function An () { Sn.call(this, new kt(-5, 5, 5, -5, 0.5, 500)) } function Pn (t, e) { $n.call(this, t, e), this.type = 'DirectionalLight', this.position.copy(at.DefaultUp), this.updateMatrix(), this.target = new at(), this.shadow = new An() } function kn (t, e) { $n.call(this, t, e), this.type = 'AmbientLight', this.castShadow = void 0 } function Dn (t, e, n, i) { this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== i ? i : new e.constructor(n), this.sampleValues = e, this.valueSize = n } function On (t, e, n, i) { Dn.call(this, t, e, n, i), this._offsetNext = this._weightNext = this._offsetPrev = this._weightPrev = -0 } function Ln (t, e, n, i) { Dn.call(this, t, e, n, i) } function In (t, e, n, i) { Dn.call(this, t, e, n, i) } function Rn (t, e, n, i) { if (void 0 === t) throw Error('track name is undefined'); if (void 0 === e || e.length === 0) throw Error('no keyframes in track named ' + t); this.name = t, this.times = Ar.convertArray(e, this.TimeBufferType), this.values = Ar.convertArray(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation), this.validate(), this.optimize() } function Nn (t, e, n, i) { Rn.call(this, t, e, n, i) } function Fn (t, e, n, i) { Dn.call(this, t, e, n, i) } function Un (t, e, n, i) { Rn.call(this, t, e, n, i) } function zn (t, e, n, i) { Rn.call(this, t, e, n, i) } function Bn (t, e, n, i) { Rn.call(this, t, e, n, i) } function jn (t, e, n) { Rn.call(this, t, e, n) } function Vn (t, e, n, i) { Rn.call(this, t, e, n, i) } function Gn (t, e, n, i) { Rn.apply(this, arguments) } function Hn (t, e, n) { this.name = t, this.tracks = n, this.duration = void 0 !== e ? e : -1, this.uuid = lr.generateUUID(), this.duration < 0 && this.resetDuration(), this.optimize() } function Wn (t) { this.manager = void 0 !== t ? t : Er, this.textures = {} } function qn (t) { this.manager = void 0 !== t ? t : Er } function Xn () { this.onLoadStart = function () {}, this.onLoadProgress = function () {}, this.onLoadComplete = function () {} } function Yn (t) { typeof t === 'boolean' && (t = void 0), this.manager = void 0 !== t ? t : Er, this.withCredentials = !1 } function Zn (t) { this.manager = void 0 !== t ? t : Er, this.texturePath = '' } function Kn (t, e, n, i, r) { e = 0.5 * (i - e), r = 0.5 * (r - n); const a = t * t; return (2 * n - 2 * i + e + r) * t * a + (-3 * n + 3 * i - 2 * e - r) * a + e * t + n } function Jn (t, e, n, i) { const r = 1 - t; return r * r * e + 2 * (1 - t) * t * n + t * t * i } function Qn (t, e, n, i, r) { const a = 1 - t; const o = 1 - t; return a * a * a * e + 3 * o * o * t * n + 3 * (1 - t) * t * t * i + t * t * t * r } function ti () {} function ei (t, e) { this.v1 = t, this.v2 = e } function ni () { this.curves = [], this.autoClose = !1 } function ii (t, e, n, i, r, a, o, s) { this.aX = t, this.aY = e, this.xRadius = n, this.yRadius = i, this.aStartAngle = r, this.aEndAngle = a, this.aClockwise = o, this.aRotation = s || 0 } function ri (t) { this.points = void 0 === t ? [] : t } function ai (t, e, n, i) { this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = i } function oi (t, e, n) { this.v0 = t, this.v1 = e, this.v2 = n } function si (t) { ni.call(this), this.currentPoint = new n(), t && this.fromPoints(t) } function li () { si.apply(this, arguments), this.holes = [] } function ci () { this.subPaths = [], this.currentPath = null } function ui (t) { this.data = t } function hi (t) { this.manager = void 0 !== t ? t : Er } function pi (t) { this.manager = void 0 !== t ? t : Er } function di (t, e, n, i) { $n.call(this, t, e), this.type = 'RectAreaLight', this.position.set(0, 1, 0), this.updateMatrix(), this.width = void 0 !== n ? n : 10, this.height = void 0 !== i ? i : 10 } function fi () { this.type = 'StereoCamera', this.aspect = 1, this.eyeSep = 0.064, this.cameraL = new Pt(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Pt(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1 } function mi (t, e, n) { at.call(this), this.type = 'CubeCamera'; const i = new Pt(90, 1, t, e); i.up.set(0, -1, 0), i.lookAt(new l(1, 0, 0)), this.add(i); const r = new Pt(90, 1, t, e); r.up.set(0, -1, 0), r.lookAt(new l(-1, 0, 0)), this.add(r); const a = new Pt(90, 1, t, e); a.up.set(0, 0, 1), a.lookAt(new l(0, 1, 0)), this.add(a); const s = new Pt(90, 1, t, e); s.up.set(0, 0, -1), s.lookAt(new l(0, -1, 0)), this.add(s); const c = new Pt(90, 1, t, e); c.up.set(0, -1, 0), c.lookAt(new l(0, 0, 1)), this.add(c); const u = new Pt(90, 1, t, e); u.up.set(0, -1, 0), u.lookAt(new l(0, 0, -1)), this.add(u), this.renderTarget = new o(n, n, { format: 1022, magFilter: 1006, minFilter: 1006 }), this.updateCubeMap = function (t, e) { this.parent === null && this.updateMatrixWorld(); const n = this.renderTarget; const o = n.texture.generateMipmaps; n.texture.generateMipmaps = !1, n.activeCubeFace = 0, t.render(e, i, n), n.activeCubeFace = 1, t.render(e, r, n), n.activeCubeFace = 2, t.render(e, a, n), n.activeCubeFace = 3, t.render(e, s, n), n.activeCubeFace = 4, t.render(e, c, n), n.texture.generateMipmaps = o, n.activeCubeFace = 5, t.render(e, u, n), t.setRenderTarget(null) } } function gi () { at.call(this), this.type = 'AudioListener', this.context = Or.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null } function vi (t) { at.call(this), this.type = 'Audio', this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.loop = !1, this.startTime = 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = 'empty', this.filters = [] } function yi (t) { vi.call(this, t), this.panner = this.context.createPanner(), this.panner.connect(this.gain) } function bi (t, e) { this.analyser = t.context.createAnalyser(), this.analyser.fftSize = void 0 !== e ? e : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser) } function xi (t, e, n) { switch (this.binding = t, this.valueSize = n, t = Float64Array, e) { case 'quaternion':e = this._slerp; break; case 'string':case 'bool':t = Array, e = this._select; break; default:e = this._lerp } this.buffer = new t(4 * n), this._mixBufferRegion = e, this.referenceCount = this.useCount = this.cumulativeWeight = 0 } function wi (t, e, n) { this.path = e, this.parsedPath = n || wi.parseTrackName(e), this.node = wi.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t } function _i (t) { this.uuid = lr.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0; const e = {}; this._indicesByUUID = e; for (let n = 0, i = arguments.length; n !== i; ++n)e[arguments[n].uuid] = n; this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {}; const r = this; this.stats = { objects: { get total () { return r._objects.length }, get inUse () { return this.total - r.nCachedObjects_ } }, get bindingsPerObject () { return r._bindings.length } } } function $i (t, e, n) { this._mixer = t, this._clip = e, this._localRoot = n || null, t = e.tracks, e = t.length, n = Array(e); for (var i = { endingStart: 2400, endingEnd: 2400 }, r = 0; r !== e; ++r) { const a = t[r].createInterpolant(null); n[r] = a, a.settings = i } this._interpolantSettings = i, this._interpolants = n, this._propertyBindings = Array(e), this._weightInterpolant = this._timeScaleInterpolant = this._byClipCacheIndex = this._cacheIndex = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this._effectiveWeight = this.weight = this._effectiveTimeScale = this.timeScale = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtEnd = this.zeroSlopeAtStart = !0 } function Ti (t) { this._root = t, this._initMemoryManager(), this.time = this._accuIndex = 0, this.timeScale = 1 } function Si (t, e) { typeof t === 'string' && (t = e), this.value = t } function Mi () { $t.call(this), this.type = 'InstancedBufferGeometry', this.maxInstancedCount = void 0 } function Ci (t, e, n, i) { this.uuid = lr.generateUUID(), this.data = t, this.itemSize = e, this.offset = n, this.normalized = !0 === i } function Ei (t, e) { this.uuid = lr.generateUUID(), this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.dynamic = !1, this.updateRange = { offset: 0, count: -1 }, this.onUploadCallback = function () {}, this.version = 0 } function Ai (t, e, n) { Ei.call(this, t, e), this.meshPerAttribute = n || 1 } function Pi (t, e, n) { ut.call(this, t, e), this.meshPerAttribute = n || 1 } function ki (t, e, n, i) { this.ray = new nt(t, e), this.near = n || 0, this.far = i || 1 / 0, this.params = { Mesh: {}, Line: {}, LOD: {}, Points: { threshold: 1 }, Sprite: {} }, Object.defineProperties(this.params, { PointCloud: { get: function () { return this.Points } } }) } function Di (t, e) { return t.distance - e.distance } function Oi (t, e, n, i) { if (!1 !== t.visible && (t.raycast(e, n), !0 === i)) { t = t.children, i = 0; for (let r = t.length; i < r; i++)Oi(t[i], e, n, !0) } } function Li (t) { this.autoStart = void 0 === t || t, this.elapsedTime = this.oldTime = this.startTime = 0, this.running = !1 } function Ii (t, e, n) { return this.radius = void 0 !== t ? t : 1, this.phi = void 0 !== e ? e : 0, this.theta = void 0 !== n ? n : 0, this } function Ri (t, e, n) { return this.radius = void 0 !== t ? t : 1, this.theta = void 0 !== e ? e : 0, this.y = void 0 !== n ? n : 0, this } function Ni (t, e) { Tt.call(this, t, e), this.animationsMap = {}, this.animationsList = []; const n = this.geometry.morphTargets.length; this.createAnimation('__default', 0, n - 1, n / 1), this.setAnimationWeight('__default', 1) } function Fi (t) { at.call(this), this.material = t, this.render = function (t) {} } function Ui (t, e, n, i) { this.object = t, this.size = void 0 !== e ? e : 1, t = void 0 !== n ? n : 16711680, i = void 0 !== i ? i : 1, e = 0, (n = this.object.geometry) && n.isGeometry ? e = 3 * n.faces.length : n && n.isBufferGeometry && (e = n.attributes.normal.count), n = new $t(), e = new yt(6 * e, 3), n.addAttribute('position', e), me.call(this, n, new de({ color: t, linewidth: i })), this.matrixAutoUpdate = !1, this.update() } function zi (t) { at.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, t = new $t(); for (var e = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], n = 0, i = 1; n < 32; n++, i++) { const r = n / 32 * Math.PI * 2; const a = i / 32 * Math.PI * 2; e.push(Math.cos(r), Math.sin(r), 1, Math.cos(a), Math.sin(a), 1) }t.addAttribute('position', new yt(e, 3)), e = new de({ fog: !1 }), this.cone = new me(t, e), this.add(this.cone), this.update() } function Bi (t) { this.bones = this.getBoneList(t); for (var e = new $t(), n = [], i = [], r = new j(0, 0, 1), a = new j(0, 1, 0), o = 0; o < this.bones.length; o++) { const s = this.bones[o]; s.parent && s.parent.isBone && (n.push(0, 0, 0), n.push(0, 0, 0), i.push(r.r, r.g, r.b), i.push(a.r, a.g, a.b)) }e.addAttribute('position', new yt(n, 3)), e.addAttribute('color', new yt(i, 3)), n = new de({ vertexColors: 2, depthTest: !1, depthWrite: !1, transparent: !0 }), me.call(this, e, n), this.root = t, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.update() } function ji (t, e) { this.light = t, this.light.updateMatrixWorld(); const n = new He(e, 4, 2); const i = new ct({ wireframe: !0, fog: !1 }); i.color.copy(this.light.color).multiplyScalar(this.light.intensity), Tt.call(this, n, i), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1 } function Vi (t) { at.call(this), this.light = t, this.light.updateMatrixWorld(); const e = new ct({ color: t.color, fog: !1 }); t = new ct({ color: t.color, fog: !1, wireframe: !0 }); const n = new $t(); n.addAttribute('position', new ut(new Float32Array(18), 3)), this.add(new Tt(n, e)), this.add(new Tt(n, t)), this.update() } function Gi (t, e) { at.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1; const n = new ke(e); n.rotateY(0.5 * Math.PI); const i = new ct({ vertexColors: 2, wireframe: !0 }); var r = n.getAttribute('position'); var r = new Float32Array(3 * r.count); n.addAttribute('color', new ut(r, 3)), this.add(new Tt(n, i)), this.update() } function Hi (t, e, n, i) { t = t || 10, e = e || 10, n = new j(void 0 !== n ? n : 4473924), i = new j(void 0 !== i ? i : 8947848); const r = e / 2; const a = t / e; const o = t / 2; t = []; for (var s = [], l = 0, c = 0, u = -o; l <= e; l++, u += a) { t.push(-o, 0, u, o, 0, u), t.push(u, 0, -o, u, 0, o); const h = l === r ? n : i; h.toArray(s, c), c += 3, h.toArray(s, c), c += 3, h.toArray(s, c), c += 3, h.toArray(s, c), c += 3 }e = new $t(), e.addAttribute('position', new yt(t, 3)), e.addAttribute('color', new yt(s, 3)), n = new de({ vertexColors: 2 }), me.call(this, e, n) } function Wi (t, e, n, i, r, a) { t = t || 10, e = e || 16, n = n || 8, i = i || 64, r = new j(void 0 !== r ? r : 4473924), a = new j(void 0 !== a ? a : 8947848); let o; let s; let l; let c; let u; let h = []; const p = []; for (l = 0; l <= e; l++)s = l / e * 2 * Math.PI, o = Math.sin(s) * t, s = Math.cos(s) * t, h.push(0, 0, 0), h.push(o, 0, s), u = 1 & l ? r : a, p.push(u.r, u.g, u.b), p.push(u.r, u.g, u.b); for (l = 0; l <= n; l++) for (u = 1 & l ? r : a, c = t - t / n * l, e = 0; e < i; e++)s = e / i * 2 * Math.PI, o = Math.sin(s) * c, s = Math.cos(s) * c, h.push(o, 0, s), p.push(u.r, u.g, u.b), s = (e + 1) / i * 2 * Math.PI, o = Math.sin(s) * c, s = Math.cos(s) * c, h.push(o, 0, s), p.push(u.r, u.g, u.b); t = new $t(), t.addAttribute('position', new yt(h, 3)), t.addAttribute('color', new yt(p, 3)), h = new de({ vertexColors: 2 }), me.call(this, t, h) } function qi (t, e, n, i) { this.object = t, this.size = void 0 !== e ? e : 1, t = void 0 !== n ? n : 16776960, i = void 0 !== i ? i : 1, e = 0, (n = this.object.geometry) && n.isGeometry && (e = n.faces.length), n = new $t(), e = new yt(6 * e, 3), n.addAttribute('position', e), me.call(this, n, new de({ color: t, linewidth: i })), this.matrixAutoUpdate = !1, this.update() } function Xi (t, e) { at.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, void 0 === e && (e = 1); let n = new $t(); n.addAttribute('position', new yt([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3)); const i = new de({ fog: !1 }); this.add(new fe(n, i)), n = new $t(), n.addAttribute('position', new yt([0, 0, 0, 0, 0, 1], 3)), this.add(new fe(n, i)), this.update() } function Yi (t) {
    function e (t, e, i) { n(t, i), n(e, i) } function n (t, e) { a.push(0, 0, 0), o.push(e.r, e.g, e.b), void 0 === s[t] && (s[t] = []), s[t].push(a.length / 3 - 1) } const i = new $t(); const r = new de({ color: 16777215, vertexColors: 1 }); var a = []; var o = []; var s = {}; const l = new j(16755200); const c = new j(16711680); const u = new j(43775); const h = new j(16777215); const p = new j(3355443); e('n1', 'n2', l), e('n2', 'n4', l), e('n4', 'n3', l), e('n3', 'n1', l), e('f1', 'f2', l), e('f2', 'f4', l), e('f4', 'f3', l), e('f3', 'f1', l), e('n1', 'f1', l), e('n2', 'f2', l), e('n3', 'f3', l), e('n4', 'f4', l), e('p', 'n1', c), e('p', 'n2', c), e('p', 'n3', c), e('p', 'n4', c), e('u1', 'u2', u), e('u2', 'u3', u), e('u3', 'u1', u), e('c', 't', h), e('p', 'c', p), e('cn1', 'cn2', p), e('cn3', 'cn4', p), e('cf1', 'cf2', p), e('cf3', 'cf4', p), i.addAttribute('position', new yt(a, 3)),
    i.addAttribute('color', new yt(o, 3)), me.call(this, i, r), this.camera = t, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = s, this.update()
  } function Zi (t, e) { void 0 === e && (e = 16776960); const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]); const i = new Float32Array(24); const r = new $t(); r.setIndex(new ut(n, 1)), r.addAttribute('position', new ut(i, 3)), me.call(this, r, new de({ color: e })), void 0 !== t && this.update(t) } function Ki (t, e, n, i, r, a) { at.call(this), void 0 === i && (i = 16776960), void 0 === n && (n = 1), void 0 === r && (r = 0.2 * n), void 0 === a && (a = 0.2 * r), void 0 === Lr && (Lr = new $t(), Lr.addAttribute('position', new yt([0, 0, 0, 0, 1, 0], 3)), Ir = new tn(0, 0.5, 1, 5, 1), Ir.translate(0, -0.5, 0)), this.position.copy(e), this.line = new fe(Lr, new de({ color: i })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Tt(Ir, new ct({ color: i })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(t), this.setLength(n, r, a) } function Ji (t) { t = t || 1; let e = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t]; t = new $t(), t.addAttribute('position', new yt(e, 3)), t.addAttribute('color', new yt([1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1], 3)), e = new de({ vertexColors: 2 }), me.call(this, t, e) } function Qi () { let t = 0; let e = 0; let n = 0; let i = 0; return { initCatmullRom: function (r, a, o, s, l) { r = l * (o - r), s = l * (s - a), t = a, e = r, n = -3 * a + 3 * o - 2 * r - s, i = 2 * a - 2 * o + r + s }, initNonuniformCatmullRom: function (r, a, o, s, l, c, u) { r = ((a - r) / l - (o - r) / (l + c) + (o - a) / c) * c, s = ((o - a) / c - (s - a) / (c + u) + (s - o) / u) * c, t = a, e = r, n = -3 * a + 3 * o - 2 * r - s, i = 2 * a - 2 * o + r + s }, calc: function (r) { const a = r * r; return t + e * r + n * a + i * a * r } } } function tr (t) { this.points = t || [], this.closed = !1 } function er (t, e, n, i) { this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = i } function nr (t, e, n) { this.v0 = t, this.v1 = e, this.v2 = n } function ir (t, e) { this.v1 = t, this.v2 = e } function rr (t, e, n, i, r, a) { ii.call(this, t, e, n, n, i, r, a) } function ar (t) { tr.call(this, t), this.type = 'catmullrom', this.closed = !0 } function or (t) { tr.call(this, t), this.type = 'catmullrom' } function sr (t) { tr.call(this, t), this.type = 'catmullrom' } void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Math.sign && (Math.sign = function (t) { return t < 0 ? -1 : t > 0 ? 1 : +t }), void 0 === Function.prototype.name && Object.defineProperty(Function.prototype, 'name', { get: function () { return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1] } }), void 0 === Object.assign && (function () { Object.assign = function (t) { if (void 0 === t || t === null) throw new TypeError('Cannot convert undefined or null to object'); for (var e = Object(t), n = 1; n < arguments.length; n++) { const i = arguments[n]; if (void 0 !== i && i !== null) for (const r in i)Object.prototype.hasOwnProperty.call(i, r) && (e[r] = i[r]) } return e } }()), e.prototype = { addEventListener: function (t, e) { void 0 === this._listeners && (this._listeners = {}); const n = this._listeners; void 0 === n[t] && (n[t] = []), n[t].indexOf(e) === -1 && n[t].push(e) }, hasEventListener: function (t, e) { if (void 0 === this._listeners) return !1; const n = this._listeners; return void 0 !== n[t] && n[t].indexOf(e) !== -1 }, removeEventListener: function (t, e) { if (void 0 !== this._listeners) { const n = this._listeners[t]; if (void 0 !== n) { const i = n.indexOf(e); i !== -1 && n.splice(i, 1) } } }, dispatchEvent: function (t) { if (void 0 !== this._listeners) { const e = this._listeners[t.type]; if (void 0 !== e) { t.target = this; let n; const i = []; const r = e.length; for (n = 0; n < r; n++)i[n] = e[n]; for (n = 0; n < r; n++)i[n].call(this, t) } } } }; var lr = { DEG2RAD: Math.PI / 180, RAD2DEG: 180 / Math.PI, generateUUID: (function () { let t; const e = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split(''); const n = Array(36); let i = 0; return function () { for (let r = 0; r < 36; r++)r === 8 || r === 13 || r === 18 || r === 23 ? n[r] = '-' : r === 14 ? n[r] = '4' : (i <= 2 && (i = 33554432 + 16777216 * Math.random() | 0), t = 15 & i, i >>= 4, n[r] = e[r === 19 ? 3 & t | 8 : t]); return n.join('') } }()), clamp: function (t, e, n) { return Math.max(e, Math.min(n, t)) }, euclideanModulo: function (t, e) { return (t % e + e) % e }, mapLinear: function (t, e, n, i, r) { return i + (t - e) * (r - i) / (n - e) }, lerp: function (t, e, n) { return (1 - n) * t + n * e }, smoothstep: function (t, e, n) { return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t) }, smootherstep: function (t, e, n) { return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10) }, randInt: function (t, e) { return t + Math.floor(Math.random() * (e - t + 1)) }, randFloat: function (t, e) { return t + Math.random() * (e - t) }, randFloatSpread: function (t) { return t * (0.5 - Math.random()) }, degToRad: function (t) { return t * lr.DEG2RAD }, radToDeg: function (t) { return t * lr.RAD2DEG }, isPowerOfTwo: function (t) { return (t & t - 1) == 0 && t !== 0 }, nearestPowerOfTwo: function (t) { return Math.pow(2, Math.round(Math.log(t) / Math.LN2)) }, nextPowerOfTwo: function (t) { return t--, t |= t >> 1, t |= t >> 2, t |= t >> 4, t |= t >> 8, t |= t >> 16, ++t } }; n.prototype = { constructor: n, isVector2: !0, get width () { return this.x }, set width (t) { this.x = t }, get height () { return this.y }, set height (t) { this.y = t }, set: function (t, e) { return this.x = t, this.y = e, this }, setScalar: function (t) { return this.y = this.x = t, this }, setX: function (t) { return this.x = t, this }, setY: function (t) { return this.y = t, this }, setComponent: function (t, e) { switch (t) { case 0:this.x = e; break; case 1:this.y = e; break; default:throw Error('index is out of range: ' + t) } return this }, getComponent: function (t) { switch (t) { case 0:return this.x; case 1:return this.y; default:throw Error('index is out of range: ' + t) } }, clone: function () { return new this.constructor(this.x, this.y) }, copy: function (t) { return this.x = t.x, this.y = t.y, this }, add: function (t, e) { return void 0 !== e ? this.addVectors(t, e) : (this.x += t.x, this.y += t.y, this) }, addScalar: function (t) { return this.x += t, this.y += t, this }, addVectors: function (t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this }, addScaledVector: function (t, e) { return this.x += t.x * e, this.y += t.y * e, this }, sub: function (t, e) { return void 0 !== e ? this.subVectors(t, e) : (this.x -= t.x, this.y -= t.y, this) }, subScalar: function (t) { return this.x -= t, this.y -= t, this }, subVectors: function (t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this }, multiply: function (t) { return this.x *= t.x, this.y *= t.y, this }, multiplyScalar: function (t) { return isFinite(t) ? (this.x *= t, this.y *= t) : this.y = this.x = 0, this }, divide: function (t) { return this.x /= t.x, this.y /= t.y, this }, divideScalar: function (t) { return this.multiplyScalar(1 / t) }, min: function (t) { return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this }, max: function (t) { return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this }, clamp: function (t, e) { return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this }, clampScalar: (function () { let t, e; return function (i, r) { return void 0 === t && (t = new n(), e = new n()), t.set(i, i), e.set(r, r), this.clamp(t, e) } }()), clampLength: function (t, e) { const n = this.length(); return this.multiplyScalar(Math.max(t, Math.min(e, n)) / n) }, floor: function () { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this }, ceil: function () { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this }, round: function () { return this.x = Math.round(this.x), this.y = Math.round(this.y), this }, roundToZero: function () { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this }, negate: function () { return this.x = -this.x, this.y = -this.y, this }, dot: function (t) { return this.x * t.x + this.y * t.y }, lengthSq: function () { return this.x * this.x + this.y * this.y }, length: function () { return Math.sqrt(this.x * this.x + this.y * this.y) }, lengthManhattan: function () { return Math.abs(this.x) + Math.abs(this.y) }, normalize: function () { return this.divideScalar(this.length()) }, angle: function () { let t = Math.atan2(this.y, this.x); return t < 0 && (t += 2 * Math.PI), t }, distanceTo: function (t) { return Math.sqrt(this.distanceToSquared(t)) }, distanceToSquared: function (t) { const e = this.x - t.x; return t = this.y - t.y, e * e + t * t }, distanceToManhattan: function (t) { return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) }, setLength: function (t) { return this.multiplyScalar(t / this.length()) }, lerp: function (t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this }, lerpVectors: function (t, e, n) { return this.subVectors(e, t).multiplyScalar(n).add(t) }, equals: function (t) { return t.x === this.x && t.y === this.y }, fromArray: function (t, e) { return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this }, toArray: function (t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t }, fromBufferAttribute: function (t, e, n) { return this.x = t.getX(e), this.y = t.getY(e), this }, rotateAround: function (t, e) { const n = Math.cos(e); const i = Math.sin(e); const r = this.x - t.x; const a = this.y - t.y; return this.x = r * n - a * i + t.x, this.y = r * i + a * n + t.y, this } }; var cr = 0; i.DEFAULT_IMAGE = void 0, i.DEFAULT_MAPPING = 300, i.prototype = { constructor: i, isTexture: !0, set needsUpdate (t) { !0 === t && this.version++ }, clone: function () { return (new this.constructor()).copy(this) }, copy: function (t) { return this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this }, toJSON: function (t) { if (void 0 !== t.textures[this.uuid]) return t.textures[this.uuid]; const e = { metadata: { version: 4.4, type: 'Texture', generator: 'Texture.toJSON' }, uuid: this.uuid, name: this.name, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], wrap: [this.wrapS, this.wrapT], minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY }; if (void 0 !== this.image) { const n = this.image; if (void 0 === n.uuid && (n.uuid = lr.generateUUID()), void 0 === t.images[n.uuid]) { let i; const r = t.images; const a = n.uuid; const o = n.uuid; void 0 !== n.toDataURL ? i = n : (i = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas'), i.width = n.width, i.height = n.height, i.getContext('2d').drawImage(n, 0, 0, n.width, n.height)), i = i.width > 2048 || i.height > 2048 ? i.toDataURL('image/jpeg', 0.6) : i.toDataURL('image/png'), r[a] = { uuid: o, url: i } }e.image = n.uuid } return t.textures[this.uuid] = e }, dispose: function () { this.dispatchEvent({ type: 'dispose' }) }, transformUv: function (t) { if (this.mapping === 300) { if (t.multiply(this.repeat), t.add(this.offset), t.x < 0 || t.x > 1) switch (this.wrapS) { case 1e3:t.x -= Math.floor(t.x); break; case 1001:t.x = t.x < 0 ? 0 : 1; break; case 1002:t.x = Math.abs(Math.floor(t.x) % 2) === 1 ? Math.ceil(t.x) - t.x : t.x - Math.floor(t.x) } if (t.y < 0 || t.y > 1) switch (this.wrapT) { case 1e3:t.y -= Math.floor(t.y); break; case 1001:t.y = t.y < 0 ? 0 : 1; break; case 1002:t.y = Math.abs(Math.floor(t.y) % 2) === 1 ? Math.ceil(t.y) - t.y : t.y - Math.floor(t.y) } this.flipY && (t.y = 1 - t.y) } } }, Object.assign(i.prototype, e.prototype), r.prototype = { constructor: r, isVector4: !0, set: function (t, e, n, i) { return this.x = t, this.y = e, this.z = n, this.w = i, this }, setScalar: function (t) { return this.w = this.z = this.y = this.x = t, this }, setX: function (t) { return this.x = t, this }, setY: function (t) { return this.y = t, this }, setZ: function (t) { return this.z = t, this }, setW: function (t) { return this.w = t, this }, setComponent: function (t, e) { switch (t) { case 0:this.x = e; break; case 1:this.y = e; break; case 2:this.z = e; break; case 3:this.w = e; break; default:throw Error('index is out of range: ' + t) } return this }, getComponent: function (t) { switch (t) { case 0:return this.x; case 1:return this.y; case 2:return this.z; case 3:return this.w; default:throw Error('index is out of range: ' + t) } }, clone: function () { return new this.constructor(this.x, this.y, this.z, this.w) }, copy: function (t) { return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this }, add: function (t, e) { return void 0 !== e ? this.addVectors(t, e) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this) }, addScalar: function (t) { return this.x += t, this.y += t, this.z += t, this.w += t, this }, addVectors: function (t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this }, addScaledVector: function (t, e) { return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this }, sub: function (t, e) { return void 0 !== e ? this.subVectors(t, e) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this) }, subScalar: function (t) { return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this }, subVectors: function (t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this }, multiplyScalar: function (t) { return isFinite(t) ? (this.x *= t, this.y *= t, this.z *= t, this.w *= t) : this.w = this.z = this.y = this.x = 0, this }, applyMatrix4: function (t) { const e = this.x; const n = this.y; const i = this.z; const r = this.w; return t = t.elements, this.x = t[0] * e + t[4] * n + t[8] * i + t[12] * r, this.y = t[1] * e + t[5] * n + t[9] * i + t[13] * r, this.z = t[2] * e + t[6] * n + t[10] * i + t[14] * r, this.w = t[3] * e + t[7] * n + t[11] * i + t[15] * r, this }, divideScalar: function (t) { return this.multiplyScalar(1 / t) }, setAxisAngleFromQuaternion: function (t) { this.w = 2 * Math.acos(t.w); const e = Math.sqrt(1 - t.w * t.w); return e < 1e-4 ? (this.x = 1, this.z = this.y = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this }, setAxisAngleFromRotationMatrix: function (t) { let e, n, i; t = t.elements; let r = t[0]; i = t[4]; let a = t[8]; const o = t[1]; let s = t[5]; let l = t[9]; n = t[2], e = t[6]; let c = t[10]; return Math.abs(i - o) < 0.01 && Math.abs(a - n) < 0.01 && Math.abs(l - e) < 0.01 ? Math.abs(i + o) < 0.1 && Math.abs(a + n) < 0.1 && Math.abs(l + e) < 0.1 && Math.abs(r + s + c - 3) < 0.1 ? (this.set(1, 0, 0, 0), this) : (t = Math.PI, r = (r + 1) / 2, s = (s + 1) / 2, c = (c + 1) / 2, i = (i + o) / 4, a = (a + n) / 4, l = (l + e) / 4, r > s && r > c ? r < 0.01 ? (e = 0, i = n = 0.707106781) : (e = Math.sqrt(r), n = i / e, i = a / e) : s > c ? s < 0.01 ? (e = 0.707106781, n = 0, i = 0.707106781) : (n = Math.sqrt(s), e = i / n, i = l / n) : c < 0.01 ? (n = e = 0.707106781, i = 0) : (i = Math.sqrt(c), e = a / i, n = l / i), this.set(e, n, i, t), this) : (t = Math.sqrt((e - l) * (e - l) + (a - n) * (a - n) + (o - i) * (o - i)), Math.abs(t) < 0.001 && (t = 1), this.x = (e - l) / t, this.y = (a - n) / t, this.z = (o - i) / t, this.w = Math.acos((r + s + c - 1) / 2), this) }, min: function (t) { return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this }, max: function (t) { return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this }, clamp: function (t, e) { return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this }, clampScalar: (function () { let t, e; return function (n, i) { return void 0 === t && (t = new r(), e = new r()), t.set(n, n, n, n), e.set(i, i, i, i), this.clamp(t, e) } }()), floor: function () { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this }, ceil: function () { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this }, round: function () { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this }, roundToZero: function () { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this }, negate: function () { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this }, dot: function (t) { return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w }, lengthSq: function () { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w }, length: function () { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w) }, lengthManhattan: function () { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w) }, normalize: function () { return this.divideScalar(this.length()) }, setLength: function (t) { return this.multiplyScalar(t / this.length()) }, lerp: function (t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this }, lerpVectors: function (t, e, n) { return this.subVectors(e, t).multiplyScalar(n).add(t) }, equals: function (t) { return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w }, fromArray: function (t, e) { return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this }, toArray: function (t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t }, fromBufferAttribute: function (t, e, n) { return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this } }, a.prototype = { constructor: a, isWebGLRenderTarget: !0, setSize: function (t, e) { this.width === t && this.height === e || (this.width = t, this.height = e, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e) }, clone: function () { return (new this.constructor()).copy(this) }, copy: function (t) { return this.width = t.width, this.height = t.height, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this }, dispose: function () { this.dispatchEvent({ type: 'dispose' }) } }, Object.assign(a.prototype, e.prototype), o.prototype = Object.create(a.prototype), o.prototype.constructor = o, o.prototype.isWebGLRenderTargetCube = !0, s.prototype = { constructor: s, get x () { return this._x }, set x (t) { this._x = t, this.onChangeCallback() }, get y () { return this._y }, set y (t) { this._y = t, this.onChangeCallback() }, get z () { return this._z }, set z (t) { this._z = t, this.onChangeCallback() }, get w () { return this._w }, set w (t) { this._w = t, this.onChangeCallback() }, set: function (t, e, n, i) { return this._x = t, this._y = e, this._z = n, this._w = i, this.onChangeCallback(), this }, clone: function () { return new this.constructor(this._x, this._y, this._z, this._w) }, copy: function (t) { return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this.onChangeCallback(), this }, setFromEuler: function (t, e) { if (!1 === (t && t.isEuler)) throw Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.'); const n = Math.cos(t._x / 2); const i = Math.cos(t._y / 2); const r = Math.cos(t._z / 2); const a = Math.sin(t._x / 2); const o = Math.sin(t._y / 2); const s = Math.sin(t._z / 2); const l = t.order; return l === 'XYZ' ? (this._x = a * i * r + n * o * s, this._y = n * o * r - a * i * s, this._z = n * i * s + a * o * r, this._w = n * i * r - a * o * s) : l === 'YXZ' ? (this._x = a * i * r + n * o * s, this._y = n * o * r - a * i * s, this._z = n * i * s - a * o * r, this._w = n * i * r + a * o * s) : l === 'ZXY' ? (this._x = a * i * r - n * o * s, this._y = n * o * r + a * i * s, this._z = n * i * s + a * o * r, this._w = n * i * r - a * o * s) : l === 'ZYX' ? (this._x = a * i * r - n * o * s, this._y = n * o * r + a * i * s, this._z = n * i * s - a * o * r, this._w = n * i * r + a * o * s) : l === 'YZX' ? (this._x = a * i * r + n * o * s, this._y = n * o * r + a * i * s, this._z = n * i * s - a * o * r, this._w = n * i * r - a * o * s) : l === 'XZY' && (this._x = a * i * r - n * o * s, this._y = n * o * r - a * i * s, this._z = n * i * s + a * o * r, this._w = n * i * r + a * o * s), !1 !== e && this.onChangeCallback(), this }, setFromAxisAngle: function (t, e) { const n = e / 2; const i = Math.sin(n); return this._x = t.x * i, this._y = t.y * i, this._z = t.z * i, this._w = Math.cos(n), this.onChangeCallback(), this }, setFromRotationMatrix: function (t) { var e = t.elements; let n = e[0]; t = e[4]; const i = e[8]; const r = e[1]; const a = e[5]; const o = e[9]; const s = e[2]; const l = e[6]; var e = e[10]; const c = n + a + e; return c > 0 ? (n = 0.5 / Math.sqrt(c + 1), this._w = 0.25 / n, this._x = (l - o) * n, this._y = (i - s) * n, this._z = (r - t) * n) : n > a && n > e ? (n = 2 * Math.sqrt(1 + n - a - e), this._w = (l - o) / n, this._x = 0.25 * n, this._y = (t + r) / n, this._z = (i + s) / n) : a > e ? (n = 2 * Math.sqrt(1 + a - n - e), this._w = (i - s) / n, this._x = (t + r) / n, this._y = 0.25 * n, this._z = (o + l) / n) : (n = 2 * Math.sqrt(1 + e - n - a), this._w = (r - t) / n, this._x = (i + s) / n, this._y = (o + l) / n, this._z = 0.25 * n), this.onChangeCallback(), this }, setFromUnitVectors: (function () { let t, e; return function (n, i) { return void 0 === t && (t = new l()), e = n.dot(i) + 1, e < 1e-6 ? (e = 0, Math.abs(n.x) > Math.abs(n.z) ? t.set(-n.y, n.x, 0) : t.set(0, -n.z, n.y)) : t.crossVectors(n, i), this._x = t.x, this._y = t.y, this._z = t.z, this._w = e, this.normalize() } }()), inverse: function () { return this.conjugate().normalize() }, conjugate: function () { return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this }, dot: function (t) { return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w }, lengthSq: function () { return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w }, length: function () { return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w) }, normalize: function () { let t = this.length(); return t === 0 ? (this._z = this._y = this._x = 0, this._w = 1) : (t = 1 / t, this._x *= t, this._y *= t, this._z *= t, this._w *= t), this.onChangeCallback(), this }, multiply: function (t, e) { return void 0 !== e ? this.multiplyQuaternions(t, e) : this.multiplyQuaternions(this, t) }, premultiply: function (t) { return this.multiplyQuaternions(t, this) }, multiplyQuaternions: function (t, e) { const n = t._x; const i = t._y; const r = t._z; const a = t._w; const o = e._x; const s = e._y; const l = e._z; const c = e._w; return this._x = n * c + a * o + i * l - r * s, this._y = i * c + a * s + r * o - n * l, this._z = r * c + a * l + n * s - i * o, this._w = a * c - n * o - i * s - r * l, this.onChangeCallback(), this }, slerp: function (t, e) { if (e === 0) return this; if (e === 1) return this.copy(t); const n = this._x; const i = this._y; const r = this._z; const a = this._w; var o = a * t._w + n * t._x + i * t._y + r * t._z; if (o < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, o = -o) : this.copy(t), o >= 1) return this._w = a, this._x = n, this._y = i, this._z = r, this; var s = Math.sqrt(1 - o * o); if (Math.abs(s) < 0.001) return this._w = 0.5 * (a + this._w), this._x = 0.5 * (n + this._x), this._y = 0.5 * (i + this._y), this._z = 0.5 * (r + this._z), this; const l = Math.atan2(s, o); var o = Math.sin((1 - e) * l) / s; var s = Math.sin(e * l) / s; return this._w = a * o + this._w * s, this._x = n * o + this._x * s, this._y = i * o + this._y * s, this._z = r * o + this._z * s, this.onChangeCallback(), this }, equals: function (t) { return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w }, fromArray: function (t, e) { return void 0 === e && (e = 0), this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this.onChangeCallback(), this }, toArray: function (t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t }, onChange: function (t) { return this.onChangeCallback = t, this }, onChangeCallback: function () {} }, Object.assign(s, { slerp: function (t, e, n, i) { return n.copy(t).slerp(e, i) }, slerpFlat: function (t, e, n, i, r, a, o) { let s = n[i + 0]; let l = n[i + 1]; let c = n[i + 2]; n = n[i + 3], i = r[a + 0]; const u = r[a + 1]; const h = r[a + 2]; if (r = r[a + 3], n !== r || s !== i || l !== u || c !== h) { a = 1 - o; let p = s * i + l * u + c * h + n * r; let d = p >= 0 ? 1 : -1; let f = 1 - p * p; f > Number.EPSILON && (f = Math.sqrt(f), p = Math.atan2(f, p * d), a = Math.sin(a * p) / f, o = Math.sin(o * p) / f), d *= o, s = s * a + i * d, l = l * a + u * d, c = c * a + h * d, n = n * a + r * d, a === 1 - o && (o = 1 / Math.sqrt(s * s + l * l + c * c + n * n), s *= o, l *= o, c *= o, n *= o) }t[e] = s, t[e + 1] = l, t[e + 2] = c, t[e + 3] = n } }), l.prototype = { constructor: l, isVector3: !0, set: function (t, e, n) { return this.x = t, this.y = e, this.z = n, this }, setScalar: function (t) { return this.z = this.y = this.x = t, this }, setX: function (t) { return this.x = t, this }, setY: function (t) { return this.y = t, this }, setZ: function (t) { return this.z = t, this }, setComponent: function (t, e) { switch (t) { case 0:this.x = e; break; case 1:this.y = e; break; case 2:this.z = e; break; default:throw Error('index is out of range: ' + t) } return this }, getComponent: function (t) { switch (t) { case 0:return this.x; case 1:return this.y; case 2:return this.z; default:throw Error('index is out of range: ' + t) } }, clone: function () { return new this.constructor(this.x, this.y, this.z) }, copy: function (t) { return this.x = t.x, this.y = t.y, this.z = t.z, this }, add: function (t, e) { return void 0 !== e ? this.addVectors(t, e) : (this.x += t.x, this.y += t.y, this.z += t.z, this) }, addScalar: function (t) { return this.x += t, this.y += t, this.z += t, this }, addVectors: function (t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this }, addScaledVector: function (t, e) { return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this }, sub: function (t, e) { return void 0 !== e ? this.subVectors(t, e) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this) }, subScalar: function (t) { return this.x -= t, this.y -= t, this.z -= t, this }, subVectors: function (t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this }, multiply: function (t, e) { return void 0 !== e ? this.multiplyVectors(t, e) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this) }, multiplyScalar: function (t) { return isFinite(t) ? (this.x *= t, this.y *= t, this.z *= t) : this.z = this.y = this.x = 0, this }, multiplyVectors: function (t, e) { return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this }, applyEuler: (function () { let t; return function (e) { return e && e.isEuler, void 0 === t && (t = new s()), this.applyQuaternion(t.setFromEuler(e)) } }()), applyAxisAngle: (function () { let t; return function (e, n) { return void 0 === t && (t = new s()), this.applyQuaternion(t.setFromAxisAngle(e, n)) } }()), applyMatrix3: function (t) { const e = this.x; const n = this.y; const i = this.z; return t = t.elements, this.x = t[0] * e + t[3] * n + t[6] * i, this.y = t[1] * e + t[4] * n + t[7] * i, this.z = t[2] * e + t[5] * n + t[8] * i, this }, applyMatrix4: function (t) { const e = this.x; const n = this.y; const i = this.z; return t = t.elements, this.x = t[0] * e + t[4] * n + t[8] * i + t[12], this.y = t[1] * e + t[5] * n + t[9] * i + t[13], this.z = t[2] * e + t[6] * n + t[10] * i + t[14], this.divideScalar(t[3] * e + t[7] * n + t[11] * i + t[15]) }, applyQuaternion: function (t) { var e = this.x; const n = this.y; const i = this.z; const r = t.x; const a = t.y; const o = t.z; t = t.w; const s = t * e + a * i - o * n; const l = t * n + o * e - r * i; const c = t * i + r * n - a * e; var e = -r * e - a * n - o * i; return this.x = s * t + e * -r + l * -o - c * -a, this.y = l * t + e * -a + c * -r - s * -o, this.z = c * t + e * -o + s * -a - l * -r, this }, project: (function () { let t; return function (e) { return void 0 === t && (t = new c()), t.multiplyMatrices(e.projectionMatrix, t.getInverse(e.matrixWorld)), this.applyMatrix4(t) } }()), unproject: (function () { let t; return function (e) { return void 0 === t && (t = new c()), t.multiplyMatrices(e.matrixWorld, t.getInverse(e.projectionMatrix)), this.applyMatrix4(t) } }()), transformDirection: function (t) { const e = this.x; const n = this.y; const i = this.z; return t = t.elements, this.x = t[0] * e + t[4] * n + t[8] * i, this.y = t[1] * e + t[5] * n + t[9] * i, this.z = t[2] * e + t[6] * n + t[10] * i, this.normalize() }, divide: function (t) { return this.x /= t.x, this.y /= t.y, this.z /= t.z, this }, divideScalar: function (t) { return this.multiplyScalar(1 / t) }, min: function (t) { return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this }, max: function (t) { return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this }, clamp: function (t, e) { return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this }, clampScalar: (function () { let t, e; return function (n, i) { return void 0 === t && (t = new l(), e = new l()), t.set(n, n, n), e.set(i, i, i), this.clamp(t, e) } }()), clampLength: function (t, e) { const n = this.length(); return this.multiplyScalar(Math.max(t, Math.min(e, n)) / n) }, floor: function () { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this }, ceil: function () { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this }, round: function () { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this }, roundToZero: function () { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this }, negate: function () { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this }, dot: function (t) { return this.x * t.x + this.y * t.y + this.z * t.z }, lengthSq: function () { return this.x * this.x + this.y * this.y + this.z * this.z }, length: function () { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z) }, lengthManhattan: function () { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) }, normalize: function () { return this.divideScalar(this.length()) }, setLength: function (t) { return this.multiplyScalar(t / this.length()) }, lerp: function (t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this }, lerpVectors: function (t, e, n) { return this.subVectors(e, t).multiplyScalar(n).add(t) }, cross: function (t, e) { if (void 0 !== e) return this.crossVectors(t, e); const n = this.x; const i = this.y; const r = this.z; return this.x = i * t.z - r * t.y, this.y = r * t.x - n * t.z, this.z = n * t.y - i * t.x, this }, crossVectors: function (t, e) { const n = t.x; const i = t.y; const r = t.z; const a = e.x; const o = e.y; const s = e.z; return this.x = i * s - r * o, this.y = r * a - n * s, this.z = n * o - i * a, this }, projectOnVector: function (t) { const e = t.dot(this) / t.lengthSq(); return this.copy(t).multiplyScalar(e) }, projectOnPlane: (function () { let t; return function (e) { return void 0 === t && (t = new l()), t.copy(this).projectOnVector(e), this.sub(t) } }()), reflect: (function () { let t; return function (e) { return void 0 === t && (t = new l()), this.sub(t.copy(e).multiplyScalar(2 * this.dot(e))) } }()), angleTo: function (t) { return t = this.dot(t) / Math.sqrt(this.lengthSq() * t.lengthSq()), Math.acos(lr.clamp(t, -1, 1)) }, distanceTo: function (t) { return Math.sqrt(this.distanceToSquared(t)) }, distanceToSquared: function (t) { const e = this.x - t.x; const n = this.y - t.y; return t = this.z - t.z, e * e + n * n + t * t }, distanceToManhattan: function (t) { return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z) }, setFromSpherical: function (t) { const e = Math.sin(t.phi) * t.radius; return this.x = e * Math.sin(t.theta), this.y = Math.cos(t.phi) * t.radius, this.z = e * Math.cos(t.theta), this }, setFromCylindrical: function (t) { return this.x = t.radius * Math.sin(t.theta), this.y = t.y, this.z = t.radius * Math.cos(t.theta), this }, setFromMatrixPosition: function (t) { return this.setFromMatrixColumn(t, 3) }, setFromMatrixScale: function (t) { const e = this.setFromMatrixColumn(t, 0).length(); const n = this.setFromMatrixColumn(t, 1).length(); return t = this.setFromMatrixColumn(t, 2).length(), this.x = e, this.y = n, this.z = t, this }, setFromMatrixColumn: function (t, e) { if (typeof t === 'number') { const n = t; t = e, e = n } return this.fromArray(t.elements, 4 * e) }, equals: function (t) { return t.x === this.x && t.y === this.y && t.z === this.z }, fromArray: function (t, e) { return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this }, toArray: function (t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t }, fromBufferAttribute: function (t, e, n) { return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this } }, c.prototype = {
    constructor: c,
    isMatrix4: !0,
    set: function (t, e, n, i, r, a, o, s, l, c, u, h, p, d, f, m) { const g = this.elements; return g[0] = t, g[4] = e, g[8] = n, g[12] = i, g[1] = r, g[5] = a, g[9] = o, g[13] = s, g[2] = l, g[6] = c, g[10] = u, g[14] = h, g[3] = p, g[7] = d, g[11] = f, g[15] = m, this },
    identity: function () { return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this },
    clone: function () { return (new c()).fromArray(this.elements) },
    copy: function (t) { return this.elements.set(t.elements), this },
    copyPosition: function (t) { const e = this.elements; return t = t.elements, e[12] = t[12], e[13] = t[13], e[14] = t[14], this },
    extractBasis: function (t, e, n) { return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this },
    makeBasis: function (t, e, n) { return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this },
    extractRotation: (function () { let t; return function (e) { void 0 === t && (t = new l()); const n = this.elements; const i = e.elements; const r = 1 / t.setFromMatrixColumn(e, 0).length(); const a = 1 / t.setFromMatrixColumn(e, 1).length(); return e = 1 / t.setFromMatrixColumn(e, 2).length(), n[0] = i[0] * r, n[1] = i[1] * r, n[2] = i[2] * r, n[4] = i[4] * a, n[5] = i[5] * a, n[6] = i[6] * a, n[8] = i[8] * e, n[9] = i[9] * e, n[10] = i[10] * e, this } }()),
    makeRotationFromEuler: function (t) { t && t.isEuler; const e = this.elements; var n = t.x; var i = t.y; var r = t.z; const a = Math.cos(n); var n = Math.sin(n); const o = Math.cos(i); var i = Math.sin(i); const s = Math.cos(r); var r = Math.sin(r); if (t.order === 'XYZ') { t = a * s; var l = a * r; var c = n * s; var u = n * r; e[0] = o * s, e[4] = -o * r, e[8] = i, e[1] = l + c * i, e[5] = t - u * i, e[9] = -n * o, e[2] = u - t * i, e[6] = c + l * i, e[10] = a * o } else t.order === 'YXZ' ? (t = o * s, l = o * r, c = i * s, u = i * r, e[0] = t + u * n, e[4] = c * n - l, e[8] = a * i, e[1] = a * r, e[5] = a * s, e[9] = -n, e[2] = l * n - c, e[6] = u + t * n, e[10] = a * o) : t.order === 'ZXY' ? (t = o * s, l = o * r, c = i * s, u = i * r, e[0] = t - u * n, e[4] = -a * r, e[8] = c + l * n, e[1] = l + c * n, e[5] = a * s, e[9] = u - t * n, e[2] = -a * i, e[6] = n, e[10] = a * o) : t.order === 'ZYX' ? (t = a * s, l = a * r, c = n * s, u = n * r, e[0] = o * s, e[4] = c * i - l, e[8] = t * i + u, e[1] = o * r, e[5] = u * i + t, e[9] = l * i - c, e[2] = -i, e[6] = n * o, e[10] = a * o) : t.order === 'YZX' ? (t = a * o, l = a * i, c = n * o, u = n * i, e[0] = o * s, e[4] = u - t * r, e[8] = c * r + l, e[1] = r, e[5] = a * s, e[9] = -n * s, e[2] = -i * s, e[6] = l * r + c, e[10] = t - u * r) : t.order === 'XZY' && (t = a * o, l = a * i, c = n * o, u = n * i, e[0] = o * s, e[4] = -r, e[8] = i * s, e[1] = t * r + u, e[5] = a * s, e[9] = l * r - c, e[2] = c * r - l, e[6] = n * s, e[10] = u * r + t); return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this },
    makeRotationFromQuaternion: function (t) { const e = this.elements; var n = t.x; var i = t.y; var r = t.z; var a = t.w; var o = n + n; var s = i + i; const l = r + r; t = n * o; const c = n * s; var n = n * l; const u = i * s; var i = i * l; var r = r * l; var o = a * o; var s = a * s; var a = a * l; return e[0] = 1 - (u + r), e[4] = c - a, e[8] = n + s, e[1] = c + a, e[5] = 1 - (t + r), e[9] = i - o, e[2] = n - s, e[6] = i + o, e[10] = 1 - (t + u), e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this },
    lookAt: (function () { let t, e, n; return function (i, r, a) { void 0 === t && (t = new l(), e = new l(), n = new l()); const o = this.elements; return n.subVectors(i, r).normalize(), n.lengthSq() === 0 && (n.z = 1), t.crossVectors(a, n).normalize(), t.lengthSq() === 0 && (n.z += 1e-4, t.crossVectors(a, n).normalize()), e.crossVectors(n, t), o[0] = t.x, o[4] = e.x, o[8] = n.x, o[1] = t.y, o[5] = e.y, o[9] = n.y, o[2] = t.z, o[6] = e.z, o[10] = n.z, this } }()),
    multiply: function (t, e) { return void 0 !== e ? this.multiplyMatrices(t, e) : this.multiplyMatrices(this, t) },
    premultiply: function (t) { return this.multiplyMatrices(t, this) },
    multiplyMatrices: function (t, e) {
      var n = t.elements; var i = e.elements; const r = this.elements; const a = n[0]; const o = n[4]; const s = n[8]; const l = n[12]; const c = n[1]; const u = n[5]; const h = n[9]; const p = n[13]; const d = n[2]; const f = n[6]; const m = n[10]; const g = n[14]; const v = n[3]; const y = n[7]; const b = n[11]; var n = n[15]; const x = i[0]; const w = i[4]; const _ = i[8]; const $ = i[12]; const T = i[1]; const S = i[5]; const M = i[9]; const C = i[13]; const E = i[2]; const A = i[6]; const P = i[10]; const k = i[14]; const D = i[3]; const O = i[7]; const L = i[11]; var i = i[15]; return r[0] = a * x + o * T + s * E + l * D, r[4] = a * w + o * S + s * A + l * O, r[8] = a * _ + o * M + s * P + l * L, r[12] = a * $ + o * C + s * k + l * i, r[1] = c * x + u * T + h * E + p * D, r[5] = c * w + u * S + h * A + p * O, r[9] = c * _ + u * M + h * P + p * L, r[13] = c * $ + u * C + h * k + p * i, r[2] = d * x + f * T + m * E + g * D, r[6] = d * w + f * S + m * A + g * O, r[10] = d * _ + f * M + m * P + g * L, r[14] = d * $ + f * C + m * k + g * i, r[3] = v * x + y * T + b * E + n * D, r[7] = v * w + y * S + b * A + n * O, r[11] = v * _ + y * M + b * P + n * L,
      r[15] = v * $ + y * C + b * k + n * i, this
    },
    multiplyToArray: function (t, e, n) { const i = this.elements; return this.multiplyMatrices(t, e), n[0] = i[0], n[1] = i[1], n[2] = i[2], n[3] = i[3], n[4] = i[4], n[5] = i[5], n[6] = i[6], n[7] = i[7], n[8] = i[8], n[9] = i[9], n[10] = i[10], n[11] = i[11], n[12] = i[12], n[13] = i[13], n[14] = i[14], n[15] = i[15], this },
    multiplyScalar: function (t) { const e = this.elements; return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this },
    applyToBufferAttribute: (function () { let t; return function (e) { void 0 === t && (t = new l()); for (let n = 0, i = e.count; n < i; n++)t.x = e.getX(n), t.y = e.getY(n), t.z = e.getZ(n), t.applyMatrix4(this), e.setXYZ(n, t.x, t.y, t.z); return e } }()),
    determinant: function () { const t = this.elements; const e = t[0]; const n = t[4]; const i = t[8]; const r = t[12]; const a = t[1]; const o = t[5]; const s = t[9]; const l = t[13]; const c = t[2]; const u = t[6]; const h = t[10]; const p = t[14]; return t[3] * (+r * s * u - i * l * u - r * o * h + n * l * h + i * o * p - n * s * p) + t[7] * (+e * s * p - e * l * h + r * a * h - i * a * p + i * l * c - r * s * c) + t[11] * (+e * l * u - e * o * p - r * a * u + n * a * p + r * o * c - n * l * c) + t[15] * (-i * o * c - e * s * u + e * o * h + i * a * u - n * a * h + n * s * c) },
    transpose: function () { let t; const e = this.elements; return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this },
    setPosition: function (t) { const e = this.elements; return e[12] = t.x, e[13] = t.y, e[14] = t.z, this },
    getInverse: function (t, e) { const n = this.elements; var i = t.elements; const r = i[0]; const a = i[1]; const o = i[2]; const s = i[3]; const l = i[4]; const c = i[5]; const u = i[6]; const h = i[7]; const p = i[8]; const d = i[9]; const f = i[10]; const m = i[11]; const g = i[12]; const v = i[13]; const y = i[14]; var i = i[15]; const b = d * y * h - v * f * h + v * u * m - c * y * m - d * u * i + c * f * i; const x = g * f * h - p * y * h - g * u * m + l * y * m + p * u * i - l * f * i; const w = p * v * h - g * d * h + g * c * m - l * v * m - p * c * i + l * d * i; const _ = g * d * u - p * v * u - g * c * f + l * v * f + p * c * y - l * d * y; let $ = r * b + a * x + o * w + s * _; if ($ === 0) { if (!0 === e) throw Error("THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0"); return this.identity() } return $ = 1 / $, n[0] = b * $, n[1] = (v * f * s - d * y * s - v * o * m + a * y * m + d * o * i - a * f * i) * $, n[2] = (c * y * s - v * u * s + v * o * h - a * y * h - c * o * i + a * u * i) * $, n[3] = (d * u * s - c * f * s - d * o * h + a * f * h + c * o * m - a * u * m) * $, n[4] = x * $, n[5] = (p * y * s - g * f * s + g * o * m - r * y * m - p * o * i + r * f * i) * $, n[6] = (g * u * s - l * y * s - g * o * h + r * y * h + l * o * i - r * u * i) * $, n[7] = (l * f * s - p * u * s + p * o * h - r * f * h - l * o * m + r * u * m) * $, n[8] = w * $, n[9] = (g * d * s - p * v * s - g * a * m + r * v * m + p * a * i - r * d * i) * $, n[10] = (l * v * s - g * c * s + g * a * h - r * v * h - l * a * i + r * c * i) * $, n[11] = (p * c * s - l * d * s - p * a * h + r * d * h + l * a * m - r * c * m) * $, n[12] = _ * $, n[13] = (p * v * o - g * d * o + g * a * f - r * v * f - p * a * y + r * d * y) * $, n[14] = (g * c * o - l * v * o - g * a * u + r * v * u + l * a * y - r * c * y) * $, n[15] = (l * d * o - p * c * o + p * a * u - r * d * u - l * a * f + r * c * f) * $, this },
    scale: function (t) { const e = this.elements; const n = t.x; const i = t.y; return t = t.z, e[0] *= n, e[4] *= i, e[8] *= t, e[1] *= n, e[5] *= i, e[9] *= t, e[2] *= n, e[6] *= i, e[10] *= t, e[3] *= n, e[7] *= i, e[11] *= t, this },
    getMaxScaleOnAxis: function () { const t = this.elements; return Math.sqrt(Math.max(t[0] * t[0] + t[1] * t[1] + t[2] * t[2], t[4] * t[4] + t[5] * t[5] + t[6] * t[6], t[8] * t[8] + t[9] * t[9] + t[10] * t[10])) },
    makeTranslation: function (t, e, n) { return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this },
    makeRotationX: function (t) { const e = Math.cos(t); return t = Math.sin(t), this.set(1, 0, 0, 0, 0, e, -t, 0, 0, t, e, 0, 0, 0, 0, 1), this },
    makeRotationY: function (t) { const e = Math.cos(t); return t = Math.sin(t), this.set(e, 0, t, 0, 0, 1, 0, 0, -t, 0, e, 0, 0, 0, 0, 1), this },
    makeRotationZ: function (t) { const e = Math.cos(t); return t = Math.sin(t), this.set(e, -t, 0, 0, t, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this },
    makeRotationAxis: function (t, e) { const n = Math.cos(e); const i = Math.sin(e); const r = 1 - n; const a = t.x; const o = t.y; const s = t.z; const l = r * a; const c = r * o; return this.set(l * a + n, l * o - i * s, l * s + i * o, 0, l * o + i * s, c * o + n, c * s - i * a, 0, l * s - i * o, c * s + i * a, r * s * s + n, 0, 0, 0, 0, 1), this },
    makeScale: function (t, e, n) { return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this },
    makeShear: function (t, e, n) { return this.set(1, e, n, 0, t, 1, n, 0, t, e, 1, 0, 0, 0, 0, 1), this },
    compose: function (t, e, n) { return this.makeRotationFromQuaternion(e), this.scale(n), this.setPosition(t), this },
    decompose: (function () { let t, e; return function (n, i, r) { void 0 === t && (t = new l(), e = new c()); var a = this.elements; let o = t.set(a[0], a[1], a[2]).length(); const s = t.set(a[4], a[5], a[6]).length(); const u = t.set(a[8], a[9], a[10]).length(); this.determinant() < 0 && (o = -o), n.x = a[12], n.y = a[13], n.z = a[14], e.elements.set(this.elements), n = 1 / o; var a = 1 / s; const h = 1 / u; return e.elements[0] *= n, e.elements[1] *= n, e.elements[2] *= n, e.elements[4] *= a, e.elements[5] *= a, e.elements[6] *= a, e.elements[8] *= h, e.elements[9] *= h, e.elements[10] *= h, i.setFromRotationMatrix(e), r.x = o, r.y = s, r.z = u, this } }()),
    makePerspective: function (t, e, n, i, r, a) { const o = this.elements; return o[0] = 2 * r / (e - t), o[4] = 0, o[8] = (e + t) / (e - t), o[12] = 0, o[1] = 0, o[5] = 2 * r / (n - i), o[9] = (n + i) / (n - i), o[13] = 0, o[2] = 0, o[6] = 0, o[10] = -(a + r) / (a - r), o[14] = -2 * a * r / (a - r), o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this },
    makeOrthographic: function (t, e, n, i, r, a) { const o = this.elements; const s = 1 / (e - t); const l = 1 / (n - i); const c = 1 / (a - r); return o[0] = 2 * s, o[4] = 0, o[8] = 0, o[12] = -(e + t) * s, o[1] = 0, o[5] = 2 * l, o[9] = 0, o[13] = -(n + i) * l, o[2] = 0, o[6] = 0, o[10] = -2 * c, o[14] = -(a + r) * c, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this },
    equals: function (t) { const e = this.elements; t = t.elements; for (let n = 0; n < 16; n++) if (e[n] !== t[n]) return !1; return !0 },
    fromArray: function (t, e) { void 0 === e && (e = 0); for (let n = 0; n < 16; n++) this.elements[n] = t[n + e]; return this },
    toArray: function (t, e) { void 0 === t && (t = []), void 0 === e && (e = 0); const n = this.elements; return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t }
  }, u.prototype = Object.create(i.prototype), u.prototype.constructor = u, u.prototype.isCubeTexture = !0, Object.defineProperty(u.prototype, 'images', { get: function () { return this.image }, set: function (t) { this.image = t } }); var ur = new i(); var hr = new u(); var pr = []; var dr = []; z.prototype.setValue = function (t, e) { for (let n = this.seq, i = 0, r = n.length; i !== r; ++i) { const a = n[i]; a.setValue(t, e[a.id]) } }; var fr = /([\w\d_]+)(\])?(\[|\.)?/g; B.prototype.setValue = function (t, e, n) { void 0 !== (e = this.map[e]) && e.setValue(t, n, this.renderer) }, B.prototype.set = function (t, e, n) { const i = this.map[n]; void 0 !== i && i.setValue(t, e[n], this.renderer) }, B.prototype.setOptional = function (t, e, n) { void 0 !== (e = e[n]) && this.setValue(t, n, e) }, B.upload = function (t, e, n, i) { for (let r = 0, a = e.length; r !== a; ++r) { const o = e[r]; const s = n[o.id]; !1 !== s.needsUpdate && o.setValue(t, s.value, i) } }, B.seqWithValue = function (t, e) { for (var n = [], i = 0, r = t.length; i !== r; ++i) { const a = t[i]; a.id in e && n.push(a) } return n }; var mr = { merge: function (t) { for (var e = {}, n = 0; n < t.length; n++) { var i; const r = this.clone(t[n]); for (i in r)e[i] = r[i] } return e }, clone: function (t) { let e; const n = {}; for (e in t) { n[e] = {}; for (const i in t[e]) { const r = t[e][i]; r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? n[e][i] = r.clone() : Array.isArray(r) ? n[e][i] = r.slice() : n[e][i] = r } } return n } }; var gr = {
    alphamap_fragment: '#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n',
    alphamap_pars_fragment: '#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n',
    alphatest_fragment: '#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n',
    aomap_fragment: '#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n',
    aomap_pars_fragment: '#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif',
    begin_vertex: '\nvec3 transformed = vec3( position );\n',
    beginnormal_vertex: '\nvec3 objectNormal = vec3( normal );\n',
    bsdfs: 'float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t\t}\n\t\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 ltcTextureCoords( const in GeometricContext geometry, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = (LUT_SIZE - 1.0)/LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5/LUT_SIZE;\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 P = geometry.position;\n\tfloat theta = acos( dot( N, V ) );\n\tvec2 uv = vec2(\n\t\tsqrt( saturate( roughness ) ),\n\t\tsaturate( theta / ( 0.5 * PI ) ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nvoid clipQuadToHorizon( inout vec3 L[5], out int n ) {\n\tint config = 0;\n\tif ( L[0].z > 0.0 ) config += 1;\n\tif ( L[1].z > 0.0 ) config += 2;\n\tif ( L[2].z > 0.0 ) config += 4;\n\tif ( L[3].z > 0.0 ) config += 8;\n\tn = 0;\n\tif ( config == 0 ) {\n\t} else if ( config == 1 ) {\n\t\tn = 3;\n\t\tL[1] = -L[1].z * L[0] + L[0].z * L[1];\n\t\tL[2] = -L[3].z * L[0] + L[0].z * L[3];\n\t} else if ( config == 2 ) {\n\t\tn = 3;\n\t\tL[0] = -L[0].z * L[1] + L[1].z * L[0];\n\t\tL[2] = -L[2].z * L[1] + L[1].z * L[2];\n\t} else if ( config == 3 ) {\n\t\tn = 4;\n\t\tL[2] = -L[2].z * L[1] + L[1].z * L[2];\n\t\tL[3] = -L[3].z * L[0] + L[0].z * L[3];\n\t} else if ( config == 4 ) {\n\t\tn = 3;\n\t\tL[0] = -L[3].z * L[2] + L[2].z * L[3];\n\t\tL[1] = -L[1].z * L[2] + L[2].z * L[1];\n\t} else if ( config == 5 ) {\n\t\tn = 0;\n\t} else if ( config == 6 ) {\n\t\tn = 4;\n\t\tL[0] = -L[0].z * L[1] + L[1].z * L[0];\n\t\tL[3] = -L[3].z * L[2] + L[2].z * L[3];\n\t} else if ( config == 7 ) {\n\t\tn = 5;\n\t\tL[4] = -L[3].z * L[0] + L[0].z * L[3];\n\t\tL[3] = -L[3].z * L[2] + L[2].z * L[3];\n\t} else if ( config == 8 ) {\n\t\tn = 3;\n\t\tL[0] = -L[0].z * L[3] + L[3].z * L[0];\n\t\tL[1] = -L[2].z * L[3] + L[3].z * L[2];\n\t\tL[2] =  L[3];\n\t} else if ( config == 9 ) {\n\t\tn = 4;\n\t\tL[1] = -L[1].z * L[0] + L[0].z * L[1];\n\t\tL[2] = -L[2].z * L[3] + L[3].z * L[2];\n\t} else if ( config == 10 ) {\n\t\tn = 0;\n\t} else if ( config == 11 ) {\n\t\tn = 5;\n\t\tL[4] = L[3];\n\t\tL[3] = -L[2].z * L[3] + L[3].z * L[2];\n\t\tL[2] = -L[2].z * L[1] + L[1].z * L[2];\n\t} else if ( config == 12 ) {\n\t\tn = 4;\n\t\tL[1] = -L[1].z * L[2] + L[2].z * L[1];\n\t\tL[0] = -L[0].z * L[3] + L[3].z * L[0];\n\t} else if ( config == 13 ) {\n\t\tn = 5;\n\t\tL[4] = L[3];\n\t\tL[3] = L[2];\n\t\tL[2] = -L[1].z * L[2] + L[2].z * L[1];\n\t\tL[1] = -L[1].z * L[0] + L[0].z * L[1];\n\t} else if ( config == 14 ) {\n\t\tn = 5;\n\t\tL[4] = -L[0].z * L[3] + L[3].z * L[0];\n\t\tL[0] = -L[0].z * L[1] + L[1].z * L[0];\n\t} else if ( config == 15 ) {\n\t\tn = 4;\n\t}\n\tif ( n == 3 )\n\t\tL[3] = L[0];\n\tif ( n == 4 )\n\t\tL[4] = L[0];\n}\nfloat integrateLtcBrdfOverRectEdge( vec3 v1, vec3 v2 ) {\n\tfloat cosTheta = dot( v1, v2 );\n\tfloat theta = acos( cosTheta );\n\tfloat res = cross( v1, v2 ).z * ( ( theta > 0.001 ) ? theta / sin( theta ) : 1.0 );\n\treturn res;\n}\nvoid initRectPoints( const in vec3 pos, const in vec3 halfWidth, const in vec3 halfHeight, out vec3 rectPoints[4] ) {\n\trectPoints[0] = pos - halfWidth - halfHeight;\n\trectPoints[1] = pos + halfWidth - halfHeight;\n\trectPoints[2] = pos + halfWidth + halfHeight;\n\trectPoints[3] = pos - halfWidth + halfHeight;\n}\nvec3 integrateLtcBrdfOverRect( const in GeometricContext geometry, const in mat3 brdfMat, const in vec3 rectPoints[4] ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 P = geometry.position;\n\tvec3 T1, T2;\n\tT1 = normalize(V - N * dot( V, N ));\n\tT2 = - cross( N, T1 );\n\tmat3 brdfWrtSurface = brdfMat * transpose( mat3( T1, T2, N ) );\n\tvec3 clippedRect[5];\n\tclippedRect[0] = brdfWrtSurface * ( rectPoints[0] - P );\n\tclippedRect[1] = brdfWrtSurface * ( rectPoints[1] - P );\n\tclippedRect[2] = brdfWrtSurface * ( rectPoints[2] - P );\n\tclippedRect[3] = brdfWrtSurface * ( rectPoints[3] - P );\n\tint n;\n\tclipQuadToHorizon(clippedRect, n);\n\tif ( n == 0 )\n\t\treturn vec3( 0, 0, 0 );\n\tclippedRect[0] = normalize( clippedRect[0] );\n\tclippedRect[1] = normalize( clippedRect[1] );\n\tclippedRect[2] = normalize( clippedRect[2] );\n\tclippedRect[3] = normalize( clippedRect[3] );\n\tclippedRect[4] = normalize( clippedRect[4] );\n\tfloat sum = 0.0;\n\tsum += integrateLtcBrdfOverRectEdge( clippedRect[0], clippedRect[1] );\n\tsum += integrateLtcBrdfOverRectEdge( clippedRect[1], clippedRect[2] );\n\tsum += integrateLtcBrdfOverRectEdge( clippedRect[2], clippedRect[3] );\n\tif (n >= 4)\n\t\tsum += integrateLtcBrdfOverRectEdge( clippedRect[3], clippedRect[4] );\n\tif (n == 5)\n\t\tsum += integrateLtcBrdfOverRectEdge( clippedRect[4], clippedRect[0] );\n\tsum = max( 0.0, sum );\n\tvec3 Lo_i = vec3( sum, sum, sum );\n\treturn Lo_i;\n}\nvec3 Rect_Area_Light_Specular_Reflectance(\n\t\tconst in GeometricContext geometry,\n\t\tconst in vec3 lightPos, const in vec3 lightHalfWidth, const in vec3 lightHalfHeight,\n\t\tconst in float roughness,\n\t\tconst in sampler2D ltcMat, const in sampler2D ltcMag ) {\n\tvec3 rectPoints[4];\n\tinitRectPoints( lightPos, lightHalfWidth, lightHalfHeight, rectPoints );\n\tvec2 uv = ltcTextureCoords( geometry, roughness );\n\tvec4 brdfLtcApproxParams, t;\n\tbrdfLtcApproxParams = texture2D( ltcMat, uv );\n\tt = texture2D( ltcMat, uv );\n\tfloat brdfLtcScalar = texture2D( ltcMag, uv ).a;\n\tmat3 brdfLtcApproxMat = mat3(\n\t\tvec3(   1,   0, t.y ),\n\t\tvec3(   0, t.z,   0 ),\n\t\tvec3( t.w,   0, t.x )\n\t);\n\tvec3 specularReflectance = integrateLtcBrdfOverRect( geometry, brdfLtcApproxMat, rectPoints );\n\tspecularReflectance *= brdfLtcScalar;\n\treturn specularReflectance;\n}\nvec3 Rect_Area_Light_Diffuse_Reflectance(\n\t\tconst in GeometricContext geometry,\n\t\tconst in vec3 lightPos, const in vec3 lightHalfWidth, const in vec3 lightHalfHeight ) {\n\tvec3 rectPoints[4];\n\tinitRectPoints( lightPos, lightHalfWidth, lightHalfHeight, rectPoints );\n\tmat3 diffuseBrdfMat = mat3(1);\n\tvec3 diffuseReflectance = integrateLtcBrdfOverRect( geometry, diffuseBrdfMat, rectPoints );\n\treturn diffuseReflectance;\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n',
    bumpmap_pars_fragment: '#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos );\n\t\tvec3 vSigmaY = dFdy( surf_pos );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n',
    clipping_planes_fragment: '#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t\t\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\t\tvec4 plane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t\n\t#endif\n#endif\n',
    clipping_planes_pars_fragment: '#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n',
    clipping_planes_pars_vertex: '#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n',
    clipping_planes_vertex: '#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n',
    color_fragment: '#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif',
    color_pars_fragment: '#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n',
    color_pars_vertex: '#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif',
    color_vertex: '#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif',
    common: '#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transpose( const in mat3 v ) {\n\tmat3 tmp;\n\ttmp[0] = vec3(v[0].x, v[1].x, v[2].x);\n\ttmp[1] = vec3(v[0].y, v[1].y, v[2].y);\n\ttmp[2] = vec3(v[0].z, v[1].z, v[2].z);\n\treturn tmp;\n}\n',
    cube_uv_reflection_fragment: '#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n',
    defaultnormal_vertex: '#ifdef FLIP_SIDED\n\tobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n',
    displacementmap_pars_vertex: '#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n',
    displacementmap_vertex: '#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n',
    emissivemap_fragment: '#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n',
    emissivemap_pars_fragment: '#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n',
    encodings_fragment: '  gl_FragColor = linearToOutputTexel( gl_FragColor );\n',
    encodings_pars_fragment: '\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n',
    envmap_fragment: '#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n',
    envmap_pars_fragment: '#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n',
    envmap_pars_vertex: '#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n',
    envmap_vertex: '#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n',
    fog_vertex: '\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif',
    fog_pars_vertex: '#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n',
    fog_fragment: '#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n',
    fog_pars_fragment: '#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n',
    gradientmap_pars_fragment: '#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n',
    lightmap_fragment: '#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n',
    lightmap_pars_fragment: '#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif',
    lights_lambert_vertex: 'vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n',
    lights_pars: 'uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltcMat;\tuniform sampler2D ltcMag;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = saturate( reflectVec.y * 0.5 + 0.5 );\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n',
    lights_phong_fragment: 'BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n',
    lights_phong_pars_fragment: 'varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_BlinnPhong( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 matDiffColor = material.diffuseColor;\n\t\tvec3 matSpecColor = material.specularColor;\n\t\tvec3 lightColor   = rectAreaLight.color;\n\t\tfloat roughness = BlinnExponentToGGXRoughness( material.specularShininess );\n\t\tvec3 spec = Rect_Area_Light_Specular_Reflectance(\n\t\t\t\tgeometry,\n\t\t\t\trectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight,\n\t\t\t\troughness,\n\t\t\t\tltcMat, ltcMag );\n\t\tvec3 diff = Rect_Area_Light_Diffuse_Reflectance(\n\t\t\t\tgeometry,\n\t\t\t\trectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight );\n\t\treflectedLight.directSpecular += lightColor * matSpecColor * spec / PI2;\n\t\treflectedLight.directDiffuse  += lightColor * matDiffColor * diff / PI2;\n\t}\n#endif\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n',
    lights_physical_fragment: 'PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n',
    lights_physical_pars_fragment: 'struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 matDiffColor = material.diffuseColor;\n\t\tvec3 matSpecColor = material.specularColor;\n\t\tvec3 lightColor   = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 spec = Rect_Area_Light_Specular_Reflectance(\n\t\t\t\tgeometry,\n\t\t\t\trectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight,\n\t\t\t\troughness,\n\t\t\t\tltcMat, ltcMag );\n\t\tvec3 diff = Rect_Area_Light_Diffuse_Reflectance(\n\t\t\t\tgeometry,\n\t\t\t\trectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight );\n\t\treflectedLight.directSpecular += lightColor * matSpecColor * spec;\n\t\treflectedLight.directDiffuse  += lightColor * matDiffColor * diff;\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n',
    lights_template: '\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n',
    logdepthbuf_fragment: '#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif',
    logdepthbuf_pars_fragment: '#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n',
    logdepthbuf_pars_vertex: '#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif',
    logdepthbuf_vertex: '#ifdef USE_LOGDEPTHBUF\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\t#endif\n#endif\n',
    map_fragment: '#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n',
    map_pars_fragment: '#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n',
    map_particle_fragment: '#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n',
    map_particle_pars_fragment: '#ifdef USE_MAP\n\tuniform vec4 offsetRepeat;\n\tuniform sampler2D map;\n#endif\n',
    metalnessmap_fragment: 'float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.r;\n#endif\n',
    metalnessmap_pars_fragment: '#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif',
    morphnormal_vertex: '#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n',
    morphtarget_pars_vertex: '#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif',
    morphtarget_vertex: '#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n',
    normal_flip: '#ifdef DOUBLE_SIDED\n\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n#else\n\tfloat flipNormal = 1.0;\n#endif\n',
    normal_fragment: '#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal ) * flipNormal;\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n',
    normalmap_pars_fragment: '#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n',
    packing: 'vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 1.0 - 2.0 * rgb.xyz;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n',
    premultiplied_alpha_fragment: '#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n',
    project_vertex: '#ifdef USE_SKINNING\n\tvec4 mvPosition = modelViewMatrix * skinned;\n#else\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n',
    roughnessmap_fragment: 'float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.r;\n#endif\n',
    roughnessmap_pars_fragment: '#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif',
    shadowmap_pars_fragment: '#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn 1.0;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n',
    shadowmap_pars_vertex: '#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n',
    shadowmap_vertex: '#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n',
    shadowmask_pars_fragment: 'float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n',
    skinbase_vertex: '#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif',
    skinning_pars_vertex: '#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureWidth;\n\t\tuniform int boneTextureHeight;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n',
    skinning_vertex: '#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\tskinned  = bindMatrixInverse * skinned;\n#endif\n',
    skinnormal_vertex: '#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n',
    specularmap_fragment: 'float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif',
    specularmap_pars_fragment: '#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif',
    tonemapping_fragment: '#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n',
    tonemapping_pars_fragment: '#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n',
    uv_pars_fragment: '#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif',
    uv_pars_vertex: '#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n#endif\n',
    uv_vertex: '#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif',
    uv2_pars_fragment: '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif',
    uv2_pars_vertex: '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif',
    uv2_vertex: '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif',
    worldpos_vertex: '#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\t#ifdef USE_SKINNING\n\t\tvec4 worldPosition = modelMatrix * skinned;\n\t#else\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t#endif\n#endif\n',
    cube_frag: 'uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n',
    cube_vert: 'varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n',
    depth_frag: '#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n',
    depth_vert: '#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n',
    distanceRGBA_frag: 'uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\n#include <packing>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\n}\n',
    distanceRGBA_vert: 'varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition;\n}\n',
    equirect_frag: 'uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n',
    equirect_vert: 'varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n',
    linedashed_frag: 'uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n',
    linedashed_vert: 'uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n',
    meshbasic_frag: 'uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n',
    meshbasic_vert: '#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n',
    meshlambert_frag: 'uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n',
    meshlambert_vert: '#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n',
    meshphong_frag: '#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n',
    meshphong_vert: '#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n',
    meshphysical_frag: '#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n',
    meshphysical_vert: '#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n',
    normal_frag: '#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n',
    normal_vert: '#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n',
    points_frag: 'uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n',
    points_vert: 'uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n',
    shadow_frag: 'uniform float opacity;\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0 - getShadowMask() ) );\n}\n',
    shadow_vert: '#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n'
  }; j.prototype = { constructor: j, isColor: !0, r: 1, g: 1, b: 1, set: function (t) { return t && t.isColor ? this.copy(t) : typeof t === 'number' ? this.setHex(t) : typeof t === 'string' && this.setStyle(t), this }, setScalar: function (t) { return this.b = this.g = this.r = t, this }, setHex: function (t) { return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this }, setRGB: function (t, e, n) { return this.r = t, this.g = e, this.b = n, this }, setHSL: (function () { function t (t, e, n) { return n < 0 && (n += 1), n > 1 && --n, n < 1 / 6 ? t + 6 * (e - t) * n : n < 0.5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t } return function (e, n, i) { return e = lr.euclideanModulo(e, 1), n = lr.clamp(n, 0, 1), i = lr.clamp(i, 0, 1), n === 0 ? this.r = this.g = this.b = i : (n = i <= 0.5 ? i * (1 + n) : i + n - i * n, i = 2 * i - n, this.r = t(i, n, e + 1 / 3), this.g = t(i, n, e), this.b = t(i, n, e - 1 / 3)), this } }()), setStyle: function (t) { function e (t) { void 0 !== t && parseFloat(t) } let n; if (n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) { var i = n[2]; switch (n[1]) { case 'rgb':case 'rgba':if (n = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(i)) return this.r = Math.min(255, parseInt(n[1], 10)) / 255, this.g = Math.min(255, parseInt(n[2], 10)) / 255, this.b = Math.min(255, parseInt(n[3], 10)) / 255, e(n[5]), this; if (n = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(i)) return this.r = Math.min(100, parseInt(n[1], 10)) / 100, this.g = Math.min(100, parseInt(n[2], 10)) / 100, this.b = Math.min(100, parseInt(n[3], 10)) / 100, e(n[5]), this; break; case 'hsl':case 'hsla':if (n = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(i)) { var i = parseFloat(n[1]) / 360; const r = parseInt(n[2], 10) / 100; const a = parseInt(n[3], 10) / 100; return e(n[5]), this.setHSL(i, r, a) } } } else if (n = /^\#([A-Fa-f0-9]+)$/.exec(t)) { if (n = n[1], (i = n.length) === 3) return this.r = parseInt(n.charAt(0) + n.charAt(0), 16) / 255, this.g = parseInt(n.charAt(1) + n.charAt(1), 16) / 255, this.b = parseInt(n.charAt(2) + n.charAt(2), 16) / 255, this; if (i === 6) return this.r = parseInt(n.charAt(0) + n.charAt(1), 16) / 255, this.g = parseInt(n.charAt(2) + n.charAt(3), 16) / 255, this.b = parseInt(n.charAt(4) + n.charAt(5), 16) / 255, this } return t && t.length > 0 && void 0 !== (n = vr[t]) && this.setHex(n), this }, clone: function () { return new this.constructor(this.r, this.g, this.b) }, copy: function (t) { return this.r = t.r, this.g = t.g, this.b = t.b, this }, copyGammaToLinear: function (t, e) { return void 0 === e && (e = 2), this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this }, copyLinearToGamma: function (t, e) { void 0 === e && (e = 2); const n = e > 0 ? 1 / e : 1; return this.r = Math.pow(t.r, n), this.g = Math.pow(t.g, n), this.b = Math.pow(t.b, n), this }, convertGammaToLinear: function () { const t = this.r; const e = this.g; const n = this.b; return this.r = t * t, this.g = e * e, this.b = n * n, this }, convertLinearToGamma: function () { return this.r = Math.sqrt(this.r), this.g = Math.sqrt(this.g), this.b = Math.sqrt(this.b), this }, getHex: function () { return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0 }, getHexString: function () { return ('000000' + this.getHex().toString(16)).slice(-6) }, getHSL: function (t) { t = t || { h: 0, s: 0, l: 0 }; let e; const n = this.r; const i = this.g; const r = this.b; const a = Math.max(n, i, r); var o = Math.min(n, i, r); const s = (o + a) / 2; if (o === a)o = e = 0; else { const l = a - o; var o = s <= 0.5 ? l / (a + o) : l / (2 - a - o); switch (a) { case n:e = (i - r) / l + (i < r ? 6 : 0); break; case i:e = (r - n) / l + 2; break; case r:e = (n - i) / l + 4 }e /= 6 } return t.h = e, t.s = o, t.l = s, t }, getStyle: function () { return 'rgb(' + (255 * this.r | 0) + ',' + (255 * this.g | 0) + ',' + (255 * this.b | 0) + ')' }, offsetHSL: function (t, e, n) { const i = this.getHSL(); return i.h += t, i.s += e, i.l += n, this.setHSL(i.h, i.s, i.l), this }, add: function (t) { return this.r += t.r, this.g += t.g, this.b += t.b, this }, addColors: function (t, e) { return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this }, addScalar: function (t) { return this.r += t, this.g += t, this.b += t, this }, sub: function (t) { return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this }, multiply: function (t) { return this.r *= t.r, this.g *= t.g, this.b *= t.b, this }, multiplyScalar: function (t) { return this.r *= t, this.g *= t, this.b *= t, this }, lerp: function (t, e) { return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this }, equals: function (t) { return t.r === this.r && t.g === this.g && t.b === this.b }, fromArray: function (t, e) { return void 0 === e && (e = 0), this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this }, toArray: function (t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t }, toJSON: function () { return this.getHex() } }; var vr = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }; V.prototype = Object.create(i.prototype), V.prototype.constructor = V, V.prototype.isDataTexture = !0; var yr = { common: { diffuse: { value: new j(15658734) }, opacity: { value: 1 }, map: { value: null }, offsetRepeat: { value: new r(0, 0, 1, 1) }, specularMap: { value: null }, alphaMap: { value: null }, envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, refractionRatio: { value: 0.98 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new n(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new j(16777215) } }, lights: { ambientLightColor: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {}, shadow: {}, shadowBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {}, shadow: {}, shadowBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotShadowMap: { value: [] }, spotShadowMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {}, shadow: {}, shadowBias: {}, shadowRadius: {}, shadowMapSize: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } } }, points: { diffuse: { value: new j(15658734) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, offsetRepeat: { value: new r(0, 0, 1, 1) } } }; var br = { basic: { uniforms: mr.merge([yr.common, yr.aomap, yr.lightmap, yr.fog]), vertexShader: gr.meshbasic_vert, fragmentShader: gr.meshbasic_frag }, lambert: { uniforms: mr.merge([yr.common, yr.aomap, yr.lightmap, yr.emissivemap, yr.fog, yr.lights, { emissive: { value: new j(0) } }]), vertexShader: gr.meshlambert_vert, fragmentShader: gr.meshlambert_frag }, phong: { uniforms: mr.merge([yr.common, yr.aomap, yr.lightmap, yr.emissivemap, yr.bumpmap, yr.normalmap, yr.displacementmap, yr.gradientmap, yr.fog, yr.lights, { emissive: { value: new j(0) }, specular: { value: new j(1118481) }, shininess: { value: 30 } }]), vertexShader: gr.meshphong_vert, fragmentShader: gr.meshphong_frag }, standard: { uniforms: mr.merge([yr.common, yr.aomap, yr.lightmap, yr.emissivemap, yr.bumpmap, yr.normalmap, yr.displacementmap, yr.roughnessmap, yr.metalnessmap, yr.fog, yr.lights, { emissive: { value: new j(0) }, roughness: { value: 0.5 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: gr.meshphysical_vert, fragmentShader: gr.meshphysical_frag }, points: { uniforms: mr.merge([yr.points, yr.fog]), vertexShader: gr.points_vert, fragmentShader: gr.points_frag }, dashed: { uniforms: mr.merge([yr.common, yr.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: gr.linedashed_vert, fragmentShader: gr.linedashed_frag }, depth: { uniforms: mr.merge([yr.common, yr.displacementmap]), vertexShader: gr.depth_vert, fragmentShader: gr.depth_frag }, normal: { uniforms: mr.merge([yr.common, yr.bumpmap, yr.normalmap, yr.displacementmap, { opacity: { value: 1 } }]), vertexShader: gr.normal_vert, fragmentShader: gr.normal_frag }, cube: { uniforms: { tCube: { value: null }, tFlip: { value: -1 }, opacity: { value: 1 } }, vertexShader: gr.cube_vert, fragmentShader: gr.cube_frag }, equirect: { uniforms: { tEquirect: { value: null }, tFlip: { value: -1 } }, vertexShader: gr.equirect_vert, fragmentShader: gr.equirect_frag }, distanceRGBA: { uniforms: { lightPos: { value: new l() } }, vertexShader: gr.distanceRGBA_vert, fragmentShader: gr.distanceRGBA_frag } }; br.physical = { uniforms: mr.merge([br.standard.uniforms, { clearCoat: { value: 0 }, clearCoatRoughness: { value: 0 } }]), vertexShader: gr.meshphysical_vert, fragmentShader: gr.meshphysical_frag }, G.prototype = { constructor: G, set: function (t, e) { return this.min.copy(t), this.max.copy(e), this }, setFromPoints: function (t) { this.makeEmpty(); for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]); return this }, setFromCenterAndSize: (function () { const t = new n(); return function (e, n) { const i = t.copy(n).multiplyScalar(0.5); return this.min.copy(e).sub(i), this.max.copy(e).add(i), this } }()), clone: function () { return (new this.constructor()).copy(this) }, copy: function (t) { return this.min.copy(t.min), this.max.copy(t.max), this }, makeEmpty: function () { return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this }, isEmpty: function () { return this.max.x < this.min.x || this.max.y < this.min.y }, getCenter: function (t) { return t = t || new n(), this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(0.5) }, getSize: function (t) { return t = t || new n(), this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min) }, expandByPoint: function (t) { return this.min.min(t), this.max.max(t), this }, expandByVector: function (t) { return this.min.sub(t), this.max.add(t), this }, expandByScalar: function (t) { return this.min.addScalar(-t), this.max.addScalar(t), this }, containsPoint: function (t) { return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y) }, containsBox: function (t) { return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y }, getParameter: function (t, e) { return (e || new n()).set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y)) }, intersectsBox: function (t) { return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y) }, clampPoint: function (t, e) { return (e || new n()).copy(t).clamp(this.min, this.max) }, distanceToPoint: (function () { const t = new n(); return function (e) { return t.copy(e).clamp(this.min, this.max).sub(e).length() } }()), intersect: function (t) { return this.min.max(t.min), this.max.min(t.max), this }, union: function (t) { return this.min.min(t.min), this.max.max(t.max), this }, translate: function (t) { return this.min.add(t), this.max.add(t), this }, equals: function (t) { return t.min.equals(this.min) && t.max.equals(this.max) } }; var xr = 0; q.prototype = { constructor: q, isMaterial: !0, get needsUpdate () { return this._needsUpdate }, set needsUpdate (t) { !0 === t && this.update(), this._needsUpdate = t }, setValues: function (t) { if (void 0 !== t) for (const e in t) { const n = t[e]; if (void 0 === n);else { const i = this[e]; void 0 === i || (i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[e] = e === 'overdraw' ? Number(n) : n) } } }, toJSON: function (t) { function e (t) { let e; const n = []; for (e in t) { const i = t[e]; delete i.metadata, n.push(i) } return n } let n = void 0 === t; n && (t = { textures: {}, images: {} }); const i = { metadata: { version: 4.4, type: 'Material', generator: 'Material.toJSON' } }; return i.uuid = this.uuid, i.type = this.type, this.name !== '' && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), void 0 !== this.roughness && (i.roughness = this.roughness), void 0 !== this.metalness && (i.metalness = this.metalness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), void 0 !== this.shininess && (i.shininess = this.shininess), void 0 !== this.clearCoat && (i.clearCoat = this.clearCoat), void 0 !== this.clearCoatRoughness && (i.clearCoatRoughness = this.clearCoatRoughness), this.map && this.map.isTexture && (i.map = this.map.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(t).uuid), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(t).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(t).uuid, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(t).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(t).uuid, i.reflectivity = this.reflectivity), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.size && (i.size = this.size), void 0 !== this.sizeAttenuation && (i.sizeAttenuation = this.sizeAttenuation), this.blending !== 1 && (i.blending = this.blending), this.shading !== 2 && (i.shading = this.shading), this.side !== 0 && (i.side = this.side), this.vertexColors !== 0 && (i.vertexColors = this.vertexColors), this.opacity < 1 && (i.opacity = this.opacity), !0 === this.transparent && (i.transparent = this.transparent), i.depthFunc = this.depthFunc, i.depthTest = this.depthTest, i.depthWrite = this.depthWrite, this.alphaTest > 0 && (i.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (i.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (i.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== 'round' && (i.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== 'round' && (i.wireframeLinejoin = this.wireframeLinejoin), i.skinning = this.skinning, i.morphTargets = this.morphTargets, n && (n = e(t.textures), t = e(t.images), n.length > 0 && (i.textures = n), t.length > 0 && (i.images = t)), i }, clone: function () { return (new this.constructor()).copy(this) }, copy: function (t) { this.name = t.name, this.fog = t.fog, this.lights = t.lights, this.blending = t.blending, this.side = t.side, this.shading = t.shading, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.alphaTest = t.alphaTest, this.premultipliedAlpha = t.premultipliedAlpha, this.overdraw = t.overdraw, this.visible = t.visible, this.clipShadows = t.clipShadows, this.clipIntersection = t.clipIntersection, t = t.clippingPlanes; var e = null; if (t !== null) for (var n = t.length, e = Array(n), i = 0; i !== n; ++i)e[i] = t[i].clone(); return this.clippingPlanes = e, this }, update: function () { this.dispatchEvent({ type: 'update' }) }, dispose: function () { this.dispatchEvent({ type: 'dispose' }) } }, Object.assign(q.prototype, e.prototype), X.prototype = Object.create(q.prototype), X.prototype.constructor = X, X.prototype.isShaderMaterial = !0, X.prototype.copy = function (t) { return q.prototype.copy.call(this, t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = mr.clone(t.uniforms), this.defines = t.defines, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = t.extensions, this }, X.prototype.toJSON = function (t) { return t = q.prototype.toJSON.call(this, t), t.uniforms = this.uniforms, t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t }, Y.prototype = Object.create(q.prototype), Y.prototype.constructor = Y, Y.prototype.isMeshDepthMaterial = !0, Y.prototype.copy = function (t) { return q.prototype.copy.call(this, t), this.depthPacking = t.depthPacking, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this }, Z.prototype = { constructor: Z, isBox3: !0, set: function (t, e) { return this.min.copy(t), this.max.copy(e), this }, setFromArray: function (t) { for (var e = 1 / 0, n = 1 / 0, i = 1 / 0, r = -1 / 0, a = -1 / 0, o = -1 / 0, s = 0, l = t.length; s < l; s += 3) { const c = t[s]; const u = t[s + 1]; const h = t[s + 2]; c < e && (e = c), u < n && (n = u), h < i && (i = h), c > r && (r = c), u > a && (a = u), h > o && (o = h) } return this.min.set(e, n, i), this.max.set(r, a, o), this }, setFromBufferAttribute: function (t) { for (var e = 1 / 0, n = 1 / 0, i = 1 / 0, r = -1 / 0, a = -1 / 0, o = -1 / 0, s = 0, l = t.count; s < l; s++) { const c = t.getX(s); const u = t.getY(s); const h = t.getZ(s); c < e && (e = c), u < n && (n = u), h < i && (i = h), c > r && (r = c), u > a && (a = u), h > o && (o = h) } return this.min.set(e, n, i), this.max.set(r, a, o), this }, setFromPoints: function (t) { this.makeEmpty(); for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]); return this }, setFromCenterAndSize: (function () { const t = new l(); return function (e, n) { const i = t.copy(n).multiplyScalar(0.5); return this.min.copy(e).sub(i), this.max.copy(e).add(i), this } }()), setFromObject: function (t) { return this.makeEmpty(), this.expandByObject(t) }, clone: function () { return (new this.constructor()).copy(this) }, copy: function (t) { return this.min.copy(t.min), this.max.copy(t.max), this }, makeEmpty: function () { return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this }, isEmpty: function () { return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z }, getCenter: function (t) { return t = t || new l(), this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(0.5) }, getSize: function (t) { return t = t || new l(), this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min) }, expandByPoint: function (t) { return this.min.min(t), this.max.max(t), this }, expandByVector: function (t) { return this.min.sub(t), this.max.add(t), this }, expandByScalar: function (t) { return this.min.addScalar(-t), this.max.addScalar(t), this }, expandByObject: (function () { const t = new l(); return function (e) { const n = this; return e.updateMatrixWorld(!0), e.traverse(function (e) { let i, r; if (void 0 !== (i = e.geometry)) if (i.isGeometry) { var a = i.vertices; for (i = 0, r = a.length; i < r; i++)t.copy(a[i]), t.applyMatrix4(e.matrixWorld), n.expandByPoint(t) } else if (i.isBufferGeometry && void 0 !== (a = i.attributes.position)) for (i = 0, r = a.count; i < r; i++)t.fromBufferAttribute(a, i).applyMatrix4(e.matrixWorld), n.expandByPoint(t) }), this } }()), containsPoint: function (t) { return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z) }, containsBox: function (t) { return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z }, getParameter: function (t, e) { return (e || new l()).set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z)) }, intersectsBox: function (t) { return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z) }, intersectsSphere: (function () { let t; return function (e) { return void 0 === t && (t = new l()), this.clampPoint(e.center, t), t.distanceToSquared(e.center) <= e.radius * e.radius } }()), intersectsPlane: function (t) { let e, n; return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= t.constant && n >= t.constant }, clampPoint: function (t, e) { return (e || new l()).copy(t).clamp(this.min, this.max) }, distanceToPoint: (function () { const t = new l(); return function (e) { return t.copy(e).clamp(this.min, this.max).sub(e).length() } }()), getBoundingSphere: (function () { const t = new l(); return function (e) { return e = e || new K(), this.getCenter(e.center), e.radius = 0.5 * this.getSize(t).length(), e } }()), intersect: function (t) { return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this }, union: function (t) { return this.min.min(t.min), this.max.max(t.max), this }, applyMatrix4: (function () { const t = [new l(), new l(), new l(), new l(), new l(), new l(), new l(), new l()]; return function (e) { return this.isEmpty() ? this : (t[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), t[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), t[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), t[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), t[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), t[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), t[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), t[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(t), this) } }()), translate: function (t) { return this.min.add(t), this.max.add(t), this }, equals: function (t) { return t.min.equals(this.min) && t.max.equals(this.max) } }, K.prototype = { constructor: K, set: function (t, e) { return this.center.copy(t), this.radius = e, this }, setFromPoints: (function () { let t; return function (e, n) { void 0 === t && (t = new Z()); const i = this.center; void 0 !== n ? i.copy(n) : t.setFromPoints(e).getCenter(i); for (var r = 0, a = 0, o = e.length; a < o; a++)r = Math.max(r, i.distanceToSquared(e[a])); return this.radius = Math.sqrt(r), this } }()), clone: function () { return (new this.constructor()).copy(this) }, copy: function (t) { return this.center.copy(t.center), this.radius = t.radius, this }, empty: function () { return this.radius <= 0 }, containsPoint: function (t) { return t.distanceToSquared(this.center) <= this.radius * this.radius }, distanceToPoint: function (t) { return t.distanceTo(this.center) - this.radius }, intersectsSphere: function (t) { const e = this.radius + t.radius; return t.center.distanceToSquared(this.center) <= e * e }, intersectsBox: function (t) { return t.intersectsSphere(this) }, intersectsPlane: function (t) { return Math.abs(this.center.dot(t.normal) - t.constant) <= this.radius }, clampPoint: function (t, e) { const n = this.center.distanceToSquared(t); const i = e || new l(); return i.copy(t), n > this.radius * this.radius && (i.sub(this.center).normalize(), i.multiplyScalar(this.radius).add(this.center)), i }, getBoundingBox: function (t) { return t = t || new Z(), t.set(this.center, this.center), t.expandByScalar(this.radius), t }, applyMatrix4: function (t) { return this.center.applyMatrix4(t), this.radius *= t.getMaxScaleOnAxis(), this }, translate: function (t) { return this.center.add(t), this }, equals: function (t) { return t.center.equals(this.center) && t.radius === this.radius } }, J.prototype = { constructor: J, isMatrix3: !0, set: function (t, e, n, i, r, a, o, s, l) { const c = this.elements; return c[0] = t, c[1] = i, c[2] = o, c[3] = e, c[4] = r, c[5] = s, c[6] = n, c[7] = a, c[8] = l, this }, identity: function () { return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this }, clone: function () { return (new this.constructor()).fromArray(this.elements) }, copy: function (t) { return t = t.elements, this.set(t[0], t[3], t[6], t[1], t[4], t[7], t[2], t[5], t[8]), this }, setFromMatrix4: function (t) { return t = t.elements, this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this }, applyToBufferAttribute: (function () { let t; return function (e) { void 0 === t && (t = new l()); for (let n = 0, i = e.count; n < i; n++)t.x = e.getX(n), t.y = e.getY(n), t.z = e.getZ(n), t.applyMatrix3(this), e.setXYZ(n, t.x, t.y, t.z); return e } }()), multiplyScalar: function (t) { const e = this.elements; return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this }, determinant: function () { var t = this.elements; const e = t[0]; const n = t[1]; const i = t[2]; const r = t[3]; const a = t[4]; const o = t[5]; const s = t[6]; const l = t[7]; var t = t[8]; return e * a * t - e * o * l - n * r * t + n * o * s + i * r * l - i * a * s }, getInverse: function (t, e) { t && t.isMatrix4; var n = t.elements; const i = this.elements; const r = n[0]; const a = n[1]; const o = n[2]; const s = n[3]; const l = n[4]; const c = n[5]; const u = n[6]; const h = n[7]; var n = n[8]; const p = n * l - c * h; const d = c * u - n * s; const f = h * s - l * u; let m = r * p + a * d + o * f; if (m === 0) { if (!0 === e) throw Error("THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0"); return this.identity() } return m = 1 / m, i[0] = p * m, i[1] = (o * h - n * a) * m, i[2] = (c * a - o * l) * m, i[3] = d * m, i[4] = (n * r - o * u) * m, i[5] = (o * s - c * r) * m, i[6] = f * m, i[7] = (a * u - h * r) * m, i[8] = (l * r - a * s) * m, this }, transpose: function () { let t; const e = this.elements; return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this }, getNormalMatrix: function (t) { return this.setFromMatrix4(t).getInverse(this).transpose() }, transposeIntoArray: function (t) { const e = this.elements; return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this }, fromArray: function (t, e) { void 0 === e && (e = 0); for (let n = 0; n < 9; n++) this.elements[n] = t[n + e]; return this }, toArray: function (t, e) { void 0 === t && (t = []), void 0 === e && (e = 0); const n = this.elements; return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t } }, Q.prototype = { constructor: Q, set: function (t, e) { return this.normal.copy(t), this.constant = e, this }, setComponents: function (t, e, n, i) { return this.normal.set(t, e, n), this.constant = i, this }, setFromNormalAndCoplanarPoint: function (t, e) { return this.normal.copy(t), this.constant = -e.dot(this.normal), this }, setFromCoplanarPoints: (function () { const t = new l(); const e = new l(); return function (n, i, r) { return i = t.subVectors(r, i).cross(e.subVectors(n, i)).normalize(), this.setFromNormalAndCoplanarPoint(i, n), this } }()), clone: function () { return (new this.constructor()).copy(this) }, copy: function (t) { return this.normal.copy(t.normal), this.constant = t.constant, this }, normalize: function () { const t = 1 / this.normal.length(); return this.normal.multiplyScalar(t), this.constant *= t, this }, negate: function () { return this.constant *= -1, this.normal.negate(), this }, distanceToPoint: function (t) { return this.normal.dot(t) + this.constant }, distanceToSphere: function (t) { return this.distanceToPoint(t.center) - t.radius }, projectPoint: function (t, e) { return this.orthoPoint(t, e).sub(t).negate() }, orthoPoint: function (t, e) { const n = this.distanceToPoint(t); return (e || new l()).copy(this.normal).multiplyScalar(n) }, intersectLine: (function () { const t = new l(); return function (e, n) { const i = n || new l(); const r = e.delta(t); let a = this.normal.dot(r); return a !== 0 ? (a = -(e.start.dot(this.normal) + this.constant) / a, a < 0 || a > 1 ? void 0 : i.copy(r).multiplyScalar(a).add(e.start)) : this.distanceToPoint(e.start) === 0 ? i.copy(e.start) : void 0 } }()), intersectsLine: function (t) { const e = this.distanceToPoint(t.start); return t = this.distanceToPoint(t.end), e < 0 && t > 0 || t < 0 && e > 0 }, intersectsBox: function (t) { return t.intersectsPlane(this) }, intersectsSphere: function (t) { return t.intersectsPlane(this) }, coplanarPoint: function (t) { return (t || new l()).copy(this.normal).multiplyScalar(-this.constant) }, applyMatrix4: (function () { const t = new l(); const e = new J(); return function (n, i) { const r = this.coplanarPoint(t).applyMatrix4(n); var a = i || e.getNormalMatrix(n); var a = this.normal.applyMatrix3(a).normalize(); return this.constant = -r.dot(a), this } }()), translate: function (t) { return this.constant -= t.dot(this.normal), this }, equals: function (t) { return t.normal.equals(this.normal) && t.constant === this.constant } }, tt.prototype = {
    constructor: tt,
    set: function (t, e, n, i, r, a) { const o = this.planes; return o[0].copy(t), o[1].copy(e), o[2].copy(n), o[3].copy(i), o[4].copy(r), o[5].copy(a), this },
    clone: function () { return (new this.constructor()).copy(this) },
    copy: function (t) { for (let e = this.planes, n = 0; n < 6; n++)e[n].copy(t.planes[n]); return this },
    setFromMatrix: function (t) { const e = this.planes; var n = t.elements; t = n[0]; const i = n[1]; const r = n[2]; const a = n[3]; const o = n[4]; const s = n[5]; const l = n[6]; const c = n[7]; const u = n[8]; const h = n[9]; const p = n[10]; const d = n[11]; const f = n[12]; const m = n[13]; const g = n[14]; var n = n[15]; return e[0].setComponents(a - t, c - o, d - u, n - f).normalize(), e[1].setComponents(a + t, c + o, d + u, n + f).normalize(), e[2].setComponents(a + i, c + s, d + h, n + m).normalize(), e[3].setComponents(a - i, c - s, d - h, n - m).normalize(), e[4].setComponents(a - r, c - l, d - p, n - g).normalize(), e[5].setComponents(a + r, c + l, d + p, n + g).normalize(), this },
    intersectsObject: (function () {
      const t = new K(); return function (e) {
        const n = e.geometry
        return n.boundingSphere === null && n.computeBoundingSphere(), t.copy(n.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(t)
      }
    }()),
    intersectsSprite: (function () { const t = new K(); return function (e) { return t.center.set(0, 0, 0), t.radius = 0.7071067811865476, t.applyMatrix4(e.matrixWorld), this.intersectsSphere(t) } }()),
    intersectsSphere: function (t) { const e = this.planes; const n = t.center; t = -t.radius; for (let i = 0; i < 6; i++) if (e[i].distanceToPoint(n) < t) return !1; return !0 },
    intersectsBox: (function () { const t = new l(); const e = new l(); return function (n) { for (let i = this.planes, r = 0; r < 6; r++) { var a = i[r]; t.x = a.normal.x > 0 ? n.min.x : n.max.x, e.x = a.normal.x > 0 ? n.max.x : n.min.x, t.y = a.normal.y > 0 ? n.min.y : n.max.y, e.y = a.normal.y > 0 ? n.max.y : n.min.y, t.z = a.normal.z > 0 ? n.min.z : n.max.z, e.z = a.normal.z > 0 ? n.max.z : n.min.z; const o = a.distanceToPoint(t); var a = a.distanceToPoint(e); if (o < 0 && a < 0) return !1 } return !0 } }()),
    containsPoint: function (t) { for (let e = this.planes, n = 0; n < 6; n++) if (e[n].distanceToPoint(t) < 0) return !1; return !0 }
  }, nt.prototype = { constructor: nt, set: function (t, e) { return this.origin.copy(t), this.direction.copy(e), this }, clone: function () { return (new this.constructor()).copy(this) }, copy: function (t) { return this.origin.copy(t.origin), this.direction.copy(t.direction), this }, at: function (t, e) { return (e || new l()).copy(this.direction).multiplyScalar(t).add(this.origin) }, lookAt: function (t) { return this.direction.copy(t).sub(this.origin).normalize(), this }, recast: (function () { const t = new l(); return function (e) { return this.origin.copy(this.at(e, t)), this } }()), closestPointToPoint: function (t, e) { const n = e || new l(); n.subVectors(t, this.origin); const i = n.dot(this.direction); return i < 0 ? n.copy(this.origin) : n.copy(this.direction).multiplyScalar(i).add(this.origin) }, distanceToPoint: function (t) { return Math.sqrt(this.distanceSqToPoint(t)) }, distanceSqToPoint: (function () { const t = new l(); return function (e) { const n = t.subVectors(e, this.origin).dot(this.direction); return n < 0 ? this.origin.distanceToSquared(e) : (t.copy(this.direction).multiplyScalar(n).add(this.origin), t.distanceToSquared(e)) } }()), distanceSqToSegment: (function () { const t = new l(); const e = new l(); const n = new l(); return function (i, r, a, o) { t.copy(i).add(r).multiplyScalar(0.5), e.copy(r).sub(i).normalize(), n.copy(this.origin).sub(t); let s; let l = 0.5 * i.distanceTo(r); let c = -this.direction.dot(e); const u = n.dot(this.direction); const h = -n.dot(e); const p = n.lengthSq(); const d = Math.abs(1 - c * c); return d > 0 ? (i = c * h - u, r = c * u - h, s = l * d, i >= 0 ? r >= -s ? r <= s ? (l = 1 / d, i *= l, r *= l, c = i * (i + c * r + 2 * u) + r * (c * i + r + 2 * h) + p) : (r = l, i = Math.max(0, -(c * r + u)), c = -i * i + r * (r + 2 * h) + p) : (r = -l, i = Math.max(0, -(c * r + u)), c = -i * i + r * (r + 2 * h) + p) : r <= -s ? (i = Math.max(0, -(-c * l + u)), r = i > 0 ? -l : Math.min(Math.max(-l, -h), l), c = -i * i + r * (r + 2 * h) + p) : r <= s ? (i = 0, r = Math.min(Math.max(-l, -h), l), c = r * (r + 2 * h) + p) : (i = Math.max(0, -(c * l + u)), r = i > 0 ? l : Math.min(Math.max(-l, -h), l), c = -i * i + r * (r + 2 * h) + p)) : (r = c > 0 ? -l : l, i = Math.max(0, -(c * r + u)), c = -i * i + r * (r + 2 * h) + p), a && a.copy(this.direction).multiplyScalar(i).add(this.origin), o && o.copy(e).multiplyScalar(r).add(t), c } }()), intersectSphere: (function () { const t = new l(); return function (e, n) { t.subVectors(e.center, this.origin); let i = t.dot(this.direction); let r = t.dot(t) - i * i; let a = e.radius * e.radius; return r > a ? null : (a = Math.sqrt(a - r), r = i - a, i += a, r < 0 && i < 0 ? null : r < 0 ? this.at(i, n) : this.at(r, n)) } }()), intersectsSphere: function (t) { return this.distanceToPoint(t.center) <= t.radius }, distanceToPlane: function (t) { const e = t.normal.dot(this.direction); return e === 0 ? t.distanceToPoint(this.origin) === 0 ? 0 : null : (t = -(this.origin.dot(t.normal) + t.constant) / e, t >= 0 ? t : null) }, intersectPlane: function (t, e) { const n = this.distanceToPlane(t); return n === null ? null : this.at(n, e) }, intersectsPlane: function (t) { const e = t.distanceToPoint(this.origin); return e === 0 || t.normal.dot(this.direction) * e < 0 }, intersectBox: function (t, e) { let n, i, r, a, o; i = 1 / this.direction.x, a = 1 / this.direction.y, o = 1 / this.direction.z; const s = this.origin; return i >= 0 ? (n = (t.min.x - s.x) * i, i *= t.max.x - s.x) : (n = (t.max.x - s.x) * i, i *= t.min.x - s.x), a >= 0 ? (r = (t.min.y - s.y) * a, a *= t.max.y - s.y) : (r = (t.max.y - s.y) * a, a *= t.min.y - s.y), n > a || r > i ? null : ((r > n || n !== n) && (n = r), (a < i || i !== i) && (i = a), o >= 0 ? (r = (t.min.z - s.z) * o, o *= t.max.z - s.z) : (r = (t.max.z - s.z) * o, o *= t.min.z - s.z), n > o || r > i ? null : ((r > n || n !== n) && (n = r), (o < i || i !== i) && (i = o), i < 0 ? null : this.at(n >= 0 ? n : i, e))) }, intersectsBox: (function () { const t = new l(); return function (e) { return this.intersectBox(e, t) !== null } }()), intersectTriangle: (function () { const t = new l(); const e = new l(); const n = new l(); const i = new l(); return function (r, a, o, s, l) { if (e.subVectors(a, r), n.subVectors(o, r), i.crossVectors(e, n), (a = this.direction.dot(i)) > 0) { if (s) return null; s = 1 } else { if (!(a < 0)) return null; s = -1, a = -a } return t.subVectors(this.origin, r), (r = s * this.direction.dot(n.crossVectors(t, n))) < 0 ? null : (o = s * this.direction.dot(e.cross(t))) < 0 || r + o > a ? null : (r = -s * t.dot(i), r < 0 ? null : this.at(r / a, l)) } }()), applyMatrix4: function (t) { return this.direction.add(this.origin).applyMatrix4(t), this.origin.applyMatrix4(t), this.direction.sub(this.origin), this.direction.normalize(), this }, equals: function (t) { return t.origin.equals(this.origin) && t.direction.equals(this.direction) } }, it.RotationOrders = 'XYZ YZX ZXY XZY YXZ ZYX'.split(' '), it.DefaultOrder = 'XYZ', it.prototype = { constructor: it, isEuler: !0, get x () { return this._x }, set x (t) { this._x = t, this.onChangeCallback() }, get y () { return this._y }, set y (t) { this._y = t, this.onChangeCallback() }, get z () { return this._z }, set z (t) { this._z = t, this.onChangeCallback() }, get order () { return this._order }, set order (t) { this._order = t, this.onChangeCallback() }, set: function (t, e, n, i) { return this._x = t, this._y = e, this._z = n, this._order = i || this._order, this.onChangeCallback(), this }, clone: function () { return new this.constructor(this._x, this._y, this._z, this._order) }, copy: function (t) { return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this.onChangeCallback(), this }, setFromRotationMatrix: function (t, e, n) { const i = lr.clamp; var r = t.elements; t = r[0]; const a = r[4]; const o = r[8]; const s = r[1]; const l = r[5]; const c = r[9]; const u = r[2]; const h = r[6]; var r = r[10]; return e = e || this._order, e === 'XYZ' ? (this._y = Math.asin(i(o, -1, 1)), Math.abs(o) < 0.99999 ? (this._x = Math.atan2(-c, r), this._z = Math.atan2(-a, t)) : (this._x = Math.atan2(h, l), this._z = 0)) : e === 'YXZ' ? (this._x = Math.asin(-i(c, -1, 1)), Math.abs(c) < 0.99999 ? (this._y = Math.atan2(o, r), this._z = Math.atan2(s, l)) : (this._y = Math.atan2(-u, t), this._z = 0)) : e === 'ZXY' ? (this._x = Math.asin(i(h, -1, 1)), Math.abs(h) < 0.99999 ? (this._y = Math.atan2(-u, r), this._z = Math.atan2(-a, l)) : (this._y = 0, this._z = Math.atan2(s, t))) : e === 'ZYX' ? (this._y = Math.asin(-i(u, -1, 1)), Math.abs(u) < 0.99999 ? (this._x = Math.atan2(h, r), this._z = Math.atan2(s, t)) : (this._x = 0, this._z = Math.atan2(-a, l))) : e === 'YZX' ? (this._z = Math.asin(i(s, -1, 1)), Math.abs(s) < 0.99999 ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-u, t)) : (this._x = 0, this._y = Math.atan2(o, r))) : e === 'XZY' && (this._z = Math.asin(-i(a, -1, 1)), Math.abs(a) < 0.99999 ? (this._x = Math.atan2(h, l), this._y = Math.atan2(o, t)) : (this._x = Math.atan2(-c, r), this._y = 0)), this._order = e, !1 !== n && this.onChangeCallback(), this }, setFromQuaternion: (function () { let t; return function (e, n, i) { return void 0 === t && (t = new c()), t.makeRotationFromQuaternion(e), this.setFromRotationMatrix(t, n, i) } }()), setFromVector3: function (t, e) { return this.set(t.x, t.y, t.z, e || this._order) }, reorder: (function () { const t = new s(); return function (e) { return t.setFromEuler(this), this.setFromQuaternion(t, e) } }()), equals: function (t) { return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order }, fromArray: function (t) { return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this.onChangeCallback(), this }, toArray: function (t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t }, toVector3: function (t) { return t ? t.set(this._x, this._y, this._z) : new l(this._x, this._y, this._z) }, onChange: function (t) { return this.onChangeCallback = t, this }, onChangeCallback: function () {} }, rt.prototype = { constructor: rt, set: function (t) { this.mask = 1 << t }, enable: function (t) { this.mask |= 1 << t }, toggle: function (t) { this.mask ^= 1 << t }, disable: function (t) { this.mask &= ~(1 << t) }, test: function (t) { return (this.mask & t.mask) != 0 } }; var wr = 0; at.DefaultUp = new l(0, 1, 0), at.DefaultMatrixAutoUpdate = !0, at.prototype = { constructor: at, isObject3D: !0, applyMatrix: function (t) { this.matrix.multiplyMatrices(t, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale) }, setRotationFromAxisAngle: function (t, e) { this.quaternion.setFromAxisAngle(t, e) }, setRotationFromEuler: function (t) { this.quaternion.setFromEuler(t, !0) }, setRotationFromMatrix: function (t) { this.quaternion.setFromRotationMatrix(t) }, setRotationFromQuaternion: function (t) { this.quaternion.copy(t) }, rotateOnAxis: (function () { const t = new s(); return function (e, n) { return t.setFromAxisAngle(e, n), this.quaternion.multiply(t), this } }()), rotateX: (function () { const t = new l(1, 0, 0); return function (e) { return this.rotateOnAxis(t, e) } }()), rotateY: (function () { const t = new l(0, 1, 0); return function (e) { return this.rotateOnAxis(t, e) } }()), rotateZ: (function () { const t = new l(0, 0, 1); return function (e) { return this.rotateOnAxis(t, e) } }()), translateOnAxis: (function () { const t = new l(); return function (e, n) { return t.copy(e).applyQuaternion(this.quaternion), this.position.add(t.multiplyScalar(n)), this } }()), translateX: (function () { const t = new l(1, 0, 0); return function (e) { return this.translateOnAxis(t, e) } }()), translateY: (function () { const t = new l(0, 1, 0); return function (e) { return this.translateOnAxis(t, e) } }()), translateZ: (function () { const t = new l(0, 0, 1); return function (e) { return this.translateOnAxis(t, e) } }()), localToWorld: function (t) { return t.applyMatrix4(this.matrixWorld) }, worldToLocal: (function () { const t = new c(); return function (e) { return e.applyMatrix4(t.getInverse(this.matrixWorld)) } }()), lookAt: (function () { const t = new c(); return function (e) { t.lookAt(e, this.position, this.up), this.quaternion.setFromRotationMatrix(t) } }()), add: function (t) { if (arguments.length > 1) { for (let e = 0; e < arguments.length; e++) this.add(arguments[e]); return this } return t === this ? this : (t && t.isObject3D && (t.parent !== null && t.parent.remove(t), t.parent = this, t.dispatchEvent({ type: 'added' }), this.children.push(t)), this) }, remove: function (t) { if (arguments.length > 1) for (var e = 0; e < arguments.length; e++) this.remove(arguments[e]); (e = this.children.indexOf(t)) !== -1 && (t.parent = null, t.dispatchEvent({ type: 'removed' }), this.children.splice(e, 1)) }, getObjectById: function (t) { return this.getObjectByProperty('id', t) }, getObjectByName: function (t) { return this.getObjectByProperty('name', t) }, getObjectByProperty: function (t, e) { if (this[t] === e) return this; for (let n = 0, i = this.children.length; n < i; n++) { const r = this.children[n].getObjectByProperty(t, e); if (void 0 !== r) return r } }, getWorldPosition: function (t) { return t = t || new l(), this.updateMatrixWorld(!0), t.setFromMatrixPosition(this.matrixWorld) }, getWorldQuaternion: (function () { const t = new l(); const e = new l(); return function (n) { return n = n || new s(), this.updateMatrixWorld(!0), this.matrixWorld.decompose(t, n, e), n } }()), getWorldRotation: (function () { const t = new s(); return function (e) { return e = e || new it(), this.getWorldQuaternion(t), e.setFromQuaternion(t, this.rotation.order, !1) } }()), getWorldScale: (function () { const t = new l(); const e = new s(); return function (n) { return n = n || new l(), this.updateMatrixWorld(!0), this.matrixWorld.decompose(t, e, n), n } }()), getWorldDirection: (function () { const t = new s(); return function (e) { return e = e || new l(), this.getWorldQuaternion(t), e.set(0, 0, 1).applyQuaternion(t) } }()), raycast: function () {}, traverse: function (t) { t(this); for (let e = this.children, n = 0, i = e.length; n < i; n++)e[n].traverse(t) }, traverseVisible: function (t) { if (!1 !== this.visible) { t(this); for (let e = this.children, n = 0, i = e.length; n < i; n++)e[n].traverseVisible(t) } }, traverseAncestors: function (t) { const e = this.parent; e !== null && (t(e), e.traverseAncestors(t)) }, updateMatrix: function () { this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0 }, updateMatrixWorld: function (t) { !0 === this.matrixAutoUpdate && this.updateMatrix(), !0 !== this.matrixWorldNeedsUpdate && !0 !== t || (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0); for (let e = this.children, n = 0, i = e.length; n < i; n++)e[n].updateMatrixWorld(t) }, toJSON: function (t) { function e (t) { let e; const n = []; for (e in t) { const i = t[e]; delete i.metadata, n.push(i) } return n } var n = void 0 === t || t === ''; const i = {}; n && (t = { geometries: {}, materials: {}, textures: {}, images: {} }, i.metadata = { version: 4.4, type: 'Object', generator: 'Object3D.toJSON' }); const r = {}; if (r.uuid = this.uuid, r.type = this.type, this.name !== '' && (r.name = this.name), JSON.stringify(this.userData) !== '{}' && (r.userData = this.userData), !0 === this.castShadow && (r.castShadow = !0), !0 === this.receiveShadow && (r.receiveShadow = !0), !1 === this.visible && (r.visible = !1), r.matrix = this.matrix.toArray(), void 0 !== this.geometry && (void 0 === t.geometries[this.geometry.uuid] && (t.geometries[this.geometry.uuid] = this.geometry.toJSON(t)), r.geometry = this.geometry.uuid), void 0 !== this.material && (void 0 === t.materials[this.material.uuid] && (t.materials[this.material.uuid] = this.material.toJSON(t)), r.material = this.material.uuid), this.children.length > 0) { r.children = []; for (var a = 0; a < this.children.length; a++)r.children.push(this.children[a].toJSON(t).object) } if (n) { var n = e(t.geometries); var a = e(t.materials); const o = e(t.textures); t = e(t.images), n.length > 0 && (i.geometries = n), a.length > 0 && (i.materials = a), o.length > 0 && (i.textures = o), t.length > 0 && (i.images = t) } return i.object = r, i }, clone: function (t) { return (new this.constructor()).copy(this, t) }, copy: function (t, e) { if (void 0 === e && (e = !0), this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e) for (let n = 0; n < t.children.length; n++) this.add(t.children[n].clone()); return this } }, Object.assign(at.prototype, e.prototype), ot.prototype = { constructor: ot, set: function (t, e) { return this.start.copy(t), this.end.copy(e), this }, clone: function () { return (new this.constructor()).copy(this) }, copy: function (t) { return this.start.copy(t.start), this.end.copy(t.end), this }, getCenter: function (t) { return (t || new l()).addVectors(this.start, this.end).multiplyScalar(0.5) }, delta: function (t) { return (t || new l()).subVectors(this.end, this.start) }, distanceSq: function () { return this.start.distanceToSquared(this.end) }, distance: function () { return this.start.distanceTo(this.end) }, at: function (t, e) { const n = e || new l(); return this.delta(n).multiplyScalar(t).add(this.start) }, closestPointToPointParameter: (function () { const t = new l(); const e = new l(); return function (n, i) { t.subVectors(n, this.start), e.subVectors(this.end, this.start); var r = e.dot(e); var r = e.dot(t) / r; return i && (r = lr.clamp(r, 0, 1)), r } }()), closestPointToPoint: function (t, e, n) { return t = this.closestPointToPointParameter(t, e), n = n || new l(), this.delta(n).multiplyScalar(t).add(this.start) }, applyMatrix4: function (t) { return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this }, equals: function (t) { return t.start.equals(this.start) && t.end.equals(this.end) } }, st.normal = (function () { const t = new l(); return function (e, n, i, r) { return r = r || new l(), r.subVectors(i, n), t.subVectors(e, n), r.cross(t), e = r.lengthSq(), e > 0 ? r.multiplyScalar(1 / Math.sqrt(e)) : r.set(0, 0, 0) } }()), st.barycoordFromPoint = (function () { const t = new l(); const e = new l(); const n = new l(); return function (i, r, a, o, s) { t.subVectors(o, r), e.subVectors(a, r), n.subVectors(i, r), i = t.dot(t), r = t.dot(e), a = t.dot(n); let c = e.dot(e); o = e.dot(n); let u = i * c - r * r; return s = s || new l(), u === 0 ? s.set(-2, -1, -1) : (u = 1 / u, c = (c * a - r * o) * u, i = (i * o - r * a) * u, s.set(1 - c - i, i, c)) } }()), st.containsPoint = (function () { const t = new l(); return function (e, n, i, r) { return e = st.barycoordFromPoint(e, n, i, r, t), e.x >= 0 && e.y >= 0 && e.x + e.y <= 1 } }()), st.prototype = { constructor: st, set: function (t, e, n) { return this.a.copy(t), this.b.copy(e), this.c.copy(n), this }, setFromPointsAndIndices: function (t, e, n, i) { return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this }, clone: function () { return (new this.constructor()).copy(this) }, copy: function (t) { return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this }, area: (function () { const t = new l(); const e = new l(); return function () { return t.subVectors(this.c, this.b), e.subVectors(this.a, this.b), 0.5 * t.cross(e).length() } }()), midpoint: function (t) { return (t || new l()).addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3) }, normal: function (t) { return st.normal(this.a, this.b, this.c, t) }, plane: function (t) { return (t || new Q()).setFromCoplanarPoints(this.a, this.b, this.c) }, barycoordFromPoint: function (t, e) { return st.barycoordFromPoint(t, this.a, this.b, this.c, e) }, containsPoint: function (t) { return st.containsPoint(t, this.a, this.b, this.c) }, closestPointToPoint: (function () { let t, e, n, i; return function (r, a) { void 0 === t && (t = new Q(), e = [new ot(), new ot(), new ot()], n = new l(), i = new l()); const o = a || new l(); let s = 1 / 0; if (t.setFromCoplanarPoints(this.a, this.b, this.c), t.projectPoint(r, n), !0 === this.containsPoint(n))o.copy(n); else { e[0].set(this.a, this.b), e[1].set(this.b, this.c), e[2].set(this.c, this.a); for (let c = 0; c < e.length; c++) { e[c].closestPointToPoint(n, !0, i); const u = n.distanceToSquared(i); u < s && (s = u, o.copy(i)) } } return o } }()), equals: function (t) { return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c) } }, lt.prototype = { constructor: lt, clone: function () { return (new this.constructor()).copy(this) }, copy: function (t) { this.a = t.a, this.b = t.b, this.c = t.c, this.normal.copy(t.normal), this.color.copy(t.color), this.materialIndex = t.materialIndex; for (var e = 0, n = t.vertexNormals.length; e < n; e++) this.vertexNormals[e] = t.vertexNormals[e].clone(); for (e = 0, n = t.vertexColors.length; e < n; e++) this.vertexColors[e] = t.vertexColors[e].clone(); return this } }, ct.prototype = Object.create(q.prototype), ct.prototype.constructor = ct, ct.prototype.isMeshBasicMaterial = !0, ct.prototype.copy = function (t) { return q.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this }, ut.prototype = { constructor: ut, isBufferAttribute: !0, set needsUpdate (t) { !0 === t && this.version++ }, setArray: function (t) { if (Array.isArray(t)) throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.'); this.count = void 0 !== t ? t.length / this.itemSize : 0, this.array = t }, setDynamic: function (t) { return this.dynamic = t, this }, copy: function (t) { return this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.dynamic = t.dynamic, this }, copyAt: function (t, e, n) { t *= this.itemSize, n *= e.itemSize; for (let i = 0, r = this.itemSize; i < r; i++) this.array[t + i] = e.array[n + i]; return this }, copyArray: function (t) { return this.array.set(t), this }, copyColorsArray: function (t) { for (let e = this.array, n = 0, i = 0, r = t.length; i < r; i++) { let a = t[i]; void 0 === a && (a = new j()), e[n++] = a.r, e[n++] = a.g, e[n++] = a.b } return this }, copyIndicesArray: function (t) { for (let e = this.array, n = 0, i = 0, r = t.length; i < r; i++) { const a = t[i]; e[n++] = a.a, e[n++] = a.b, e[n++] = a.c } return this }, copyVector2sArray: function (t) { for (let e = this.array, i = 0, r = 0, a = t.length; r < a; r++) { let o = t[r]; void 0 === o && (o = new n()), e[i++] = o.x, e[i++] = o.y } return this }, copyVector3sArray: function (t) { for (let e = this.array, n = 0, i = 0, r = t.length; i < r; i++) { let a = t[i]; void 0 === a && (a = new l()), e[n++] = a.x, e[n++] = a.y, e[n++] = a.z } return this }, copyVector4sArray: function (t) { for (let e = this.array, n = 0, i = 0, a = t.length; i < a; i++) { let o = t[i]; void 0 === o && (o = new r()), e[n++] = o.x, e[n++] = o.y, e[n++] = o.z, e[n++] = o.w } return this }, set: function (t, e) { return void 0 === e && (e = 0), this.array.set(t, e), this }, getX: function (t) { return this.array[t * this.itemSize] }, setX: function (t, e) { return this.array[t * this.itemSize] = e, this }, getY: function (t) { return this.array[t * this.itemSize + 1] }, setY: function (t, e) { return this.array[t * this.itemSize + 1] = e, this }, getZ: function (t) { return this.array[t * this.itemSize + 2] }, setZ: function (t, e) { return this.array[t * this.itemSize + 2] = e, this }, getW: function (t) { return this.array[t * this.itemSize + 3] }, setW: function (t, e) { return this.array[t * this.itemSize + 3] = e, this }, setXY: function (t, e, n) { return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this }, setXYZ: function (t, e, n, i) { return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this }, setXYZW: function (t, e, n, i, r) { return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this.array[t + 3] = r, this }, onUpload: function (t) { return this.onUploadCallback = t, this }, clone: function () { return new this.constructor(this.array, this.itemSize).copy(this) } }, ht.prototype = Object.create(ut.prototype), ht.prototype.constructor = ht, pt.prototype = Object.create(ut.prototype), pt.prototype.constructor = pt, dt.prototype = Object.create(ut.prototype), dt.prototype.constructor = dt, ft.prototype = Object.create(ut.prototype), ft.prototype.constructor = ft, mt.prototype = Object.create(ut.prototype), mt.prototype.constructor = mt, gt.prototype = Object.create(ut.prototype), gt.prototype.constructor = gt, vt.prototype = Object.create(ut.prototype), vt.prototype.constructor = vt, yt.prototype = Object.create(ut.prototype), yt.prototype.constructor = yt, bt.prototype = Object.create(ut.prototype), bt.prototype.constructor = bt, Object.assign(xt.prototype, { computeGroups: function (t) { let e; const n = []; let i = void 0; t = t.faces; for (var r = 0; r < t.length; r++) { const a = t[r]; a.materialIndex !== i && (i = a.materialIndex, void 0 !== e && (e.count = 3 * r - e.start, n.push(e)), e = { start: 3 * r, materialIndex: i }) } void 0 !== e && (e.count = 3 * r - e.start, n.push(e)), this.groups = n }, fromGeometry: function (t) { let e; const i = t.faces; const r = t.vertices; const a = t.faceVertexUvs; const o = a[0] && a[0].length > 0; const s = a[1] && a[1].length > 0; const l = t.morphTargets; const c = l.length; if (c > 0) { e = []; for (var u = 0; u < c; u++)e[u] = []; this.morphTargets.position = e } let h; const p = t.morphNormals; const d = p.length; if (d > 0) { for (h = [], u = 0; u < d; u++)h[u] = []; this.morphTargets.normal = h } for (var f = t.skinIndices, m = t.skinWeights, g = f.length === r.length, v = m.length === r.length, u = 0; u < i.length; u++) { const y = i[u]; this.vertices.push(r[y.a], r[y.b], r[y.c]); let b = y.vertexNormals; for (b.length === 3 ? this.normals.push(b[0], b[1], b[2]) : (b = y.normal, this.normals.push(b, b, b)), b = y.vertexColors, b.length === 3 ? this.colors.push(b[0], b[1], b[2]) : (b = y.color, this.colors.push(b, b, b)), !0 === o && (b = a[0][u], void 0 !== b ? this.uvs.push(b[0], b[1], b[2]) : this.uvs.push(new n(), new n(), new n())), !0 === s && (b = a[1][u], void 0 !== b ? this.uvs2.push(b[0], b[1], b[2]) : this.uvs2.push(new n(), new n(), new n())), b = 0; b < c; b++) { var x = l[b].vertices; e[b].push(x[y.a], x[y.b], x[y.c]) } for (b = 0; b < d; b++)x = p[b].vertexNormals[u], h[b].push(x.a, x.b, x.c); g && this.skinIndices.push(f[y.a], f[y.b], f[y.c]), v && this.skinWeights.push(m[y.a], m[y.b], m[y.c]) } return this.computeGroups(t), this.verticesNeedUpdate = t.verticesNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this } }); var _r = 0; _t.prototype = {
    constructor: _t,
    isGeometry: !0,
    applyMatrix: function (t) { for (var e = (new J()).getNormalMatrix(t), n = 0, i = this.vertices.length; n < i; n++) this.vertices[n].applyMatrix4(t); for (n = 0, i = this.faces.length; n < i; n++) { t = this.faces[n], t.normal.applyMatrix3(e).normalize(); for (let r = 0, a = t.vertexNormals.length; r < a; r++)t.vertexNormals[r].applyMatrix3(e).normalize() } return this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this.normalsNeedUpdate = this.verticesNeedUpdate = !0, this },
    rotateX: (function () { let t; return function (e) { return void 0 === t && (t = new c()), t.makeRotationX(e), this.applyMatrix(t), this } }()),
    rotateY: (function () { let t; return function (e) { return void 0 === t && (t = new c()), t.makeRotationY(e), this.applyMatrix(t), this } }()),
    rotateZ: (function () { let t; return function (e) { return void 0 === t && (t = new c()), t.makeRotationZ(e), this.applyMatrix(t), this } }()),
    translate: (function () { let t; return function (e, n, i) { return void 0 === t && (t = new c()), t.makeTranslation(e, n, i), this.applyMatrix(t), this } }()),
    scale: (function () { let t; return function (e, n, i) { return void 0 === t && (t = new c()), t.makeScale(e, n, i), this.applyMatrix(t), this } }()),
    lookAt: (function () { let t; return function (e) { void 0 === t && (t = new at()), t.lookAt(e), t.updateMatrix(), this.applyMatrix(t.matrix) } }()),
    fromBufferGeometry: function (t) { function e (t, e, n, r) { r = new lt(t, e, n, void 0 !== s ? [p[t].clone(), p[e].clone(), p[n].clone()] : [], void 0 !== c ? [i.colors[t].clone(), i.colors[e].clone(), i.colors[n].clone()] : [], r), i.faces.push(r), void 0 !== u && i.faceVertexUvs[0].push([d[t].clone(), d[e].clone(), d[n].clone()]), void 0 !== h && i.faceVertexUvs[1].push([f[t].clone(), f[e].clone(), f[n].clone()]) } var i = this; const r = t.index !== null ? t.index.array : void 0; let a = t.attributes; let o = a.position.array; var s = void 0 !== a.normal ? a.normal.array : void 0; var c = void 0 !== a.color ? a.color.array : void 0; var u = void 0 !== a.uv ? a.uv.array : void 0; var h = void 0 !== a.uv2 ? a.uv2.array : void 0; void 0 !== h && (this.faceVertexUvs[1] = []); for (var p = [], d = [], f = [], m = a = 0; a < o.length; a += 3, m += 2)i.vertices.push(new l(o[a], o[a + 1], o[a + 2])), void 0 !== s && p.push(new l(s[a], s[a + 1], s[a + 2])), void 0 !== c && i.colors.push(new j(c[a], c[a + 1], c[a + 2])), void 0 !== u && d.push(new n(u[m], u[m + 1])), void 0 !== h && f.push(new n(h[m], h[m + 1])); if (void 0 !== r) if (o = t.groups, o.length > 0) for (a = 0; a < o.length; a++) for (var g = o[a], v = g.start, y = g.count, m = v, v = v + y; m < v; m += 3)e(r[m], r[m + 1], r[m + 2], g.materialIndex); else for (a = 0; a < r.length; a += 3)e(r[a], r[a + 1], r[a + 2]); else for (a = 0; a < o.length / 3; a += 3)e(a, a + 1, a + 2); return this.computeFaceNormals(), t.boundingBox !== null && (this.boundingBox = t.boundingBox.clone()), t.boundingSphere !== null && (this.boundingSphere = t.boundingSphere.clone()), this },
    center: function () { this.computeBoundingBox(); const t = this.boundingBox.getCenter().negate(); return this.translate(t.x, t.y, t.z), t },
    normalize: function () { this.computeBoundingSphere(); const t = this.boundingSphere.center; var e = this.boundingSphere.radius; var e = e === 0 ? 1 : 1 / e; const n = new c(); return n.set(e, 0, 0, -e * t.x, 0, e, 0, -e * t.y, 0, 0, e, -e * t.z, 0, 0, 0, 1), this.applyMatrix(n), this },
    computeFaceNormals: function () { for (let t = new l(), e = new l(), n = 0, i = this.faces.length; n < i; n++) { const r = this.faces[n]; const a = this.vertices[r.a]; const o = this.vertices[r.b]; t.subVectors(this.vertices[r.c], o), e.subVectors(a, o), t.cross(e), t.normalize(), r.normal.copy(t) } },
    computeVertexNormals: function (t) { void 0 === t && (t = !0); let e, n, i; for (i = Array(this.vertices.length), e = 0, n = this.vertices.length; e < n; e++)i[e] = new l(); if (t) { var r; let a; let o; const s = new l(); const c = new l(); for (t = 0, e = this.faces.length; t < e; t++)n = this.faces[t], r = this.vertices[n.a], a = this.vertices[n.b], o = this.vertices[n.c], s.subVectors(o, a), c.subVectors(r, a), s.cross(c), i[n.a].add(s), i[n.b].add(s), i[n.c].add(s) } else for (this.computeFaceNormals(), t = 0, e = this.faces.length; t < e; t++)n = this.faces[t], i[n.a].add(n.normal), i[n.b].add(n.normal), i[n.c].add(n.normal); for (e = 0, n = this.vertices.length; e < n; e++)i[e].normalize(); for (t = 0, e = this.faces.length; t < e; t++)n = this.faces[t], r = n.vertexNormals, r.length === 3 ? (r[0].copy(i[n.a]), r[1].copy(i[n.b]), r[2].copy(i[n.c])) : (r[0] = i[n.a].clone(), r[1] = i[n.b].clone(), r[2] = i[n.c].clone()); this.faces.length > 0 && (this.normalsNeedUpdate = !0) },
    computeFlatVertexNormals: function () { let t, e, n; for (this.computeFaceNormals(), t = 0, e = this.faces.length; t < e; t++) { n = this.faces[t]; const i = n.vertexNormals; i.length === 3 ? (i[0].copy(n.normal), i[1].copy(n.normal), i[2].copy(n.normal)) : (i[0] = n.normal.clone(), i[1] = n.normal.clone(), i[2] = n.normal.clone()) } this.faces.length > 0 && (this.normalsNeedUpdate = !0) },
    computeMorphNormals: function () { let t, e, n, i, r; for (n = 0, i = this.faces.length; n < i; n++) for (r = this.faces[n], r.__originalFaceNormal ? r.__originalFaceNormal.copy(r.normal) : r.__originalFaceNormal = r.normal.clone(), r.__originalVertexNormals || (r.__originalVertexNormals = []), t = 0, e = r.vertexNormals.length; t < e; t++)r.__originalVertexNormals[t] ? r.__originalVertexNormals[t].copy(r.vertexNormals[t]) : r.__originalVertexNormals[t] = r.vertexNormals[t].clone(); const a = new _t(); for (a.faces = this.faces, t = 0, e = this.morphTargets.length; t < e; t++) { if (!this.morphNormals[t]) { this.morphNormals[t] = {}, this.morphNormals[t].faceNormals = [], this.morphNormals[t].vertexNormals = [], r = this.morphNormals[t].faceNormals; var o; var s; var c = this.morphNormals[t].vertexNormals; for (n = 0, i = this.faces.length; n < i; n++)o = new l(), s = { a: new l(), b: new l(), c: new l() }, r.push(o), c.push(s) } for (c = this.morphNormals[t], a.vertices = this.morphTargets[t].vertices, a.computeFaceNormals(), a.computeVertexNormals(), n = 0, i = this.faces.length; n < i; n++)r = this.faces[n], o = c.faceNormals[n], s = c.vertexNormals[n], o.copy(r.normal), s.a.copy(r.vertexNormals[0]), s.b.copy(r.vertexNormals[1]), s.c.copy(r.vertexNormals[2]) } for (n = 0, i = this.faces.length; n < i; n++)r = this.faces[n], r.normal = r.__originalFaceNormal, r.vertexNormals = r.__originalVertexNormals },
    computeLineDistances: function () { for (let t = 0, e = this.vertices, n = 0, i = e.length; n < i; n++)n > 0 && (t += e[n].distanceTo(e[n - 1])), this.lineDistances[n] = t },
    computeBoundingBox: function () { this.boundingBox === null && (this.boundingBox = new Z()), this.boundingBox.setFromPoints(this.vertices) },
    computeBoundingSphere: function () { this.boundingSphere === null && (this.boundingSphere = new K()), this.boundingSphere.setFromPoints(this.vertices) },
    merge: function (t, e, n) { if (!1 === (t && t.isGeometry));else { let i; const r = this.vertices.length; let a = this.vertices; var o = t.vertices; const s = this.faces; const l = t.faces; const c = this.faceVertexUvs[0]; const u = t.faceVertexUvs[0]; var h = this.colors; var p = t.colors; void 0 === n && (n = 0), void 0 !== e && (i = (new J()).getNormalMatrix(e)), t = 0; for (var d = o.length; t < d; t++) { var f = o[t].clone(); void 0 !== e && f.applyMatrix4(e), a.push(f) } for (t = 0, d = p.length; t < d; t++)h.push(p[t].clone()); for (t = 0, d = l.length; t < d; t++) { var o = l[t]; const m = o.vertexNormals; var p = o.vertexColors; var h = new lt(o.a + r, o.b + r, o.c + r); for (h.normal.copy(o.normal), void 0 !== i && h.normal.applyMatrix3(i).normalize(), e = 0, a = m.length; e < a; e++)f = m[e].clone(), void 0 !== i && f.applyMatrix3(i).normalize(), h.vertexNormals.push(f); for (h.color.copy(o.color), e = 0, a = p.length; e < a; e++)f = p[e], h.vertexColors.push(f.clone()); h.materialIndex = o.materialIndex + n, s.push(h) } for (t = 0, d = u.length; t < d; t++) if (n = u[t], i = [], void 0 !== n) { for (e = 0, a = n.length; e < a; e++)i.push(n[e].clone()); c.push(i) } } },
    mergeMesh: function (t) { !1 === (t && t.isMesh) || (t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix)) },
    mergeVertices: function () { let t; let e; let n; let i = {}; const r = []; let a = []; let o = Math.pow(10, 4); for (e = 0, n = this.vertices.length; e < n; e++)t = this.vertices[e], t = Math.round(t.x * o) + '_' + Math.round(t.y * o) + '_' + Math.round(t.z * o), void 0 === i[t] ? (i[t] = e, r.push(this.vertices[e]), a[e] = r.length - 1) : a[e] = a[i[t]]; for (i = [], e = 0, n = this.faces.length; e < n; e++) for (o = this.faces[e], o.a = a[o.a], o.b = a[o.b], o.c = a[o.c], o = [o.a, o.b, o.c], t = 0; t < 3; t++) if (o[t] === o[(t + 1) % 3]) { i.push(e); break } for (e = i.length - 1; e >= 0; e--) for (o = i[e], this.faces.splice(o, 1), a = 0, n = this.faceVertexUvs.length; a < n; a++) this.faceVertexUvs[a].splice(o, 1); return e = this.vertices.length - r.length, this.vertices = r, e },
    sortFacesByMaterialIndex: function () { for (var t = this.faces, e = t.length, n = 0; n < e; n++)t[n]._id = n; t.sort(function (t, e) { return t.materialIndex - e.materialIndex }); let i; let r; const a = this.faceVertexUvs[0]; const o = this.faceVertexUvs[1]; for (a && a.length === e && (i = []), o && o.length === e && (r = []), n = 0; n < e; n++) { const s = t[n]._id; i && i.push(a[s]), r && r.push(o[s]) }i && (this.faceVertexUvs[0] = i), r && (this.faceVertexUvs[1] = r) },
    toJSON: function () {
      function t (t, e, n) { return n ? t | 1 << e : t & ~(1 << e) } function e (t) { const e = t.x.toString() + t.y.toString() + t.z.toString(); return void 0 !== c[e] ? c[e] : (c[e] = l.length / 3, l.push(t.x, t.y, t.z), c[e]) } function n (t) { const e = t.r.toString() + t.g.toString() + t.b.toString(); return void 0 !== h[e] ? h[e] : (h[e] = u.length, u.push(t.getHex()), h[e]) } function i (t) { const e = t.x.toString() + t.y.toString(); return void 0 !== d[e] ? d[e] : (d[e] = p.length / 2, p.push(t.x, t.y), d[e]) } const r = { metadata: { version: 4.4, type: 'Geometry', generator: 'Geometry.toJSON' } }; if (r.uuid = this.uuid, r.type = this.type, this.name !== '' && (r.name = this.name), void 0 !== this.parameters) { var a; var o = this.parameters; for (a in o) void 0 !== o[a] && (r[a] = o[a]); return r } for (o = [], a = 0; a < this.vertices.length; a++) { var s = this.vertices[a]; o.push(s.x, s.y, s.z) } var s = []; var l = []; var c = {}; var u = []; var h = {}; var p = []; var d = {}; for (a = 0; a < this.faces.length; a++) {
        let f = this.faces[a]; let m = void 0 !== this.faceVertexUvs[0][a]; let g = f.normal.length() > 0; const v = f.vertexNormals.length > 0; const y = f.color.r !== 1 || f.color.g !== 1 || f.color.b !== 1; const b = f.vertexColors.length > 0; var x = 0; var x = t(x, 0, 0); var x = t(x, 1, !0); var x = t(x, 2, !1); var x = t(x, 3, m); var x = t(x, 4, g); var x = t(x, 5, v); var x = t(x, 6, y); var x = t(x, 7, b); s.push(x),
        s.push(f.a, f.b, f.c), s.push(f.materialIndex), m && (m = this.faceVertexUvs[0][a], s.push(i(m[0]), i(m[1]), i(m[2]))), g && s.push(e(f.normal)), v && (g = f.vertexNormals, s.push(e(g[0]), e(g[1]), e(g[2]))), y && s.push(n(f.color)), b && (f = f.vertexColors, s.push(n(f[0]), n(f[1]), n(f[2])))
      } return r.data = {}, r.data.vertices = o, r.data.normals = l, u.length > 0 && (r.data.colors = u), p.length > 0 && (r.data.uvs = [p]), r.data.faces = s, r
    },
    clone: function () { return (new _t()).copy(this) },
    copy: function (t) { let e, n, i, r, a, o; for (this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingSphere = this.boundingBox = null, this.name = t.name, i = t.vertices, e = 0, n = i.length; e < n; e++) this.vertices.push(i[e].clone()); for (i = t.colors, e = 0, n = i.length; e < n; e++) this.colors.push(i[e].clone()); for (i = t.faces, e = 0, n = i.length; e < n; e++) this.faces.push(i[e].clone()); for (e = 0, n = t.faceVertexUvs.length; e < n; e++) { var s = t.faceVertexUvs[e]; for (void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []), i = 0, r = s.length; i < r; i++) { var l = s[i]; const c = []; for (a = 0, o = l.length; a < o; a++)c.push(l[a].clone()); this.faceVertexUvs[e].push(c) } } for (a = t.morphTargets, e = 0, n = a.length; e < n; e++) { if (o = {}, o.name = a[e].name, void 0 !== a[e].vertices) for (o.vertices = [], i = 0, r = a[e].vertices.length; i < r; i++)o.vertices.push(a[e].vertices[i].clone()); if (void 0 !== a[e].normals) for (o.normals = [], i = 0, r = a[e].normals.length; i < r; i++)o.normals.push(a[e].normals[i].clone()); this.morphTargets.push(o) } for (a = t.morphNormals, e = 0, n = a.length; e < n; e++) { if (o = {}, void 0 !== a[e].vertexNormals) for (o.vertexNormals = [], i = 0, r = a[e].vertexNormals.length; i < r; i++)s = a[e].vertexNormals[i], l = {}, l.a = s.a.clone(), l.b = s.b.clone(), l.c = s.c.clone(), o.vertexNormals.push(l); if (void 0 !== a[e].faceNormals) for (o.faceNormals = [], i = 0, r = a[e].faceNormals.length; i < r; i++)o.faceNormals.push(a[e].faceNormals[i].clone()); this.morphNormals.push(o) } for (i = t.skinWeights, e = 0, n = i.length; e < n; e++) this.skinWeights.push(i[e].clone()); for (i = t.skinIndices, e = 0, n = i.length; e < n; e++) this.skinIndices.push(i[e].clone()); for (i = t.lineDistances, e = 0, n = i.length; e < n; e++) this.lineDistances.push(i[e]); return e = t.boundingBox, e !== null && (this.boundingBox = e.clone()), e = t.boundingSphere, e !== null && (this.boundingSphere = e.clone()), this.elementsNeedUpdate = t.elementsNeedUpdate, this.verticesNeedUpdate = t.verticesNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this },
    dispose: function () { this.dispatchEvent({ type: 'dispose' }) }
  }, Object.assign(_t.prototype, e.prototype), $t.prototype = { constructor: $t, isBufferGeometry: !0, getIndex: function () { return this.index }, setIndex: function (t) { Array.isArray(t) ? this.index = new (wt(t) > 65535 ? vt : mt)(t, 1) : this.index = t }, addAttribute: function (t, e, n) { if (!1 === (e && e.isBufferAttribute) && !1 === (e && e.isInterleavedBufferAttribute)) this.addAttribute(t, new ut(e, n)); else { if (t !== 'index') return this.attributes[t] = e, this; this.setIndex(e) } }, getAttribute: function (t) { return this.attributes[t] }, removeAttribute: function (t) { return delete this.attributes[t], this }, addGroup: function (t, e, n) { this.groups.push({ start: t, count: e, materialIndex: void 0 !== n ? n : 0 }) }, clearGroups: function () { this.groups = [] }, setDrawRange: function (t, e) { this.drawRange.start = t, this.drawRange.count = e }, applyMatrix: function (t) { let e = this.attributes.position; return void 0 !== e && (t.applyToBufferAttribute(e), e.needsUpdate = !0), e = this.attributes.normal, void 0 !== e && ((new J()).getNormalMatrix(t).applyToBufferAttribute(e), e.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this }, rotateX: (function () { let t; return function (e) { return void 0 === t && (t = new c()), t.makeRotationX(e), this.applyMatrix(t), this } }()), rotateY: (function () { let t; return function (e) { return void 0 === t && (t = new c()), t.makeRotationY(e), this.applyMatrix(t), this } }()), rotateZ: (function () { let t; return function (e) { return void 0 === t && (t = new c()), t.makeRotationZ(e), this.applyMatrix(t), this } }()), translate: (function () { let t; return function (e, n, i) { return void 0 === t && (t = new c()), t.makeTranslation(e, n, i), this.applyMatrix(t), this } }()), scale: (function () { let t; return function (e, n, i) { return void 0 === t && (t = new c()), t.makeScale(e, n, i), this.applyMatrix(t), this } }()), lookAt: (function () { let t; return function (e) { void 0 === t && (t = new at()), t.lookAt(e), t.updateMatrix(), this.applyMatrix(t.matrix) } }()), center: function () { this.computeBoundingBox(); const t = this.boundingBox.getCenter().negate(); return this.translate(t.x, t.y, t.z), t }, setFromObject: function (t) { const e = t.geometry; if (t.isPoints || t.isLine) { t = new yt(3 * e.vertices.length, 3); const n = new yt(3 * e.colors.length, 3); this.addAttribute('position', t.copyVector3sArray(e.vertices)), this.addAttribute('color', n.copyColorsArray(e.colors)), e.lineDistances && e.lineDistances.length === e.vertices.length && (t = new yt(e.lineDistances.length, 1), this.addAttribute('lineDistance', t.copyArray(e.lineDistances))), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()) } else t.isMesh && e && e.isGeometry && this.fromGeometry(e); return this }, updateFromObject: function (t) { let e = t.geometry; if (t.isMesh) { var n = e.__directGeometry; if (!0 === e.elementsNeedUpdate && (n = void 0, e.elementsNeedUpdate = !1), void 0 === n) return this.fromGeometry(e); n.verticesNeedUpdate = e.verticesNeedUpdate, n.normalsNeedUpdate = e.normalsNeedUpdate, n.colorsNeedUpdate = e.colorsNeedUpdate, n.uvsNeedUpdate = e.uvsNeedUpdate, n.groupsNeedUpdate = e.groupsNeedUpdate, e.verticesNeedUpdate = !1, e.normalsNeedUpdate = !1, e.colorsNeedUpdate = !1, e.uvsNeedUpdate = !1, e.groupsNeedUpdate = !1, e = n } return !0 === e.verticesNeedUpdate && (n = this.attributes.position, void 0 !== n && (n.copyVector3sArray(e.vertices), n.needsUpdate = !0), e.verticesNeedUpdate = !1), !0 === e.normalsNeedUpdate && (n = this.attributes.normal, void 0 !== n && (n.copyVector3sArray(e.normals), n.needsUpdate = !0), e.normalsNeedUpdate = !1), !0 === e.colorsNeedUpdate && (n = this.attributes.color, void 0 !== n && (n.copyColorsArray(e.colors), n.needsUpdate = !0), e.colorsNeedUpdate = !1), e.uvsNeedUpdate && (n = this.attributes.uv, void 0 !== n && (n.copyVector2sArray(e.uvs), n.needsUpdate = !0), e.uvsNeedUpdate = !1), e.lineDistancesNeedUpdate && (n = this.attributes.lineDistance, void 0 !== n && (n.copyArray(e.lineDistances), n.needsUpdate = !0), e.lineDistancesNeedUpdate = !1), e.groupsNeedUpdate && (e.computeGroups(t.geometry), this.groups = e.groups, e.groupsNeedUpdate = !1), this }, fromGeometry: function (t) { return t.__directGeometry = (new xt()).fromGeometry(t), this.fromDirectGeometry(t.__directGeometry) }, fromDirectGeometry: function (t) { var e = new Float32Array(3 * t.vertices.length); this.addAttribute('position', new ut(e, 3).copyVector3sArray(t.vertices)), t.normals.length > 0 && (e = new Float32Array(3 * t.normals.length), this.addAttribute('normal', new ut(e, 3).copyVector3sArray(t.normals))), t.colors.length > 0 && (e = new Float32Array(3 * t.colors.length), this.addAttribute('color', new ut(e, 3).copyColorsArray(t.colors))), t.uvs.length > 0 && (e = new Float32Array(2 * t.uvs.length), this.addAttribute('uv', new ut(e, 2).copyVector2sArray(t.uvs))), t.uvs2.length > 0 && (e = new Float32Array(2 * t.uvs2.length), this.addAttribute('uv2', new ut(e, 2).copyVector2sArray(t.uvs2))), t.indices.length > 0 && (e = new (wt(t.indices) > 65535 ? Uint32Array : Uint16Array)(3 * t.indices.length), this.setIndex(new ut(e, 1).copyIndicesArray(t.indices))), this.groups = t.groups; for (var n in t.morphTargets) { for (var e = [], i = t.morphTargets[n], r = 0, a = i.length; r < a; r++) { const o = i[r]; const s = new yt(3 * o.length, 3); e.push(s.copyVector3sArray(o)) } this.morphAttributes[n] = e } return t.skinIndices.length > 0 && (n = new yt(4 * t.skinIndices.length, 4), this.addAttribute('skinIndex', n.copyVector4sArray(t.skinIndices))), t.skinWeights.length > 0 && (n = new yt(4 * t.skinWeights.length, 4), this.addAttribute('skinWeight', n.copyVector4sArray(t.skinWeights))), t.boundingSphere !== null && (this.boundingSphere = t.boundingSphere.clone()), t.boundingBox !== null && (this.boundingBox = t.boundingBox.clone()), this }, computeBoundingBox: function () { this.boundingBox === null && (this.boundingBox = new Z()); const t = this.attributes.position; void 0 !== t ? this.boundingBox.setFromBufferAttribute(t) : this.boundingBox.makeEmpty(), isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z) }, computeBoundingSphere: (function () { const t = new Z(); const e = new l(); return function () { this.boundingSphere === null && (this.boundingSphere = new K()); const n = this.attributes.position; if (n) { const i = this.boundingSphere.center; t.setFromBufferAttribute(n), t.getCenter(i); for (var r = 0, a = 0, o = n.count; a < o; a++)e.x = n.getX(a), e.y = n.getY(a), e.z = n.getZ(a), r = Math.max(r, i.distanceToSquared(e)); this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) } } }()), computeFaceNormals: function () {}, computeVertexNormals: function () { let t = this.index; const e = this.attributes; const n = this.groups; if (e.position) { const i = e.position.array; if (void 0 === e.normal) this.addAttribute('normal', new ut(new Float32Array(i.length), 3)); else for (var r = e.normal.array, a = 0, o = r.length; a < o; a++)r[a] = 0; let s; let c; let u; var r = e.normal.array; const h = new l(); const p = new l(); const d = new l(); const f = new l(); const m = new l(); if (t) { t = t.array, n.length === 0 && this.addGroup(0, t.length); for (let g = 0, v = n.length; g < v; ++g) for (a = n[g], o = a.start, s = a.count, a = o, o += s; a < o; a += 3)s = 3 * t[a + 0], c = 3 * t[a + 1], u = 3 * t[a + 2], h.fromArray(i, s), p.fromArray(i, c), d.fromArray(i, u), f.subVectors(d, p), m.subVectors(h, p), f.cross(m), r[s] += f.x, r[s + 1] += f.y, r[s + 2] += f.z, r[c] += f.x, r[c + 1] += f.y, r[c + 2] += f.z, r[u] += f.x, r[u + 1] += f.y, r[u + 2] += f.z } else for (a = 0, o = i.length; a < o; a += 9)h.fromArray(i, a), p.fromArray(i, a + 3), d.fromArray(i, a + 6), f.subVectors(d, p), m.subVectors(h, p), f.cross(m), r[a] = f.x, r[a + 1] = f.y, r[a + 2] = f.z, r[a + 3] = f.x, r[a + 4] = f.y, r[a + 5] = f.z, r[a + 6] = f.x, r[a + 7] = f.y, r[a + 8] = f.z; this.normalizeNormals(), e.normal.needsUpdate = !0 } }, merge: function (t, e) { if (!1 !== (t && t.isBufferGeometry)) { void 0 === e && (e = 0); let n; const i = this.attributes; for (n in i) if (void 0 !== t.attributes[n]) for (var r = i[n].array, a = t.attributes[n], o = a.array, s = 0, a = a.itemSize * e; s < o.length; s++, a++)r[a] = o[s]; return this } }, normalizeNormals: function () { for (var t, e, n, i = this.attributes.normal.array, r = 0, a = i.length; r < a; r += 3)t = i[r], e = i[r + 1], n = i[r + 2], t = 1 / Math.sqrt(t * t + e * e + n * n), i[r] *= t, i[r + 1] *= t, i[r + 2] *= t }, toNonIndexed: function () { if (this.index === null) return this; let t; const e = new $t(); const n = this.index.array; const i = this.attributes; for (t in i) { for (var r, a = i[t], o = a.array, a = a.itemSize, s = new o.constructor(n.length * a), l = 0, c = 0, u = n.length; c < u; c++) { r = n[c] * a; for (let h = 0; h < a; h++)s[l++] = o[r++] }e.addAttribute(t, new ut(s, a)) } return e }, toJSON: function () { const t = { metadata: { version: 4.4, type: 'BufferGeometry', generator: 'BufferGeometry.toJSON' } }; if (t.uuid = this.uuid, t.type = this.type, this.name !== '' && (t.name = this.name), void 0 !== this.parameters) { var e; var n = this.parameters; for (e in n) void 0 !== n[e] && (t[e] = n[e]); return t }t.data = { attributes: {} }; let i = this.index; i !== null && (n = Array.prototype.slice.call(i.array), t.data.index = { type: i.array.constructor.name, array: n }), i = this.attributes; for (e in i) { const r = i[e]; var n = Array.prototype.slice.call(r.array); t.data.attributes[e] = { itemSize: r.itemSize, type: r.array.constructor.name, array: n, normalized: r.normalized } } return e = this.groups, e.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(e))), e = this.boundingSphere, e !== null && (t.data.boundingSphere = { center: e.center.toArray(), radius: e.radius }), t }, clone: function () { return (new $t()).copy(this) }, copy: function (t) { let e, n, i; this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingSphere = this.boundingBox = null, this.name = t.name, n = t.index, n !== null && this.setIndex(n.clone()), n = t.attributes; for (e in n) this.addAttribute(e, n[e].clone()); let r = t.morphAttributes; for (e in r) { const a = []; const o = r[e]; for (n = 0, i = o.length; n < i; n++)a.push(o[n].clone()); this.morphAttributes[e] = a } for (e = t.groups, n = 0, i = e.length; n < i; n++)r = e[n], this.addGroup(r.start, r.count, r.materialIndex); return e = t.boundingBox, e !== null && (this.boundingBox = e.clone()), e = t.boundingSphere, e !== null && (this.boundingSphere = e.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this }, dispose: function () { this.dispatchEvent({ type: 'dispose' }) } }, $t.MaxIndex = 65535, Object.assign($t.prototype, e.prototype), Tt.prototype = Object.assign(Object.create(at.prototype), { constructor: Tt, isMesh: !0, setDrawMode: function (t) { this.drawMode = t }, copy: function (t) { return at.prototype.copy.call(this, t), this.drawMode = t.drawMode, this }, updateMorphTargets: function () { const t = this.geometry.morphTargets; if (void 0 !== t && t.length > 0) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let e = 0, n = t.length; e < n; e++) this.morphTargetInfluences.push(0), this.morphTargetDictionary[t[e].name] = e } }, raycast: (function () { function t (t, e, n, i, r, a, o) { return st.barycoordFromPoint(t, e, n, i, y), r.multiplyScalar(y.x), a.multiplyScalar(y.y), o.multiplyScalar(y.z), r.add(a).add(o), r.clone() } function e (t, e, n, i, r, a, o) { const s = t.material; return (s.side === 1 ? n.intersectTriangle(a, r, i, !0, o) : n.intersectTriangle(i, r, a, s.side !== 2, o)) === null ? null : (x.copy(o), x.applyMatrix4(t.matrixWorld), n = e.ray.origin.distanceTo(x), n < e.near || n > e.far ? null : { distance: n, point: x.clone(), object: t }) } function i (n, i, r, a, o, l, c, p) { return s.fromBufferAttribute(a, l), u.fromBufferAttribute(a, c), h.fromBufferAttribute(a, p), (n = e(n, i, r, s, u, h, b)) && (o && (m.fromBufferAttribute(o, l), g.fromBufferAttribute(o, c), v.fromBufferAttribute(o, p), n.uv = t(b, s, u, h, m, g, v)), n.face = new lt(l, c, p, st.normal(s, u, h)), n.faceIndex = l), n } const r = new c(); const a = new nt(); const o = new K(); var s = new l(); var u = new l(); var h = new l(); const p = new l(); const d = new l(); const f = new l(); var m = new n(); var g = new n(); var v = new n(); var y = new l(); var b = new l(); var x = new l(); return function (n, l) { let c = this.geometry; var y = this.material; var x = this.matrixWorld; if (void 0 !== y && (c.boundingSphere === null && c.computeBoundingSphere(), o.copy(c.boundingSphere), o.applyMatrix4(x), !1 !== n.ray.intersectsSphere(o) && (r.getInverse(x), a.copy(n.ray).applyMatrix4(r), c.boundingBox === null || !1 !== a.intersectsBox(c.boundingBox)))) { let w; if (c.isBufferGeometry) { var _; var $; var T; var S; var y = c.index; var M = c.attributes.position; var x = c.attributes.uv; if (y !== null) for (T = 0, S = y.count; T < S; T += 3)c = y.getX(T), _ = y.getX(T + 1), $ = y.getX(T + 2), (w = i(this, n, a, M, x, c, _, $)) && (w.faceIndex = Math.floor(T / 3), l.push(w)); else for (T = 0, S = M.count; T < S; T += 3)c = T, _ = T + 1, $ = T + 2, (w = i(this, n, a, M, x, c, _, $)) && (w.index = c, l.push(w)) } else if (c.isGeometry) { let C; let E; var x = y && y.isMultiMaterial; T = !0 === x ? y.materials : null, S = c.vertices, _ = c.faces, $ = c.faceVertexUvs[0], $.length > 0 && (M = $); for (let A = 0, P = _.length; A < P; A++) { const k = _[A]; if (void 0 !== (w = !0 === x ? T[k.materialIndex] : y)) { if ($ = S[k.a], C = S[k.b], E = S[k.c], !0 === w.morphTargets) { w = c.morphTargets; var D = this.morphTargetInfluences; s.set(0, 0, 0), u.set(0, 0, 0), h.set(0, 0, 0); for (let O = 0, L = w.length; O < L; O++) { const I = D[O]; if (I !== 0) { const R = w[O].vertices; s.addScaledVector(p.subVectors(R[k.a], $), I), u.addScaledVector(d.subVectors(R[k.b], C), I), h.addScaledVector(f.subVectors(R[k.c], E), I) } }s.add($), u.add(C), h.add(E), $ = s, C = u, E = h }(w = e(this, n, a, $, C, E, b)) && (M && (D = M[A], m.copy(D[0]), g.copy(D[1]), v.copy(D[2]), w.uv = t(b, $, C, E, m, g, v)), w.face = k, w.faceIndex = A, l.push(w)) } } } } } }()), clone: function () { return new this.constructor(this.geometry, this.material).copy(this) } }), St.prototype = Object.create(_t.prototype), St.prototype.constructor = St, Mt.prototype = Object.create($t.prototype), Mt.prototype.constructor = Mt, Ct.prototype = Object.create(_t.prototype), Ct.prototype.constructor = Ct, Et.prototype = Object.create($t.prototype), Et.prototype.constructor = Et, At.prototype = Object.create(at.prototype), At.prototype.constructor = At, At.prototype.isCamera = !0, At.prototype.getWorldDirection = (function () { const t = new s(); return function (e) { return e = e || new l(), this.getWorldQuaternion(t), e.set(0, 0, -1).applyQuaternion(t) } }()), At.prototype.lookAt = (function () { const t = new c(); return function (e) { t.lookAt(this.position, e, this.up), this.quaternion.setFromRotationMatrix(t) } }()), At.prototype.clone = function () { return (new this.constructor()).copy(this) }, At.prototype.copy = function (t) { return at.prototype.copy.call(this, t), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this }, Pt.prototype = Object.assign(Object.create(At.prototype), { constructor: Pt, isPerspectiveCamera: !0, copy: function (t) { return At.prototype.copy.call(this, t), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = t.view === null ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this }, setFocalLength: function (t) { t = 0.5 * this.getFilmHeight() / t, this.fov = 2 * lr.RAD2DEG * Math.atan(t), this.updateProjectionMatrix() }, getFocalLength: function () { const t = Math.tan(0.5 * lr.DEG2RAD * this.fov); return 0.5 * this.getFilmHeight() / t }, getEffectiveFOV: function () { return 2 * lr.RAD2DEG * Math.atan(Math.tan(0.5 * lr.DEG2RAD * this.fov) / this.zoom) }, getFilmWidth: function () { return this.filmGauge * Math.min(this.aspect, 1) }, getFilmHeight: function () { return this.filmGauge / Math.max(this.aspect, 1) }, setViewOffset: function (t, e, n, i, r, a) { this.aspect = t / e, this.view = { fullWidth: t, fullHeight: e, offsetX: n, offsetY: i, width: r, height: a }, this.updateProjectionMatrix() }, clearViewOffset: function () { this.view = null, this.updateProjectionMatrix() }, updateProjectionMatrix: function () { const t = this.near; var e = t * Math.tan(0.5 * lr.DEG2RAD * this.fov) / this.zoom; var n = 2 * e; var i = this.aspect * n; var r = -0.5 * i; let a = this.view; if (a !== null) var o = a.fullWidth, s = a.fullHeight, r = r + a.offsetX * i / o, e = e - a.offsetY * n / s, i = a.width / o * i, n = a.height / s * n; a = this.filmOffset, a !== 0 && (r += t * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, e, e - n, t, this.far) }, toJSON: function (t) { return t = at.prototype.toJSON.call(this, t), t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t } }), kt.prototype = Object.assign(Object.create(At.prototype), { constructor: kt, isOrthographicCamera: !0, copy: function (t) { return At.prototype.copy.call(this, t), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = t.view === null ? null : Object.assign({}, t.view), this }, setViewOffset: function (t, e, n, i, r, a) { this.view = { fullWidth: t, fullHeight: e, offsetX: n, offsetY: i, width: r, height: a }, this.updateProjectionMatrix() }, clearViewOffset: function () { this.view = null, this.updateProjectionMatrix() }, updateProjectionMatrix: function () { var t = (this.right - this.left) / (2 * this.zoom); var e = (this.top - this.bottom) / (2 * this.zoom); var n = (this.right + this.left) / 2; var i = (this.top + this.bottom) / 2; var r = n - t; var n = n + t; var t = i + e; var e = i - e; if (this.view !== null) var n = this.zoom / (this.view.width / this.view.fullWidth), e = this.zoom / (this.view.height / this.view.fullHeight), a = (this.right - this.left) / this.view.width, i = (this.top - this.bottom) / this.view.height, r = r + this.view.offsetX / n * a, n = r + this.view.width / n * a, t = t - this.view.offsetY / e * i, e = t - this.view.height / e * i; this.projectionMatrix.makeOrthographic(r, n, t, e, this.near, this.far) }, toJSON: function (t) { return t = at.prototype.toJSON.call(this, t), t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t } }); var $r = 0; ie.prototype.isFogExp2 = !0, ie.prototype.clone = function () { return new ie(this.color.getHex(), this.density) }, ie.prototype.toJSON = function (t) { return { type: 'FogExp2', color: this.color.getHex(), density: this.density } }, re.prototype.isFog = !0, re.prototype.clone = function () { return new re(this.color.getHex(), this.near, this.far) }, re.prototype.toJSON = function (t) { return { type: 'Fog', color: this.color.getHex(), near: this.near, far: this.far } }, ae.prototype = Object.create(at.prototype), ae.prototype.constructor = ae, ae.prototype.copy = function (t, e) { return at.prototype.copy.call(this, t, e), t.background !== null && (this.background = t.background.clone()), t.fog !== null && (this.fog = t.fog.clone()), t.overrideMaterial !== null && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this }, ae.prototype.toJSON = function (t) { const e = at.prototype.toJSON.call(this, t); return this.background !== null && (e.object.background = this.background.toJSON(t)), this.fog !== null && (e.object.fog = this.fog.toJSON()), e }, oe.prototype = Object.assign(Object.create(at.prototype), { constructor: oe, isLensFlare: !0, copy: function (t) { at.prototype.copy.call(this, t), this.positionScreen.copy(t.positionScreen), this.customUpdateCallback = t.customUpdateCallback; for (let e = 0, n = t.lensFlares.length; e < n; e++) this.lensFlares.push(t.lensFlares[e]); return this }, add: function (t, e, n, i, r, a) { void 0 === e && (e = -1), void 0 === n && (n = 0), void 0 === a && (a = 1), void 0 === r && (r = new j(16777215)), void 0 === i && (i = 1), n = Math.min(n, Math.max(0, n)), this.lensFlares.push({ texture: t, size: e, distance: n, x: 0, y: 0, z: 0, scale: 1, rotation: 0, opacity: a, color: r, blending: i }) }, updateLensFlares: function () { let t; let e; const n = this.lensFlares.length; const i = 2 * -this.positionScreen.x; const r = 2 * -this.positionScreen.y; for (t = 0; t < n; t++)e = this.lensFlares[t], e.x = this.positionScreen.x + i * e.distance, e.y = this.positionScreen.y + r * e.distance, e.wantedRotation = e.x * Math.PI * 0.25, e.rotation += 0.25 * (e.wantedRotation - e.rotation) } }), se.prototype = Object.create(q.prototype), se.prototype.constructor = se, se.prototype.copy = function (t) { return q.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.rotation = t.rotation, this }, le.prototype = Object.assign(Object.create(at.prototype), { constructor: le, isSprite: !0, raycast: (function () { const t = new l(); return function (e, n) { t.setFromMatrixPosition(this.matrixWorld); const i = e.ray.distanceSqToPoint(t); i > this.scale.x * this.scale.y / 4 || n.push({ distance: Math.sqrt(i), point: this.position, face: null, object: this }) } }()), clone: function () { return new this.constructor(this.material).copy(this) } }), ce.prototype = Object.assign(Object.create(at.prototype), { constructor: ce, copy: function (t) { at.prototype.copy.call(this, t, !1), t = t.levels; for (let e = 0, n = t.length; e < n; e++) { const i = t[e]; this.addLevel(i.object.clone(), i.distance) } return this }, addLevel: function (t, e) { void 0 === e && (e = 0), e = Math.abs(e); for (var n = this.levels, i = 0; i < n.length && !(e < n[i].distance); i++);n.splice(i, 0, { distance: e, object: t }), this.add(t) }, getObjectForDistance: function (t) { for (var e = this.levels, n = 1, i = e.length; n < i && !(t < e[n].distance); n++);return e[n - 1].object }, raycast: (function () { const t = new l(); return function (e, n) { t.setFromMatrixPosition(this.matrixWorld); const i = e.ray.origin.distanceTo(t); this.getObjectForDistance(i).raycast(e, n) } }()), update: (function () { const t = new l(); const e = new l(); return function (n) { const i = this.levels; if (i.length > 1) { t.setFromMatrixPosition(n.matrixWorld), e.setFromMatrixPosition(this.matrixWorld), n = t.distanceTo(e), i[0].object.visible = !0; for (var r = 1, a = i.length; r < a && n >= i[r].distance; r++)i[r - 1].object.visible = !1, i[r].object.visible = !0; for (;r < a; r++)i[r].object.visible = !1 } } }()), toJSON: function (t) { t = at.prototype.toJSON.call(this, t), t.object.levels = []; for (let e = this.levels, n = 0, i = e.length; n < i; n++) { const r = e[n]; t.object.levels.push({ object: r.object.uuid, distance: r.distance }) } return t } }), Object.assign(ue.prototype, { calculateInverses: function () { this.boneInverses = []; for (let t = 0, e = this.bones.length; t < e; t++) { const n = new c(); this.bones[t] && n.getInverse(this.bones[t].matrixWorld), this.boneInverses.push(n) } }, pose: function () { for (var t, e = 0, n = this.bones.length; e < n; e++)(t = this.bones[e]) && t.matrixWorld.getInverse(this.boneInverses[e]); for (e = 0, n = this.bones.length; e < n; e++)(t = this.bones[e]) && (t.parent && t.parent.isBone ? (t.matrix.getInverse(t.parent.matrixWorld), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale)) }, update: (function () { const t = new c(); return function () { for (let e = 0, n = this.bones.length; e < n; e++)t.multiplyMatrices(this.bones[e] ? this.bones[e].matrixWorld : this.identityMatrix, this.boneInverses[e]), t.toArray(this.boneMatrices, 16 * e); this.useVertexTexture && (this.boneTexture.needsUpdate = !0) } }()), clone: function () { return new ue(this.bones, this.boneInverses, this.useVertexTexture) } }), he.prototype = Object.assign(Object.create(at.prototype), { constructor: he, isBone: !0 }), pe.prototype = Object.assign(Object.create(Tt.prototype), { constructor: pe, isSkinnedMesh: !0, bind: function (t, e) { this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.getInverse(e) }, pose: function () { this.skeleton.pose() }, normalizeSkinWeights: function () { if (this.geometry && this.geometry.isGeometry) for (var t = 0; t < this.geometry.skinWeights.length; t++) { var e = this.geometry.skinWeights[t]; var n = 1 / e.lengthManhattan(); 1 / 0 !== n ? e.multiplyScalar(n) : e.set(1, 0, 0, 0) } else if (this.geometry && this.geometry.isBufferGeometry) for (var e = new r(), i = this.geometry.attributes.skinWeight, t = 0; t < i.count; t++)e.x = i.getX(t), e.y = i.getY(t), e.z = i.getZ(t), e.w = i.getW(t), n = 1 / e.lengthManhattan(), 1 / 0 !== n ? e.multiplyScalar(n) : e.set(1, 0, 0, 0), i.setXYZW(t, e.x, e.y, e.z, e.w) }, updateMatrixWorld: function (t) { Tt.prototype.updateMatrixWorld.call(this, !0), this.bindMode === 'attached' ? this.bindMatrixInverse.getInverse(this.matrixWorld) : this.bindMode === 'detached' && this.bindMatrixInverse.getInverse(this.bindMatrix) }, clone: function () { return new this.constructor(this.geometry, this.material, this.skeleton.useVertexTexture).copy(this) } }), de.prototype = Object.create(q.prototype), de.prototype.constructor = de, de.prototype.isLineBasicMaterial = !0, de.prototype.copy = function (t) { return q.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this }, fe.prototype = Object.assign(Object.create(at.prototype), { constructor: fe, isLine: !0, raycast: (function () { const t = new c(); const e = new nt(); const n = new K(); return function (i, r) { var a = i.linePrecision; var a = a * a; var o = this.geometry; var s = this.matrixWorld; if (o.boundingSphere === null && o.computeBoundingSphere(), n.copy(o.boundingSphere), n.applyMatrix4(s), !1 !== i.ray.intersectsSphere(n)) { t.getInverse(s), e.copy(i.ray).applyMatrix4(t); let c = new l(); let u = new l(); var s = new l(); const h = new l(); const p = this && this.isLineSegments ? 2 : 1; if (o.isBufferGeometry) { var d = o.index; const f = o.attributes.position.array; if (d !== null) for (var d = d.array, o = 0, m = d.length - 1; o < m; o += p) { var g = d[o + 1]; c.fromArray(f, 3 * d[o]), u.fromArray(f, 3 * g), g = e.distanceSqToSegment(c, u, h, s), g > a || (h.applyMatrix4(this.matrixWorld), (g = i.ray.origin.distanceTo(h)) < i.near || g > i.far || r.push({ distance: g, point: s.clone().applyMatrix4(this.matrixWorld), index: o, face: null, faceIndex: null, object: this })) } else for (o = 0, m = f.length / 3 - 1; o < m; o += p)c.fromArray(f, 3 * o), u.fromArray(f, 3 * o + 3), (g = e.distanceSqToSegment(c, u, h, s)) > a || (h.applyMatrix4(this.matrixWorld), (g = i.ray.origin.distanceTo(h)) < i.near || g > i.far || r.push({ distance: g, point: s.clone().applyMatrix4(this.matrixWorld), index: o, face: null, faceIndex: null, object: this })) } else if (o.isGeometry) for (c = o.vertices, u = c.length, o = 0; o < u - 1; o += p)(g = e.distanceSqToSegment(c[o], c[o + 1], h, s)) > a || (h.applyMatrix4(this.matrixWorld), (g = i.ray.origin.distanceTo(h)) < i.near || g > i.far || r.push({ distance: g, point: s.clone().applyMatrix4(this.matrixWorld), index: o, face: null, faceIndex: null, object: this })) } } }()), clone: function () { return new this.constructor(this.geometry, this.material).copy(this) } }), me.prototype = Object.assign(Object.create(fe.prototype), { constructor: me, isLineSegments: !0 }), ge.prototype = Object.create(q.prototype), ge.prototype.constructor = ge, ge.prototype.isPointsMaterial = !0, ge.prototype.copy = function (t) { return q.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this }, ve.prototype = Object.assign(Object.create(at.prototype), { constructor: ve, isPoints: !0, raycast: (function () { const t = new c(); const e = new nt(); const n = new K(); return function (i, r) { function a (t, n) { const a = e.distanceSqToPoint(t); if (a < h) { const s = e.closestPointToPoint(t); s.applyMatrix4(c); const l = i.ray.origin.distanceTo(s); l < i.near || l > i.far || r.push({ distance: l, distanceToRay: Math.sqrt(a), point: s.clone(), index: n, face: null, object: o }) } } var o = this; var s = this.geometry; var c = this.matrixWorld; var u = i.params.Points.threshold; if (s.boundingSphere === null && s.computeBoundingSphere(), n.copy(s.boundingSphere), n.applyMatrix4(c), !1 !== i.ray.intersectsSphere(n)) { t.getInverse(c), e.copy(i.ray).applyMatrix4(t); var u = u / ((this.scale.x + this.scale.y + this.scale.z) / 3); var h = u * u; var u = new l(); if (s.isBufferGeometry) { var p = s.index; var s = s.attributes.position.array; if (p !== null) for (var d = p.array, p = 0, f = d.length; p < f; p++) { const m = d[p]; u.fromArray(s, 3 * m), a(u, m) } else for (p = 0, d = s.length / 3; p < d; p++)u.fromArray(s, 3 * p), a(u, p) } else for (u = s.vertices, p = 0, d = u.length; p < d; p++)a(u[p], p) } } }()), clone: function () { return new this.constructor(this.geometry, this.material).copy(this) } }), ye.prototype = Object.assign(Object.create(at.prototype), { constructor: ye }), be.prototype = Object.create(i.prototype), be.prototype.constructor = be, xe.prototype = Object.create(i.prototype), xe.prototype.constructor = xe, xe.prototype.isCompressedTexture = !0, we.prototype = Object.create(i.prototype), we.prototype.constructor = we, _e.prototype = Object.create(i.prototype), _e.prototype.constructor = _e, _e.prototype.isDepthTexture = !0, $e.prototype = Object.create($t.prototype), $e.prototype.constructor = $e, Te.prototype = Object.create(_t.prototype), Te.prototype.constructor = Te, Se.prototype = Object.create($t.prototype), Se.prototype.constructor = Se, Me.prototype = Object.create(_t.prototype), Me.prototype.constructor = Me, Ce.prototype = Object.create($t.prototype), Ce.prototype.constructor = Ce, Ee.prototype = Object.create(_t.prototype), Ee.prototype.constructor = Ee, Ae.prototype = Object.create(Ce.prototype), Ae.prototype.constructor = Ae, Pe.prototype = Object.create(_t.prototype), Pe.prototype.constructor = Pe, ke.prototype = Object.create(Ce.prototype), ke.prototype.constructor = ke, De.prototype = Object.create(_t.prototype), De.prototype.constructor = De, Oe.prototype = Object.create(Ce.prototype), Oe.prototype.constructor = Oe, Le.prototype = Object.create(_t.prototype), Le.prototype.constructor = Le, Ie.prototype = Object.create(Ce.prototype), Ie.prototype.constructor = Ie, Re.prototype = Object.create(_t.prototype), Re.prototype.constructor = Re, Ne.prototype = Object.create($t.prototype), Ne.prototype.constructor = Ne, Fe.prototype = Object.create(_t.prototype), Fe.prototype.constructor = Fe, Ue.prototype = Object.create($t.prototype), Ue.prototype.constructor = Ue, ze.prototype = Object.create(_t.prototype), ze.prototype.constructor = ze, Be.prototype = Object.create($t.prototype), Be.prototype.constructor = Be; var Tr = {
    area: function (t) { for (var e = t.length, n = 0, i = e - 1, r = 0; r < e; i = r++)n += t[i].x * t[r].y - t[r].x * t[i].y; return 0.5 * n },
    triangulate: (function () { return function (t, e) { let n = t.length; if (n < 3) return null; let i; let r; let a; const o = []; const s = []; const l = []; if (Tr.area(t) > 0) for (r = 0; r < n; r++)s[r] = r; else for (r = 0; r < n; r++)s[r] = n - 1 - r; let c = 2 * n; for (r = n - 1; n > 2 && !(c-- <= 0);) { i = r, n <= i && (i = 0), r = i + 1, n <= r && (r = 0), a = r + 1, n <= a && (a = 0); var u; t: { var h, p, d, f, m, g, v, y; if (h = t[s[i]].x, p = t[s[i]].y, d = t[s[r]].x, f = t[s[r]].y, m = t[s[a]].x, g = t[s[a]].y, (d - h) * (g - p) - (f - p) * (m - h) <= 0)u = !1; else { var b, x, w, _, $, T, S, M, C, E; for (b = m - d, x = g - f, w = h - m, _ = p - g, $ = d - h, T = f - p, u = 0; u < n; u++) if (v = t[s[u]].x, y = t[s[u]].y, !(v === h && y === p || v === d && y === f || v === m && y === g) && (S = v - h, M = y - p, C = v - d, E = y - f, v -= m, y -= g, C = b * E - x * C, S = $ * M - T * S, M = w * y - _ * v, C >= -Number.EPSILON && M >= -Number.EPSILON && S >= -Number.EPSILON)) { u = !1; break t }u = !0 } } if (u) { for (o.push([t[s[i]], t[s[r]], t[s[a]]]), l.push([s[i], s[r], s[a]]), i = r, a = r + 1; a < n; i++, a++)s[i] = s[a]; n--, c = 2 * n } } return e ? l : o } }()),
    triangulateShape: function (t, e) {
      function n (t) { const e = t.length; e > 2 && t[e - 1].equals(t[0]) && t.pop() } function i (t, e, n) { return t.x !== e.x ? t.x < e.x ? t.x <= n.x && n.x <= e.x : e.x <= n.x && n.x <= t.x : t.y < e.y ? t.y <= n.y && n.y <= e.y : e.y <= n.y && n.y <= t.y } function r (t, e, n, r, a) { let o = e.x - t.x; let s = e.y - t.y; let l = r.x - n.x; let c = r.y - n.y; const u = t.x - n.x; const h = t.y - n.y; let p = s * l - o * c; const d = s * u - o * h; if (Math.abs(p) > Number.EPSILON) { if (p > 0) { if (d < 0 || d > p) return []; if ((l = c * u - l * h) < 0 || l > p) return [] } else { if (d > 0 || d < p) return []; if ((l = c * u - l * h) > 0 || l < p) return [] } return l === 0 ? !a || d !== 0 && d !== p ? [t] : [] : l === p ? !a || d !== 0 && d !== p ? [e] : [] : d === 0 ? [n] : d === p ? [r] : (a = l / p, [{ x: t.x + a * o, y: t.y + a * s }]) } return d !== 0 || c * u != l * h ? [] : (s = o === 0 && s === 0, l = l === 0 && c === 0, s && l ? t.x !== n.x || t.y !== n.y ? [] : [t] : s ? i(n, r, t) ? [t] : [] : l ? i(t, e, n) ? [n] : [] : (o !== 0 ? (t.x < e.x ? (o = t, l = t.x, s = e, t = e.x) : (o = e, l = e.x, s = t, t = t.x), n.x < r.x ? (e = n, p = n.x, c = r, n = r.x) : (e = r, p = r.x, c = n, n = n.x)) : (t.y < e.y ? (o = t, l = t.y, s = e, t = e.y) : (o = e, l = e.y, s = t, t = t.y), n.y < r.y ? (e = n, p = n.y, c = r, n = r.y) : (e = r, p = r.y, c = n, n = n.y)), l <= p ? t < p ? [] : t === p ? a ? [] : [e] : t <= n ? [e, s] : [e, c] : l > n ? [] : l === n ? a ? [] : [o] : t <= n ? [o, s] : [o, c])) }
      function a (t, e, n, i) { let r = e.x - t.x; const a = e.y - t.y; e = n.x - t.x, n = n.y - t.y; const o = i.x - t.x; return i = i.y - t.y, t = r * n - a * e, r = r * i - a * o, Math.abs(t) > Number.EPSILON ? (e = o * n - i * e, t > 0 ? r >= 0 && e >= 0 : r >= 0 || e >= 0) : r > 0 }n(t), e.forEach(n); let o; let s; let l; let c; let u; const h = {}; for (l = t.concat(), o = 0, s = e.length; o < s; o++)Array.prototype.push.apply(l, e[o]); for (o = 0, s = l.length; o < s; o++)u = l[o].x + ':' + l[o].y, h[u], h[u] = o; o = (function (t, e) { let n; let i; let o; let s; let l; let c; let u; let h; let p; let d = t.concat(); const f = []; const m = []; let g = 0; for (i = e.length; g < i; g++)f.push(g); u = 0; for (let v = 2 * f.length; f.length > 0 && !(--v < 0);) for (o = u; o < d.length; o++) { for (s = d[o], i = -1, g = 0; g < f.length; g++) if (l = f[g], c = s.x + ':' + s.y + ':' + l, void 0 === m[c]) { for (n = e[l], h = 0; h < n.length; h++) if (l = n[h], (function (t, e) { let i = d.length - 1; let r = t - 1; r < 0 && (r = i); let o = t + 1; return o > i && (o = 0), !!(i = a(d[t], d[r], d[o], n[e])) && (i = n.length - 1, r = e - 1, r < 0 && (r = i), o = e + 1, o > i && (o = 0), !!(i = a(n[e], n[r], n[o], d[t]))) }(o, h)) && !(function (t, e) { let n, i; for (n = 0; n < d.length; n++) if (i = n + 1, i %= d.length, i = r(t, e, d[n], d[i], !0), i.length > 0) return !0; return !1 }(s, l)) && !(function (t, n) { let i, a, o, s; for (i = 0; i < f.length; i++) for (a = e[f[i]], o = 0; o < a.length; o++) if (s = o + 1, s %= a.length, s = r(t, n, a[o], a[s], !0), s.length > 0) return !0; return !1 }(s, l))) { i = h, f.splice(g, 1), u = d.slice(0, o + 1), l = d.slice(o), h = n.slice(i), p = n.slice(0, i + 1), d = u.concat(h).concat(p).concat(l), u = o; break } if (i >= 0) break; m[c] = !0 } if (i >= 0) break } return d }(t, e)); const p = Tr.triangulate(o, !1); for (o = 0, s = p.length; o < s; o++) for (c = p[o], l = 0; l < 3; l++)u = c[l].x + ':' + c[l].y, void 0 !== (u = h[u]) && (c[l] = u); return p.concat()
    },
    isClockWise: function (t) { return Tr.area(t) < 0 }
  }; je.prototype = Object.create(_t.prototype), je.prototype.constructor = je, je.prototype.addShapeList = function (t, e) { for (let n = t.length, i = 0; i < n; i++) this.addShape(t[i], e) }, je.prototype.addShape = function (t, e) { function i (t, e, n) { return e.clone().multiplyScalar(n).add(t) } function r (t, e, i) { let r, a, o; a = t.x - e.x, o = t.y - e.y, r = i.x - t.x; let s = i.y - t.y; var l = a * a + o * o; if (Math.abs(a * s - o * r) > Number.EPSILON) { const c = Math.sqrt(l); const u = Math.sqrt(r * r + s * s); var l = e.x - o / c; if (e = e.y + a / c, s = ((i.x - s / u - l) * s - (i.y + r / u - e) * r) / (a * s - o * r), r = l + a * s - t.x, a = e + o * s - t.y, (o = r * r + a * a) <= 2) return new n(r, a); o = Math.sqrt(o / 2) } else t = !1, a > Number.EPSILON ? r > Number.EPSILON && (t = !0) : a < -Number.EPSILON ? r < -Number.EPSILON && (t = !0) : Math.sign(o) === Math.sign(s) && (t = !0), t ? (r = -o, o = Math.sqrt(l)) : (r = a, a = o, o = Math.sqrt(l / 2)); return new n(r / o, a / o) } function a (t, e) { let n, i; for (z = t.length; --z >= 0;) { n = z, i = z - 1, i < 0 && (i = t.length - 1); var r; const a = x + 2 * v; for (r = 0; r < a; r++) { var o = F * r; var s = F * (r + 1); var l = e + n + o; var o = e + i + o; var c = e + i + s; var s = e + n + s; var l = l + E; var o = o + E; var c = c + E; var s = s + E; C.faces.push(new lt(l, o, s, null, null, 1)), C.faces.push(new lt(o, c, s, null, null, 1)), l = $.generateSideWallUV(C, l, o, c, s), C.faceVertexUvs[0].push([l[0], l[1], l[3]]), C.faceVertexUvs[0].push([l[1], l[2], l[3]]) } } } function o (t, e, n) { C.vertices.push(new l(t, e, n)) } function s (t, e, n) { t += E, e += E, n += E, C.faces.push(new lt(t, e, n, null, null, 0)), t = $.generateTopUV(C, t, e, n), C.faceVertexUvs[0].push(t) } let c; let u; let h; let p; let d; const f = void 0 !== e.amount ? e.amount : 100; let m = void 0 !== e.bevelThickness ? e.bevelThickness : 6; let g = void 0 !== e.bevelSize ? e.bevelSize : m - 2; var v = void 0 !== e.bevelSegments ? e.bevelSegments : 3; let y = void 0 === e.bevelEnabled || e.bevelEnabled; var b = void 0 !== e.curveSegments ? e.curveSegments : 12; var x = void 0 !== e.steps ? e.steps : 1; var w = e.extrudePath; let _ = !1; var $ = void 0 !== e.UVGenerator ? e.UVGenerator : je.WorldUVGenerator; w && (c = w.getSpacedPoints(x), _ = !0, y = !1, u = void 0 !== e.frames ? e.frames : w.computeFrenetFrames(x, !1), h = new l(), p = new l(), d = new l()), y || (g = m = v = 0); let T; let S; let M; var C = this; var E = this.vertices.length; var w = t.extractPoints(b); var b = w.shape; const A = w.holes; if (w = !Tr.isClockWise(b)) { for (b = b.reverse(), S = 0, M = A.length; S < M; S++)T = A[S], Tr.isClockWise(T) && (A[S] = T.reverse()); w = !1 } const P = Tr.triangulateShape(b, A); const k = b; for (S = 0, M = A.length; S < M; S++)T = A[S], b = b.concat(T); let D; let O; let L; let I; let R; let N; var F = b.length; const U = P.length; var w = []; var z = 0; for (L = k.length, D = L - 1, O = z + 1; z < L; z++, D++, O++)D === L && (D = 0), O === L && (O = 0), w[z] = r(k[z], k[D], k[O]); let B; const j = []; let V = w.concat(); for (S = 0, M = A.length; S < M; S++) { for (T = A[S], B = [], z = 0, L = T.length, D = L - 1, O = z + 1; z < L; z++, D++, O++)D === L && (D = 0), O === L && (O = 0), B[z] = r(T[z], T[D], T[O]); j.push(B), V = V.concat(B) } for (D = 0; D < v; D++) { for (L = D / v, I = m * Math.cos(L * Math.PI / 2), O = g * Math.sin(L * Math.PI / 2), z = 0, L = k.length; z < L; z++)R = i(k[z], w[z], O), o(R.x, R.y, -I); for (S = 0, M = A.length; S < M; S++) for (T = A[S], B = j[S], z = 0, L = T.length; z < L; z++)R = i(T[z], B[z], O), o(R.x, R.y, -I) } for (O = g, z = 0; z < F; z++)R = y ? i(b[z], V[z], O) : b[z], _ ? (p.copy(u.normals[0]).multiplyScalar(R.x), h.copy(u.binormals[0]).multiplyScalar(R.y), d.copy(c[0]).add(p).add(h), o(d.x, d.y, d.z)) : o(R.x, R.y, 0); for (L = 1; L <= x; L++) for (z = 0; z < F; z++)R = y ? i(b[z], V[z], O) : b[z], _ ? (p.copy(u.normals[L]).multiplyScalar(R.x), h.copy(u.binormals[L]).multiplyScalar(R.y), d.copy(c[L]).add(p).add(h), o(d.x, d.y, d.z)) : o(R.x, R.y, f / x * L); for (D = v - 1; D >= 0; D--) { for (L = D / v, I = m * Math.cos(L * Math.PI / 2), O = g * Math.sin(L * Math.PI / 2), z = 0, L = k.length; z < L; z++)R = i(k[z], w[z], O), o(R.x, R.y, f + I); for (S = 0, M = A.length; S < M; S++) for (T = A[S], B = j[S], z = 0, L = T.length; z < L; z++)R = i(T[z], B[z], O), _ ? o(R.x, R.y + c[x - 1].y, c[x - 1].x + I) : o(R.x, R.y, f + I) }!(function () { if (y) { let t = 0 * F; for (z = 0; z < U; z++)N = P[z], s(N[2] + t, N[1] + t, N[0] + t); for (t = F * (x + 2 * v), z = 0; z < U; z++)N = P[z], s(N[0] + t, N[1] + t, N[2] + t) } else { for (z = 0; z < U; z++)N = P[z], s(N[2], N[1], N[0]); for (z = 0; z < U; z++)N = P[z], s(N[0] + F * x, N[1] + F * x, N[2] + F * x) } }()), (function () { let t = 0; for (a(k, t), t += k.length, S = 0, M = A.length; S < M; S++)T = A[S], a(T, t), t += T.length }()) }, je.WorldUVGenerator = { generateTopUV: function (t, e, i, r) { return t = t.vertices, e = t[e], i = t[i], r = t[r], [new n(e.x, e.y), new n(i.x, i.y), new n(r.x, r.y)] }, generateSideWallUV: function (t, e, i, r, a) { return t = t.vertices, e = t[e], i = t[i], r = t[r], a = t[a], Math.abs(e.y - i.y) < 0.01 ? [new n(e.x, 1 - e.z), new n(i.x, 1 - i.z), new n(r.x, 1 - r.z), new n(a.x, 1 - a.z)] : [new n(e.y, 1 - e.z), new n(i.y, 1 - i.z), new n(r.y, 1 - r.z), new n(a.y, 1 - a.z)] } }, Ve.prototype = Object.create(je.prototype), Ve.prototype.constructor = Ve, Ge.prototype = Object.create(_t.prototype), Ge.prototype.constructor = Ge, He.prototype = Object.create($t.prototype), He.prototype.constructor = He, We.prototype = Object.create(_t.prototype), We.prototype.constructor = We, qe.prototype = Object.create($t.prototype), qe.prototype.constructor = qe, Xe.prototype = Object.create(_t.prototype), Xe.prototype.constructor = Xe, Ye.prototype = Object.create($t.prototype), Ye.prototype.constructor = Ye, Ze.prototype = Object.create(_t.prototype), Ze.prototype.constructor = Ze, Ke.prototype = Object.create($t.prototype), Ke.prototype.constructor = Ke, Je.prototype = Object.create($t.prototype), Je.prototype.constructor = Je, Qe.prototype = Object.create(_t.prototype), Qe.prototype.constructor = Qe, tn.prototype = Object.create($t.prototype), tn.prototype.constructor = tn, en.prototype = Object.create(Qe.prototype), en.prototype.constructor = en, nn.prototype = Object.create(tn.prototype), nn.prototype.constructor = nn, rn.prototype = Object.create(_t.prototype), rn.prototype.constructor = rn, an.prototype = Object.create($t.prototype), an.prototype.constructor = an; const Sr = Object.freeze({ WireframeGeometry: $e, ParametricGeometry: Te, ParametricBufferGeometry: Se, TetrahedronGeometry: Ee, TetrahedronBufferGeometry: Ae, OctahedronGeometry: Pe, OctahedronBufferGeometry: ke, IcosahedronGeometry: De, IcosahedronBufferGeometry: Oe, DodecahedronGeometry: Le, DodecahedronBufferGeometry: Ie, PolyhedronGeometry: Me, PolyhedronBufferGeometry: Ce, TubeGeometry: Re, TubeBufferGeometry: Ne, TorusKnotGeometry: Fe, TorusKnotBufferGeometry: Ue, TorusGeometry: ze, TorusBufferGeometry: Be, TextGeometry: Ve, SphereGeometry: Ge, SphereBufferGeometry: He, RingGeometry: We, RingBufferGeometry: qe, PlaneGeometry: Ct, PlaneBufferGeometry: Et, LatheGeometry: Xe, LatheBufferGeometry: Ye, ShapeGeometry: Ze, ShapeBufferGeometry: Ke, ExtrudeGeometry: je, EdgesGeometry: Je, ConeGeometry: en, ConeBufferGeometry: nn, CylinderGeometry: Qe, CylinderBufferGeometry: tn, CircleGeometry: rn, CircleBufferGeometry: an, BoxGeometry: St, BoxBufferGeometry: Mt }); on.prototype = Object.create(X.prototype), on.prototype.constructor = on, on.prototype.isShadowMaterial = !0, sn.prototype = Object.create(X.prototype), sn.prototype.constructor = sn, sn.prototype.isRawShaderMaterial = !0, ln.prototype = { constructor: ln, isMultiMaterial: !0, toJSON: function (t) { for (var e = { metadata: { version: 4.2, type: 'material', generator: 'MaterialExporter' }, uuid: this.uuid, type: this.type, materials: [] }, n = this.materials, i = 0, r = n.length; i < r; i++) { const a = n[i].toJSON(t); delete a.metadata, e.materials.push(a) } return e.visible = this.visible, e }, clone: function () { for (var t = new this.constructor(), e = 0; e < this.materials.length; e++)t.materials.push(this.materials[e].clone()); return t.visible = this.visible, t } }, cn.prototype = Object.create(q.prototype), cn.prototype.constructor = cn, cn.prototype.isMeshStandardMaterial = !0, cn.prototype.copy = function (t) { return q.prototype.copy.call(this, t), this.defines = { STANDARD: '' }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this }, un.prototype = Object.create(cn.prototype), un.prototype.constructor = un, un.prototype.isMeshPhysicalMaterial = !0, un.prototype.copy = function (t) { return cn.prototype.copy.call(this, t), this.defines = { PHYSICAL: '' }, this.reflectivity = t.reflectivity, this.clearCoat = t.clearCoat, this.clearCoatRoughness = t.clearCoatRoughness, this }, hn.prototype = Object.create(q.prototype), hn.prototype.constructor = hn, hn.prototype.isMeshPhongMaterial = !0, hn.prototype.copy = function (t) { return q.prototype.copy.call(this, t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this }, pn.prototype = Object.create(hn.prototype), pn.prototype.constructor = pn, pn.prototype.isMeshToonMaterial = !0, pn.prototype.copy = function (t) { return hn.prototype.copy.call(this, t), this.gradientMap = t.gradientMap, this }, dn.prototype = Object.create(q.prototype), dn.prototype.constructor = dn, dn.prototype.isMeshNormalMaterial = !0, dn.prototype.copy = function (t) { return q.prototype.copy.call(this, t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this }, fn.prototype = Object.create(q.prototype), fn.prototype.constructor = fn, fn.prototype.isMeshLambertMaterial = !0, fn.prototype.copy = function (t) { return q.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this }, mn.prototype = Object.create(q.prototype), mn.prototype.constructor = mn, mn.prototype.isLineDashedMaterial = !0, mn.prototype.copy = function (t) { return q.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t.linewidth, this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this }; const Mr = Object.freeze({ ShadowMaterial: on, SpriteMaterial: se, RawShaderMaterial: sn, ShaderMaterial: X, PointsMaterial: ge, MultiMaterial: ln, MeshPhysicalMaterial: un, MeshStandardMaterial: cn, MeshPhongMaterial: hn, MeshToonMaterial: pn, MeshNormalMaterial: dn, MeshLambertMaterial: fn, MeshDepthMaterial: Y, MeshBasicMaterial: ct, LineDashedMaterial: mn, LineBasicMaterial: de, Material: q }); const Cr = { enabled: !1, files: {}, add: function (t, e) { !1 !== this.enabled && (this.files[t] = e) }, get: function (t) { if (!1 !== this.enabled) return this.files[t] }, remove: function (t) { delete this.files[t] }, clear: function () { this.files = {} } }; var Er = new gn(); Object.assign(vn.prototype, { load: function (t, e, n, i) { void 0 === t && (t = ''), void 0 !== this.path && (t = this.path + t); const r = this; const a = Cr.get(t); if (void 0 !== a) return r.manager.itemStart(t), setTimeout(function () { e && e(a), r.manager.itemEnd(t) }, 0), a; var o = t.match(/^data:(.*?)(;base64)?,(.*)$/); if (o) { const s = o[1]; var l = !!o[2]; var o = o[3]; var o = window.decodeURIComponent(o); l && (o = window.atob(o)); try { let c; const u = (this.responseType || '').toLowerCase(); switch (u) { case 'arraybuffer':case 'blob':c = new ArrayBuffer(o.length); for (var h = new Uint8Array(c), l = 0; l < o.length; l++)h[l] = o.charCodeAt(l); u === 'blob' && (c = new Blob([c], { type: s })); break; case 'document':c = (new DOMParser()).parseFromString(o, s); break; case 'json':c = JSON.parse(o); break; default:c = o }window.setTimeout(function () { e && e(c), r.manager.itemEnd(t) }, 0) } catch (e) { window.setTimeout(function () { i && i(e), r.manager.itemError(t) }, 0) } } else { var p = new XMLHttpRequest(); p.open('GET', t, !0), p.addEventListener('load', function (n) { const a = n.target.response; Cr.add(t, a), this.status === 200 ? (e && e(a), r.manager.itemEnd(t)) : this.status === 0 ? (e && e(a), r.manager.itemEnd(t)) : (i && i(n), r.manager.itemError(t)) }, !1), void 0 !== n && p.addEventListener('progress', function (t) { n(t) }, !1), p.addEventListener('error', function (e) { i && i(e), r.manager.itemError(t) }, !1), void 0 !== this.responseType && (p.responseType = this.responseType), void 0 !== this.withCredentials && (p.withCredentials = this.withCredentials), p.overrideMimeType && p.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : 'text/plain'), p.send(null) } return r.manager.itemStart(t), p }, setPath: function (t) { return this.path = t, this }, setResponseType: function (t) { return this.responseType = t, this }, setWithCredentials: function (t) { return this.withCredentials = t, this }, setMimeType: function (t) { return this.mimeType = t, this } }), Object.assign(yn.prototype, { load: function (t, e, n, i) { const r = this; const a = []; const o = new xe(); o.image = a; const s = new vn(this.manager); if (s.setPath(this.path), s.setResponseType('arraybuffer'), Array.isArray(t)) for (var l = 0, c = 0, u = t.length; c < u; ++c)!(function (c) { s.load(t[c], function (t) { t = r._parser(t, !0), a[c] = { width: t.width, height: t.height, format: t.format, mipmaps: t.mipmaps }, (l += 1) === 6 && (t.mipmapCount === 1 && (o.minFilter = 1006), o.format = t.format, o.needsUpdate = !0, e && e(o)) }, n, i) }(c)); else s.load(t, function (t) { if (t = r._parser(t, !0), t.isCubemap) for (let n = t.mipmaps.length / t.mipmapCount, i = 0; i < n; i++) { a[i] = { mipmaps: [] }; for (let s = 0; s < t.mipmapCount; s++)a[i].mipmaps.push(t.mipmaps[i * t.mipmapCount + s]), a[i].format = t.format, a[i].width = t.width, a[i].height = t.height } else o.image.width = t.width, o.image.height = t.height, o.mipmaps = t.mipmaps; t.mipmapCount === 1 && (o.minFilter = 1006), o.format = t.format, o.needsUpdate = !0, e && e(o) }, n, i); return o }, setPath: function (t) { return this.path = t, this } }), Object.assign(bn.prototype, { load: function (t, e, n, i) { const r = this; const a = new V(); const o = new vn(this.manager); return o.setResponseType('arraybuffer'), o.load(t, function (t) { (t = r._parser(t)) && (void 0 !== t.image ? a.image = t.image : void 0 !== t.data && (a.image.width = t.width, a.image.height = t.height, a.image.data = t.data), a.wrapS = void 0 !== t.wrapS ? t.wrapS : 1001, a.wrapT = void 0 !== t.wrapT ? t.wrapT : 1001, a.magFilter = void 0 !== t.magFilter ? t.magFilter : 1006, a.minFilter = void 0 !== t.minFilter ? t.minFilter : 1008, a.anisotropy = void 0 !== t.anisotropy ? t.anisotropy : 1, void 0 !== t.format && (a.format = t.format), void 0 !== t.type && (a.type = t.type), void 0 !== t.mipmaps && (a.mipmaps = t.mipmaps), t.mipmapCount === 1 && (a.minFilter = 1006), a.needsUpdate = !0, e && e(a, t)) }, n, i), a } }), Object.assign(xn.prototype, { load: function (t, e, n, i) { void 0 === t && (t = ''), void 0 !== this.path && (t = this.path + t); const r = this; const a = Cr.get(t); return void 0 !== a ? (r.manager.itemStart(t), setTimeout(function () { e && e(a), r.manager.itemEnd(t) }, 0), a) : (n = document.createElementNS('http://www.w3.org/1999/xhtml', 'img'), n.addEventListener('load', function () { Cr.add(t, this), e && e(this), r.manager.itemEnd(t) }, !1), n.addEventListener('error', function (e) { i && i(e), r.manager.itemError(t) }, !1), void 0 !== this.crossOrigin && (n.crossOrigin = this.crossOrigin), r.manager.itemStart(t), n.src = t, n) }, setCrossOrigin: function (t) { return this.crossOrigin = t, this }, setPath: function (t) { return this.path = t, this } }), Object.assign(wn.prototype, { load: function (t, e, n, i) { const r = new u(); const a = new xn(this.manager); a.setCrossOrigin(this.crossOrigin), a.setPath(this.path); let o = 0; for (n = 0; n < t.length; ++n)!(function (n) { a.load(t[n], function (t) { r.images[n] = t, ++o == 6 && (r.needsUpdate = !0, e && e(r)) }, void 0, i) }(n)); return r }, setCrossOrigin: function (t) { return this.crossOrigin = t, this }, setPath: function (t) { return this.path = t, this } }), Object.assign(_n.prototype, { load: function (t, e, n, r) { const a = new i(); const o = new xn(this.manager); return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(t, function (n) { const i = t.search(/\.(jpg|jpeg)$/) > 0 || t.search(/^data\:image\/jpeg/) === 0; a.format = i ? 1022 : 1023, a.image = n, a.needsUpdate = !0, void 0 !== e && e(a) }, n, r), a }, setCrossOrigin: function (t) { return this.crossOrigin = t, this }, setPath: function (t) { return this.path = t, this } }), $n.prototype = Object.assign(Object.create(at.prototype), { constructor: $n, isLight: !0, copy: function (t) { return at.prototype.copy.call(this, t), this.color.copy(t.color), this.intensity = t.intensity, this }, toJSON: function (t) { return t = at.prototype.toJSON.call(this, t), t.object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()), t } }), Tn.prototype = Object.assign(Object.create($n.prototype), { constructor: Tn, isHemisphereLight: !0, copy: function (t) { return $n.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this } }), Object.assign(Sn.prototype, { copy: function (t) { return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this }, clone: function () { return (new this.constructor()).copy(this) }, toJSON: function () { const t = {}; return this.bias !== 0 && (t.bias = this.bias), this.radius !== 1 && (t.radius = this.radius), this.mapSize.x === 512 && this.mapSize.y === 512 || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t } }), Mn.prototype = Object.assign(Object.create(Sn.prototype), { constructor: Mn, isSpotLightShadow: !0, update: function (t) { const e = 2 * lr.RAD2DEG * t.angle; const n = this.mapSize.width / this.mapSize.height; t = t.distance || 500; const i = this.camera; e === i.fov && n === i.aspect && t === i.far || (i.fov = e, i.aspect = n, i.far = t, i.updateProjectionMatrix()) } }), Cn.prototype = Object.assign(Object.create($n.prototype), { constructor: Cn, isSpotLight: !0, copy: function (t) { return $n.prototype.copy.call(this, t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this } }), En.prototype = Object.assign(Object.create($n.prototype), { constructor: En, isPointLight: !0, copy: function (t) { return $n.prototype.copy.call(this, t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this } }), An.prototype = Object.assign(Object.create(Sn.prototype), { constructor: An }), Pn.prototype = Object.assign(Object.create($n.prototype), { constructor: Pn, isDirectionalLight: !0, copy: function (t) { return $n.prototype.copy.call(this, t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this } }), kn.prototype = Object.assign(Object.create($n.prototype), { constructor: kn, isAmbientLight: !0 }); var Ar = { arraySlice: function (t, e, n) { return Ar.isTypedArray(t) ? new t.constructor(t.subarray(e, n)) : t.slice(e, n) }, convertArray: function (t, e, n) { return !t || !n && t.constructor === e ? t : typeof e.BYTES_PER_ELEMENT === 'number' ? new e(t) : Array.prototype.slice.call(t) }, isTypedArray: function (t) { return ArrayBuffer.isView(t) && !(t instanceof DataView) }, getKeyframeOrder: function (t) { for (var e = t.length, n = Array(e), i = 0; i !== e; ++i)n[i] = i; return n.sort(function (e, n) { return t[e] - t[n] }), n }, sortedArray: function (t, e, n) { for (var i = t.length, r = new t.constructor(i), a = 0, o = 0; o !== i; ++a) for (let s = n[a] * e, l = 0; l !== e; ++l)r[o++] = t[s + l]; return r }, flattenJSON: function (t, e, n, i) { for (var r = 1, a = t[0]; void 0 !== a && void 0 === a[i];)a = t[r++]; if (void 0 !== a) { let o = a[i]; if (void 0 !== o) if (Array.isArray(o)) do { o = a[i], void 0 !== o && (e.push(a.time), n.push.apply(n, o)), a = t[r++] } while (void 0 !== a); else if (void 0 !== o.toArray) do { o = a[i], void 0 !== o && (e.push(a.time), o.toArray(n, n.length)), a = t[r++] } while (void 0 !== a); else do { o = a[i], void 0 !== o && (e.push(a.time), n.push(o)), a = t[r++] } while (void 0 !== a) } } }; Dn.prototype = { constructor: Dn, evaluate: function (t) { const e = this.parameterPositions; let n = this._cachedIndex; let i = e[n]; let r = e[n - 1]; t: { e: { n: { i:if (!(t < i)) { for (var a = n + 2; ;) { if (void 0 === i) { if (t < r) break i; return this._cachedIndex = n = e.length, this.afterEnd_(n - 1, t, r) } if (n === a) break; if (r = i, i = e[++n], t < i) break e }i = e.length; break n } if (t >= r) break t; for (a = e[1], t < a && (n = 2, r = a), a = n - 2; ;) { if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, t, i); if (n === a) break; if (i = r, r = e[--n - 1], t >= r) break e }i = n, n = 0 } for (;n < i;)r = n + i >>> 1, t < e[r] ? i = r : n = r + 1; if (i = e[n], void 0 === (r = e[n - 1])) return this._cachedIndex = 0, this.beforeStart_(0, t, i); if (void 0 === i) return this._cachedIndex = n = e.length, this.afterEnd_(n - 1, r, t) } this._cachedIndex = n, this.intervalChanged_(n, r, i) } return this.interpolate_(n, r, t, i) }, settings: null, DefaultSettings_: {}, getSettings_: function () { return this.settings || this.DefaultSettings_ }, copySampleValue_: function (t) { const e = this.resultBuffer; const n = this.sampleValues; const i = this.valueSize; t *= i; for (let r = 0; r !== i; ++r)e[r] = n[t + r]; return e }, interpolate_: function (t, e, n, i) { throw Error('call to abstract method') }, intervalChanged_: function (t, e, n) {} }, Object.assign(Dn.prototype, { beforeStart_: Dn.prototype.copySampleValue_, afterEnd_: Dn.prototype.copySampleValue_ }), On.prototype = Object.assign(Object.create(Dn.prototype), { constructor: On, DefaultSettings_: { endingStart: 2400, endingEnd: 2400 }, intervalChanged_: function (t, e, n) { let i = this.parameterPositions; let r = t - 2; let a = t + 1; let o = i[r]; let s = i[a]; if (void 0 === o) switch (this.getSettings_().endingStart) { case 2401:r = t, o = 2 * e - n; break; case 2402:r = i.length - 2, o = e + i[r] - i[r + 1]; break; default:r = t, o = n } if (void 0 === s) switch (this.getSettings_().endingEnd) { case 2401:a = t, s = 2 * n - e; break; case 2402:a = 1, s = n + i[1] - i[0]; break; default:a = t - 1, s = e }t = 0.5 * (n - e), i = this.valueSize, this._weightPrev = t / (e - o), this._weightNext = t / (s - n), this._offsetPrev = r * i, this._offsetNext = a * i }, interpolate_: function (t, e, n, i) { const r = this.resultBuffer; const a = this.sampleValues; const o = this.valueSize; t *= o; const s = t - o; const l = this._offsetPrev; const c = this._offsetNext; let u = this._weightPrev; let h = this._weightNext; let p = (n - e) / (i - e); for (n = p * p, i = n * p, e = -u * i + 2 * u * n - u * p, u = (1 + u) * i + (-1.5 - 2 * u) * n + (-0.5 + u) * p + 1, p = (-1 - h) * i + (1.5 + h) * n + 0.5 * p, h = h * i - h * n, n = 0; n !== o; ++n)r[n] = e * a[l + n] + u * a[s + n] + p * a[t + n] + h * a[c + n]; return r } }), Ln.prototype = Object.assign(Object.create(Dn.prototype), { constructor: Ln, interpolate_: function (t, e, n, i) { const r = this.resultBuffer; const a = this.sampleValues; const o = this.valueSize; t *= o; const s = t - o; for (e = (n - e) / (i - e), n = 1 - e, i = 0; i !== o; ++i)r[i] = a[s + i] * n + a[t + i] * e; return r } }), In.prototype = Object.assign(Object.create(Dn.prototype), { constructor: In, interpolate_: function (t, e, n, i) { return this.copySampleValue_(t - 1) } }); let Pr; Pr = { TimeBufferType: Float32Array, ValueBufferType: Float32Array, DefaultInterpolation: 2301, InterpolantFactoryMethodDiscrete: function (t) { return new In(this.times, this.values, this.getValueSize(), t) }, InterpolantFactoryMethodLinear: function (t) { return new Ln(this.times, this.values, this.getValueSize(), t) }, InterpolantFactoryMethodSmooth: function (t) { return new On(this.times, this.values, this.getValueSize(), t) }, setInterpolation: function (t) { let e; switch (t) { case 2300:e = this.InterpolantFactoryMethodDiscrete; break; case 2301:e = this.InterpolantFactoryMethodLinear; break; case 2302:e = this.InterpolantFactoryMethodSmooth } if (void 0 === e) { if (e = 'unsupported interpolation for ' + this.ValueTypeName + ' keyframe track named ' + this.name, void 0 === this.createInterpolant) { if (t === this.DefaultInterpolation) throw Error(e); this.setInterpolation(this.DefaultInterpolation) } } else this.createInterpolant = e }, getInterpolation: function () { switch (this.createInterpolant) { case this.InterpolantFactoryMethodDiscrete:return 2300; case this.InterpolantFactoryMethodLinear:return 2301; case this.InterpolantFactoryMethodSmooth:return 2302 } }, getValueSize: function () { return this.values.length / this.times.length }, shift: function (t) { if (t !== 0) for (let e = this.times, n = 0, i = e.length; n !== i; ++n)e[n] += t; return this }, scale: function (t) { if (t !== 1) for (let e = this.times, n = 0, i = e.length; n !== i; ++n)e[n] *= t; return this }, trim: function (t, e) { for (var n = this.times, i = n.length, r = 0, a = i - 1; r !== i && n[r] < t;)++r; for (;a !== -1 && n[a] > e;)--a; return ++a, r === 0 && a === i || (r >= a && (a = Math.max(a, 1), r = a - 1), i = this.getValueSize(), this.times = Ar.arraySlice(n, r, a), this.values = Ar.arraySlice(this.values, r * i, a * i)), this }, validate: function () { let t = !0; var e = this.getValueSize(); e - Math.floor(e) != 0 && (t = !1); let n = this.times; var e = this.values; let i = n.length; i === 0 && (t = !1); for (var r = null, a = 0; a !== i; a++) { const o = n[a]; if (typeof o === 'number' && isNaN(o)) { t = !1; break } if (r !== null && r > o) { t = !1; break }r = o } if (void 0 !== e && Ar.isTypedArray(e)) for (a = 0, n = e.length; a !== n; ++a) if (i = e[a], isNaN(i)) { t = !1; break } return t }, optimize: function () { for (var t = this.times, e = this.values, n = this.getValueSize(), i = this.getInterpolation() === 2302, r = 1, a = t.length - 1, o = 1; o < a; ++o) { var s = !1; var l = t[o]; if (l !== t[o + 1] && (o !== 1 || l !== l[0])) if (i)s = !0; else for (var c = o * n, u = c - n, h = c + n, l = 0; l !== n; ++l) { const p = e[c + l]; if (p !== e[u + l] || p !== e[h + l]) { s = !0; break } } if (s) { if (o !== r) for (t[r] = t[o], s = o * n, c = r * n, l = 0; l !== n; ++l)e[c + l] = e[s + l]; ++r } } if (a > 0) { for (t[r] = t[a], s = a * n, c = r * n, l = 0; l !== n; ++l)e[c + l] = e[s + l]; ++r } return r !== t.length && (this.times = Ar.arraySlice(t, 0, r), this.values = Ar.arraySlice(e, 0, r * n)), this } }, Nn.prototype = Object.assign(Object.create(Pr), { constructor: Nn, ValueTypeName: 'vector' }), Fn.prototype = Object.assign(Object.create(Dn.prototype), { constructor: Fn, interpolate_: function (t, e, n, i) { const r = this.resultBuffer; const a = this.sampleValues; const o = this.valueSize; for (t *= o, e = (n - e) / (i - e), n = t + o; t !== n; t += 4)s.slerpFlat(r, 0, a, t - o, a, t, e); return r } }), Un.prototype = Object.assign(Object.create(Pr), { constructor: Un, ValueTypeName: 'quaternion', DefaultInterpolation: 2301, InterpolantFactoryMethodLinear: function (t) { return new Fn(this.times, this.values, this.getValueSize(), t) }, InterpolantFactoryMethodSmooth: void 0 }), zn.prototype = Object.assign(Object.create(Pr), { constructor: zn, ValueTypeName: 'number' }), Bn.prototype = Object.assign(Object.create(Pr), { constructor: Bn, ValueTypeName: 'string', ValueBufferType: Array, DefaultInterpolation: 2300, InterpolantFactoryMethodLinear: void 0, InterpolantFactoryMethodSmooth: void 0 }), jn.prototype = Object.assign(Object.create(Pr), { constructor: jn, ValueTypeName: 'bool', ValueBufferType: Array, DefaultInterpolation: 2300, InterpolantFactoryMethodLinear: void 0, InterpolantFactoryMethodSmooth: void 0 }), Vn.prototype = Object.assign(Object.create(Pr), { constructor: Vn, ValueTypeName: 'color' }), Gn.prototype = Pr, Pr.constructor = Gn, Object.assign(Gn, { parse: function (t) { if (void 0 === t.type) throw Error('track type undefined, can not parse'); const e = Gn._getTrackTypeForValueTypeName(t.type); if (void 0 === t.times) { const n = []; const i = []; Ar.flattenJSON(t.keys, n, i, 'value'), t.times = n, t.values = i } return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation) }, toJSON: function (t) { var e = t.constructor; if (void 0 !== e.toJSON)e = e.toJSON(t); else { var e = { name: t.name, times: Ar.convertArray(t.times, Array), values: Ar.convertArray(t.values, Array) }; const n = t.getInterpolation(); n !== t.DefaultInterpolation && (e.interpolation = n) } return e.type = t.ValueTypeName, e }, _getTrackTypeForValueTypeName: function (t) { switch (t.toLowerCase()) { case 'scalar':case 'double':case 'float':case 'number':case 'integer':return zn; case 'vector':case 'vector2':case 'vector3':case 'vector4':return Nn; case 'color':return Vn; case 'quaternion':return Un; case 'bool':case 'boolean':return jn; case 'string':return Bn } throw Error('Unsupported typeName: ' + t) } }), Hn.prototype = { constructor: Hn, resetDuration: function () { for (var t = 0, e = 0, n = this.tracks.length; e !== n; ++e) var i = this.tracks[e], t = Math.max(t, i.times[i.times.length - 1]); this.duration = t }, trim: function () { for (let t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration); return this }, optimize: function () { for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize(); return this } }, Object.assign(Hn, { parse: function (t) { for (var e = [], n = t.tracks, i = 1 / (t.fps || 1), r = 0, a = n.length; r !== a; ++r)e.push(Gn.parse(n[r]).scale(i)); return new Hn(t.name, t.duration, e) }, toJSON: function (t) { const e = []; const n = t.tracks; t = { name: t.name, duration: t.duration, tracks: e }; for (let i = 0, r = n.length; i !== r; ++i)e.push(Gn.toJSON(n[i])); return t }, CreateFromMorphTargetSequence: function (t, e, n, i) { for (var r = e.length, a = [], o = 0; o < r; o++) { var s = []; var l = []; s.push((o + r - 1) % r, o, (o + 1) % r), l.push(0, 1, 0); const c = Ar.getKeyframeOrder(s); var s = Ar.sortedArray(s, 1, c); var l = Ar.sortedArray(l, 1, c); i || s[0] !== 0 || (s.push(r), l.push(l[0])), a.push(new zn('.morphTargetInfluences[' + e[o].name + ']', s, l).scale(1 / n)) } return new Hn(t, -1, a) }, findByName: function (t, e) { let n = t; Array.isArray(t) || (n = t.geometry && t.geometry.animations || t.animations); for (let i = 0; i < n.length; i++) if (n[i].name === e) return n[i]; return null }, CreateClipsFromMorphTargetSequences: function (t, e, n) { for (var i = {}, r = 0, a = t.length; r < a; r++) { const o = t[r]; let s = o.name.match(/^([\w-]*?)([\d]+)$/); if (s && s.length > 1) { var l = s[1]; (s = i[l]) || (i[l] = s = []), s.push(o) } }t = []; for (l in i)t.push(Hn.CreateFromMorphTargetSequence(l, i[l], e, n)); return t }, parseAnimation: function (t, e) { if (!t) return null; for (var n = function (t, e, n, i, r) { if (n.length !== 0) { const a = []; const o = []; Ar.flattenJSON(n, a, o, i), a.length !== 0 && r.push(new t(e, a, o)) } }, i = [], r = t.name || 'default', a = t.length || -1, o = t.fps || 30, s = t.hierarchy || [], l = 0; l < s.length; l++) { const c = s[l].keys; if (c && c.length !== 0) if (c[0].morphTargets) { for (var a = {}, u = 0; u < c.length; u++) if (c[u].morphTargets) for (var h = 0; h < c[u].morphTargets.length; h++)a[c[u].morphTargets[h]] = -1; for (const p in a) { for (var d = [], f = [], h = 0; h !== c[u].morphTargets.length; ++h) { const m = c[u]; d.push(m.time), f.push(m.morphTarget === p ? 1 : 0) }i.push(new zn('.morphTargetInfluence[' + p + ']', d, f)) }a = a.length * (o || 1) } else u = '.bones[' + e[l].name + ']', n(Nn, u + '.position', c, 'pos', i), n(Un, u + '.quaternion', c, 'rot', i), n(Nn, u + '.scale', c, 'scl', i) } return i.length === 0 ? null : new Hn(r, a, i) } }), Object.assign(Wn.prototype, {
    load: function (t, e, n, i) { const r = this; new vn(r.manager).load(t, function (t) { e(r.parse(JSON.parse(t))) }, n, i) },
    setTextures: function (t) { this.textures = t },
    parse: function (t) {
      function e (t) { return i[t], i[t] } var i = this.textures; const r = new Mr[t.type](); if (void 0 !== t.uuid && (r.uuid = t.uuid), void 0 !== t.name && (r.name = t.name), void 0 !== t.color && r.color.setHex(t.color), void 0 !== t.roughness && (r.roughness = t.roughness), void 0 !== t.metalness && (r.metalness = t.metalness), void 0 !== t.emissive && r.emissive.setHex(t.emissive), void 0 !== t.specular && r.specular.setHex(t.specular),
      void 0 !== t.shininess && (r.shininess = t.shininess), void 0 !== t.clearCoat && (r.clearCoat = t.clearCoat), void 0 !== t.clearCoatRoughness && (r.clearCoatRoughness = t.clearCoatRoughness), void 0 !== t.uniforms && (r.uniforms = t.uniforms), void 0 !== t.vertexShader && (r.vertexShader = t.vertexShader), void 0 !== t.fragmentShader && (r.fragmentShader = t.fragmentShader), void 0 !== t.vertexColors && (r.vertexColors = t.vertexColors), void 0 !== t.fog && (r.fog = t.fog), void 0 !== t.shading && (r.shading = t.shading), void 0 !== t.blending && (r.blending = t.blending), void 0 !== t.side && (r.side = t.side), void 0 !== t.opacity && (r.opacity = t.opacity), void 0 !== t.transparent && (r.transparent = t.transparent), void 0 !== t.alphaTest && (r.alphaTest = t.alphaTest), void 0 !== t.depthTest && (r.depthTest = t.depthTest), void 0 !== t.depthWrite && (r.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (r.colorWrite = t.colorWrite), void 0 !== t.wireframe && (r.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (r.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.wireframeLinecap && (r.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin && (r.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.skinning && (r.skinning = t.skinning), void 0 !== t.morphTargets && (r.morphTargets = t.morphTargets), void 0 !== t.size && (r.size = t.size), void 0 !== t.sizeAttenuation && (r.sizeAttenuation = t.sizeAttenuation), void 0 !== t.map && (r.map = e(t.map)), void 0 !== t.alphaMap && (r.alphaMap = e(t.alphaMap), r.transparent = !0), void 0 !== t.bumpMap && (r.bumpMap = e(t.bumpMap)), void 0 !== t.bumpScale && (r.bumpScale = t.bumpScale), void 0 !== t.normalMap && (r.normalMap = e(t.normalMap)), void 0 !== t.normalScale) { var a = t.normalScale; !1 === Array.isArray(a) && (a = [a, a]), r.normalScale = (new n()).fromArray(a) } if (void 0 !== t.displacementMap && (r.displacementMap = e(t.displacementMap)), void 0 !== t.displacementScale && (r.displacementScale = t.displacementScale), void 0 !== t.displacementBias && (r.displacementBias = t.displacementBias), void 0 !== t.roughnessMap && (r.roughnessMap = e(t.roughnessMap)), void 0 !== t.metalnessMap && (r.metalnessMap = e(t.metalnessMap)), void 0 !== t.emissiveMap && (r.emissiveMap = e(t.emissiveMap)), void 0 !== t.emissiveIntensity && (r.emissiveIntensity = t.emissiveIntensity), void 0 !== t.specularMap && (r.specularMap = e(t.specularMap)), void 0 !== t.envMap && (r.envMap = e(t.envMap)), void 0 !== t.reflectivity && (r.reflectivity = t.reflectivity), void 0 !== t.lightMap && (r.lightMap = e(t.lightMap)), void 0 !== t.lightMapIntensity && (r.lightMapIntensity = t.lightMapIntensity), void 0 !== t.aoMap && (r.aoMap = e(t.aoMap)), void 0 !== t.aoMapIntensity && (r.aoMapIntensity = t.aoMapIntensity), void 0 !== t.gradientMap && (r.gradientMap = e(t.gradientMap)), void 0 !== t.materials) for (var a = 0, o = t.materials.length; a < o; a++)r.materials.push(this.parse(t.materials[a])); return r
    }
  }), Object.assign(qn.prototype, { load: function (t, e, n, i) { const r = this; new vn(r.manager).load(t, function (t) { e(r.parse(JSON.parse(t))) }, n, i) }, parse: function (t) { const e = new $t(); var n = t.data.index; let i = { Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array }; void 0 !== n && (n = new i[n.type](n.array), e.setIndex(new ut(n, 1))); let r; let a = t.data.attributes; for (r in a) { const o = a[r]; var n = new i[o.type](o.array); e.addAttribute(r, new ut(n, o.itemSize, o.normalized)) } if (void 0 !== (i = t.data.groups || t.data.drawcalls || t.data.offsets)) for (r = 0, n = i.length; r !== n; ++r)a = i[r], e.addGroup(a.start, a.count, a.materialIndex); return t = t.data.boundingSphere, void 0 !== t && (i = new l(), void 0 !== t.center && i.fromArray(t.center), e.boundingSphere = new K(i, t.radius)), e } }), Xn.prototype = { constructor: Xn, crossOrigin: void 0, extractUrlBase: function (t) { return t = t.split('/'), t.length === 1 ? './' : (t.pop(), t.join('/') + '/') }, initMaterials: function (t, e, n) { for (var i = [], r = 0; r < t.length; ++r)i[r] = this.createMaterial(t[r], e, n); return i }, createMaterial: (function () { let t; let e; let n; const i = { NoBlending: 0, NormalBlending: 1, AdditiveBlending: 2, SubtractiveBlending: 3, MultiplyBlending: 4, CustomBlending: 5 }; return function (r, a, o) { function s (t, n, i, r, s) { t = a + t; const l = Xn.Handlers.get(t); return l !== null ? t = l.load(t) : (e.setCrossOrigin(o), t = e.load(t)), void 0 !== n && (t.repeat.fromArray(n), n[0] !== 1 && (t.wrapS = 1e3), n[1] !== 1 && (t.wrapT = 1e3)), void 0 !== i && t.offset.fromArray(i), void 0 !== r && (r[0] === 'repeat' && (t.wrapS = 1e3), r[0] === 'mirror' && (t.wrapS = 1002), r[1] === 'repeat' && (t.wrapT = 1e3), r[1] === 'mirror' && (t.wrapT = 1002)), void 0 !== s && (t.anisotropy = s), n = lr.generateUUID(), c[n] = t, n } void 0 === t && (t = new j()), void 0 === e && (e = new _n()), void 0 === n && (n = new Wn()); let l; var c = {}; const u = { uuid: lr.generateUUID(), type: 'MeshLambertMaterial' }; for (l in r) { const h = r[l]; switch (l) { case 'DbgColor':case 'DbgIndex':case 'opticalDensity':case 'illumination':break; case 'DbgName':u.name = h; break; case 'blending':u.blending = i[h]; break; case 'colorAmbient':case 'mapAmbient':break; case 'colorDiffuse':u.color = t.fromArray(h).getHex(); break; case 'colorSpecular':u.specular = t.fromArray(h).getHex(); break; case 'colorEmissive':u.emissive = t.fromArray(h).getHex(); break; case 'specularCoef':u.shininess = h; break; case 'shading':h.toLowerCase() === 'basic' && (u.type = 'MeshBasicMaterial'), h.toLowerCase() === 'phong' && (u.type = 'MeshPhongMaterial'), h.toLowerCase() === 'standard' && (u.type = 'MeshStandardMaterial'); break; case 'mapDiffuse':u.map = s(h, r.mapDiffuseRepeat, r.mapDiffuseOffset, r.mapDiffuseWrap, r.mapDiffuseAnisotropy); break; case 'mapDiffuseRepeat':case 'mapDiffuseOffset':case 'mapDiffuseWrap':case 'mapDiffuseAnisotropy':break; case 'mapEmissive':u.emissiveMap = s(h, r.mapEmissiveRepeat, r.mapEmissiveOffset, r.mapEmissiveWrap, r.mapEmissiveAnisotropy); break; case 'mapEmissiveRepeat':case 'mapEmissiveOffset':case 'mapEmissiveWrap':case 'mapEmissiveAnisotropy':break; case 'mapLight':u.lightMap = s(h, r.mapLightRepeat, r.mapLightOffset, r.mapLightWrap, r.mapLightAnisotropy); break; case 'mapLightRepeat':case 'mapLightOffset':case 'mapLightWrap':case 'mapLightAnisotropy':break; case 'mapAO':u.aoMap = s(h, r.mapAORepeat, r.mapAOOffset, r.mapAOWrap, r.mapAOAnisotropy); break; case 'mapAORepeat':case 'mapAOOffset':case 'mapAOWrap':case 'mapAOAnisotropy':break; case 'mapBump':u.bumpMap = s(h, r.mapBumpRepeat, r.mapBumpOffset, r.mapBumpWrap, r.mapBumpAnisotropy); break; case 'mapBumpScale':u.bumpScale = h; break; case 'mapBumpRepeat':case 'mapBumpOffset':case 'mapBumpWrap':case 'mapBumpAnisotropy':break; case 'mapNormal':u.normalMap = s(h, r.mapNormalRepeat, r.mapNormalOffset, r.mapNormalWrap, r.mapNormalAnisotropy); break; case 'mapNormalFactor':u.normalScale = [h, h]; break; case 'mapNormalRepeat':case 'mapNormalOffset':case 'mapNormalWrap':case 'mapNormalAnisotropy':break; case 'mapSpecular':u.specularMap = s(h, r.mapSpecularRepeat, r.mapSpecularOffset, r.mapSpecularWrap, r.mapSpecularAnisotropy); break; case 'mapSpecularRepeat':case 'mapSpecularOffset':case 'mapSpecularWrap':case 'mapSpecularAnisotropy':break; case 'mapMetalness':u.metalnessMap = s(h, r.mapMetalnessRepeat, r.mapMetalnessOffset, r.mapMetalnessWrap, r.mapMetalnessAnisotropy); break; case 'mapMetalnessRepeat':case 'mapMetalnessOffset':case 'mapMetalnessWrap':case 'mapMetalnessAnisotropy':break; case 'mapRoughness':u.roughnessMap = s(h, r.mapRoughnessRepeat, r.mapRoughnessOffset, r.mapRoughnessWrap, r.mapRoughnessAnisotropy); break; case 'mapRoughnessRepeat':case 'mapRoughnessOffset':case 'mapRoughnessWrap':case 'mapRoughnessAnisotropy':break; case 'mapAlpha':u.alphaMap = s(h, r.mapAlphaRepeat, r.mapAlphaOffset, r.mapAlphaWrap, r.mapAlphaAnisotropy); break; case 'mapAlphaRepeat':case 'mapAlphaOffset':case 'mapAlphaWrap':case 'mapAlphaAnisotropy':break; case 'flipSided':u.side = 1; break; case 'doubleSided':u.side = 2; break; case 'transparency':u.opacity = h; break; case 'depthTest':case 'depthWrite':case 'colorWrite':case 'opacity':case 'reflectivity':case 'transparent':case 'visible':case 'wireframe':u[l] = h; break; case 'vertexColors':!0 === h && (u.vertexColors = 2), h === 'face' && (u.vertexColors = 1) } } return u.type === 'MeshBasicMaterial' && delete u.emissive, u.type !== 'MeshPhongMaterial' && delete u.specular, u.opacity < 1 && (u.transparent = !0), n.setTextures(c), n.parse(u) } }()) }, Xn.Handlers = { handlers: [], add: function (t, e) { this.handlers.push(t, e) }, get: function (t) { for (let e = this.handlers, n = 0, i = e.length; n < i; n += 2) { const r = e[n + 1]; if (e[n].test(t)) return r } return null } }, Object.assign(Yn.prototype, { load: function (t, e, n, i) { const r = this; const a = this.texturePath && typeof this.texturePath === 'string' ? this.texturePath : Xn.prototype.extractUrlBase(t); const o = new vn(this.manager); o.setWithCredentials(this.withCredentials), o.load(t, function (t) { t = JSON.parse(t); let n = t.metadata; if (void 0 !== n && void 0 !== (n = n.type)) { if (n.toLowerCase() === 'object') return; if (n.toLowerCase() === 'scene') return }t = r.parse(t, a), e(t.geometry, t.materials) }, n, i) }, setTexturePath: function (t) { this.texturePath = t }, parse: function (t, e) { const i = new _t(); let a = void 0 !== t.scale ? 1 / t.scale : 1; return (function (e) { let r; let a; let o; let s; let c; let u; let h; let p; let d; let f; let m; let g; let v; const y = t.faces; u = t.vertices; const b = t.normals; const x = t.colors; let w = 0; if (void 0 !== t.uvs) { for (r = 0; r < t.uvs.length; r++)t.uvs[r].length && w++; for (r = 0; r < w; r++)i.faceVertexUvs[r] = [] } for (s = 0, c = u.length; s < c;)r = new l(), r.x = u[s++] * e, r.y = u[s++] * e, r.z = u[s++] * e, i.vertices.push(r); for (s = 0, c = y.length; s < c;) if (e = y[s++], d = 1 & e, o = 2 & e, r = 8 & e, h = 16 & e, f = 32 & e, u = 64 & e, e &= 128, d) { if (d = new lt(), d.a = y[s], d.b = y[s + 1], d.c = y[s + 3], m = new lt(), m.a = y[s + 1], m.b = y[s + 2], m.c = y[s + 3], s += 4, o && (o = y[s++], d.materialIndex = o, m.materialIndex = o), o = i.faces.length, r) for (r = 0; r < w; r++) for (g = t.uvs[r], i.faceVertexUvs[r][o] = [], i.faceVertexUvs[r][o + 1] = [], a = 0; a < 4; a++)p = y[s++], v = g[2 * p], p = g[2 * p + 1], v = new n(v, p), a !== 2 && i.faceVertexUvs[r][o].push(v), a !== 0 && i.faceVertexUvs[r][o + 1].push(v); if (h && (h = 3 * y[s++], d.normal.set(b[h++], b[h++], b[h]), m.normal.copy(d.normal)), f) for (r = 0; r < 4; r++)h = 3 * y[s++], f = new l(b[h++], b[h++], b[h]), r !== 2 && d.vertexNormals.push(f), r !== 0 && m.vertexNormals.push(f); if (u && (u = y[s++], u = x[u], d.color.setHex(u), m.color.setHex(u)), e) for (r = 0; r < 4; r++)u = y[s++], u = x[u], r !== 2 && d.vertexColors.push(new j(u)), r !== 0 && m.vertexColors.push(new j(u)); i.faces.push(d), i.faces.push(m) } else { if (d = new lt(), d.a = y[s++], d.b = y[s++], d.c = y[s++], o && (o = y[s++], d.materialIndex = o), o = i.faces.length, r) for (r = 0; r < w; r++) for (g = t.uvs[r], i.faceVertexUvs[r][o] = [], a = 0; a < 3; a++)p = y[s++], v = g[2 * p], p = g[2 * p + 1], v = new n(v, p), i.faceVertexUvs[r][o].push(v); if (h && (h = 3 * y[s++], d.normal.set(b[h++], b[h++], b[h])), f) for (r = 0; r < 3; r++)h = 3 * y[s++], f = new l(b[h++], b[h++], b[h]), d.vertexNormals.push(f); if (u && (u = y[s++], d.color.setHex(x[u])), e) for (r = 0; r < 3; r++)u = y[s++], d.vertexColors.push(new j(x[u])); i.faces.push(d) } }(a)), (function () { const e = void 0 !== t.influencesPerVertex ? t.influencesPerVertex : 2; if (t.skinWeights) for (var n = 0, a = t.skinWeights.length; n < a; n += e)i.skinWeights.push(new r(t.skinWeights[n], e > 1 ? t.skinWeights[n + 1] : 0, e > 2 ? t.skinWeights[n + 2] : 0, e > 3 ? t.skinWeights[n + 3] : 0)); if (t.skinIndices) for (n = 0, a = t.skinIndices.length; n < a; n += e)i.skinIndices.push(new r(t.skinIndices[n], e > 1 ? t.skinIndices[n + 1] : 0, e > 2 ? t.skinIndices[n + 2] : 0, e > 3 ? t.skinIndices[n + 3] : 0)); i.bones = t.bones, i.bones && i.bones.length > 0 && (i.skinWeights.length !== i.skinIndices.length || (i.skinIndices.length, i.vertices.length)) }()), (function (e) { if (void 0 !== t.morphTargets) for (var n = 0, r = t.morphTargets.length; n < r; n++) { i.morphTargets[n] = {}, i.morphTargets[n].name = t.morphTargets[n].name, i.morphTargets[n].vertices = []; for (var a = i.morphTargets[n].vertices, o = t.morphTargets[n].vertices, s = 0, c = o.length; s < c; s += 3) { const u = new l(); u.x = o[s] * e, u.y = o[s + 1] * e, u.z = o[s + 2] * e, a.push(u) } } if (void 0 !== t.morphColors && t.morphColors.length > 0) for (e = i.faces, a = t.morphColors[0].colors, n = 0, r = e.length; n < r; n++)e[n].color.fromArray(a, 3 * n) }(a)), (function () { let e = []; let n = []; void 0 !== t.animation && n.push(t.animation), void 0 !== t.animations && (t.animations.length ? n = n.concat(t.animations) : n.push(t.animations)); for (let r = 0; r < n.length; r++) { const a = Hn.parseAnimation(n[r], i.bones); a && e.push(a) }i.morphTargets && (n = Hn.CreateClipsFromMorphTargetSequences(i.morphTargets, 10), e = e.concat(n)), e.length > 0 && (i.animations = e) }()), i.computeFaceNormals(), i.computeBoundingSphere(), void 0 === t.materials || t.materials.length === 0 ? { geometry: i } : (a = Xn.prototype.initMaterials(t.materials, e, this.crossOrigin), { geometry: i, materials: a }) } }), Object.assign(Zn.prototype, { load: function (t, e, n, i) { this.texturePath === '' && (this.texturePath = t.substring(0, t.lastIndexOf('/') + 1)); const r = this; new vn(r.manager).load(t, function (t) { let n = null; try { n = JSON.parse(t) } catch (t) { return void (void 0 !== i && i(t)) } void 0 === (t = n.metadata) || void 0 === t.type || t.type.toLowerCase() === 'geometry' || r.parse(n, e) }, n, i) }, setTexturePath: function (t) { this.texturePath = t }, setCrossOrigin: function (t) { this.crossOrigin = t }, parse: function (t, e) { const n = this.parseGeometries(t.geometries); var i = this.parseImages(t.images, function () { void 0 !== e && e(r) }); var i = this.parseTextures(t.textures, i); var i = this.parseMaterials(t.materials, i); var r = this.parseObject(t.object, n, i); return t.animations && (r.animations = this.parseAnimations(t.animations)), void 0 !== t.images && t.images.length !== 0 || void 0 === e || e(r), r }, parseGeometries: function (t) { const e = {}; if (void 0 !== t) for (let n = new Yn(), i = new qn(), r = 0, a = t.length; r < a; r++) { var o; const s = t[r]; switch (s.type) { case 'PlaneGeometry':case 'PlaneBufferGeometry':o = new Sr[s.type](s.width, s.height, s.widthSegments, s.heightSegments); break; case 'BoxGeometry':case 'BoxBufferGeometry':case 'CubeGeometry':o = new Sr[s.type](s.width, s.height, s.depth, s.widthSegments, s.heightSegments, s.depthSegments); break; case 'CircleGeometry':case 'CircleBufferGeometry':o = new Sr[s.type](s.radius, s.segments, s.thetaStart, s.thetaLength); break; case 'CylinderGeometry':case 'CylinderBufferGeometry':o = new Sr[s.type](s.radiusTop, s.radiusBottom, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength); break; case 'ConeGeometry':case 'ConeBufferGeometry':o = new Sr[s.type](s.radius, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength); break; case 'SphereGeometry':case 'SphereBufferGeometry':o = new Sr[s.type](s.radius, s.widthSegments, s.heightSegments, s.phiStart, s.phiLength, s.thetaStart, s.thetaLength); break; case 'DodecahedronGeometry':case 'IcosahedronGeometry':case 'OctahedronGeometry':case 'TetrahedronGeometry':o = new Sr[s.type](s.radius, s.detail); break; case 'RingGeometry':case 'RingBufferGeometry':o = new Sr[s.type](s.innerRadius, s.outerRadius, s.thetaSegments, s.phiSegments, s.thetaStart, s.thetaLength); break; case 'TorusGeometry':case 'TorusBufferGeometry':o = new Sr[s.type](s.radius, s.tube, s.radialSegments, s.tubularSegments, s.arc); break; case 'TorusKnotGeometry':case 'TorusKnotBufferGeometry':o = new Sr[s.type](s.radius, s.tube, s.tubularSegments, s.radialSegments, s.p, s.q); break; case 'LatheGeometry':case 'LatheBufferGeometry':o = new Sr[s.type](s.points, s.segments, s.phiStart, s.phiLength); break; case 'BufferGeometry':o = i.parse(s); break; case 'Geometry':o = n.parse(s.data, this.texturePath).geometry; break; default:continue }o.uuid = s.uuid, void 0 !== s.name && (o.name = s.name), e[s.uuid] = o } return e }, parseMaterials: function (t, e) { const n = {}; if (void 0 !== t) { const i = new Wn(); i.setTextures(e); for (let r = 0, a = t.length; r < a; r++) { const o = i.parse(t[r]); n[o.uuid] = o } } return n }, parseAnimations: function (t) { for (var e = [], n = 0; n < t.length; n++) { const i = Hn.parse(t[n]); e.push(i) } return e }, parseImages: function (t, e) { const n = this; const i = {}; if (void 0 !== t && t.length > 0) { var r = new gn(e); const a = new xn(r); a.setCrossOrigin(this.crossOrigin); for (var r = 0, o = t.length; r < o; r++) { const s = t[r]; const l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(s.url) ? s.url : n.texturePath + s.url; i[s.uuid] = (function (t) { return n.manager.itemStart(t), a.load(t, function () { n.manager.itemEnd(t) }, void 0, function () { n.manager.itemError(t) }) }(l)) } } return i }, parseTextures: function (t, e) { function n (t, e) { return typeof t === 'number' ? t : e[t] } const r = { UVMapping: 300, CubeReflectionMapping: 301, CubeRefractionMapping: 302, EquirectangularReflectionMapping: 303, EquirectangularRefractionMapping: 304, SphericalReflectionMapping: 305, CubeUVReflectionMapping: 306, CubeUVRefractionMapping: 307 }; const a = { RepeatWrapping: 1e3, ClampToEdgeWrapping: 1001, MirroredRepeatWrapping: 1002 }; const o = { NearestFilter: 1003, NearestMipMapNearestFilter: 1004, NearestMipMapLinearFilter: 1005, LinearFilter: 1006, LinearMipMapNearestFilter: 1007, LinearMipMapLinearFilter: 1008 }; const s = {}; if (void 0 !== t) for (let l = 0, c = t.length; l < c; l++) { const u = t[l]; u.image, e[u.image]; const h = new i(e[u.image]); h.needsUpdate = !0, h.uuid = u.uuid, void 0 !== u.name && (h.name = u.name), void 0 !== u.mapping && (h.mapping = n(u.mapping, r)), void 0 !== u.offset && h.offset.fromArray(u.offset), void 0 !== u.repeat && h.repeat.fromArray(u.repeat), void 0 !== u.wrap && (h.wrapS = n(u.wrap[0], a), h.wrapT = n(u.wrap[1], a)), void 0 !== u.minFilter && (h.minFilter = n(u.minFilter, o)), void 0 !== u.magFilter && (h.magFilter = n(u.magFilter, o)), void 0 !== u.anisotropy && (h.anisotropy = u.anisotropy), void 0 !== u.flipY && (h.flipY = u.flipY), s[u.uuid] = h } return s }, parseObject: (function () { const t = new c(); return function (e, n, i) { function r (t) { return n[t], n[t] } function a (t) { if (void 0 !== t) return i[t], i[t] } let o; switch (e.type) { case 'Scene':o = new ae(), void 0 !== e.background && Number.isInteger(e.background) && (o.background = new j(e.background)), void 0 !== e.fog && (e.fog.type === 'Fog' ? o.fog = new re(e.fog.color, e.fog.near, e.fog.far) : e.fog.type === 'FogExp2' && (o.fog = new ie(e.fog.color, e.fog.density))); break; case 'PerspectiveCamera':o = new Pt(e.fov, e.aspect, e.near, e.far), void 0 !== e.focus && (o.focus = e.focus), void 0 !== e.zoom && (o.zoom = e.zoom), void 0 !== e.filmGauge && (o.filmGauge = e.filmGauge), void 0 !== e.filmOffset && (o.filmOffset = e.filmOffset), void 0 !== e.view && (o.view = Object.assign({}, e.view)); break; case 'OrthographicCamera':o = new kt(e.left, e.right, e.top, e.bottom, e.near, e.far); break; case 'AmbientLight':o = new kn(e.color, e.intensity); break; case 'DirectionalLight':o = new Pn(e.color, e.intensity); break; case 'PointLight':o = new En(e.color, e.intensity, e.distance, e.decay); break; case 'SpotLight':o = new Cn(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay); break; case 'HemisphereLight':o = new Tn(e.color, e.groundColor, e.intensity); break; case 'Mesh':o = r(e.geometry); var s = a(e.material); o = o.bones && o.bones.length > 0 ? new pe(o, s) : new Tt(o, s); break; case 'LOD':o = new ce(); break; case 'Line':o = new fe(r(e.geometry), a(e.material), e.mode); break; case 'LineSegments':o = new me(r(e.geometry), a(e.material)); break; case 'PointCloud':case 'Points':o = new ve(r(e.geometry), a(e.material)); break; case 'Sprite':o = new le(a(e.material)); break; case 'Group':o = new ye(); break; case 'SkinnedMesh':default:o = new at() } if (o.uuid = e.uuid, void 0 !== e.name && (o.name = e.name), void 0 !== e.matrix ? (t.fromArray(e.matrix), t.decompose(o.position, o.quaternion, o.scale)) : (void 0 !== e.position && o.position.fromArray(e.position), void 0 !== e.rotation && o.rotation.fromArray(e.rotation), void 0 !== e.quaternion && o.quaternion.fromArray(e.quaternion), void 0 !== e.scale && o.scale.fromArray(e.scale)), void 0 !== e.castShadow && (o.castShadow = e.castShadow), void 0 !== e.receiveShadow && (o.receiveShadow = e.receiveShadow), e.shadow && (void 0 !== e.shadow.bias && (o.shadow.bias = e.shadow.bias), void 0 !== e.shadow.radius && (o.shadow.radius = e.shadow.radius), void 0 !== e.shadow.mapSize && o.shadow.mapSize.fromArray(e.shadow.mapSize), void 0 !== e.shadow.camera && (o.shadow.camera = this.parseObject(e.shadow.camera))), void 0 !== e.visible && (o.visible = e.visible), void 0 !== e.userData && (o.userData = e.userData), void 0 !== e.children) for (var l in e.children)o.add(this.parseObject(e.children[l], n, i)); if (e.type === 'LOD') for (e = e.levels, s = 0; s < e.length; s++) { const c = e[s]; l = o.getObjectByProperty('uuid', c.object), void 0 !== l && o.addLevel(l, c.distance) } return o } }()) }), ti.prototype = { constructor: ti, getPoint: function (t) { return null }, getPointAt: function (t) { return t = this.getUtoTmapping(t), this.getPoint(t) }, getPoints: function (t) { isNaN(t) && (t = 5); for (var e = [], n = 0; n <= t; n++)e.push(this.getPoint(n / t)); return e }, getSpacedPoints: function (t) { isNaN(t) && (t = 5); for (var e = [], n = 0; n <= t; n++)e.push(this.getPointAt(n / t)); return e }, getLength: function () { const t = this.getLengths(); return t[t.length - 1] }, getLengths: function (t) { if (isNaN(t) && (t = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200), this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths; this.needsUpdate = !1; let e; let n; const i = []; let r = this.getPoint(0); let a = 0; for (i.push(0), n = 1; n <= t; n++)e = this.getPoint(n / t), a += e.distanceTo(r), i.push(a), r = e; return this.cacheArcLengths = i }, updateArcLengths: function () { this.needsUpdate = !0, this.getLengths() }, getUtoTmapping: function (t, e) { let n; let i; const r = this.getLengths(); const a = r.length; i = e || t * r[a - 1]; for (var o, s = 0, l = a - 1; s <= l;) if (n = Math.floor(s + (l - s) / 2), (o = r[n] - i) < 0)s = n + 1; else { if (!(o > 0)) { l = n; break }l = n - 1 } return n = l, r[n] === i ? n / (a - 1) : (s = r[n], (n + (i - s) / (r[n + 1] - s)) / (a - 1)) }, getTangent: function (t) { let e = t - 1e-4; return t += 1e-4, e < 0 && (e = 0), t > 1 && (t = 1), e = this.getPoint(e), this.getPoint(t).clone().sub(e).normalize() }, getTangentAt: function (t) { return t = this.getUtoTmapping(t), this.getTangent(t) }, computeFrenetFrames: function (t, e) { let n; let i; let r = new l(); const a = []; const o = []; const s = []; const u = new l(); const h = new c(); for (n = 0; n <= t; n++)i = n / t, a[n] = this.getTangentAt(i), a[n].normalize(); o[0] = new l(), s[0] = new l(), n = Number.MAX_VALUE, i = Math.abs(a[0].x); const p = Math.abs(a[0].y); const d = Math.abs(a[0].z); for (i <= n && (n = i, r.set(1, 0, 0)), p <= n && (n = p, r.set(0, 1, 0)), d <= n && r.set(0, 0, 1), u.crossVectors(a[0], r).normalize(), o[0].crossVectors(a[0], u), s[0].crossVectors(a[0], o[0]), n = 1; n <= t; n++)o[n] = o[n - 1].clone(), s[n] = s[n - 1].clone(), u.crossVectors(a[n - 1], a[n]), u.length() > Number.EPSILON && (u.normalize(), r = Math.acos(lr.clamp(a[n - 1].dot(a[n]), -1, 1)), o[n].applyMatrix4(h.makeRotationAxis(u, r))), s[n].crossVectors(a[n], o[n]); if (!0 === e) for (r = Math.acos(lr.clamp(o[0].dot(o[t]), -1, 1)), r /= t, a[0].dot(u.crossVectors(o[0], o[t])) > 0 && (r = -r), n = 1; n <= t; n++)o[n].applyMatrix4(h.makeRotationAxis(a[n], r * n)), s[n].crossVectors(a[n], o[n]); return { tangents: a, normals: o, binormals: s } } }, ei.prototype = Object.create(ti.prototype), ei.prototype.constructor = ei, ei.prototype.isLineCurve = !0, ei.prototype.getPoint = function (t) { if (t === 1) return this.v2.clone(); const e = this.v2.clone().sub(this.v1); return e.multiplyScalar(t).add(this.v1), e }, ei.prototype.getPointAt = function (t) { return this.getPoint(t) }, ei.prototype.getTangent = function (t) { return this.v2.clone().sub(this.v1).normalize() }, ni.prototype = Object.assign(Object.create(ti.prototype), { constructor: ni, add: function (t) { this.curves.push(t) }, closePath: function () { const t = this.curves[0].getPoint(0); const e = this.curves[this.curves.length - 1].getPoint(1); t.equals(e) || this.curves.push(new ei(e, t)) }, getPoint: function (t) { let e = t * this.getLength(); let n = this.getCurveLengths(); for (t = 0; t < n.length;) { if (n[t] >= e) return e = n[t] - e, t = this.curves[t], n = t.getLength(), t.getPointAt(n === 0 ? 0 : 1 - e / n); t++ } return null }, getLength: function () { const t = this.getCurveLengths(); return t[t.length - 1] }, updateArcLengths: function () { this.needsUpdate = !0, this.cacheLengths = null, this.getLengths() }, getCurveLengths: function () { if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths; for (var t = [], e = 0, n = 0, i = this.curves.length; n < i; n++)e += this.curves[n].getLength(), t.push(e); return this.cacheLengths = t }, getSpacedPoints: function (t) { isNaN(t) && (t = 40); for (var e = [], n = 0; n <= t; n++)e.push(this.getPoint(n / t)); return this.autoClose && e.push(e[0]), e }, getPoints: function (t) { t = t || 12; for (var e, n = [], i = 0, r = this.curves; i < r.length; i++) for (var a = r[i], a = a.getPoints(a && a.isEllipseCurve ? 2 * t : a && a.isLineCurve ? 1 : a && a.isSplineCurve ? t * a.points.length : t), o = 0; o < a.length; o++) { const s = a[o]; e && e.equals(s) || (n.push(s), e = s) } return this.autoClose && n.length > 1 && !n[n.length - 1].equals(n[0]) && n.push(n[0]), n }, createPointsGeometry: function (t) { return t = this.getPoints(t), this.createGeometry(t) }, createSpacedPointsGeometry: function (t) { return t = this.getSpacedPoints(t), this.createGeometry(t) }, createGeometry: function (t) { for (var e = new _t(), n = 0, i = t.length; n < i; n++) { const r = t[n]; e.vertices.push(new l(r.x, r.y, r.z || 0)) } return e } }), ii.prototype = Object.create(ti.prototype), ii.prototype.constructor = ii, ii.prototype.isEllipseCurve = !0, ii.prototype.getPoint = function (t) { for (var e = 2 * Math.PI, i = this.aEndAngle - this.aStartAngle, r = Math.abs(i) < Number.EPSILON; i < 0;)i += e; for (;i > e;)i -= e; i < Number.EPSILON && (i = r ? 0 : e), !0 !== this.aClockwise || r || (i = i === e ? -e : i - e), e = this.aStartAngle + t * i, t = this.aX + this.xRadius * Math.cos(e); let a = this.aY + this.yRadius * Math.sin(e); return this.aRotation !== 0 && (e = Math.cos(this.aRotation), i = Math.sin(this.aRotation), r = t - this.aX, a -= this.aY, t = r * e - a * i + this.aX, a = r * i + a * e + this.aY), new n(t, a) }, ri.prototype = Object.create(ti.prototype), ri.prototype.constructor = ri, ri.prototype.isSplineCurve = !0, ri.prototype.getPoint = function (t) { var e = this.points; var i = (e.length - 1) * t; t = Math.floor(i); var i = i - t; const r = e[t === 0 ? t : t - 1]; const a = e[t]; const o = e[t > e.length - 2 ? e.length - 1 : t + 1]; var e = e[t > e.length - 3 ? e.length - 1 : t + 2]; return new n(Kn(i, r.x, a.x, o.x, e.x), Kn(i, r.y, a.y, o.y, e.y)) }, ai.prototype = Object.create(ti.prototype), ai.prototype.constructor = ai, ai.prototype.getPoint = function (t) { const e = this.v0; const i = this.v1; const r = this.v2; const a = this.v3; return new n(Qn(t, e.x, i.x, r.x, a.x), Qn(t, e.y, i.y, r.y, a.y)) }, oi.prototype = Object.create(ti.prototype), oi.prototype.constructor = oi, oi.prototype.getPoint = function (t) { const e = this.v0; const i = this.v1; const r = this.v2; return new n(Jn(t, e.x, i.x, r.x), Jn(t, e.y, i.y, r.y)) }; const kr = Object.assign(Object.create(ni.prototype), { fromPoints: function (t) { this.moveTo(t[0].x, t[0].y); for (let e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y) }, moveTo: function (t, e) { this.currentPoint.set(t, e) }, lineTo: function (t, e) { const i = new ei(this.currentPoint.clone(), new n(t, e)); this.curves.push(i), this.currentPoint.set(t, e) }, quadraticCurveTo: function (t, e, i, r) { t = new oi(this.currentPoint.clone(), new n(t, e), new n(i, r)), this.curves.push(t), this.currentPoint.set(i, r) }, bezierCurveTo: function (t, e, i, r, a, o) { t = new ai(this.currentPoint.clone(), new n(t, e), new n(i, r), new n(a, o)), this.curves.push(t), this.currentPoint.set(a, o) }, splineThru: function (t) { var e = [this.currentPoint.clone()].concat(t); var e = new ri(e); this.curves.push(e), this.currentPoint.copy(t[t.length - 1]) }, arc: function (t, e, n, i, r, a) { this.absarc(t + this.currentPoint.x, e + this.currentPoint.y, n, i, r, a) }, absarc: function (t, e, n, i, r, a) { this.absellipse(t, e, n, n, i, r, a) }, ellipse: function (t, e, n, i, r, a, o, s) { this.absellipse(t + this.currentPoint.x, e + this.currentPoint.y, n, i, r, a, o, s) }, absellipse: function (t, e, n, i, r, a, o, s) { t = new ii(t, e, n, i, r, a, o, s), this.curves.length > 0 && (e = t.getPoint(0), e.equals(this.currentPoint) || this.lineTo(e.x, e.y)), this.curves.push(t), t = t.getPoint(1), this.currentPoint.copy(t) } }); si.prototype = kr, kr.constructor = si, li.prototype = Object.assign(Object.create(kr), { constructor: li, getPointsHoles: function (t) { for (var e = [], n = 0, i = this.holes.length; n < i; n++)e[n] = this.holes[n].getPoints(t); return e }, extractAllPoints: function (t) { return { shape: this.getPoints(t), holes: this.getPointsHoles(t) } }, extractPoints: function (t) { return this.extractAllPoints(t) } }), ci.prototype = { moveTo: function (t, e) { this.currentPath = new si(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e) }, lineTo: function (t, e) { this.currentPath.lineTo(t, e) }, quadraticCurveTo: function (t, e, n, i) { this.currentPath.quadraticCurveTo(t, e, n, i) }, bezierCurveTo: function (t, e, n, i, r, a) { this.currentPath.bezierCurveTo(t, e, n, i, r, a) }, splineThru: function (t) { this.currentPath.splineThru(t) }, toShapes: function (t, e) { function n (t) { for (var e = [], n = 0, i = t.length; n < i; n++) { const r = t[n]; const a = new li(); a.curves = r.curves, e.push(a) } return e } let i = Tr.isClockWise; let r = this.subPaths; if (r.length === 0) return []; if (!0 === e) return n(r); let a; let o; let s; const l = []; if (r.length === 1) return o = r[0], s = new li(), s.curves = o.curves, l.push(s), l; var c = !i(r[0].getPoints()); var c = t ? !c : c; s = []; let u; const h = []; let p = []; let d = 0; h[d] = void 0, p[d] = []; for (var f = 0, m = r.length; f < m; f++)o = r[f], u = o.getPoints(), a = i(u), (a = t ? !a : a) ? (!c && h[d] && d++, h[d] = { s: new li(), p: u }, h[d].s.curves = o.curves, c && d++, p[d] = []) : p[d].push({ h: o, p: u[0] }); if (!h[0]) return n(r); if (h.length > 1) { for (f = !1, o = [], i = 0, r = h.length; i < r; i++)s[i] = []; for (i = 0, r = h.length; i < r; i++) for (a = p[i], c = 0; c < a.length; c++) { for (d = a[c], u = !0, m = 0; m < h.length; m++)(function (t, e) { for (var n = e.length, i = !1, r = n - 1, a = 0; a < n; r = a++) { let o = e[r]; let s = e[a]; let l = s.x - o.x; let c = s.y - o.y; if (Math.abs(c) > Number.EPSILON) { if (c < 0 && (o = e[a], l = -l, s = e[r], c = -c), !(t.y < o.y || t.y > s.y)) if (t.y === o.y) { if (t.x === o.x) return !0 } else { if ((r = c * (t.x - o.x) - l * (t.y - o.y)) === 0) return !0; r < 0 || (i = !i) } } else if (t.y === o.y && (s.x <= t.x && t.x <= o.x || o.x <= t.x && t.x <= s.x)) return !0 } return i })(d.p, h[m].p) && (i !== m && o.push({ froms: i, tos: m, hole: c }), u ? (u = !1, s[m].push(d)) : f = !0); u && s[i].push(d) }o.length > 0 && (f || (p = s)) } for (f = 0, i = h.length; f < i; f++) for (s = h[f].s, l.push(s), o = p[f], r = 0, a = o.length; r < a; r++)s.holes.push(o[r].h); return l } }, Object.assign(ui.prototype, { isFont: !0, generateShapes: function (t, e, n) { void 0 === e && (e = 100), void 0 === n && (n = 4); let i = this.data; t = String(t).split(''); const r = e / i.resolution; const a = (i.boundingBox.yMax - i.boundingBox.yMin + i.underlineThickness) * r; let o = 0; let s = 0; e = []; for (let l = 0; l < t.length; l++) { let c = t[l]; if (c === '\n')o = 0, s -= a; else { var u; u = r; const h = o; const p = s; if (c = i.glyphs[c] || i.glyphs['?']) { var d; var f; var m; var g; var v; var y; var b; var x; const w = new ci(); const _ = []; if (c.o) for (let $ = c._cachedOutline || (c._cachedOutline = c.o.split(' ')), T = 0, S = $.length; T < S;) switch ($[T++]) { case 'm':d = $[T++] * u + h, f = $[T++] * u + p, w.moveTo(d, f); break; case 'l':d = $[T++] * u + h, f = $[T++] * u + p, w.lineTo(d, f); break; case 'q':if (d = $[T++] * u + h, f = $[T++] * u + p, v = $[T++] * u + h, y = $[T++] * u + p, w.quadraticCurveTo(v, y, d, f), g = _[_.length - 1]) { m = g.x, g = g.y; for (var M = 1; M <= n; M++) { var C = M / n; Jn(C, m, v, d), Jn(C, g, y, f) } } break; case 'b':if (d = $[T++] * u + h, f = $[T++] * u + p, v = $[T++] * u + h, y = $[T++] * u + p, b = $[T++] * u + h, x = $[T++] * u + p, w.bezierCurveTo(v, y, b, x, d, f), g = _[_.length - 1]) for (m = g.x, g = g.y, M = 1; M <= n; M++)C = M / n, Qn(C, m, v, b, d), Qn(C, g, y, x, f) }u = { offsetX: c.ha * u, path: w } } else u = void 0; o += u.offsetX, e.push(u.path) } } for (n = [], i = 0, t = e.length; i < t; i++)Array.prototype.push.apply(n, e[i].toShapes()); return n } }), Object.assign(hi.prototype, { load: function (t, e, n, i) { const r = this; new vn(this.manager).load(t, function (t) { let n; try { n = JSON.parse(t) } catch (e) { n = JSON.parse(t.substring(65, t.length - 2)) }t = r.parse(n), e && e(t) }, n, i) }, parse: function (t) { return new ui(t) } }); let Dr; var Or = { getContext: function () { return void 0 === Dr && (Dr = new (window.AudioContext || window.webkitAudioContext)()), Dr }, setContext: function (t) { Dr = t } }; Object.assign(pi.prototype, { load: function (t, e, n, i) { const r = new vn(this.manager); r.setResponseType('arraybuffer'), r.load(t, function (t) { Or.getContext().decodeAudioData(t, function (t) { e(t) }) }, n, i) } }), di.prototype = Object.assign(Object.create($n.prototype), { constructor: di, isRectAreaLight: !0, copy: function (t) { return $n.prototype.copy.call(this, t), this.width = t.width, this.height = t.height, this } }), Object.assign(fi.prototype, { update: (function () { let t; let e; let n; let i; let r; let a; let o; const s = new c(); const l = new c(); return function (c) { if (t !== this || e !== c.focus || n !== c.fov || i !== c.aspect * this.aspect || r !== c.near || a !== c.far || o !== c.zoom) { t = this, e = c.focus, n = c.fov, i = c.aspect * this.aspect, r = c.near, a = c.far, o = c.zoom; let u; const h = c.projectionMatrix.clone(); let p = this.eyeSep / 2; const d = p * r / e; const f = r * Math.tan(lr.DEG2RAD * n * 0.5) / o; l.elements[12] = -p, s.elements[12] = p, p = -f * i + d, u = f * i + d, h.elements[0] = 2 * r / (u - p), h.elements[8] = (u + p) / (u - p), this.cameraL.projectionMatrix.copy(h), p = -f * i - d, u = f * i - d, h.elements[0] = 2 * r / (u - p), h.elements[8] = (u + p) / (u - p), this.cameraR.projectionMatrix.copy(h) } this.cameraL.matrixWorld.copy(c.matrixWorld).multiply(l), this.cameraR.matrixWorld.copy(c.matrixWorld).multiply(s) } }()) }), mi.prototype = Object.create(at.prototype), mi.prototype.constructor = mi, gi.prototype = Object.assign(Object.create(at.prototype), {
    constructor: gi,
    getInput: function () { return this.gain },
    removeFilter: function () { this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null) },
    getFilter: function () { return this.filter },
    setFilter: function (t) { this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = t, this.gain.connect(this.filter), this.filter.connect(this.context.destination) },
    getMasterVolume: function () { return this.gain.gain.value },
    setMasterVolume: function (t) { this.gain.gain.value = t },
    updateMatrixWorld: (function () {
      const t = new l(); const e = new s(); const n = new l(); const i = new l(); return function (r) {
        at.prototype.updateMatrixWorld.call(this, r), r = this.context.listener; const a = this.up; this.matrixWorld.decompose(t, e, n), i.set(0, 0, -1).applyQuaternion(e), r.positionX
          ? (r.positionX.setValueAtTime(t.x, this.context.currentTime), r.positionY.setValueAtTime(t.y, this.context.currentTime), r.positionZ.setValueAtTime(t.z, this.context.currentTime), r.forwardX.setValueAtTime(i.x, this.context.currentTime), r.forwardY.setValueAtTime(i.y, this.context.currentTime), r.forwardZ.setValueAtTime(i.z, this.context.currentTime), r.upX.setValueAtTime(a.x, this.context.currentTime), r.upY.setValueAtTime(a.y, this.context.currentTime), r.upZ.setValueAtTime(a.z, this.context.currentTime))
          : (r.setPosition(t.x, t.y, t.z),
            r.setOrientation(i.x, i.y, i.z, a.x, a.y, a.z))
      }
    }())
  }), vi.prototype = Object.assign(Object.create(at.prototype), { constructor: vi, getOutput: function () { return this.gain }, setNodeSource: function (t) { return this.hasPlaybackControl = !1, this.sourceType = 'audioNode', this.source = t, this.connect(), this }, setBuffer: function (t) { return this.buffer = t, this.sourceType = 'buffer', this.autoplay && this.play(), this }, play: function () { if (!0 === this.isPlaying);else if (!1 !== this.hasPlaybackControl) { const t = this.context.createBufferSource(); return t.buffer = this.buffer, t.loop = this.loop, t.onended = this.onEnded.bind(this), t.playbackRate.setValueAtTime(this.playbackRate, this.startTime), t.start(0, this.startTime), this.isPlaying = !0, this.source = t, this.connect() } }, pause: function () { if (!1 !== this.hasPlaybackControl) return this.source.stop(), this.startTime = this.context.currentTime, this.isPlaying = !1, this }, stop: function () { if (!1 !== this.hasPlaybackControl) return this.source.stop(), this.startTime = 0, this.isPlaying = !1, this }, connect: function () { if (this.filters.length > 0) { this.source.connect(this.filters[0]); for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].connect(this.filters[t]); this.filters[this.filters.length - 1].connect(this.getOutput()) } else this.source.connect(this.getOutput()); return this }, disconnect: function () { if (this.filters.length > 0) { this.source.disconnect(this.filters[0]); for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].disconnect(this.filters[t]); this.filters[this.filters.length - 1].disconnect(this.getOutput()) } else this.source.disconnect(this.getOutput()); return this }, getFilters: function () { return this.filters }, setFilters: function (t) { return t || (t = []), !0 === this.isPlaying ? (this.disconnect(), this.filters = t, this.connect()) : this.filters = t, this }, getFilter: function () { return this.getFilters()[0] }, setFilter: function (t) { return this.setFilters(t ? [t] : []) }, setPlaybackRate: function (t) { if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setValueAtTime(this.playbackRate, this.context.currentTime), this }, getPlaybackRate: function () { return this.playbackRate }, onEnded: function () { this.isPlaying = !1 }, getLoop: function () { return !1 !== this.hasPlaybackControl && this.loop }, setLoop: function (t) { if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this }, getVolume: function () { return this.gain.gain.value }, setVolume: function (t) { return this.gain.gain.value = t, this } }), yi.prototype = Object.assign(Object.create(vi.prototype), { constructor: yi, getOutput: function () { return this.panner }, getRefDistance: function () { return this.panner.refDistance }, setRefDistance: function (t) { this.panner.refDistance = t }, getRolloffFactor: function () { return this.panner.rolloffFactor }, setRolloffFactor: function (t) { this.panner.rolloffFactor = t }, getDistanceModel: function () { return this.panner.distanceModel }, setDistanceModel: function (t) { this.panner.distanceModel = t }, getMaxDistance: function () { return this.panner.maxDistance }, setMaxDistance: function (t) { this.panner.maxDistance = t }, updateMatrixWorld: (function () { const t = new l(); return function (e) { at.prototype.updateMatrixWorld.call(this, e), t.setFromMatrixPosition(this.matrixWorld), this.panner.setPosition(t.x, t.y, t.z) } }()) }), Object.assign(bi.prototype, { getFrequencyData: function () { return this.analyser.getByteFrequencyData(this.data), this.data }, getAverageFrequency: function () { for (var t = 0, e = this.getFrequencyData(), n = 0; n < e.length; n++)t += e[n]; return t / e.length } }), xi.prototype = { constructor: xi, accumulate: function (t, e) { const n = this.buffer; const i = this.valueSize; const r = t * i + i; let a = this.cumulativeWeight; if (a === 0) { for (a = 0; a !== i; ++a)n[r + a] = n[a]; a = e } else a += e, this._mixBufferRegion(n, r, 0, e / a, i); this.cumulativeWeight = a }, apply: function (t) { const e = this.valueSize; const n = this.buffer; t = t * e + e; var i = this.cumulativeWeight; const r = this.binding; this.cumulativeWeight = 0, i < 1 && this._mixBufferRegion(n, t, 3 * e, 1 - i, e); for (var i = e, a = e + e; i !== a; ++i) if (n[i] !== n[i + e]) { r.setValue(n, t); break } }, saveOriginalState: function () { const t = this.buffer; const e = this.valueSize; const n = 3 * e; this.binding.getValue(t, n); for (let i = e; i !== n; ++i)t[i] = t[n + i % e]; this.cumulativeWeight = 0 }, restoreOriginalState: function () { this.binding.setValue(this.buffer, 3 * this.valueSize) }, _select: function (t, e, n, i, r) { if (i >= 0.5) for (i = 0; i !== r; ++i)t[e + i] = t[n + i] }, _slerp: function (t, e, n, i, r) { s.slerpFlat(t, e, t, e, t, n, i) }, _lerp: function (t, e, n, i, r) { for (let a = 1 - i, o = 0; o !== r; ++o) { const s = e + o; t[s] = t[s] * a + t[n + o] * i } } }, wi.prototype = { constructor: wi, getValue: function (t, e) { this.bind(), this.getValue(t, e) }, setValue: function (t, e) { this.bind(), this.setValue(t, e) }, bind: function () { let t = this.node; let e = this.parsedPath; let n = e.objectName; const i = e.propertyName; let r = e.propertyIndex; if (t || (this.node = t = wi.findNode(this.rootNode, e.nodeName) || this.rootNode), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, t) { if (n) { var a = e.objectIndex; switch (n) { case 'materials':if (!t.material) return; if (!t.material.materials) return; t = t.material.materials; break; case 'bones':if (!t.skeleton) return; for (t = t.skeleton.bones, n = 0; n < t.length; n++) if (t[n].name === a) { a = n; break } break; default:if (void 0 === t[n]) return; t = t[n] } if (void 0 !== a) { if (void 0 === t[a]) return; t = t[a] } } if (void 0 === (a = t[i]));else { if (e = this.Versioning.None, void 0 !== t.needsUpdate ? (e = this.Versioning.NeedsUpdate, this.targetObject = t) : void 0 !== t.matrixWorldNeedsUpdate && (e = this.Versioning.MatrixWorldNeedsUpdate, this.targetObject = t), n = this.BindingType.Direct, void 0 !== r) { if (i === 'morphTargetInfluences') { if (!t.geometry) return; if (!t.geometry.morphTargets) return; for (n = 0; n < this.node.geometry.morphTargets.length; n++) if (t.geometry.morphTargets[n].name === r) { r = n; break } }n = this.BindingType.ArrayElement, this.resolvedProperty = a, this.propertyIndex = r } else void 0 !== a.fromArray && void 0 !== a.toArray ? (n = this.BindingType.HasFromToArray, this.resolvedProperty = a) : void 0 !== a.length ? (n = this.BindingType.EntireArray, this.resolvedProperty = a) : this.propertyName = i; this.getValue = this.GetterByBindingType[n], this.setValue = this.SetterByBindingTypeAndVersioning[n][e] } } }, unbind: function () { this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } }, Object.assign(wi.prototype, { _getValue_unavailable: function () {}, _setValue_unavailable: function () {}, _getValue_unbound: wi.prototype.getValue, _setValue_unbound: wi.prototype.setValue, BindingType: { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, GetterByBindingType: [function (t, e) { t[e] = this.node[this.propertyName] }, function (t, e) { for (let n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i)t[e++] = n[i] }, function (t, e) { t[e] = this.resolvedProperty[this.propertyIndex] }, function (t, e) { this.resolvedProperty.toArray(t, e) }], SetterByBindingTypeAndVersioning: [[function (t, e) { this.node[this.propertyName] = t[e] }, function (t, e) { this.node[this.propertyName] = t[e], this.targetObject.needsUpdate = !0 }, function (t, e) { this.node[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0 }], [function (t, e) { for (let n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i)n[i] = t[e++] }, function (t, e) { for (let n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i)n[i] = t[e++]; this.targetObject.needsUpdate = !0 }, function (t, e) { for (let n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i)n[i] = t[e++]; this.targetObject.matrixWorldNeedsUpdate = !0 }], [function (t, e) { this.resolvedProperty[this.propertyIndex] = t[e] }, function (t, e) { this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0 }, function (t, e) { this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0 }], [function (t, e) { this.resolvedProperty.fromArray(t, e) }, function (t, e) { this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0 }, function (t, e) { this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0 }]] }), wi.Composite = function (t, e, n) { n = n || wi.parseTrackName(e), this._targetGroup = t, this._bindings = t.subscribe_(e, n) }, wi.Composite.prototype = { constructor: wi.Composite, getValue: function (t, e) { this.bind(); const n = this._bindings[this._targetGroup.nCachedObjects_]; void 0 !== n && n.getValue(t, e) }, setValue: function (t, e) { for (let n = this._bindings, i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i)n[i].setValue(t, e) }, bind: function () { for (let t = this._bindings, e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)t[e].bind() }, unbind: function () { for (let t = this._bindings, e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)t[e].unbind() } }, wi.create = function (t, e, n) { return t && t.isAnimationObjectGroup ? new wi.Composite(t, e, n) : new wi(t, e, n) }, wi.parseTrackName = function (t) { let e = /^((?:[\w-]+[\/:])*)([\w-]+)?(?:\.([\w-]+)(?:\[(.+)\])?)?\.([\w-]+)(?:\[(.+)\])?$/.exec(t); if (!e) throw Error('cannot parse trackName at all: ' + t); if (e = { nodeName: e[2], objectName: e[3], objectIndex: e[4], propertyName: e[5], propertyIndex: e[6] }, e.propertyName === null || e.propertyName.length === 0) throw Error('can not parse propertyName from trackName: ' + t); return e }, wi.findNode = function (t, e) { if (!e || e === '' || e === 'root' || e === '.' || e === -1 || e === t.name || e === t.uuid) return t; if (t.skeleton) { var n = (function (t) { for (let n = 0; n < t.bones.length; n++) { const i = t.bones[n]; if (i.name === e) return i } return null }(t.skeleton)); if (n) return n } if (t.children) { const i = function (t) { for (let n = 0; n < t.length; n++) { let r = t[n]; if (r.name === e || r.uuid === e || (r = i(r.children))) return r } return null }; if (n = i(t.children)) return n } return null }, _i.prototype = { constructor: _i, isAnimationObjectGroup: !0, add: function (t) { for (var e = this._objects, n = e.length, i = this.nCachedObjects_, r = this._indicesByUUID, a = this._paths, o = this._parsedPaths, s = this._bindings, l = s.length, c = 0, u = arguments.length; c !== u; ++c) { const h = arguments[c]; var p = h.uuid; let d = r[p]; if (void 0 === d) { d = n++, r[p] = d, e.push(h); for (var p = 0, f = l; p !== f; ++p)s[p].push(new wi(h, a[p], o[p])) } else if (d < i) { const m = --i; var f = e[m]; for (r[f.uuid] = d, e[d] = f, r[p] = m, e[m] = h, p = 0, f = l; p !== f; ++p) { const g = s[p]; let v = g[d]; g[d] = g[m], void 0 === v && (v = new wi(h, a[p], o[p])), g[m] = v } } else e[d] } this.nCachedObjects_ = i }, remove: function (t) { for (var e = this._objects, n = this.nCachedObjects_, i = this._indicesByUUID, r = this._bindings, a = r.length, o = 0, s = arguments.length; o !== s; ++o) { let l = arguments[o]; let c = l.uuid; const u = i[c]; if (void 0 !== u && u >= n) { const h = n++; var p = e[h]; for (i[p.uuid] = u, e[u] = p, i[c] = h, e[h] = l, l = 0, c = a; l !== c; ++l) { var p = r[l]; const d = p[u]; p[u] = p[h], p[h] = d } } } this.nCachedObjects_ = n }, uncache: function (t) { for (var e = this._objects, n = e.length, i = this.nCachedObjects_, r = this._indicesByUUID, a = this._bindings, o = a.length, s = 0, l = arguments.length; s !== l; ++s) { var c = arguments[s].uuid; const u = r[c]; if (void 0 !== u) if (delete r[c], u < i) { var c = --i; var h = e[c]; var p = --n; var d = e[p]; for (r[h.uuid] = u, e[u] = h, r[d.uuid] = c, e[c] = d, e.pop(), h = 0, d = o; h !== d; ++h) { var f = a[h]; const m = f[p]; f[u] = f[c], f[c] = m, f.pop() } } else for (p = --n, d = e[p], r[d.uuid] = u, e[u] = d, e.pop(), h = 0, d = o; h !== d; ++h)f = a[h], f[u] = f[p], f.pop() } this.nCachedObjects_ = i }, subscribe_: function (t, e) { let n = this._bindingsIndicesByPath; var i = n[t]; const r = this._bindings; if (void 0 !== i) return r[i]; const a = this._paths; const o = this._parsedPaths; const s = this._objects; const l = this.nCachedObjects_; const c = Array(s.length); var i = r.length; for (n[t] = i, a.push(t), o.push(e), r.push(c), n = l, i = s.length; n !== i; ++n)c[n] = new wi(s[n], t, e); return c }, unsubscribe_: function (t) { const e = this._bindingsIndicesByPath; const n = e[t]; if (void 0 !== n) { const i = this._paths; const r = this._parsedPaths; const a = this._bindings; const o = a.length - 1; const s = a[o]; e[t[o]] = n, a[n] = s, a.pop(), r[n] = r[o], r.pop(), i[n] = i[o], i.pop() } } }, $i.prototype = { constructor: $i, play: function () { return this._mixer._activateAction(this), this }, stop: function () { return this._mixer._deactivateAction(this), this.reset() }, reset: function () { return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping() }, isRunning: function () { return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this) }, isScheduled: function () { return this._mixer._isActiveAction(this) }, startAt: function (t) { return this._startTime = t, this }, setLoop: function (t, e) { return this.loop = t, this.repetitions = e, this }, setEffectiveWeight: function (t) { return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading() }, getEffectiveWeight: function () { return this._effectiveWeight }, fadeIn: function (t) { return this._scheduleFading(t, 0, 1) }, fadeOut: function (t) { return this._scheduleFading(t, 1, 0) }, crossFadeFrom: function (t, e, n) { if (t.fadeOut(e), this.fadeIn(e), n) { n = this._clip.duration; const i = t._clip.duration; const r = n / i; t.warp(1, i / n, e), this.warp(r, 1, e) } return this }, crossFadeTo: function (t, e, n) { return t.crossFadeFrom(this, e, n) }, stopFading: function () { const t = this._weightInterpolant; return t !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this }, setEffectiveTimeScale: function (t) { return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping() }, getEffectiveTimeScale: function () { return this._effectiveTimeScale }, setDuration: function (t) { return this.timeScale = this._clip.duration / t, this.stopWarping() }, syncWith: function (t) { return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping() }, halt: function (t) { return this.warp(this._effectiveTimeScale, 0, t) }, warp: function (t, e, n) { let i = this._mixer; const r = i.time; let a = this._timeScaleInterpolant; const o = this.timeScale; return a === null && (this._timeScaleInterpolant = a = i._lendControlInterpolant()), i = a.parameterPositions, a = a.sampleValues, i[0] = r, i[1] = r + n, a[0] = t / o, a[1] = e / o, this }, stopWarping: function () { const t = this._timeScaleInterpolant; return t !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this }, getMixer: function () { return this._mixer }, getClip: function () { return this._clip }, getRoot: function () { return this._localRoot || this._mixer._root }, _update: function (t, e, n, i) { var r = this._startTime; if (r !== null) { if ((e = (t - r) * n) < 0 || n === 0) return; this._startTime = null, e *= n } if (e *= this._updateTimeScale(t), n = this._updateTime(e), (t = this._updateWeight(t)) > 0) { e = this._interpolants; for (var r = this._propertyBindings, a = 0, o = e.length; a !== o; ++a)e[a].evaluate(n), r[a].accumulate(i, t) } }, _updateWeight: function (t) { var e = 0; if (this.enabled) { var e = this.weight; const n = this._weightInterpolant; if (n !== null) { const i = n.evaluate(t)[0]; var e = e * i; t > n.parameterPositions[1] && (this.stopFading(), i === 0 && (this.enabled = !1)) } } return this._effectiveWeight = e }, _updateTimeScale: function (t) { var e = 0; if (!this.paused) { var e = this.timeScale; const n = this._timeScaleInterpolant; if (n !== null) { const i = n.evaluate(t)[0]; var e = e * i; t > n.parameterPositions[1] && (this.stopWarping(), e === 0 ? this.paused = !0 : this.timeScale = e) } } return this._effectiveTimeScale = e }, _updateTime: function (t) { var e = this.time + t; if (t === 0) return e; const n = this._clip.duration; let i = this.loop; var r = this._loopCount; if (i === 2200)t: { if (r === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1)), e >= n)e = n; else { if (!(e < 0)) break t; e = 0 } this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this._mixer.dispatchEvent({ type: 'finished', action: this, direction: t < 0 ? -1 : 1 }) } else { if (i = i === 2202, r === -1 && (t >= 0 ? (r = 0, this._setEndings(!0, this.repetitions === 0, i)) : this._setEndings(this.repetitions === 0, !0, i)), e >= n || e < 0) { const a = Math.floor(e / n); var e = e - n * a; var r = r + Math.abs(a); const o = this.repetitions - r; o < 0 ? (this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, e = t > 0 ? n : 0, this._mixer.dispatchEvent({ type: 'finished', action: this, direction: t > 0 ? 1 : -1 })) : (o === 0 ? (t = t < 0, this._setEndings(t, !t, i)) : this._setEndings(!1, !1, i), this._loopCount = r, this._mixer.dispatchEvent({ type: 'loop', action: this, loopDelta: a })) } if (i && (1 & r) == 1) return this.time = e, n - e } return this.time = e }, _setEndings: function (t, e, n) { const i = this._interpolantSettings; n ? (i.endingStart = 2401, i.endingEnd = 2401) : (i.endingStart = t ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, i.endingEnd = e ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402) }, _scheduleFading: function (t, e, n) { let i = this._mixer; const r = i.time; let a = this._weightInterpolant; return a === null && (this._weightInterpolant = a = i._lendControlInterpolant()), i = a.parameterPositions, a = a.sampleValues, i[0] = r, a[0] = e, i[1] = r + t, a[1] = n, this } }, Ti.prototype = { constructor: Ti, clipAction: function (t, e) { var n = e || this._root; const i = n.uuid; let r = typeof t === 'string' ? Hn.findByName(n, t) : t; var n = r !== null ? r.uuid : t; const a = this._actionsByClip[n]; let o = null; if (void 0 !== a) { if (void 0 !== (o = a.actionByRoot[i])) return o; o = a.knownActions[0], r === null && (r = o._clip) } return r === null ? null : (r = new $i(this, r, e), this._bindAction(r, o), this._addInactiveAction(r, n, i), r) }, existingAction: function (t, e) { var n = e || this._root; const i = n.uuid; var n = typeof t === 'string' ? Hn.findByName(n, t) : t; var n = this._actionsByClip[n ? n.uuid : t]; return void 0 !== n ? n.actionByRoot[i] || null : null }, stopAllAction: function () { for (var t = this._actions, e = this._nActiveActions, n = this._bindings, i = this._nActiveBindings, r = this._nActiveBindings = this._nActiveActions = 0; r !== e; ++r)t[r].reset(); for (r = 0; r !== i; ++r)n[r].useCount = 0; return this }, update: function (t) { t *= this.timeScale; for (var e = this._actions, n = this._nActiveActions, i = this.time += t, r = Math.sign(t), a = this._accuIndex ^= 1, o = 0; o !== n; ++o) { const s = e[o]; s.enabled && s._update(i, t, r, a) } for (t = this._bindings, e = this._nActiveBindings, o = 0; o !== e; ++o)t[o].apply(a); return this }, getRoot: function () { return this._root }, uncacheClip: function (t) { const e = this._actions; t = t.uuid; const n = this._actionsByClip; var i = n[t]; if (void 0 !== i) { for (var i = i.knownActions, r = 0, a = i.length; r !== a; ++r) { const o = i[r]; this._deactivateAction(o); const s = o._cacheIndex; const l = e[e.length - 1]; o._cacheIndex = null, o._byClipCacheIndex = null, l._cacheIndex = s, e[s] = l, e.pop(), this._removeInactiveBindingsForAction(o) } delete n[t] } }, uncacheRoot: function (t) { t = t.uuid; let e; const n = this._actionsByClip; for (e in n) { const i = n[e].actionByRoot[t]; void 0 !== i && (this._deactivateAction(i), this._removeInactiveAction(i)) } if (void 0 !== (e = this._bindingsByRootAndName[t])) for (const r in e)t = e[r], t.restoreOriginalState(), this._removeInactiveBinding(t) }, uncacheAction: function (t, e) { const n = this.existingAction(t, e); n !== null && (this._deactivateAction(n), this._removeInactiveAction(n)) } }, Object.assign(Ti.prototype, { _bindAction: function (t, e) { const n = t._localRoot || this._root; const i = t._clip.tracks; const r = i.length; const a = t._propertyBindings; const o = t._interpolants; const s = n.uuid; let l = this._bindingsByRootAndName; let c = l[s]; for (void 0 === c && (c = {}, l[s] = c), l = 0; l !== r; ++l) { const u = i[l]; const h = u.name; let p = c[h]; if (void 0 === p) { if (void 0 !== (p = a[l])) { p._cacheIndex === null && (++p.referenceCount, this._addInactiveBinding(p, s, h)); continue }p = new xi(wi.create(n, h, e && e._propertyBindings[l].binding.parsedPath), u.ValueTypeName, u.getValueSize()), ++p.referenceCount, this._addInactiveBinding(p, s, h) }a[l] = p, o[l].resultBuffer = p.buffer } }, _activateAction: function (t) { if (!this._isActiveAction(t)) { if (t._cacheIndex === null) { var e = (t._localRoot || this._root).uuid; var n = t._clip.uuid; var i = this._actionsByClip[n]; this._bindAction(t, i && i.knownActions[0]), this._addInactiveAction(t, n, e) } for (e = t._propertyBindings, n = 0, i = e.length; n !== i; ++n) { const r = e[n]; r.useCount++ == 0 && (this._lendBinding(r), r.saveOriginalState()) } this._lendAction(t) } }, _deactivateAction: function (t) { if (this._isActiveAction(t)) { for (let e = t._propertyBindings, n = 0, i = e.length; n !== i; ++n) { const r = e[n]; --r.useCount == 0 && (r.restoreOriginalState(), this._takeBackBinding(r)) } this._takeBackAction(t) } }, _initMemoryManager: function () { this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0; const t = this; this.stats = { actions: { get total () { return t._actions.length }, get inUse () { return t._nActiveActions } }, bindings: { get total () { return t._bindings.length }, get inUse () { return t._nActiveBindings } }, controlInterpolants: { get total () { return t._controlInterpolants.length }, get inUse () { return t._nActiveControlInterpolants } } } }, _isActiveAction: function (t) { return (t = t._cacheIndex) !== null && t < this._nActiveActions }, _addInactiveAction: function (t, e, n) { const i = this._actions; const r = this._actionsByClip; let a = r[e]; void 0 === a ? (a = { knownActions: [t], actionByRoot: {} }, t._byClipCacheIndex = 0, r[e] = a) : (e = a.knownActions, t._byClipCacheIndex = e.length, e.push(t)), t._cacheIndex = i.length, i.push(t), a.actionByRoot[n] = t }, _removeInactiveAction: function (t) { const e = this._actions; var n = e[e.length - 1]; var i = t._cacheIndex; n._cacheIndex = i, e[i] = n, e.pop(), t._cacheIndex = null; var n = t._clip.uuid; var i = this._actionsByClip; const r = i[n]; const a = r.knownActions; const o = a[a.length - 1]; const s = t._byClipCacheIndex; o._byClipCacheIndex = s, a[s] = o, a.pop(), t._byClipCacheIndex = null, delete r.actionByRoot[(e._localRoot || this._root).uuid], a.length === 0 && delete i[n], this._removeInactiveBindingsForAction(t) }, _removeInactiveBindingsForAction: function (t) { t = t._propertyBindings; for (let e = 0, n = t.length; e !== n; ++e) { const i = t[e]; --i.referenceCount == 0 && this._removeInactiveBinding(i) } }, _lendAction: function (t) { const e = this._actions; const n = t._cacheIndex; const i = this._nActiveActions++; const r = e[i]; t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r }, _takeBackAction: function (t) { const e = this._actions; const n = t._cacheIndex; const i = --this._nActiveActions; const r = e[i]; t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r }, _addInactiveBinding: function (t, e, n) { const i = this._bindingsByRootAndName; let r = i[e]; const a = this._bindings; void 0 === r && (r = {}, i[e] = r), r[n] = t, t._cacheIndex = a.length, a.push(t) }, _removeInactiveBinding: function (t) { const e = this._bindings; var n = t.binding; const i = n.rootNode.uuid; var n = n.path; const r = this._bindingsByRootAndName; const a = r[i]; const o = e[e.length - 1]; t = t._cacheIndex, o._cacheIndex = t, e[t] = o, e.pop(), delete a[n]; t: { for (const s in a) break t; delete r[i] } }, _lendBinding: function (t) { const e = this._bindings; const n = t._cacheIndex; const i = this._nActiveBindings++; const r = e[i]; t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r }, _takeBackBinding: function (t) { const e = this._bindings; const n = t._cacheIndex; const i = --this._nActiveBindings; const r = e[i]; t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r }, _lendControlInterpolant: function () { const t = this._controlInterpolants; const e = this._nActiveControlInterpolants++; let n = t[e]; return void 0 === n && (n = new Ln(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), n.__cacheIndex = e, t[e] = n), n }, _takeBackControlInterpolant: function (t) { const e = this._controlInterpolants; const n = t.__cacheIndex; const i = --this._nActiveControlInterpolants; const r = e[i]; t.__cacheIndex = i, e[i] = t, r.__cacheIndex = n, e[n] = r }, _controlInterpolantsResultBuffer: new Float32Array(1) }), Object.assign(Ti.prototype, e.prototype), Si.prototype.clone = function () { return new Si(void 0 === this.value.clone ? this.value : this.value.clone()) }, Mi.prototype = Object.create($t.prototype), Mi.prototype.constructor = Mi, Mi.prototype.isInstancedBufferGeometry = !0, Mi.prototype.addGroup = function (t, e, n) { this.groups.push({ start: t, count: e, materialIndex: n }) }, Mi.prototype.copy = function (t) { var e = t.index; e !== null && this.setIndex(e.clone()); let n; var e = t.attributes; for (n in e) this.addAttribute(n, e[n].clone()); for (t = t.groups, n = 0, e = t.length; n < e; n++) { const i = t[n]; this.addGroup(i.start, i.count, i.materialIndex) } return this }, Ci.prototype = { constructor: Ci, isInterleavedBufferAttribute: !0, get count () { return this.data.count }, get array () { return this.data.array }, setX: function (t, e) { return this.data.array[t * this.data.stride + this.offset] = e, this }, setY: function (t, e) { return this.data.array[t * this.data.stride + this.offset + 1] = e, this }, setZ: function (t, e) { return this.data.array[t * this.data.stride + this.offset + 2] = e, this }, setW: function (t, e) { return this.data.array[t * this.data.stride + this.offset + 3] = e, this }, getX: function (t) { return this.data.array[t * this.data.stride + this.offset] }, getY: function (t) { return this.data.array[t * this.data.stride + this.offset + 1] }, getZ: function (t) { return this.data.array[t * this.data.stride + this.offset + 2] }, getW: function (t) { return this.data.array[t * this.data.stride + this.offset + 3] }, setXY: function (t, e, n) { return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this }, setXYZ: function (t, e, n, i) { return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this }, setXYZW: function (t, e, n, i, r) { return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this.data.array[t + 3] = r, this } }, Ei.prototype = { constructor: Ei, isInterleavedBuffer: !0, set needsUpdate (t) { !0 === t && this.version++ }, setArray: function (t) { if (Array.isArray(t)) throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.'); this.count = void 0 !== t ? t.length / this.stride : 0, this.array = t }, setDynamic: function (t) { return this.dynamic = t, this }, copy: function (t) { return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.dynamic = t.dynamic, this }, copyAt: function (t, e, n) { t *= this.stride, n *= e.stride; for (let i = 0, r = this.stride; i < r; i++) this.array[t + i] = e.array[n + i]; return this }, set: function (t, e) { return void 0 === e && (e = 0), this.array.set(t, e), this }, clone: function () { return (new this.constructor()).copy(this) }, onUpload: function (t) { return this.onUploadCallback = t, this } }, Ai.prototype = Object.create(Ei.prototype), Ai.prototype.constructor = Ai, Ai.prototype.isInstancedInterleavedBuffer = !0, Ai.prototype.copy = function (t) { return Ei.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this }, Pi.prototype = Object.create(ut.prototype), Pi.prototype.constructor = Pi, Pi.prototype.isInstancedBufferAttribute = !0, Pi.prototype.copy = function (t) { return ut.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this }, ki.prototype = { constructor: ki, linePrecision: 1, set: function (t, e) { this.ray.set(t, e) }, setFromCamera: function (t, e) { e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, 0.5).unproject(e).sub(this.ray.origin).normalize()) : e && e.isOrthographicCamera && (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld)) }, intersectObject: function (t, e) { const n = []; return Oi(t, this, n, e), n.sort(Di), n }, intersectObjects: function (t, e) { const n = []; if (!1 === Array.isArray(t)) return n; for (let i = 0, r = t.length; i < r; i++)Oi(t[i], this, n, e); return n.sort(Di), n } }, Li.prototype = { constructor: Li, start: function () { this.oldTime = this.startTime = (performance || Date).now(), this.elapsedTime = 0, this.running = !0 }, stop: function () { this.getElapsedTime(), this.running = !1 }, getElapsedTime: function () { return this.getDelta(), this.elapsedTime }, getDelta: function () { var t = 0; if (this.autoStart && !this.running && this.start(), this.running) { const e = (performance || Date).now(); var t = (e - this.oldTime) / 1e3; this.oldTime = e, this.elapsedTime += t } return t } }, Ii.prototype = { constructor: Ii, set: function (t, e, n) { return this.radius = t, this.phi = e, this.theta = n, this }, clone: function () { return (new this.constructor()).copy(this) }, copy: function (t) { return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this }, makeSafe: function () { return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this }, setFromVector3: function (t) { return this.radius = t.length(), this.radius === 0 ? this.phi = this.theta = 0 : (this.theta = Math.atan2(t.x, t.z), this.phi = Math.acos(lr.clamp(t.y / this.radius, -1, 1))), this } }, Ri.prototype = { constructor: Ri, set: function (t, e, n) { return this.radius = t, this.theta = e, this.y = n, this }, clone: function () { return (new this.constructor()).copy(this) }, copy: function (t) { return this.radius = t.radius, this.theta = t.theta, this.y = t.y, this }, setFromVector3: function (t) { return this.radius = Math.sqrt(t.x * t.x + t.z * t.z), this.theta = Math.atan2(t.x, t.z), this.y = t.y, this } }, Ni.prototype = Object.create(Tt.prototype), Ni.prototype.constructor = Ni, Ni.prototype.createAnimation = function (t, e, n, i) { e = { start: e, end: n, length: n - e + 1, fps: i, duration: (n - e) / i, lastFrame: 0, currentFrame: 0, active: !1, time: 0, direction: 1, weight: 1, directionBackwards: !1, mirroredLoop: !1 }, this.animationsMap[t] = e, this.animationsList.push(e) }, Ni.prototype.autoCreateAnimations = function (t) { for (var e, n = {}, i = this.geometry, r = 0, a = i.morphTargets.length; r < a; r++) { var o = i.morphTargets[r].name.match(/([a-z]+)_?(\d+)/i); if (o && o.length > 1) { var s = o[1]; n[s] || (n[s] = { start: 1 / 0, end: -1 / 0 }), o = n[s], r < o.start && (o.start = r), r > o.end && (o.end = r), e || (e = s) } } for (s in n)o = n[s], this.createAnimation(s, o.start, o.end, t); this.firstAnimation = e }, Ni.prototype.setAnimationDirectionForward = function (t) { (t = this.animationsMap[t]) && (t.direction = 1, t.directionBackwards = !1) }, Ni.prototype.setAnimationDirectionBackward = function (t) { (t = this.animationsMap[t]) && (t.direction = -1, t.directionBackwards = !0) }, Ni.prototype.setAnimationFPS = function (t, e) { const n = this.animationsMap[t]; n && (n.fps = e, n.duration = (n.end - n.start) / n.fps) }, Ni.prototype.setAnimationDuration = function (t, e) { const n = this.animationsMap[t]; n && (n.duration = e, n.fps = (n.end - n.start) / n.duration) }, Ni.prototype.setAnimationWeight = function (t, e) { const n = this.animationsMap[t]; n && (n.weight = e) }, Ni.prototype.setAnimationTime = function (t, e) { const n = this.animationsMap[t]; n && (n.time = e) }, Ni.prototype.getAnimationTime = function (t) { let e = 0; return (t = this.animationsMap[t]) && (e = t.time), e }, Ni.prototype.getAnimationDuration = function (t) { let e = -1; return (t = this.animationsMap[t]) && (e = t.duration), e }, Ni.prototype.playAnimation = function (t) { const e = this.animationsMap[t]; e && (e.time = 0, e.active = !0) }, Ni.prototype.stopAnimation = function (t) { (t = this.animationsMap[t]) && (t.active = !1) }, Ni.prototype.update = function (t) { for (let e = 0, n = this.animationsList.length; e < n; e++) { const i = this.animationsList[e]; if (i.active) { let r = i.duration / i.length; i.time += i.direction * t, i.mirroredLoop ? (i.time > i.duration || i.time < 0) && (i.direction *= -1, i.time > i.duration && (i.time = i.duration, i.directionBackwards = !0), i.time < 0 && (i.time = 0, i.directionBackwards = !1)) : (i.time %= i.duration, i.time < 0 && (i.time += i.duration)); const a = i.start + lr.clamp(Math.floor(i.time / r), 0, i.length - 1); const o = i.weight; a !== i.currentFrame && (this.morphTargetInfluences[i.lastFrame] = 0, this.morphTargetInfluences[i.currentFrame] = 1 * o, this.morphTargetInfluences[a] = 0, i.lastFrame = i.currentFrame, i.currentFrame = a), r = i.time % r / r, i.directionBackwards && (r = 1 - r), i.currentFrame !== i.lastFrame ? (this.morphTargetInfluences[i.currentFrame] = r * o, this.morphTargetInfluences[i.lastFrame] = (1 - r) * o) : this.morphTargetInfluences[i.currentFrame] = o } } }, Fi.prototype = Object.create(at.prototype), Fi.prototype.constructor = Fi, Fi.prototype.isImmediateRenderObject = !0, Ui.prototype = Object.create(me.prototype), Ui.prototype.constructor = Ui, Ui.prototype.update = (function () { const t = new l(); const e = new l(); const n = new J(); return function () { let i = ['a', 'b', 'c']; this.object.updateMatrixWorld(!0), n.getNormalMatrix(this.object.matrixWorld); const r = this.object.matrixWorld; const a = this.geometry.attributes.position; let o = this.object.geometry; if (o && o.isGeometry) for (var s = o.vertices, l = o.faces, c = o = 0, u = l.length; c < u; c++) for (var h = l[c], p = 0, d = h.vertexNormals.length; p < d; p++) { const f = h.vertexNormals[p]; t.copy(s[h[i[p]]]).applyMatrix4(r), e.copy(f).applyMatrix3(n).normalize().multiplyScalar(this.size).add(t), a.setXYZ(o, t.x, t.y, t.z), o += 1, a.setXYZ(o, e.x, e.y, e.z), o += 1 } else if (o && o.isBufferGeometry) for (i = o.attributes.position, s = o.attributes.normal, p = o = 0, d = i.count; p < d; p++)t.set(i.getX(p), i.getY(p), i.getZ(p)).applyMatrix4(r), e.set(s.getX(p), s.getY(p), s.getZ(p)), e.applyMatrix3(n).normalize().multiplyScalar(this.size).add(t), a.setXYZ(o, t.x, t.y, t.z), o += 1, a.setXYZ(o, e.x, e.y, e.z), o += 1; return a.needsUpdate = !0, this } }()), zi.prototype = Object.create(at.prototype), zi.prototype.constructor = zi, zi.prototype.dispose = function () { this.cone.geometry.dispose(), this.cone.material.dispose() }, zi.prototype.update = (function () { const t = new l(); const e = new l(); return function () { const n = this.light.distance ? this.light.distance : 1e3; const i = n * Math.tan(this.light.angle); this.cone.scale.set(i, i, n), t.setFromMatrixPosition(this.light.matrixWorld), e.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(e.sub(t)), this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity) } }()), Bi.prototype = Object.create(me.prototype), Bi.prototype.constructor = Bi, Bi.prototype.getBoneList = function (t) { const e = []; t && t.isBone && e.push(t); for (let n = 0; n < t.children.length; n++)e.push.apply(e, this.getBoneList(t.children[n])); return e }, Bi.prototype.update = (function () { const t = new l(); const e = new c(); const n = new c(); return function () { const i = this.geometry; const r = i.getAttribute('position'); n.getInverse(this.root.matrixWorld); for (let a = 0, o = 0; a < this.bones.length; a++) { const s = this.bones[a]; s.parent && s.parent.isBone && (e.multiplyMatrices(n, s.matrixWorld), t.setFromMatrixPosition(e), r.setXYZ(o, t.x, t.y, t.z), e.multiplyMatrices(n, s.parent.matrixWorld), t.setFromMatrixPosition(e), r.setXYZ(o + 1, t.x, t.y, t.z), o += 2) }i.getAttribute('position').needsUpdate = !0 } }()), ji.prototype = Object.create(Tt.prototype), ji.prototype.constructor = ji, ji.prototype.dispose = function () { this.geometry.dispose(), this.material.dispose() }, ji.prototype.update = function () { this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity) }, Vi.prototype = Object.create(at.prototype), Vi.prototype.constructor = Vi,
  Vi.prototype.dispose = function () { this.children[0].geometry.dispose(), this.children[0].material.dispose(), this.children[1].geometry.dispose(), this.children[1].material.dispose() }, Vi.prototype.update = (function () { const t = new l(); const e = new l(); return function () { var n = this.children[0]; var i = this.children[1]; if (this.light.target) { t.setFromMatrixPosition(this.light.matrixWorld), e.setFromMatrixPosition(this.light.target.matrixWorld); var r = e.clone().sub(t); n.lookAt(r), i.lookAt(r) }n.material.color.copy(this.light.color).multiplyScalar(this.light.intensity), i.material.color.copy(this.light.color).multiplyScalar(this.light.intensity); var i = 0.5 * this.light.width; var r = 0.5 * this.light.height; var n = n.geometry.getAttribute('position'); const a = n.array; a[0] = i, a[1] = -r, a[2] = 0, a[3] = i, a[4] = r, a[5] = 0, a[6] = -i, a[7] = r, a[8] = 0, a[9] = -i, a[10] = r, a[11] = 0, a[12] = -i, a[13] = -r, a[14] = 0, a[15] = i, a[16] = -r, a[17] = 0, n.needsUpdate = !0 } }()), Gi.prototype = Object.create(at.prototype), Gi.prototype.constructor = Gi, Gi.prototype.dispose = function () { this.children[0].geometry.dispose(), this.children[0].material.dispose() }, Gi.prototype.update = (function () { const t = new l(); const e = new j(); const n = new j(); return function () { const i = this.children[0]; const r = i.geometry.getAttribute('color'); e.copy(this.light.color).multiplyScalar(this.light.intensity), n.copy(this.light.groundColor).multiplyScalar(this.light.intensity); for (let a = 0, o = r.count; a < o; a++) { const s = a < o / 2 ? e : n; r.setXYZ(a, s.r, s.g, s.b) }i.lookAt(t.setFromMatrixPosition(this.light.matrixWorld).negate()), r.needsUpdate = !0 } }()), Hi.prototype = Object.create(me.prototype), Hi.prototype.constructor = Hi, Wi.prototype = Object.create(me.prototype), Wi.prototype.constructor = Wi, qi.prototype = Object.create(me.prototype), qi.prototype.constructor = qi, qi.prototype.update = (function () { const t = new l(); const e = new l(); const n = new J(); return function () { this.object.updateMatrixWorld(!0), n.getNormalMatrix(this.object.matrixWorld); for (var i = this.object.matrixWorld, r = this.geometry.attributes.position, a = this.object.geometry, o = a.vertices, a = a.faces, s = 0, l = 0, c = a.length; l < c; l++) { const u = a[l]; const h = u.normal; t.copy(o[u.a]).add(o[u.b]).add(o[u.c]).divideScalar(3).applyMatrix4(i), e.copy(h).applyMatrix3(n).normalize().multiplyScalar(this.size).add(t), r.setXYZ(s, t.x, t.y, t.z), s += 1, r.setXYZ(s, e.x, e.y, e.z), s += 1 } return r.needsUpdate = !0, this } }()), Xi.prototype = Object.create(at.prototype), Xi.prototype.constructor = Xi, Xi.prototype.dispose = function () { const t = this.children[0]; const e = this.children[1]; t.geometry.dispose(), t.material.dispose(), e.geometry.dispose(), e.material.dispose() }, Xi.prototype.update = (function () { const t = new l(); const e = new l(); const n = new l(); return function () { t.setFromMatrixPosition(this.light.matrixWorld), e.setFromMatrixPosition(this.light.target.matrixWorld), n.subVectors(e, t); const i = this.children[0]; const r = this.children[1]; i.lookAt(n), i.material.color.copy(this.light.color).multiplyScalar(this.light.intensity), r.lookAt(n), r.scale.z = n.length() } }()), Yi.prototype = Object.create(me.prototype), Yi.prototype.constructor = Yi, Yi.prototype.update = (function () { function t (t, a, o, s) { if (i.set(a, o, s).unproject(r), void 0 !== (t = n[t])) for (a = e.getAttribute('position'), o = 0, s = t.length; o < s; o++)a.setXYZ(t[o], i.x, i.y, i.z) } let e; let n; var i = new l(); var r = new At(); return function () { e = this.geometry, n = this.pointMap, r.projectionMatrix.copy(this.camera.projectionMatrix), t('c', 0, 0, -1), t('t', 0, 0, 1), t('n1', -1, -1, -1), t('n2', 1, -1, -1), t('n3', -1, 1, -1), t('n4', 1, 1, -1), t('f1', -1, -1, 1), t('f2', 1, -1, 1), t('f3', -1, 1, 1), t('f4', 1, 1, 1), t('u1', 0.7, 1.1, -1), t('u2', -0.7, 1.1, -1), t('u3', 0, 2, -1), t('cf1', -1, 0, 1), t('cf2', 1, 0, 1), t('cf3', 0, -1, 1), t('cf4', 0, 1, 1), t('cn1', -1, 0, -1), t('cn2', 1, 0, -1), t('cn3', 0, -1, -1), t('cn4', 0, 1, -1), e.getAttribute('position').needsUpdate = !0 } }()), Zi.prototype = Object.create(me.prototype), Zi.prototype.constructor = Zi, Zi.prototype.update = (function () { const t = new Z(); return function (e) { if (e && e.isBox3 ? t.copy(e) : t.setFromObject(e), !t.isEmpty()) { e = t.min; const n = t.max; const i = this.geometry.attributes.position; const r = i.array; r[0] = n.x, r[1] = n.y, r[2] = n.z, r[3] = e.x, r[4] = n.y, r[5] = n.z, r[6] = e.x, r[7] = e.y, r[8] = n.z, r[9] = n.x, r[10] = e.y, r[11] = n.z, r[12] = n.x, r[13] = n.y, r[14] = e.z, r[15] = e.x, r[16] = n.y, r[17] = e.z, r[18] = e.x, r[19] = e.y, r[20] = e.z, r[21] = n.x, r[22] = e.y, r[23] = e.z, i.needsUpdate = !0, this.geometry.computeBoundingSphere() } } }()); let Lr, Ir; Ki.prototype = Object.create(at.prototype), Ki.prototype.constructor = Ki, Ki.prototype.setDirection = (function () { let t; const e = new l(); return function (n) { n.y > 0.99999 ? this.quaternion.set(0, 0, 0, 1) : n.y < -0.99999 ? this.quaternion.set(1, 0, 0, 0) : (e.set(n.z, 0, -n.x).normalize(), t = Math.acos(n.y), this.quaternion.setFromAxisAngle(e, t)) } }()), Ki.prototype.setLength = function (t, e, n) { void 0 === e && (e = 0.2 * t), void 0 === n && (n = 0.2 * e), this.line.scale.set(1, Math.max(0, t - e), 1), this.line.updateMatrix(), this.cone.scale.set(n, e, n), this.cone.position.y = t, this.cone.updateMatrix() }, Ki.prototype.setColor = function (t) { this.line.material.color.copy(t), this.cone.material.color.copy(t) }, Ji.prototype = Object.create(me.prototype), Ji.prototype.constructor = Ji; const Rr = new l(); const Nr = new Qi(); const Fr = new Qi(); const Ur = new Qi(); tr.prototype = Object.create(ti.prototype), tr.prototype.constructor = tr, tr.prototype.getPoint = function (t) { let e = this.points; var n = e.length; t *= n - (this.closed ? 0 : 1); var i = Math.floor(t); t -= i, this.closed ? i += i > 0 ? 0 : (Math.floor(Math.abs(i) / e.length) + 1) * e.length : t === 0 && i === n - 1 && (i = n - 2, t = 1); let r, a, o; if (this.closed || i > 0 ? r = e[(i - 1) % n] : (Rr.subVectors(e[0], e[1]).add(e[0]), r = Rr), a = e[i % n], o = e[(i + 1) % n], this.closed || i + 2 < n ? e = e[(i + 2) % n] : (Rr.subVectors(e[n - 1], e[n - 2]).add(e[n - 1]), e = Rr), void 0 === this.type || this.type === 'centripetal' || this.type === 'chordal') { var s = this.type === 'chordal' ? 0.5 : 0.25; var n = Math.pow(r.distanceToSquared(a), s); var i = Math.pow(a.distanceToSquared(o), s); var s = Math.pow(o.distanceToSquared(e), s); i < 1e-4 && (i = 1), n < 1e-4 && (n = i), s < 1e-4 && (s = i), Nr.initNonuniformCatmullRom(r.x, a.x, o.x, e.x, n, i, s), Fr.initNonuniformCatmullRom(r.y, a.y, o.y, e.y, n, i, s), Ur.initNonuniformCatmullRom(r.z, a.z, o.z, e.z, n, i, s) } else this.type === 'catmullrom' && (n = void 0 !== this.tension ? this.tension : 0.5, Nr.initCatmullRom(r.x, a.x, o.x, e.x, n), Fr.initCatmullRom(r.y, a.y, o.y, e.y, n), Ur.initCatmullRom(r.z, a.z, o.z, e.z, n)); return new l(Nr.calc(t), Fr.calc(t), Ur.calc(t)) }, er.prototype = Object.create(ti.prototype), er.prototype.constructor = er, er.prototype.getPoint = function (t) { const e = this.v0; const n = this.v1; const i = this.v2; const r = this.v3; return new l(Qn(t, e.x, n.x, i.x, r.x), Qn(t, e.y, n.y, i.y, r.y), Qn(t, e.z, n.z, i.z, r.z)) }, nr.prototype = Object.create(ti.prototype), nr.prototype.constructor = nr, nr.prototype.getPoint = function (t) { const e = this.v0; const n = this.v1; const i = this.v2; return new l(Jn(t, e.x, n.x, i.x), Jn(t, e.y, n.y, i.y), Jn(t, e.z, n.z, i.z)) }, ir.prototype = Object.create(ti.prototype), ir.prototype.constructor = ir, ir.prototype.getPoint = function (t) { if (t === 1) return this.v2.clone(); const e = new l(); return e.subVectors(this.v2, this.v1), e.multiplyScalar(t), e.add(this.v1), e }, rr.prototype = Object.create(ii.prototype), rr.prototype.constructor = rr, ti.create = function (t, e) { return t.prototype = Object.create(ti.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t }, ar.prototype = Object.create(tr.prototype), or.prototype = Object.create(tr.prototype), sr.prototype = Object.create(tr.prototype), Object.assign(sr.prototype, { initFromArray: function (t) {}, getControlPointsArray: function (t) {}, reparametrizeByArcLength: function (t) {} }), Hi.prototype.setColors = function () {}, Object.assign(G.prototype, { center: function (t) { return this.getCenter(t) }, empty: function () { return this.isEmpty() }, isIntersectionBox: function (t) { return this.intersectsBox(t) }, size: function (t) { return this.getSize(t) } }), Object.assign(Z.prototype, { center: function (t) { return this.getCenter(t) }, empty: function () { return this.isEmpty() }, isIntersectionBox: function (t) { return this.intersectsBox(t) }, isIntersectionSphere: function (t) { return this.intersectsSphere(t) }, size: function (t) { return this.getSize(t) } }), ot.prototype.center = function (t) { return this.getCenter(t) }, lr.random16 = function () { return Math.random() }, Object.assign(J.prototype, { flattenToArrayOffset: function (t, e) { return this.toArray(t, e) }, multiplyVector3: function (t) { return t.applyMatrix3(this) }, multiplyVector3Array: function (t) { return this.applyToVector3Array(t) }, applyToBuffer: function (t, e, n) { return this.applyToBufferAttribute(t) }, applyToVector3Array: function (t, e, n) {} }), Object.assign(c.prototype, { extractPosition: function (t) { return this.copyPosition(t) }, flattenToArrayOffset: function (t, e) { return this.toArray(t, e) }, getPosition: (function () { let t; return function () { return void 0 === t && (t = new l()), t.setFromMatrixColumn(this, 3) } }()), setRotationFromQuaternion: function (t) { return this.makeRotationFromQuaternion(t) }, multiplyVector3: function (t) { return t.applyMatrix4(this) }, multiplyVector4: function (t) { return t.applyMatrix4(this) }, multiplyVector3Array: function (t) { return this.applyToVector3Array(t) }, rotateAxis: function (t) { t.transformDirection(this) }, crossVector: function (t) { return t.applyMatrix4(this) }, translate: function () {}, rotateX: function () {}, rotateY: function () {}, rotateZ: function () {}, rotateByAxis: function () {}, applyToBuffer: function (t, e, n) { return this.applyToBufferAttribute(t) }, applyToVector3Array: function (t, e, n) {}, makeFrustum: function (t, e, n, i, r, a) { return this.makePerspective(t, e, i, n, r, a) } }), Q.prototype.isIntersectionLine = function (t) { return this.intersectsLine(t) }, s.prototype.multiplyVector3 = function (t) { return t.applyQuaternion(this) }, Object.assign(nt.prototype, { isIntersectionBox: function (t) { return this.intersectsBox(t) }, isIntersectionPlane: function (t) { return this.intersectsPlane(t) }, isIntersectionSphere: function (t) { return this.intersectsSphere(t) } }), Object.assign(li.prototype, { extrude: function (t) { return new je(this, t) }, makeGeometry: function (t) { return new Ze(this, t) } }), Object.assign(n.prototype, { fromAttribute: function (t, e, n) { return this.fromBufferAttribute(t, e, n) } }), Object.assign(l.prototype, { setEulerFromRotationMatrix: function () {}, setEulerFromQuaternion: function () {}, getPositionFromMatrix: function (t) { return this.setFromMatrixPosition(t) }, getScaleFromMatrix: function (t) { return this.setFromMatrixScale(t) }, getColumnFromMatrix: function (t, e) { return this.setFromMatrixColumn(e, t) }, applyProjection: function (t) { return this.applyMatrix4(t) }, fromAttribute: function (t, e, n) { return this.fromBufferAttribute(t, e, n) } }), Object.assign(r.prototype, { fromAttribute: function (t, e, n) { return this.fromBufferAttribute(t, e, n) } }), _t.prototype.computeTangents = function () {}, Object.assign(at.prototype, { getChildByName: function (t) { return this.getObjectByName(t) }, renderDepth: function () {}, translate: function (t, e) { return this.translateOnAxis(e, t) } }), Object.defineProperties(at.prototype, { eulerOrder: { get: function () { return this.rotation.order }, set: function (t) { this.rotation.order = t } }, useQuaternion: { get: function () {}, set: function () {} } }), Object.defineProperties(ce.prototype, { objects: { get: function () { return this.levels } } }), Pt.prototype.setLens = function (t, e) { void 0 !== e && (this.filmGauge = e), this.setFocalLength(t) }, Object.defineProperties($n.prototype, { onlyShadow: { set: function () {} }, shadowCameraFov: { set: function (t) { this.shadow.camera.fov = t } }, shadowCameraLeft: { set: function (t) { this.shadow.camera.left = t } }, shadowCameraRight: { set: function (t) { this.shadow.camera.right = t } }, shadowCameraTop: { set: function (t) { this.shadow.camera.top = t } }, shadowCameraBottom: { set: function (t) { this.shadow.camera.bottom = t } }, shadowCameraNear: { set: function (t) { this.shadow.camera.near = t } }, shadowCameraFar: { set: function (t) { this.shadow.camera.far = t } }, shadowCameraVisible: { set: function () {} }, shadowBias: { set: function (t) { this.shadow.bias = t } }, shadowDarkness: { set: function () {} }, shadowMapWidth: { set: function (t) { this.shadow.mapSize.width = t } }, shadowMapHeight: { set: function (t) { this.shadow.mapSize.height = t } } }), Object.defineProperties(ut.prototype, { length: { get: function () { return this.array.length } } }), Object.assign($t.prototype, { addIndex: function (t) { this.setIndex(t) }, addDrawCall: function (t, e, n) { this.addGroup(t, e) }, clearDrawCalls: function () { this.clearGroups() }, computeTangents: function () {}, computeOffsets: function () {} }), Object.defineProperties($t.prototype, { drawcalls: { get: function () { return this.groups } }, offsets: { get: function () { return this.groups } } }), Object.defineProperties(Si.prototype, { dynamic: { set: function () {} }, onUpdate: { value: function () { return this } } }), Object.defineProperties(q.prototype, { wrapAround: { get: function () {}, set: function () {} }, wrapRGB: { get: function () { return new j() } } }), Object.defineProperties(hn.prototype, { metal: { get: function () { return !1 }, set: function () {} } }), Object.defineProperties(X.prototype, { derivatives: { get: function () { return this.extensions.derivatives }, set: function (t) { this.extensions.derivatives = t } } }), Object.assign(ne.prototype, { supportsFloatTextures: function () { return this.extensions.get('OES_texture_float') }, supportsHalfFloatTextures: function () { return this.extensions.get('OES_texture_half_float') }, supportsStandardDerivatives: function () { return this.extensions.get('OES_standard_derivatives') }, supportsCompressedTextureS3TC: function () { return this.extensions.get('WEBGL_compressed_texture_s3tc') }, supportsCompressedTexturePVRTC: function () { return this.extensions.get('WEBGL_compressed_texture_pvrtc') }, supportsBlendMinMax: function () { return this.extensions.get('EXT_blend_minmax') }, supportsVertexTextures: function () { return this.capabilities.vertexTextures }, supportsInstancedArrays: function () { return this.extensions.get('ANGLE_instanced_arrays') }, enableScissorTest: function (t) { this.setScissorTest(t) }, initMaterial: function () {}, addPrePlugin: function () {}, addPostPlugin: function () {}, updateShadowMap: function () {} }), Object.defineProperties(ne.prototype, { shadowMapEnabled: { get: function () { return this.shadowMap.enabled }, set: function (t) { this.shadowMap.enabled = t } }, shadowMapType: { get: function () { return this.shadowMap.type }, set: function (t) { this.shadowMap.type = t } }, shadowMapCullFace: { get: function () { return this.shadowMap.cullFace }, set: function (t) { this.shadowMap.cullFace = t } } }), Object.defineProperties(et.prototype, { cullFace: { get: function () { return this.renderReverseSided ? 2 : 1 }, set: function (t) { t = t !== 1, this.renderReverseSided = t } } }), Object.defineProperties(a.prototype, { wrapS: { get: function () { return this.texture.wrapS }, set: function (t) { this.texture.wrapS = t } }, wrapT: { get: function () { return this.texture.wrapT }, set: function (t) { this.texture.wrapT = t } }, magFilter: { get: function () { return this.texture.magFilter }, set: function (t) { this.texture.magFilter = t } }, minFilter: { get: function () { return this.texture.minFilter }, set: function (t) { this.texture.minFilter = t } }, anisotropy: { get: function () { return this.texture.anisotropy }, set: function (t) { this.texture.anisotropy = t } }, offset: { get: function () { return this.texture.offset }, set: function (t) { this.texture.offset = t } }, repeat: { get: function () { return this.texture.repeat }, set: function (t) { this.texture.repeat = t } }, format: { get: function () { return this.texture.format }, set: function (t) { this.texture.format = t } }, type: { get: function () { return this.texture.type }, set: function (t) { this.texture.type = t } }, generateMipmaps: { get: function () { return this.texture.generateMipmaps }, set: function (t) { this.texture.generateMipmaps = t } } }), vi.prototype.load = function (t) { const e = this; return (new pi()).load(t, function (t) { e.setBuffer(t) }), this }, bi.prototype.getData = function () { return this.getFrequencyData() }, t.WebGLRenderTargetCube = o, t.WebGLRenderTarget = a, t.WebGLRenderer = ne, t.ShaderLib = br, t.UniformsLib = yr, t.UniformsUtils = mr, t.ShaderChunk = gr, t.FogExp2 = ie, t.Fog = re, t.Scene = ae, t.LensFlare = oe, t.Sprite = le, t.LOD = ce, t.SkinnedMesh = pe, t.Skeleton = ue, t.Bone = he, t.Mesh = Tt, t.LineSegments = me, t.Line = fe, t.Points = ve, t.Group = ye, t.VideoTexture = be, t.DataTexture = V, t.CompressedTexture = xe, t.CubeTexture = u, t.CanvasTexture = we, t.DepthTexture = _e, t.Texture = i, t.CompressedTextureLoader = yn, t.DataTextureLoader = bn, t.CubeTextureLoader = wn, t.TextureLoader = _n, t.ObjectLoader = Zn, t.MaterialLoader = Wn, t.BufferGeometryLoader = qn, t.DefaultLoadingManager = Er, t.LoadingManager = gn, t.JSONLoader = Yn, t.ImageLoader = xn, t.FontLoader = hi, t.FileLoader = vn, t.Loader = Xn, t.Cache = Cr, t.AudioLoader = pi, t.SpotLightShadow = Mn, t.SpotLight = Cn, t.PointLight = En, t.RectAreaLight = di, t.HemisphereLight = Tn, t.DirectionalLightShadow = An, t.DirectionalLight = Pn, t.AmbientLight = kn, t.LightShadow = Sn, t.Light = $n, t.StereoCamera = fi, t.PerspectiveCamera = Pt, t.OrthographicCamera = kt, t.CubeCamera = mi, t.Camera = At, t.AudioListener = gi, t.PositionalAudio = yi, t.AudioContext = Or, t.AudioAnalyser = bi, t.Audio = vi, t.VectorKeyframeTrack = Nn, t.StringKeyframeTrack = Bn, t.QuaternionKeyframeTrack = Un, t.NumberKeyframeTrack = zn, t.ColorKeyframeTrack = Vn, t.BooleanKeyframeTrack = jn, t.PropertyMixer = xi, t.PropertyBinding = wi, t.KeyframeTrack = Gn, t.AnimationUtils = Ar, t.AnimationObjectGroup = _i, t.AnimationMixer = Ti, t.AnimationClip = Hn, t.Uniform = Si, t.InstancedBufferGeometry = Mi, t.BufferGeometry = $t, t.GeometryIdCount = function () { return _r++ }, t.Geometry = _t, t.InterleavedBufferAttribute = Ci, t.InstancedInterleavedBuffer = Ai, t.InterleavedBuffer = Ei, t.InstancedBufferAttribute = Pi, t.Face3 = lt, t.Object3D = at, t.Raycaster = ki, t.Layers = rt, t.EventDispatcher = e, t.Clock = Li, t.QuaternionLinearInterpolant = Fn, t.LinearInterpolant = Ln, t.DiscreteInterpolant = In, t.CubicInterpolant = On, t.Interpolant = Dn, t.Triangle = st, t.Math = lr, t.Spherical = Ii, t.Cylindrical = Ri, t.Plane = Q, t.Frustum = tt, t.Sphere = K, t.Ray = nt, t.Matrix4 = c, t.Matrix3 = J, t.Box3 = Z, t.Box2 = G, t.Line3 = ot, t.Euler = it, t.Vector4 = r, t.Vector3 = l, t.Vector2 = n, t.Quaternion = s, t.Color = j, t.MorphBlendMesh = Ni, t.ImmediateRenderObject = Fi, t.VertexNormalsHelper = Ui, t.SpotLightHelper = zi, t.SkeletonHelper = Bi, t.PointLightHelper = ji, t.RectAreaLightHelper = Vi, t.HemisphereLightHelper = Gi, t.GridHelper = Hi, t.PolarGridHelper = Wi, t.FaceNormalsHelper = qi, t.DirectionalLightHelper = Xi, t.CameraHelper = Yi, t.BoxHelper = Zi, t.ArrowHelper = Ki, t.AxisHelper = Ji, t.CatmullRomCurve3 = tr, t.CubicBezierCurve3 = er, t.QuadraticBezierCurve3 = nr, t.LineCurve3 = ir, t.ArcCurve = rr, t.EllipseCurve = ii, t.SplineCurve = ri, t.CubicBezierCurve = ai, t.QuadraticBezierCurve = oi, t.LineCurve = ei, t.Shape = li, t.Path = si, t.ShapePath = ci, t.Font = ui, t.CurvePath = ni, t.Curve = ti; t.ShapeUtils = Tr, t.SceneUtils = { createMultiMaterialObject: function (t, e) { for (var n = new ye(), i = 0, r = e.length; i < r; i++)n.add(new Tt(t, e[i])); return n }, detach: function (t, e, n) { t.applyMatrix(e.matrixWorld), e.remove(t), n.add(t) }, attach: function (t, e, n) { const i = new c(); i.getInverse(n.matrixWorld), t.applyMatrix(i), e.remove(t), n.add(t) } }, t.WireframeGeometry = $e, t.ParametricGeometry = Te, t.ParametricBufferGeometry = Se, t.TetrahedronGeometry = Ee, t.TetrahedronBufferGeometry = Ae, t.OctahedronGeometry = Pe, t.OctahedronBufferGeometry = ke, t.IcosahedronGeometry = De, t.IcosahedronBufferGeometry = Oe, t.DodecahedronGeometry = Le, t.DodecahedronBufferGeometry = Ie, t.PolyhedronGeometry = Me, t.PolyhedronBufferGeometry = Ce, t.TubeGeometry = Re, t.TubeBufferGeometry = Ne, t.TorusKnotGeometry = Fe, t.TorusKnotBufferGeometry = Ue, t.TorusGeometry = ze, t.TorusBufferGeometry = Be, t.TextGeometry = Ve, t.SphereGeometry = Ge, t.SphereBufferGeometry = He, t.RingGeometry = We, t.RingBufferGeometry = qe, t.PlaneGeometry = Ct, t.PlaneBufferGeometry = Et, t.LatheGeometry = Xe, t.LatheBufferGeometry = Ye, t.ShapeGeometry = Ze, t.ShapeBufferGeometry = Ke, t.ExtrudeGeometry = je, t.EdgesGeometry = Je, t.ConeGeometry = en, t.ConeBufferGeometry = nn, t.CylinderGeometry = Qe, t.CylinderBufferGeometry = tn, t.CircleGeometry = rn, t.CircleBufferGeometry = an, t.BoxGeometry = St, t.BoxBufferGeometry = Mt, t.ShadowMaterial = on, t.SpriteMaterial = se, t.RawShaderMaterial = sn, t.ShaderMaterial = X, t.PointsMaterial = ge, t.MultiMaterial = ln, t.MeshPhysicalMaterial = un, t.MeshStandardMaterial = cn, t.MeshPhongMaterial = hn, t.MeshToonMaterial = pn, t.MeshNormalMaterial = dn, t.MeshLambertMaterial = fn, t.MeshDepthMaterial = Y, t.MeshBasicMaterial = ct, t.LineDashedMaterial = mn, t.LineBasicMaterial = de, t.Material = q, t.Float64BufferAttribute = bt, t.Float32BufferAttribute = yt, t.Uint32BufferAttribute = vt, t.Int32BufferAttribute = gt, t.Uint16BufferAttribute = mt, t.Int16BufferAttribute = ft, t.Uint8ClampedBufferAttribute = dt, t.Uint8BufferAttribute = pt, t.Int8BufferAttribute = ht, t.BufferAttribute = ut, t.REVISION = '84', t.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 }, t.CullFaceNone = 0, t.CullFaceBack = 1, t.CullFaceFront = 2, t.CullFaceFrontBack = 3, t.FrontFaceDirectionCW = 0, t.FrontFaceDirectionCCW = 1, t.BasicShadowMap = 0, t.PCFShadowMap = 1, t.PCFSoftShadowMap = 2, t.FrontSide = 0, t.BackSide = 1, t.DoubleSide = 2, t.FlatShading = 1, t.SmoothShading = 2, t.NoColors = 0, t.FaceColors = 1, t.VertexColors = 2, t.NoBlending = 0, t.NormalBlending = 1, t.AdditiveBlending = 2, t.SubtractiveBlending = 3, t.MultiplyBlending = 4, t.CustomBlending = 5, t.AddEquation = 100, t.SubtractEquation = 101, t.ReverseSubtractEquation = 102, t.MinEquation = 103, t.MaxEquation = 104, t.ZeroFactor = 200, t.OneFactor = 201, t.SrcColorFactor = 202, t.OneMinusSrcColorFactor = 203, t.SrcAlphaFactor = 204, t.OneMinusSrcAlphaFactor = 205, t.DstAlphaFactor = 206, t.OneMinusDstAlphaFactor = 207, t.DstColorFactor = 208, t.OneMinusDstColorFactor = 209, t.SrcAlphaSaturateFactor = 210, t.NeverDepth = 0, t.AlwaysDepth = 1, t.LessDepth = 2, t.LessEqualDepth = 3, t.EqualDepth = 4, t.GreaterEqualDepth = 5, t.GreaterDepth = 6, t.NotEqualDepth = 7, t.MultiplyOperation = 0, t.MixOperation = 1, t.AddOperation = 2, t.NoToneMapping = 0, t.LinearToneMapping = 1, t.ReinhardToneMapping = 2, t.Uncharted2ToneMapping = 3, t.CineonToneMapping = 4, t.UVMapping = 300, t.CubeReflectionMapping = 301, t.CubeRefractionMapping = 302, t.EquirectangularReflectionMapping = 303, t.EquirectangularRefractionMapping = 304, t.SphericalReflectionMapping = 305, t.CubeUVReflectionMapping = 306, t.CubeUVRefractionMapping = 307, t.RepeatWrapping = 1e3, t.ClampToEdgeWrapping = 1001, t.MirroredRepeatWrapping = 1002, t.NearestFilter = 1003, t.NearestMipMapNearestFilter = 1004, t.NearestMipMapLinearFilter = 1005, t.LinearFilter = 1006, t.LinearMipMapNearestFilter = 1007, t.LinearMipMapLinearFilter = 1008, t.UnsignedByteType = 1009, t.ByteType = 1010, t.ShortType = 1011, t.UnsignedShortType = 1012, t.IntType = 1013, t.UnsignedIntType = 1014, t.FloatType = 1015, t.HalfFloatType = 1016, t.UnsignedShort4444Type = 1017, t.UnsignedShort5551Type = 1018, t.UnsignedShort565Type = 1019, t.UnsignedInt248Type = 1020, t.AlphaFormat = 1021, t.RGBFormat = 1022, t.RGBAFormat = 1023, t.LuminanceFormat = 1024, t.LuminanceAlphaFormat = 1025, t.RGBEFormat = 1023, t.DepthFormat = 1026, t.DepthStencilFormat = 1027, t.RGB_S3TC_DXT1_Format = 2001, t.RGBA_S3TC_DXT1_Format = 2002, t.RGBA_S3TC_DXT3_Format = 2003, t.RGBA_S3TC_DXT5_Format = 2004, t.RGB_PVRTC_4BPPV1_Format = 2100, t.RGB_PVRTC_2BPPV1_Format = 2101, t.RGBA_PVRTC_4BPPV1_Format = 2102, t.RGBA_PVRTC_2BPPV1_Format = 2103, t.RGB_ETC1_Format = 2151, t.LoopOnce = 2200, t.LoopRepeat = 2201, t.LoopPingPong = 2202, t.InterpolateDiscrete = 2300, t.InterpolateLinear = 2301, t.InterpolateSmooth = 2302, t.ZeroCurvatureEnding = 2400, t.ZeroSlopeEnding = 2401, t.WrapAroundEnding = 2402, t.TrianglesDrawMode = 0, t.TriangleStripDrawMode = 1, t.TriangleFanDrawMode = 2, t.LinearEncoding = 3e3, t.sRGBEncoding = 3001, t.GammaEncoding = 3007, t.RGBEEncoding = 3002, t.LogLuvEncoding = 3003, t.RGBM7Encoding = 3004, t.RGBM16Encoding = 3005, t.RGBDEncoding = 3006, t.BasicDepthPacking = 3200, t.RGBADepthPacking = 3201, t.CubeGeometry = St, t.Face4 = function (t, e, n, i, r, a, o) { return new lt(t, e, n, r, a, o) }, t.LineStrip = 0, t.LinePieces = 1, t.MeshFaceMaterial = function (t) { return new ln(t) }, t.PointCloud = function (t, e) { return new ve(t, e) }; t.Particle = function (t) { return new le(t) }, t.ParticleSystem = function (t, e) { return new ve(t, e) }, t.PointCloudMaterial = function (t) { return new ge(t) }, t.ParticleBasicMaterial = function (t) { return new ge(t) }, t.ParticleSystemMaterial = function (t) { return new ge(t) }, t.Vertex = function (t, e, n) { return new l(t, e, n) }, t.DynamicBufferAttribute = function (t, e) { return new ut(t, e).setDynamic(!0) }, t.Int8Attribute = function (t, e) { return new ht(t, e) }, t.Uint8Attribute = function (t, e) { return new pt(t, e) }, t.Uint8ClampedAttribute = function (t, e) { return new dt(t, e) }, t.Int16Attribute = function (t, e) { return new ft(t, e) }, t.Uint16Attribute = function (t, e) { return new mt(t, e) }, t.Int32Attribute = function (t, e) { return new gt(t, e) }, t.Uint32Attribute = function (t, e) { return new vt(t, e) }, t.Float32Attribute = function (t, e) { return new yt(t, e) }, t.Float64Attribute = function (t, e) { return new bt(t, e) }, t.ClosedSplineCurve3 = ar, t.SplineCurve3 = or, t.Spline = sr, t.BoundingBoxHelper = function (t, e) { return new Zi(t, e) }, t.EdgesHelper = function (t, e) { return new me(new Je(t.geometry), new de({ color: void 0 !== e ? e : 16777215 })) }, t.WireframeHelper = function (t, e) { return new me(new $e(t.geometry), new de({ color: void 0 !== e ? e : 16777215 })) }, t.XHRLoader = function (t) { return new vn(t) }, t.BinaryTextureLoader = function (t) { return new bn(t) }, t.GeometryUtils = { merge: function (t, e, n) { let i; e.isMesh && (e.matrixAutoUpdate && e.updateMatrix(), i = e.matrix, e = e.geometry), t.merge(e, i, n) }, center: function (t) { return t.center() } }, t.ImageUtils = { crossOrigin: void 0, loadTexture: function (t, e, n, i) { const r = new _n(); return r.setCrossOrigin(this.crossOrigin), t = r.load(t, n, void 0, i), e && (t.mapping = e), t }, loadTextureCube: function (t, e, n, i) { const r = new wn(); return r.setCrossOrigin(this.crossOrigin), t = r.load(t, n, void 0, i), e && (t.mapping = e), t }, loadCompressedTexture: function () {}, loadCompressedTextureCube: function () {} }, t.Projector = function () { this.projectVector = function (t, e) { t.project(e) }, this.unprojectVector = function (t, e) { t.unproject(e) }, this.pickingRay = function () {} }, t.CanvasRenderer = function () { this.domElement = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas'), this.clear = function () {}, this.render = function () {}, this.setClearColor = function () {}, this.setSize = function () {} }, Object.defineProperty(t, '__esModule', { value: !0 })
})); const _gsScope = typeof module !== 'undefined' && module.exports && typeof global !== 'undefined' ? global : this || window; if ((_gsScope._gsQueue || (_gsScope._gsQueue = [])).push(function () {
  'use strict'; _gsScope._gsDefine('TweenMax', ['core.Animation', 'core.SimpleTimeline', 'TweenLite'], function (t, e, n) {
    const i = function (t) { let e; const n = []; const i = t.length; for (e = 0; e !== i; n.push(t[e++]));return n }; const r = function (t, e, n) { let i; let r; const a = t.cycle; for (i in a)r = a[i], t[i] = typeof r === 'function' ? r(n, e[n]) : r[n % r.length]; delete t.cycle }; const a = function (t, e, i) { n.call(this, t, e, i), this._cycle = 0, this._yoyo = !0 === this.vars.yoyo, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._dirty = !0, this.render = a.prototype.render }; const o = n._internals; const s = o.isSelector; const l = o.isArray; const c = a.prototype = n.to({}, 0.1, {}); const u = []; a.version = '1.19.1', c.constructor = a, c.kill()._gc = !1, a.killTweensOf = a.killDelayedCallsTo = n.killTweensOf, a.getTweensOf = n.getTweensOf, a.lagSmoothing = n.lagSmoothing, a.ticker = n.ticker, a.render = n.render, c.invalidate = function () { return this._yoyo = !0 === this.vars.yoyo, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._uncache(!0), n.prototype.invalidate.call(this) }, c.updateTo = function (t, e) { let i; const r = this.ratio; const a = this.vars.immediateRender || t.immediateRender; e && this._startTime < this._timeline._time && (this._startTime = this._timeline._time, this._uncache(!1), this._gc ? this._enabled(!0, !1) : this._timeline.insert(this, this._startTime - this._delay)); for (i in t) this.vars[i] = t[i]; if (this._initted || a) if (e) this._initted = !1, a && this.render(0, !0, !0); else if (this._gc && this._enabled(!0, !1), this._notifyPluginsOfEnabled && this._firstPT && n._onPluginEvent('_onDisable', this), this._time / this._duration > 0.998) { const o = this._totalTime; this.render(0, !0, !1), this._initted = !1, this.render(o, !0, !1) } else if (this._initted = !1, this._init(), this._time > 0 || a) for (var s, l = 1 / (1 - r), c = this._firstPT; c;)s = c.s + c.c, c.c *= l, c.s = s - c.c, c = c._next; return this }, c.render = function (t, e, n) { this._initted || this._duration === 0 && this.vars.repeat && this.invalidate(); let i; let r; let a; let s; let l; let c; let u; let h; const p = this._dirty ? this.totalDuration() : this._totalDuration; const d = this._time; const f = this._totalTime; const m = this._cycle; const g = this._duration; const v = this._rawPrevTime; if (t >= p - 1e-7 && t >= 0 ? (this._totalTime = p, this._cycle = this._repeat, this._yoyo && (1 & this._cycle) != 0 ? (this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0) : (this._time = g, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1), this._reversed || (i = !0, r = 'onComplete', n = n || this._timeline.autoRemoveChildren), g === 0 && (this._initted || !this.vars.lazy || n) && (this._startTime === this._timeline._duration && (t = 0), (v < 0 || t <= 0 && t >= -1e-7 || v === 1e-10 && this.data !== 'isPause') && v !== t && (n = !0, v > 1e-10 && (r = 'onReverseComplete')), this._rawPrevTime = h = !e || t || v === t ? t : 1e-10)) : t < 1e-7 ? (this._totalTime = this._time = this._cycle = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (f !== 0 || g === 0 && v > 0) && (r = 'onReverseComplete', i = this._reversed), t < 0 && (this._active = !1, g === 0 && (this._initted || !this.vars.lazy || n) && (v >= 0 && (n = !0), this._rawPrevTime = h = !e || t || v === t ? t : 1e-10)), this._initted || (n = !0)) : (this._totalTime = this._time = t, this._repeat !== 0 && (s = g + this._repeatDelay, this._cycle = this._totalTime / s >> 0, this._cycle !== 0 && this._cycle === this._totalTime / s && f <= t && this._cycle--, this._time = this._totalTime - this._cycle * s, this._yoyo && (1 & this._cycle) != 0 && (this._time = g - this._time), this._time > g ? this._time = g : this._time < 0 && (this._time = 0)), this._easeType ? (l = this._time / g, c = this._easeType, u = this._easePower, (c === 1 || c === 3 && l >= 0.5) && (l = 1 - l), c === 3 && (l *= 2), u === 1 ? l *= l : u === 2 ? l *= l * l : u === 3 ? l *= l * l * l : u === 4 && (l *= l * l * l * l), c === 1 ? this.ratio = 1 - l : c === 2 ? this.ratio = l : this._time / g < 0.5 ? this.ratio = l / 2 : this.ratio = 1 - l / 2) : this.ratio = this._ease.getRatio(this._time / g)), d === this._time && !n && m === this._cycle) return void (f !== this._totalTime && this._onUpdate && (e || this._callback('onUpdate'))); if (!this._initted) { if (this._init(), !this._initted || this._gc) return; if (!n && this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration)) return this._time = d, this._totalTime = f, this._rawPrevTime = v, this._cycle = m, o.lazyTweens.push(this), void (this._lazy = [t, e]); this._time && !i ? this.ratio = this._ease.getRatio(this._time / g) : i && this._ease._calcEnd && (this.ratio = this._ease.getRatio(this._time === 0 ? 0 : 1)) } for (!1 !== this._lazy && (this._lazy = !1), this._active || !this._paused && this._time !== d && t >= 0 && (this._active = !0), f === 0 && (this._initted === 2 && t > 0 && this._init(), this._startAt && (t >= 0 ? this._startAt.render(t, e, n) : r || (r = '_dummyGS')), this.vars.onStart && (this._totalTime === 0 && g !== 0 || e || this._callback('onStart'))), a = this._firstPT; a;)a.f ? a.t[a.p](a.c * this.ratio + a.s) : a.t[a.p] = a.c * this.ratio + a.s, a = a._next; this._onUpdate && (t < 0 && this._startAt && this._startTime && this._startAt.render(t, e, n), e || (this._totalTime !== f || r) && this._callback('onUpdate')), this._cycle !== m && (e || this._gc || this.vars.onRepeat && this._callback('onRepeat')), r && (this._gc && !n || (t < 0 && this._startAt && !this._onUpdate && this._startTime && this._startAt.render(t, e, n), i && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[r] && this._callback(r), g === 0 && this._rawPrevTime === 1e-10 && h !== 1e-10 && (this._rawPrevTime = 0))) }, a.to = function (t, e, n) { return new a(t, e, n) }, a.from = function (t, e, n) { return n.runBackwards = !0, n.immediateRender = n.immediateRender != 0, new a(t, e, n) }, a.fromTo = function (t, e, n, i) { return i.startAt = n, i.immediateRender = i.immediateRender != 0 && n.immediateRender != 0, new a(t, e, i) }, a.staggerTo = a.allTo = function (t, e, o, c, h, p, d) { c = c || 0; let f; let m; let g; let v; let y = 0; const b = []; const x = function () { o.onComplete && o.onComplete.apply(o.onCompleteScope || this, arguments), h.apply(d || o.callbackScope || this, p || u) }; const w = o.cycle; let _ = o.startAt && o.startAt.cycle; for (l(t) || (typeof t === 'string' && (t = n.selector(t) || t), s(t) && (t = i(t))), t = t || [], c < 0 && (t = i(t), t.reverse(), c *= -1), f = t.length - 1, g = 0; g <= f; g++) { m = {}; for (v in o)m[v] = o[v]; if (w && (r(m, t, g), m.duration != null && (e = m.duration, delete m.duration)), _) { _ = m.startAt = {}; for (v in o.startAt)_[v] = o.startAt[v]; r(m.startAt, t, g) }m.delay = y + (m.delay || 0), g === f && h && (m.onComplete = x), b[g] = new a(t[g], e, m), y += c } return b }, a.staggerFrom = a.allFrom = function (t, e, n, i, r, o, s) { return n.runBackwards = !0, n.immediateRender = n.immediateRender != 0, a.staggerTo(t, e, n, i, r, o, s) }, a.staggerFromTo = a.allFromTo = function (t, e, n, i, r, o, s, l) { return i.startAt = n, i.immediateRender = i.immediateRender != 0 && n.immediateRender != 0, a.staggerTo(t, e, i, r, o, s, l) }, a.delayedCall = function (t, e, n, i, r) { return new a(e, 0, { delay: t, onComplete: e, onCompleteParams: n, callbackScope: i, onReverseComplete: e, onReverseCompleteParams: n, immediateRender: !1, useFrames: r, overwrite: 0 }) }, a.set = function (t, e) { return new a(t, 0, e) }, a.isTweening = function (t) { return n.getTweensOf(t, !0).length > 0 }; const h = function (t, e) { for (var i = [], r = 0, a = t._first; a;)a instanceof n ? i[r++] = a : (e && (i[r++] = a), i = i.concat(h(a, e)), r = i.length), a = a._next; return i }; const p = a.getAllTweens = function (e) { return h(t._rootTimeline, e).concat(h(t._rootFramesTimeline, e)) }; a.killAll = function (t, n, i, r) { n == null && (n = !0), i == null && (i = !0); let a; let o; let s; const l = p(r != 0); const c = l.length; const u = n && i && r; for (s = 0; s < c; s++)o = l[s], (u || o instanceof e || (a = o.target === o.vars.onComplete) && i || n && !a) && (t ? o.totalTime(o._reversed ? 0 : o.totalDuration()) : o._enabled(!1, !1)) }, a.killChildTweensOf = function (t, e) {
      if (t != null) {
        let r; let c; let u; let h; let p; const d = o.tweenLookup; if (typeof t === 'string' && (t = n.selector(t) || t), s(t) && (t = i(t)), l(t)) for (h = t.length; --h > -1;)a.killChildTweensOf(t[h], e); else {
          r = []
          for (u in d) for (c = d[u].target.parentNode; c;)c === t && (r = r.concat(d[u].tweens)), c = c.parentNode; for (p = r.length, h = 0; h < p; h++)e && r[h].totalTime(r[h].totalDuration()), r[h]._enabled(!1, !1)
        }
      }
    }; const d = function (t, n, i, r) { n = !1 !== n, i = !1 !== i, r = !1 !== r; for (var a, o, s = p(r), l = n && i && r, c = s.length; --c > -1;)o = s[c], (l || o instanceof e || (a = o.target === o.vars.onComplete) && i || n && !a) && o.paused(t) }; return a.pauseAll = function (t, e, n) { d(!0, t, e, n) }, a.resumeAll = function (t, e, n) { d(!1, t, e, n) }, a.globalTimeScale = function (e) { let i = t._rootTimeline; let r = n.ticker.time; return arguments.length ? (e = e || 1e-10, i._startTime = r - (r - i._startTime) * i._timeScale / e, i = t._rootFramesTimeline, r = n.ticker.frame, i._startTime = r - (r - i._startTime) * i._timeScale / e, i._timeScale = t._rootTimeline._timeScale = e, e) : i._timeScale }, c.progress = function (t, e) { return arguments.length ? this.totalTime(this.duration() * (this._yoyo && (1 & this._cycle) != 0 ? 1 - t : t) + this._cycle * (this._duration + this._repeatDelay), e) : this._time / this.duration() }, c.totalProgress = function (t, e) { return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this._totalTime / this.totalDuration() }, c.time = function (t, e) { return arguments.length ? (this._dirty && this.totalDuration(), t > this._duration && (t = this._duration), this._yoyo && (1 & this._cycle) != 0 ? t = this._duration - t + this._cycle * (this._duration + this._repeatDelay) : this._repeat !== 0 && (t += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(t, e)) : this._time }, c.duration = function (e) { return arguments.length ? t.prototype.duration.call(this, e) : this._duration }, c.totalDuration = function (t) { return arguments.length ? this._repeat === -1 ? this : this.duration((t - this._repeat * this._repeatDelay) / (this._repeat + 1)) : (this._dirty && (this._totalDuration = this._repeat === -1 ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat, this._dirty = !1), this._totalDuration) }, c.repeat = function (t) { return arguments.length ? (this._repeat = t, this._uncache(!0)) : this._repeat }, c.repeatDelay = function (t) { return arguments.length ? (this._repeatDelay = t, this._uncache(!0)) : this._repeatDelay }, c.yoyo = function (t) { return arguments.length ? (this._yoyo = t, this) : this._yoyo }, a
  }, !0), _gsScope._gsDefine('TimelineLite', ['core.Animation', 'core.SimpleTimeline', 'TweenLite'], function (t, e, n) { const i = function (t) { e.call(this, t), this._labels = {}, this.autoRemoveChildren = !0 === this.vars.autoRemoveChildren, this.smoothChildTiming = !0 === this.vars.smoothChildTiming, this._sortChildren = !0, this._onUpdate = this.vars.onUpdate; let n; let i; const r = this.vars; for (i in r)n = r[i], s(n) && n.join('').indexOf('{self}') !== -1 && (r[i] = this._swapSelfInParams(n)); s(r.tweens) && this.add(r.tweens, 0, r.align, r.stagger) }; const r = n._internals; const a = i._internals = {}; const o = r.isSelector; var s = r.isArray; const l = r.lazyTweens; const c = r.lazyRender; const u = _gsScope._gsDefine.globals; const h = function (t) { let e; const n = {}; for (e in t)n[e] = t[e]; return n }; const p = function (t, e, n) { let i; let r; const a = t.cycle; for (i in a)r = a[i], t[i] = typeof r === 'function' ? r(n, e[n]) : r[n % r.length]; delete t.cycle }; const d = a.pauseCallback = function () {}; const f = function (t) { let e; const n = []; const i = t.length; for (e = 0; e !== i; n.push(t[e++]));return n }; const m = i.prototype = new e(); return i.version = '1.19.1', m.constructor = i, m.kill()._gc = m._forcingPlayhead = m._hasPause = !1, m.to = function (t, e, i, r) { const a = i.repeat && u.TweenMax || n; return e ? this.add(new a(t, e, i), r) : this.set(t, i, r) }, m.from = function (t, e, i, r) { return this.add((i.repeat && u.TweenMax || n).from(t, e, i), r) }, m.fromTo = function (t, e, i, r, a) { const o = r.repeat && u.TweenMax || n; return e ? this.add(o.fromTo(t, e, i, r), a) : this.set(t, r, a) }, m.staggerTo = function (t, e, r, a, s, l, c, u) { let d; let m; const g = new i({ onComplete: l, onCompleteParams: c, callbackScope: u, smoothChildTiming: this.smoothChildTiming }); const v = r.cycle; for (typeof t === 'string' && (t = n.selector(t) || t), t = t || [], o(t) && (t = f(t)), a = a || 0, a < 0 && (t = f(t), t.reverse(), a *= -1), m = 0; m < t.length; m++)d = h(r), d.startAt && (d.startAt = h(d.startAt), d.startAt.cycle && p(d.startAt, t, m)), v && (p(d, t, m), d.duration != null && (e = d.duration, delete d.duration)), g.to(t[m], e, d, m * a); return this.add(g, s) }, m.staggerFrom = function (t, e, n, i, r, a, o, s) { return n.immediateRender = n.immediateRender != 0, n.runBackwards = !0, this.staggerTo(t, e, n, i, r, a, o, s) }, m.staggerFromTo = function (t, e, n, i, r, a, o, s, l) { return i.startAt = n, i.immediateRender = i.immediateRender != 0 && n.immediateRender != 0, this.staggerTo(t, e, i, r, a, o, s, l) }, m.call = function (t, e, i, r) { return this.add(n.delayedCall(0, t, e, i), r) }, m.set = function (t, e, i) { return i = this._parseTimeOrLabel(i, 0, !0), e.immediateRender == null && (e.immediateRender = i === this._time && !this._paused), this.add(new n(t, 0, e), i) }, i.exportRoot = function (t, e) { t = t || {}, t.smoothChildTiming == null && (t.smoothChildTiming = !0); let r; let a; const o = new i(t); const s = o._timeline; for (e == null && (e = !0), s._remove(o, !0), o._startTime = 0, o._rawPrevTime = o._time = o._totalTime = s._time, r = s._first; r;)a = r._next, e && r instanceof n && r.target === r.vars.onComplete || o.add(r, r._startTime - r._delay), r = a; return s.add(o, 0), o }, m.add = function (r, a, o, l) { let c, u, h, p, d, f; if (typeof a !== 'number' && (a = this._parseTimeOrLabel(a, 0, !0, r)), !(r instanceof t)) { if (r instanceof Array || r && r.push && s(r)) { for (o = o || 'normal', l = l || 0, c = a, u = r.length, h = 0; h < u; h++)s(p = r[h]) && (p = new i({ tweens: p })), this.add(p, c), typeof p !== 'string' && typeof p !== 'function' && (o === 'sequence' ? c = p._startTime + p.totalDuration() / p._timeScale : o === 'start' && (p._startTime -= p.delay())), c += l; return this._uncache(!0) } if (typeof r === 'string') return this.addLabel(r, a); if (typeof r !== 'function') throw 'Cannot add ' + r + ' into the timeline; it is not a tween, timeline, function, or string.'; r = n.delayedCall(0, r) } if (e.prototype.add.call(this, r, a), (this._gc || this._time === this._duration) && !this._paused && this._duration < this.duration()) for (d = this, f = d.rawTime() > r._startTime; d._timeline;)f && d._timeline.smoothChildTiming ? d.totalTime(d._totalTime, !0) : d._gc && d._enabled(!0, !1), d = d._timeline; return this }, m.remove = function (e) { if (e instanceof t) { this._remove(e, !1); const n = e._timeline = e.vars.useFrames ? t._rootFramesTimeline : t._rootTimeline; return e._startTime = (e._paused ? e._pauseTime : n._time) - (e._reversed ? e.totalDuration() - e._totalTime : e._totalTime) / e._timeScale, this } if (e instanceof Array || e && e.push && s(e)) { for (let i = e.length; --i > -1;) this.remove(e[i]); return this } return typeof e === 'string' ? this.removeLabel(e) : this.kill(null, e) }, m._remove = function (t, n) { return e.prototype._remove.call(this, t, n), this._last ? this._time > this.duration() && (this._time = this._duration, this._totalTime = this._totalDuration) : this._time = this._totalTime = this._duration = this._totalDuration = 0, this }, m.append = function (t, e) { return this.add(t, this._parseTimeOrLabel(null, e, !0, t)) }, m.insert = m.insertMultiple = function (t, e, n, i) { return this.add(t, e || 0, n, i) }, m.appendMultiple = function (t, e, n, i) { return this.add(t, this._parseTimeOrLabel(null, e, !0, t), n, i) }, m.addLabel = function (t, e) { return this._labels[t] = this._parseTimeOrLabel(e), this }, m.addPause = function (t, e, i, r) { const a = n.delayedCall(0, d, i, r || this); return a.vars.onComplete = a.vars.onReverseComplete = e, a.data = 'isPause', this._hasPause = !0, this.add(a, t) }, m.removeLabel = function (t) { return delete this._labels[t], this }, m.getLabelTime = function (t) { return this._labels[t] != null ? this._labels[t] : -1 }, m._parseTimeOrLabel = function (e, n, i, r) { let a; if (r instanceof t && r.timeline === this) this.remove(r); else if (r && (r instanceof Array || r.push && s(r))) for (a = r.length; --a > -1;)r[a] instanceof t && r[a].timeline === this && this.remove(r[a]); if (typeof n === 'string') return this._parseTimeOrLabel(n, i && typeof e === 'number' && this._labels[n] == null ? e - this.duration() : 0, i); if (n = n || 0, typeof e !== 'string' || !isNaN(e) && this._labels[e] == null)e == null && (e = this.duration()); else { if ((a = e.indexOf('=')) === -1) return this._labels[e] == null ? i ? this._labels[e] = this.duration() + n : n : this._labels[e] + n; n = parseInt(e.charAt(a - 1) + '1', 10) * Number(e.substr(a + 1)), e = a > 1 ? this._parseTimeOrLabel(e.substr(0, a - 1), 0, i) : this.duration() } return Number(e) + n }, m.seek = function (t, e) { return this.totalTime(typeof t === 'number' ? t : this._parseTimeOrLabel(t), !1 !== e) }, m.stop = function () { return this.paused(!0) }, m.gotoAndPlay = function (t, e) { return this.play(t, e) }, m.gotoAndStop = function (t, e) { return this.pause(t, e) }, m.render = function (t, e, n) { this._gc && this._enabled(!0, !1); let i; let r; let a; let o; let s; let u; let h; const p = this._dirty ? this.totalDuration() : this._totalDuration; const d = this._time; const f = this._startTime; const m = this._timeScale; const g = this._paused; if (t >= p - 1e-7 && t >= 0) this._totalTime = this._time = p, this._reversed || this._hasPausedChild() || (r = !0, o = 'onComplete', s = !!this._timeline.autoRemoveChildren, this._duration === 0 && (t <= 0 && t >= -1e-7 || this._rawPrevTime < 0 || this._rawPrevTime === 1e-10) && this._rawPrevTime !== t && this._first && (s = !0, this._rawPrevTime > 1e-10 && (o = 'onReverseComplete'))), this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : 1e-10, t = p + 1e-4; else if (t < 1e-7) if (this._totalTime = this._time = 0, (d !== 0 || this._duration === 0 && this._rawPrevTime !== 1e-10 && (this._rawPrevTime > 0 || t < 0 && this._rawPrevTime >= 0)) && (o = 'onReverseComplete', r = this._reversed), t < 0) this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (s = r = !0, o = 'onReverseComplete') : this._rawPrevTime >= 0 && this._first && (s = !0), this._rawPrevTime = t; else { if (this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : 1e-10, t === 0 && r) for (i = this._first; i && i._startTime === 0;)i._duration || (r = !1), i = i._next; t = 0, this._initted || (s = !0) } else { if (this._hasPause && !this._forcingPlayhead && !e) { if (t >= d) for (i = this._first; i && i._startTime <= t && !u;)i._duration || i.data !== 'isPause' || i.ratio || i._startTime === 0 && this._rawPrevTime === 0 || (u = i), i = i._next; else for (i = this._last; i && i._startTime >= t && !u;)i._duration || i.data === 'isPause' && i._rawPrevTime > 0 && (u = i), i = i._prev; u && (this._time = t = u._startTime, this._totalTime = t + this._cycle * (this._totalDuration + this._repeatDelay)) } this._totalTime = this._time = this._rawPrevTime = t } if (this._time !== d && this._first || n || s || u) { if (this._initted || (this._initted = !0), this._active || !this._paused && this._time !== d && t > 0 && (this._active = !0), d === 0 && this.vars.onStart && (this._time === 0 && this._duration || e || this._callback('onStart')), (h = this._time) >= d) for (i = this._first; i && (a = i._next, h === this._time && (!this._paused || g));)(i._active || i._startTime <= h && !i._paused && !i._gc) && (u === i && this.pause(), i._reversed ? i.render((i._dirty ? i.totalDuration() : i._totalDuration) - (t - i._startTime) * i._timeScale, e, n) : i.render((t - i._startTime) * i._timeScale, e, n)), i = a; else for (i = this._last; i && (a = i._prev, h === this._time && (!this._paused || g));) { if (i._active || i._startTime <= d && !i._paused && !i._gc) { if (u === i) { for (u = i._prev; u && u.endTime() > this._time;)u.render(u._reversed ? u.totalDuration() - (t - u._startTime) * u._timeScale : (t - u._startTime) * u._timeScale, e, n), u = u._prev; u = null, this.pause() }i._reversed ? i.render((i._dirty ? i.totalDuration() : i._totalDuration) - (t - i._startTime) * i._timeScale, e, n) : i.render((t - i._startTime) * i._timeScale, e, n) }i = a } this._onUpdate && (e || (l.length && c(), this._callback('onUpdate'))), o && (this._gc || f !== this._startTime && m === this._timeScale || (this._time === 0 || p >= this.totalDuration()) && (r && (l.length && c(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[o] && this._callback(o))) } }, m._hasPausedChild = function () { for (let t = this._first; t;) { if (t._paused || t instanceof i && t._hasPausedChild()) return !0; t = t._next } return !1 }, m.getChildren = function (t, e, i, r) { r = r || -9999999999; for (var a = [], o = this._first, s = 0; o;)o._startTime < r || (o instanceof n ? !1 !== e && (a[s++] = o) : (!1 !== i && (a[s++] = o), !1 !== t && (a = a.concat(o.getChildren(!0, e, i)), s = a.length))), o = o._next; return a }, m.getTweensOf = function (t, e) { let i; let r; const a = this._gc; const o = []; let s = 0; for (a && this._enabled(!0, !0), i = n.getTweensOf(t), r = i.length; --r > -1;)(i[r].timeline === this || e && this._contains(i[r])) && (o[s++] = i[r]); return a && this._enabled(!1, !0), o }, m.recent = function () { return this._recent }, m._contains = function (t) { for (let e = t.timeline; e;) { if (e === this) return !0; e = e.timeline } return !1 }, m.shiftChildren = function (t, e, n) { n = n || 0; for (var i, r = this._first, a = this._labels; r;)r._startTime >= n && (r._startTime += t), r = r._next; if (e) for (i in a)a[i] >= n && (a[i] += t); return this._uncache(!0) }, m._kill = function (t, e) { if (!t && !e) return this._enabled(!1, !1); for (var n = e ? this.getTweensOf(e) : this.getChildren(!0, !0, !1), i = n.length, r = !1; --i > -1;)n[i]._kill(t, e) && (r = !0); return r }, m.clear = function (t) { const e = this.getChildren(!1, !0, !0); let n = e.length; for (this._time = this._totalTime = 0; --n > -1;)e[n]._enabled(!1, !1); return !1 !== t && (this._labels = {}), this._uncache(!0) }, m.invalidate = function () { for (let e = this._first; e;)e.invalidate(), e = e._next; return t.prototype.invalidate.call(this) }, m._enabled = function (t, n) { if (t === this._gc) for (let i = this._first; i;)i._enabled(t, !0), i = i._next; return e.prototype._enabled.call(this, t, n) }, m.totalTime = function (e, n, i) { this._forcingPlayhead = !0; const r = t.prototype.totalTime.apply(this, arguments); return this._forcingPlayhead = !1, r }, m.duration = function (t) { return arguments.length ? (this.duration() !== 0 && t !== 0 && this.timeScale(this._duration / t), this) : (this._dirty && this.totalDuration(), this._duration) }, m.totalDuration = function (t) { if (!arguments.length) { if (this._dirty) { for (var e, n, i = 0, r = this._last, a = 999999999999; r;)e = r._prev, r._dirty && r.totalDuration(), r._startTime > a && this._sortChildren && !r._paused ? this.add(r, r._startTime - r._delay) : a = r._startTime, r._startTime < 0 && !r._paused && (i -= r._startTime, this._timeline.smoothChildTiming && (this._startTime += r._startTime / this._timeScale), this.shiftChildren(-r._startTime, !1, -9999999999), a = 0), n = r._startTime + r._totalDuration / r._timeScale, n > i && (i = n), r = e; this._duration = this._totalDuration = i, this._dirty = !1 } return this._totalDuration } return t && this.totalDuration() ? this.timeScale(this._totalDuration / t) : this }, m.paused = function (e) { if (!e) for (let n = this._first, i = this._time; n;)n._startTime === i && n.data === 'isPause' && (n._rawPrevTime = 0), n = n._next; return t.prototype.paused.apply(this, arguments) }, m.usesFrames = function () { for (var e = this._timeline; e._timeline;)e = e._timeline; return e === t._rootFramesTimeline }, m.rawTime = function (t) { return t && (this._paused || this._repeat && this.time() > 0 && this.totalProgress() < 1) ? this._totalTime % (this._duration + this._repeatDelay) : this._paused ? this._totalTime : (this._timeline.rawTime(t) - this._startTime) * this._timeScale }, i }, !0), _gsScope._gsDefine('TimelineMax', ['TimelineLite', 'TweenLite', 'easing.Ease'], function (t, e, n) { const i = function (e) { t.call(this, e), this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._cycle = 0, this._yoyo = !0 === this.vars.yoyo, this._dirty = !0 }; const r = e._internals; const a = r.lazyTweens; const o = r.lazyRender; const s = _gsScope._gsDefine.globals; const l = new n(null, null, 1, 0); const c = i.prototype = new t(); return c.constructor = i, c.kill()._gc = !1, i.version = '1.19.1', c.invalidate = function () { return this._yoyo = !0 === this.vars.yoyo, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._uncache(!0), t.prototype.invalidate.call(this) }, c.addCallback = function (t, n, i, r) { return this.add(e.delayedCall(0, t, i, r), n) }, c.removeCallback = function (t, e) { if (t) if (e == null) this._kill(null, t); else for (let n = this.getTweensOf(t, !1), i = n.length, r = this._parseTimeOrLabel(e); --i > -1;)n[i]._startTime === r && n[i]._enabled(!1, !1); return this }, c.removePause = function (e) { return this.removeCallback(t._internals.pauseCallback, e) }, c.tweenTo = function (t, n) { n = n || {}; let i; let r; let a; const o = { ease: l, useFrames: this.usesFrames(), immediateRender: !1 }; const c = n.repeat && s.TweenMax || e; for (r in n)o[r] = n[r]; return o.time = this._parseTimeOrLabel(t), i = Math.abs(Number(o.time) - this._time) / this._timeScale || 0.001, a = new c(this, i, o), o.onStart = function () { a.target.paused(!0), a.vars.time !== a.target.time() && i === a.duration() && a.duration(Math.abs(a.vars.time - a.target.time()) / a.target._timeScale), n.onStart && n.onStart.apply(n.onStartScope || n.callbackScope || a, n.onStartParams || []) }, a }, c.tweenFromTo = function (t, e, n) { n = n || {}, t = this._parseTimeOrLabel(t), n.startAt = { onComplete: this.seek, onCompleteParams: [t], callbackScope: this }, n.immediateRender = !1 !== n.immediateRender; const i = this.tweenTo(e, n); return i.duration(Math.abs(i.vars.time - t) / this._timeScale || 0.001) }, c.render = function (t, e, n) { this._gc && this._enabled(!0, !1); let i; let r; let s; let l; let c; let u; let h; let p; const d = this._dirty ? this.totalDuration() : this._totalDuration; const f = this._duration; let m = this._time; const g = this._totalTime; const v = this._startTime; const y = this._timeScale; const b = this._rawPrevTime; const x = this._paused; const w = this._cycle; if (t >= d - 1e-7 && t >= 0) this._locked || (this._totalTime = d, this._cycle = this._repeat), this._reversed || this._hasPausedChild() || (r = !0, l = 'onComplete', c = !!this._timeline.autoRemoveChildren, this._duration === 0 && (t <= 0 && t >= -1e-7 || b < 0 || b === 1e-10) && b !== t && this._first && (c = !0, b > 1e-10 && (l = 'onReverseComplete'))), this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : 1e-10, this._yoyo && (1 & this._cycle) != 0 ? this._time = t = 0 : (this._time = f, t = f + 1e-4); else if (t < 1e-7) if (this._locked || (this._totalTime = this._cycle = 0), this._time = 0, (m !== 0 || f === 0 && b !== 1e-10 && (b > 0 || t < 0 && b >= 0) && !this._locked) && (l = 'onReverseComplete', r = this._reversed), t < 0) this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (c = r = !0, l = 'onReverseComplete') : b >= 0 && this._first && (c = !0), this._rawPrevTime = t; else { if (this._rawPrevTime = f || !e || t || this._rawPrevTime === t ? t : 1e-10, t === 0 && r) for (i = this._first; i && i._startTime === 0;)i._duration || (r = !1), i = i._next; t = 0, this._initted || (c = !0) } else if (f === 0 && b < 0 && (c = !0), this._time = this._rawPrevTime = t, this._locked || (this._totalTime = t, this._repeat !== 0 && (u = f + this._repeatDelay, this._cycle = this._totalTime / u >> 0, this._cycle !== 0 && this._cycle === this._totalTime / u && g <= t && this._cycle--, this._time = this._totalTime - this._cycle * u, this._yoyo && (1 & this._cycle) != 0 && (this._time = f - this._time), this._time > f ? (this._time = f, t = f + 1e-4) : this._time < 0 ? this._time = t = 0 : t = this._time)), this._hasPause && !this._forcingPlayhead && !e && t < f) { if ((t = this._time) >= m || this._repeat && w !== this._cycle) for (i = this._first; i && i._startTime <= t && !h;)i._duration || i.data !== 'isPause' || i.ratio || i._startTime === 0 && this._rawPrevTime === 0 || (h = i), i = i._next; else for (i = this._last; i && i._startTime >= t && !h;)i._duration || i.data === 'isPause' && i._rawPrevTime > 0 && (h = i), i = i._prev; h && (this._time = t = h._startTime, this._totalTime = t + this._cycle * (this._totalDuration + this._repeatDelay)) } if (this._cycle !== w && !this._locked) { let _ = this._yoyo && (1 & w) != 0; const $ = _ === (this._yoyo && (1 & this._cycle) != 0); const T = this._totalTime; const S = this._cycle; const M = this._rawPrevTime; const C = this._time; if (this._totalTime = w * f, this._cycle < w ? _ = !_ : this._totalTime += f, this._time = m, this._rawPrevTime = f === 0 ? b - 1e-4 : b, this._cycle = w, this._locked = !0, m = _ ? 0 : f, this.render(m, e, f === 0), e || this._gc || this.vars.onRepeat && (this._cycle = S, this._locked = !1, this._callback('onRepeat')), m !== this._time) return; if ($ && (this._cycle = w, this._locked = !0, m = _ ? f + 1e-4 : -1e-4, this.render(m, !0, !1)), this._locked = !1, this._paused && !x) return; this._time = C, this._totalTime = T, this._cycle = S, this._rawPrevTime = M } if (!(this._time !== m && this._first || n || c || h)) return void (g !== this._totalTime && this._onUpdate && (e || this._callback('onUpdate'))); if (this._initted || (this._initted = !0), this._active || !this._paused && this._totalTime !== g && t > 0 && (this._active = !0), g === 0 && this.vars.onStart && (this._totalTime === 0 && this._totalDuration || e || this._callback('onStart')), (p = this._time) >= m) for (i = this._first; i && (s = i._next, p === this._time && (!this._paused || x));)(i._active || i._startTime <= this._time && !i._paused && !i._gc) && (h === i && this.pause(), i._reversed ? i.render((i._dirty ? i.totalDuration() : i._totalDuration) - (t - i._startTime) * i._timeScale, e, n) : i.render((t - i._startTime) * i._timeScale, e, n)), i = s; else for (i = this._last; i && (s = i._prev, p === this._time && (!this._paused || x));) { if (i._active || i._startTime <= m && !i._paused && !i._gc) { if (h === i) { for (h = i._prev; h && h.endTime() > this._time;)h.render(h._reversed ? h.totalDuration() - (t - h._startTime) * h._timeScale : (t - h._startTime) * h._timeScale, e, n), h = h._prev; h = null, this.pause() }i._reversed ? i.render((i._dirty ? i.totalDuration() : i._totalDuration) - (t - i._startTime) * i._timeScale, e, n) : i.render((t - i._startTime) * i._timeScale, e, n) }i = s } this._onUpdate && (e || (a.length && o(), this._callback('onUpdate'))), l && (this._locked || this._gc || v !== this._startTime && y === this._timeScale || (this._time === 0 || d >= this.totalDuration()) && (r && (a.length && o(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[l] && this._callback(l))) }, c.getActive = function (t, e, n) { t == null && (t = !0), e == null && (e = !0), n == null && (n = !1); let i; let r; const a = []; const o = this.getChildren(t, e, n); let s = 0; const l = o.length; for (i = 0; i < l; i++)r = o[i], r.isActive() && (a[s++] = r); return a }, c.getLabelAfter = function (t) { t || t !== 0 && (t = this._time); let e; const n = this.getLabelsArray(); const i = n.length; for (e = 0; e < i; e++) if (n[e].time > t) return n[e].name; return null }, c.getLabelBefore = function (t) { t == null && (t = this._time); for (let e = this.getLabelsArray(), n = e.length; --n > -1;) if (e[n].time < t) return e[n].name; return null }, c.getLabelsArray = function () { let t; const e = []; let n = 0; for (t in this._labels)e[n++] = { time: this._labels[t], name: t }; return e.sort(function (t, e) { return t.time - e.time }), e }, c.invalidate = function () { return this._locked = !1, t.prototype.invalidate.call(this) }, c.progress = function (t, e) { return arguments.length ? this.totalTime(this.duration() * (this._yoyo && (1 & this._cycle) != 0 ? 1 - t : t) + this._cycle * (this._duration + this._repeatDelay), e) : this._time / this.duration() }, c.totalProgress = function (t, e) { return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this._totalTime / this.totalDuration() }, c.totalDuration = function (e) { return arguments.length ? this._repeat !== -1 && e ? this.timeScale(this.totalDuration() / e) : this : (this._dirty && (t.prototype.totalDuration.call(this), this._totalDuration = this._repeat === -1 ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat), this._totalDuration) }, c.time = function (t, e) { return arguments.length ? (this._dirty && this.totalDuration(), t > this._duration && (t = this._duration), this._yoyo && (1 & this._cycle) != 0 ? t = this._duration - t + this._cycle * (this._duration + this._repeatDelay) : this._repeat !== 0 && (t += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(t, e)) : this._time }, c.repeat = function (t) { return arguments.length ? (this._repeat = t, this._uncache(!0)) : this._repeat }, c.repeatDelay = function (t) { return arguments.length ? (this._repeatDelay = t, this._uncache(!0)) : this._repeatDelay }, c.yoyo = function (t) { return arguments.length ? (this._yoyo = t, this) : this._yoyo }, c.currentLabel = function (t) { return arguments.length ? this.seek(t, !0) : this.getLabelBefore(this._time + 1e-8) }, i }, !0), (function () { const t = 180 / Math.PI; const e = []; const n = []; const i = []; const r = {}; const a = _gsScope._gsDefine.globals; const o = function (t, e, n, i) { n === i && (n = i - (i - e) / 1e6), t === e && (e = t + (n - t) / 1e6), this.a = t, this.b = e, this.c = n, this.d = i, this.da = i - t, this.ca = n - t, this.ba = e - t }; const s = function (t, e, n, i) { const r = { a: t }; const a = {}; const o = {}; const s = { c: i }; const l = (t + e) / 2; const c = (e + n) / 2; const u = (n + i) / 2; const h = (l + c) / 2; const p = (c + u) / 2; const d = (p - h) / 8; return r.b = l + (t - l) / 4, a.b = h + d, r.c = a.a = (r.b + a.b) / 2, a.c = o.a = (h + p) / 2, o.b = p - d, s.b = u + (i - u) / 4, o.c = s.a = (o.b + s.b) / 2, [r, a, o, s] }; const l = function (t, r, a, o, l) { let c; let u; let h; let p; let d; let f; let m; let g; let v; let y; let b; let x; let w; const _ = t.length - 1; let $ = 0; let T = t[0].a; for (c = 0; c < _; c++)d = t[$], u = d.a, h = d.d, p = t[$ + 1].d, l ? (b = e[c], x = n[c], w = (x + b) * r * 0.25 / (o ? 0.5 : i[c] || 0.5), f = h - (h - u) * (o ? 0.5 * r : b !== 0 ? w / b : 0), m = h + (p - h) * (o ? 0.5 * r : x !== 0 ? w / x : 0), g = h - (f + ((m - f) * (3 * b / (b + x) + 0.5) / 4 || 0))) : (f = h - (h - u) * r * 0.5, m = h + (p - h) * r * 0.5, g = h - (f + m) / 2), f += g, m += g, d.c = v = f, d.b = c !== 0 ? T : T = d.a + 0.6 * (d.c - d.a), d.da = h - u, d.ca = v - u, d.ba = T - u, a ? (y = s(u, T, v, h), t.splice($, 1, y[0], y[1], y[2], y[3]), $ += 4) : $++, T = m; d = t[$], d.b = T, d.c = T + 0.4 * (d.d - T), d.da = d.d - d.a, d.ca = d.c - d.a, d.ba = T - d.a, a && (y = s(d.a, T, d.c, d.d), t.splice($, 1, y[0], y[1], y[2], y[3])) }; const c = function (t, i, r, a) { let s; let l; let c; let u; let h; let p; const d = []; if (a) for (t = [a].concat(t), l = t.length; --l > -1;) typeof (p = t[l][i]) === 'string' && p.charAt(1) === '=' && (t[l][i] = a[i] + Number(p.charAt(0) + p.substr(2))); if ((s = t.length - 2) < 0) return d[0] = new o(t[0][i], 0, 0, t[s < -1 ? 0 : 1][i]), d; for (l = 0; l < s; l++)c = t[l][i], u = t[l + 1][i], d[l] = new o(c, 0, 0, u), r && (h = t[l + 2][i], e[l] = (e[l] || 0) + (u - c) * (u - c), n[l] = (n[l] || 0) + (h - u) * (h - u)); return d[l] = new o(t[l][i], 0, 0, t[l + 1][i]), d }; const u = function (t, a, o, s, u, h) { let p; let d; let f; let m; let g; let v; let y; let b; const x = {}; const w = []; const _ = h || t[0]; u = typeof u === 'string' ? ',' + u + ',' : ',x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,', a == null && (a = 1); for (d in t[0])w.push(d); if (t.length > 1) { for (b = t[t.length - 1], y = !0, p = w.length; --p > -1;) if (d = w[p], Math.abs(_[d] - b[d]) > 0.05) { y = !1; break }y && (t = t.concat(), h && t.unshift(h), t.push(t[1]), h = t[t.length - 3]) } for (e.length = n.length = i.length = 0, p = w.length; --p > -1;)d = w[p], r[d] = u.indexOf(',' + d + ',') !== -1, x[d] = c(t, d, r[d], h); for (p = e.length; --p > -1;)e[p] = Math.sqrt(e[p]), n[p] = Math.sqrt(n[p]); if (!s) { for (p = w.length; --p > -1;) if (r[d]) for (f = x[w[p]], v = f.length - 1, m = 0; m < v; m++)g = f[m + 1].da / n[m] + f[m].da / e[m] || 0, i[m] = (i[m] || 0) + g * g; for (p = i.length; --p > -1;)i[p] = Math.sqrt(i[p]) } for (p = w.length, m = o ? 4 : 1; --p > -1;)d = w[p], f = x[d], l(f, a, o, s, r[d]), y && (f.splice(0, m), f.splice(f.length - m, m)); return x }; const h = function (t, e, n) { e = e || 'soft'; let i; let r; let a; let s; let l; let c; let u; let h; let p; let d; let f; const m = {}; const g = e === 'cubic' ? 3 : 2; const v = e === 'soft'; const y = []; if (v && n && (t = [n].concat(t)), t == null || t.length < g + 1) throw 'invalid Bezier data'; for (p in t[0])y.push(p); for (c = y.length; --c > -1;) { for (p = y[c], m[p] = l = [], d = 0, h = t.length, u = 0; u < h; u++)i = n == null ? t[u][p] : typeof (f = t[u][p]) === 'string' && f.charAt(1) === '=' ? n[p] + Number(f.charAt(0) + f.substr(2)) : Number(f), v && u > 1 && u < h - 1 && (l[d++] = (i + l[d - 2]) / 2), l[d++] = i; for (h = d - g + 1, d = 0, u = 0; u < h; u += g)i = l[u], r = l[u + 1], a = l[u + 2], s = g === 2 ? 0 : l[u + 3], l[d++] = f = g === 3 ? new o(i, r, a, s) : new o(i, (2 * r + i) / 3, (2 * r + a) / 3, a); l.length = d } return m }; const p = function (t, e, n) { for (var i, r, a, o, s, l, c, u, h, p, d, f = 1 / n, m = t.length; --m > -1;) for (p = t[m], a = p.a, o = p.d - a, s = p.c - a, l = p.b - a, i = r = 0, u = 1; u <= n; u++)c = f * u, h = 1 - c, i = r - (r = (c * c * o + 3 * h * (c * s + h * l)) * c), d = m * n + u - 1, e[d] = (e[d] || 0) + i * i }; const d = function (t, e) { e = e >> 0 || 6; let n; let i; let r; let a; const o = []; const s = []; let l = 0; let c = 0; const u = e - 1; const h = []; let d = []; for (n in t)p(t[n], o, e); for (r = o.length, i = 0; i < r; i++)l += Math.sqrt(o[i]), a = i % e, d[a] = l, a === u && (c += l, a = i / e >> 0, h[a] = d, s[a] = c, l = 0, d = []); return { length: c, lengths: s, segments: h } }; const f = _gsScope._gsDefine.plugin({ propName: 'bezier', priority: -1, version: '1.3.7', API: 2, global: !0, init: function (t, e, n) { this._target = t, e instanceof Array && (e = { values: e }), this._func = {}, this._mod = {}, this._props = [], this._timeRes = e.timeResolution == null ? 6 : parseInt(e.timeResolution, 10); let i; let r; let a; let o; let s; const l = e.values || []; const c = {}; const p = l[0]; let f = e.autoRotate || n.vars.orientToBezier; this._autoRotate = f ? f instanceof Array ? f : [['x', 'y', 'rotation', !0 === f ? 0 : Number(f) || 0]] : null; for (i in p) this._props.push(i); for (a = this._props.length; --a > -1;)i = this._props[a], this._overwriteProps.push(i), r = this._func[i] = typeof t[i] === 'function', c[i] = r ? t[i.indexOf('set') || typeof t['get' + i.substr(3)] !== 'function' ? i : 'get' + i.substr(3)]() : parseFloat(t[i]), s || c[i] !== l[0][i] && (s = c); if (this._beziers = e.type !== 'cubic' && e.type !== 'quadratic' && e.type !== 'soft' ? u(l, isNaN(e.curviness) ? 1 : e.curviness, !1, e.type === 'thruBasic', e.correlate, s) : h(l, e.type, c), this._segCount = this._beziers[i].length, this._timeRes) { const m = d(this._beziers, this._timeRes); this._length = m.length, this._lengths = m.lengths, this._segments = m.segments, this._l1 = this._li = this._s1 = this._si = 0, this._l2 = this._lengths[0], this._curSeg = this._segments[0], this._s2 = this._curSeg[0], this._prec = 1 / this._curSeg.length } if (f = this._autoRotate) for (this._initialRotations = [], f[0] instanceof Array || (this._autoRotate = f = [f]), a = f.length; --a > -1;) { for (o = 0; o < 3; o++)i = f[a][o], this._func[i] = typeof t[i] === 'function' && t[i.indexOf('set') || typeof t['get' + i.substr(3)] !== 'function' ? i : 'get' + i.substr(3)]; i = f[a][2], this._initialRotations[a] = (this._func[i] ? this._func[i].call(this._target) : this._target[i]) || 0, this._overwriteProps.push(i) } return this._startRatio = n.vars.runBackwards ? 1 : 0, !0 }, set: function (e) { let n; let i; let r; let a; let o; let s; let l; let c; let u; let h; const p = this._segCount; const d = this._func; const f = this._target; const m = e !== this._startRatio; if (this._timeRes) { if (u = this._lengths, h = this._curSeg, e *= this._length, r = this._li, e > this._l2 && r < p - 1) { for (c = p - 1; r < c && (this._l2 = u[++r]) <= e;);this._l1 = u[r - 1], this._li = r, this._curSeg = h = this._segments[r], this._s2 = h[this._s1 = this._si = 0] } else if (e < this._l1 && r > 0) { for (;r > 0 && (this._l1 = u[--r]) >= e;);r === 0 && e < this._l1 ? this._l1 = 0 : r++, this._l2 = u[r], this._li = r, this._curSeg = h = this._segments[r], this._s1 = h[(this._si = h.length - 1) - 1] || 0, this._s2 = h[this._si] } if (n = r, e -= this._l1, r = this._si, e > this._s2 && r < h.length - 1) { for (c = h.length - 1; r < c && (this._s2 = h[++r]) <= e;);this._s1 = h[r - 1], this._si = r } else if (e < this._s1 && r > 0) { for (;r > 0 && (this._s1 = h[--r]) >= e;);r === 0 && e < this._s1 ? this._s1 = 0 : r++, this._s2 = h[r], this._si = r }s = (r + (e - this._s1) / (this._s2 - this._s1)) * this._prec || 0 } else n = e < 0 ? 0 : e >= 1 ? p - 1 : p * e >> 0, s = (e - n * (1 / p)) * p; for (i = 1 - s, r = this._props.length; --r > -1;)a = this._props[r], o = this._beziers[a][n], l = (s * s * o.da + 3 * i * (s * o.ca + i * o.ba)) * s + o.a, this._mod[a] && (l = this._mod[a](l, f)), d[a] ? f[a](l) : f[a] = l; if (this._autoRotate) { let g; let v; let y; let b; let x; let w; let _; const $ = this._autoRotate; for (r = $.length; --r > -1;)a = $[r][2], w = $[r][3] || 0, _ = !0 === $[r][4] ? 1 : t, o = this._beziers[$[r][0]], g = this._beziers[$[r][1]], o && g && (o = o[n], g = g[n], v = o.a + (o.b - o.a) * s, b = o.b + (o.c - o.b) * s, v += (b - v) * s, b += (o.c + (o.d - o.c) * s - b) * s, y = g.a + (g.b - g.a) * s, x = g.b + (g.c - g.b) * s, y += (x - y) * s, x += (g.c + (g.d - g.c) * s - x) * s, l = m ? Math.atan2(x - y, b - v) * _ + w : this._initialRotations[r], this._mod[a] && (l = this._mod[a](l, f)), d[a] ? f[a](l) : f[a] = l) } } }); const m = f.prototype; f.bezierThrough = u, f.cubicToQuadratic = s, f._autoCSS = !0, f.quadraticToCubic = function (t, e, n) { return new o(t, (2 * e + t) / 3, (2 * e + n) / 3, n) }, f._cssRegister = function () { const t = a.CSSPlugin; if (t) { const e = t._internals; const n = e._parseToProxy; const i = e._setPluginRatio; const r = e.CSSPropTween; e._registerComplexSpecialProp('bezier', { parser: function (t, e, a, o, s, l) { e instanceof Array && (e = { values: e }), l = new f(); let c; let u; let h; const p = e.values; const d = p.length - 1; const m = []; const g = {}; if (d < 0) return s; for (c = 0; c <= d; c++)h = n(t, p[c], o, s, l, d !== c), m[c] = h.end; for (u in e)g[u] = e[u]; return g.values = m, s = new r(t, 'bezier', 0, 0, h.pt, 2), s.data = h, s.plugin = l, s.setRatio = i, g.autoRotate === 0 && (g.autoRotate = !0), !g.autoRotate || g.autoRotate instanceof Array || (c = !0 === g.autoRotate ? 0 : Number(g.autoRotate), g.autoRotate = h.end.left != null ? [['left', 'top', 'rotation', c, !1]] : h.end.x != null && [['x', 'y', 'rotation', c, !1]]), g.autoRotate && (o._transform || o._enableTransforms(!1), h.autoRotate = o._target._gsTransform, h.proxy.rotation = h.autoRotate.rotation || 0, o._overwriteProps.push('rotation')), l._onInitTween(h.proxy, g, o._tween), s } }) } }, m._mod = function (t) { for (var e, n = this._overwriteProps, i = n.length; --i > -1;)(e = t[n[i]]) && typeof e === 'function' && (this._mod[n[i]] = e) }, m._kill = function (t) { let e; let n; let i = this._props; for (e in this._beziers) if (e in t) for (delete this._beziers[e], delete this._func[e], n = i.length; --n > -1;)i[n] === e && i.splice(n, 1); if (i = this._autoRotate) for (n = i.length; --n > -1;)t[i[n][2]] && i.splice(n, 1); return this._super._kill.call(this, t) } }()), _gsScope._gsDefine('plugins.CSSPlugin', ['plugins.TweenPlugin', 'TweenLite'], function (t, e) {
    let n; let i; let r; let a; const o = function () { t.call(this, 'css'), this._overwriteProps.length = 0, this.setRatio = o.prototype.setRatio }; const s = _gsScope._gsDefine.globals; const l = {}; let c = o.prototype = new t('css'); c.constructor = o, o.version = '1.19.1', o.API = 2, o.defaultTransformPerspective = 0, o.defaultSkewType = 'compensated', o.defaultSmoothOrigin = !0, c = 'px', o.suffixMap = { top: c, right: c, bottom: c, left: c, width: c, height: c, fontSize: c, padding: c, margin: c, perspective: c, lineHeight: '' }; let u; let h; let p; let d; let f; let m; let g; let v; const y = /(?:\-|\.|\b)(\d|\.|e\-)+/g; const b = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g; const x = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi; const w = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g; const _ = /(?:\d|\-|\+|=|#|\.)*/g; const $ = /opacity *= *([^)]*)/i; const T = /opacity:([^;]*)/i; const S = /^(rgb|hsl)/; const M = function (t, e) { return e.toUpperCase() }; const C = /(?:Left|Right|Width)/i; const E = /,(?=[^\)]*(?:\(|$))/gi; const A = /[\s,\(]/i; const P = Math.PI / 180; const k = 180 / Math.PI; let D = {}; const O = { style: {} }; const L = _gsScope.document || { createElement: function () { return O } }; const I = function (t, e) { return L.createElementNS ? L.createElementNS(e || 'http://www.w3.org/1999/xhtml', t) : L.createElement(t) }; const R = I('div'); const N = I('img'); const F = o._internals = { _specialProps: l }; const U = (_gsScope.navigator || {}).userAgent || ''; const z = (function () { const t = U.indexOf('Android'); const e = I('a'); return p = U.indexOf('Safari') !== -1 && U.indexOf('Chrome') === -1 && (t === -1 || parseFloat(U.substr(t + 8, 2)) > 3), f = p && parseFloat(U.substr(U.indexOf('Version/') + 8, 2)) < 6, d = U.indexOf('Firefox') !== -1, (/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(U) || /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(U)) && (m = parseFloat(RegExp.$1)), !!e && (e.style.cssText = 'top:1px;opacity:.55;', /^0.55/.test(e.style.opacity)) }()); const B = function (t) { return $.test(typeof t === 'string' ? t : (t.currentStyle ? t.currentStyle.filter : t.style.filter) || '') ? parseFloat(RegExp.$1) / 100 : 1 }; const j = function (t) { _gsScope.console }; let V = ''; let G = ''; const H = function (t, e) { e = e || R; let n; let i; const r = e.style; if (void 0 !== r[t]) return t; for (t = t.charAt(0).toUpperCase() + t.substr(1), n = ['O', 'Moz', 'ms', 'Ms', 'Webkit'], i = 5; --i > -1 && void 0 === r[n[i] + t];);return i >= 0 ? (G = i === 3 ? 'ms' : n[i], V = '-' + G.toLowerCase() + '-', G + t) : null }; const W = L.defaultView ? L.defaultView.getComputedStyle : function () {}; const q = o.getStyle = function (t, e, n, i, r) {
      let a
      return z || e !== 'opacity' ? (!i && t.style[e] ? a = t.style[e] : (n = n || W(t)) ? a = n[e] || n.getPropertyValue(e) || n.getPropertyValue(e.replace(/([A-Z])/g, '-$1').toLowerCase()) : t.currentStyle && (a = t.currentStyle[e]), r == null || a && a !== 'none' && a !== 'auto' && a !== 'auto auto' ? a : r) : B(t)
    }; var X = F.convertToPixels = function (t, n, i, r, a) { if (r === 'px' || !r) return i; if (r === 'auto' || !i) return 0; let s; let l; let c; const u = C.test(n); let h = t; const p = R.style; const d = i < 0; const f = i === 1; if (d && (i = -i), f && (i *= 100), r === '%' && n.indexOf('border') !== -1)s = i / 100 * (u ? t.clientWidth : t.clientHeight); else { if (p.cssText = 'border:0 solid red;position:' + q(t, 'position') + ';line-height:0;', r !== '%' && h.appendChild && r.charAt(0) !== 'v' && r !== 'rem')p[u ? 'borderLeftWidth' : 'borderTopWidth'] = i + r; else { if (h = t.parentNode || L.body, l = h._gsCache, c = e.ticker.frame, l && u && l.time === c) return l.width * i / 100; p[u ? 'width' : 'height'] = i + r }h.appendChild(R), s = parseFloat(R[u ? 'offsetWidth' : 'offsetHeight']), h.removeChild(R), u && r === '%' && !1 !== o.cacheWidths && (l = h._gsCache = h._gsCache || {}, l.time = c, l.width = s / i * 100), s !== 0 || a || (s = X(t, n, i, r, !0)) } return f && (s /= 100), d ? -s : s }; const Y = F.calculateOffset = function (t, e, n) { if (q(t, 'position', n) !== 'absolute') return 0; const i = e === 'left' ? 'Left' : 'Top'; const r = q(t, 'margin' + i, n); return t['offset' + i] - (X(t, e, parseFloat(r), r.replace(_, '')) || 0) }; const Z = function (t, e) { let n; let i; let r; const a = {}; if (e = e || W(t, null)) if (n = e.length) for (;--n > -1;)r = e[n], r.indexOf('-transform') !== -1 && $t !== r || (a[r.replace(/-([a-z])/gi, M)] = e.getPropertyValue(r)); else for (n in e)n.indexOf('Transform') !== -1 && _t !== n || (a[n] = e[n]); else if (e = t.currentStyle || t.style) for (n in e) typeof n === 'string' && void 0 === a[n] && (a[n.replace(/-([a-z])/gi, M)] = e[n]); return z || (a.opacity = B(t)), i = Nt(t, e, !1), a.rotation = i.rotation, a.skewX = i.skewX, a.scaleX = i.scaleX, a.scaleY = i.scaleY, a.x = i.x, a.y = i.y, St && (a.z = i.z, a.rotationX = i.rotationX, a.rotationY = i.rotationY, a.scaleZ = i.scaleZ), a.filters && delete a.filters, a }; const K = function (t, e, n, i, r) { let a; let o; let s; const l = {}; const c = t.style; for (o in n)o !== 'cssText' && o !== 'length' && isNaN(o) && (e[o] !== (a = n[o]) || r && r[o]) && o.indexOf('Origin') === -1 && (typeof a !== 'number' && typeof a !== 'string' || (l[o] = a !== 'auto' || o !== 'left' && o !== 'top' ? a !== '' && a !== 'auto' && a !== 'none' || typeof e[o] !== 'string' || e[o].replace(w, '') === '' ? a : 0 : Y(t, o), void 0 !== c[o] && (s = new pt(c, o, c[o], s)))); if (i) for (o in i)o !== 'className' && (l[o] = i[o]); return { difs: l, firstMPT: s } }; const J = { width: ['Left', 'Right'], height: ['Top', 'Bottom'] }; const Q = ['marginLeft', 'marginRight', 'marginTop', 'marginBottom']; const tt = function (t, e, n) { if ((t.nodeName + '').toLowerCase() === 'svg') return (n || W(t))[e] || 0; if (t.getCTM && Lt(t)) return t.getBBox()[e] || 0; let i = parseFloat(e === 'width' ? t.offsetWidth : t.offsetHeight); const r = J[e]; let a = r.length; for (n = n || W(t, null); --a > -1;)i -= parseFloat(q(t, 'padding' + r[a], n, !0)) || 0, i -= parseFloat(q(t, 'border' + r[a] + 'Width', n, !0)) || 0; return i }; const et = function (t, e) { if (t === 'contain' || t === 'auto' || t === 'auto auto') return t + ' '; t != null && t !== '' || (t = '0 0'); let n; let i = t.split(' '); let r = t.indexOf('left') !== -1 ? '0%' : t.indexOf('right') !== -1 ? '100%' : i[0]; let a = t.indexOf('top') !== -1 ? '0%' : t.indexOf('bottom') !== -1 ? '100%' : i[1]; if (i.length > 3 && !e) { for (i = t.split(', ').join(',').split(','), t = [], n = 0; n < i.length; n++)t.push(et(i[n])); return t.join(',') } return a == null ? a = r === 'center' ? '50%' : '0' : a === 'center' && (a = '50%'), (r === 'center' || isNaN(parseFloat(r)) && (r + '').indexOf('=') === -1) && (r = '50%'), t = r + ' ' + a + (i.length > 2 ? ' ' + i[2] : ''), e && (e.oxp = r.indexOf('%') !== -1, e.oyp = a.indexOf('%') !== -1, e.oxr = r.charAt(1) === '=', e.oyr = a.charAt(1) === '=', e.ox = parseFloat(r.replace(w, '')), e.oy = parseFloat(a.replace(w, '')), e.v = t), e || t }; const nt = function (t, e) { return typeof t === 'function' && (t = t(v, g)), typeof t === 'string' && t.charAt(1) === '=' ? parseInt(t.charAt(0) + '1', 10) * parseFloat(t.substr(2)) : parseFloat(t) - parseFloat(e) || 0 }; const it = function (t, e) { return typeof t === 'function' && (t = t(v, g)), t == null ? e : typeof t === 'string' && t.charAt(1) === '=' ? parseInt(t.charAt(0) + '1', 10) * parseFloat(t.substr(2)) + e : parseFloat(t) || 0 }; const rt = function (t, e, n, i) { let r, a, o, s, l; return typeof t === 'function' && (t = t(v, g)), t == null ? s = e : typeof t === 'number' ? s = t : (r = 360, a = t.split('_'), l = t.charAt(1) === '=', o = (l ? parseInt(t.charAt(0) + '1', 10) * parseFloat(a[0].substr(2)) : parseFloat(a[0])) * (t.indexOf('rad') === -1 ? 1 : k) - (l ? 0 : e), a.length && (i && (i[n] = e + o), t.indexOf('short') !== -1 && (o %= r) !== o % (r / 2) && (o = o < 0 ? o + r : o - r), t.indexOf('_cw') !== -1 && o < 0 ? o = (o + 9999999999 * r) % r - (o / r | 0) * r : t.indexOf('ccw') !== -1 && o > 0 && (o = (o - 9999999999 * r) % r - (o / r | 0) * r)), s = e + o), s < 1e-6 && s > -1e-6 && (s = 0), s }; const at = { aqua: [0, 255, 255], lime: [0, 255, 0], silver: [192, 192, 192], black: [0, 0, 0], maroon: [128, 0, 0], teal: [0, 128, 128], blue: [0, 0, 255], navy: [0, 0, 128], white: [255, 255, 255], fuchsia: [255, 0, 255], olive: [128, 128, 0], yellow: [255, 255, 0], orange: [255, 165, 0], gray: [128, 128, 128], purple: [128, 0, 128], green: [0, 128, 0], red: [255, 0, 0], pink: [255, 192, 203], cyan: [0, 255, 255], transparent: [255, 255, 255, 0] }; const ot = function (t, e, n) { return t = t < 0 ? t + 1 : t > 1 ? t - 1 : t, 255 * (6 * t < 1 ? e + (n - e) * t * 6 : t < 0.5 ? n : 3 * t < 2 ? e + (n - e) * (2 / 3 - t) * 6 : e) + 0.5 | 0 }; const st = o.parseColor = function (t, e) { let n, i, r, a, o, s, l, c, u, h, p; if (t) if (typeof t === 'number')n = [t >> 16, t >> 8 & 255, 255 & t]; else { if (t.charAt(t.length - 1) === ',' && (t = t.substr(0, t.length - 1)), at[t])n = at[t]; else if (t.charAt(0) === '#')t.length === 4 && (i = t.charAt(1), r = t.charAt(2), a = t.charAt(3), t = '#' + i + i + r + r + a + a), t = parseInt(t.substr(1), 16), n = [t >> 16, t >> 8 & 255, 255 & t]; else if (t.substr(0, 3) === 'hsl') if (n = p = t.match(y), e) { if (t.indexOf('=') !== -1) return t.match(b) } else o = Number(n[0]) % 360 / 360, s = Number(n[1]) / 100, l = Number(n[2]) / 100, r = l <= 0.5 ? l * (s + 1) : l + s - l * s, i = 2 * l - r, n.length > 3 && (n[3] = Number(t[3])), n[0] = ot(o + 1 / 3, i, r), n[1] = ot(o, i, r), n[2] = ot(o - 1 / 3, i, r); else n = t.match(y) || at.transparent; n[0] = Number(n[0]), n[1] = Number(n[1]), n[2] = Number(n[2]), n.length > 3 && (n[3] = Number(n[3])) } else n = at.black; return e && !p && (i = n[0] / 255, r = n[1] / 255, a = n[2] / 255, c = Math.max(i, r, a), u = Math.min(i, r, a), l = (c + u) / 2, c === u ? o = s = 0 : (h = c - u, s = l > 0.5 ? h / (2 - c - u) : h / (c + u), o = c === i ? (r - a) / h + (r < a ? 6 : 0) : c === r ? (a - i) / h + 2 : (i - r) / h + 4, o *= 60), n[0] = o + 0.5 | 0, n[1] = 100 * s + 0.5 | 0, n[2] = 100 * l + 0.5 | 0), n }; const lt = function (t, e) { let n; let i; let r; const a = t.match(ct) || []; let o = 0; let s = a.length ? '' : t; for (n = 0; n < a.length; n++)i = a[n], r = t.substr(o, t.indexOf(i, o) - o), o += r.length + i.length, i = st(i, e), i.length === 3 && i.push(1), s += r + (e ? 'hsla(' + i[0] + ',' + i[1] + '%,' + i[2] + '%,' + i[3] : 'rgba(' + i.join(',')) + ')'; return s + t.substr(o) }; var ct = '(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b'; for (c in at)ct += '|' + c + '\\b'; ct = new RegExp(ct + ')', 'gi'), o.colorStringFilter = function (t) { let e; const n = t[0] + t[1]; ct.test(n) && (e = n.indexOf('hsl(') !== -1 || n.indexOf('hsla(') !== -1, t[0] = lt(t[0], e), t[1] = lt(t[1], e)), ct.lastIndex = 0 }, e.defaultStringFilter || (e.defaultStringFilter = o.colorStringFilter); const ut = function (t, e, n, i) { if (t == null) return function (t) { return t }; let r; const a = e ? (t.match(ct) || [''])[0] : ''; const o = t.split(a).join('').match(x) || []; const s = t.substr(0, t.indexOf(o[0])); const l = t.charAt(t.length - 1) === ')' ? ')' : ''; const c = t.indexOf(' ') !== -1 ? ' ' : ','; const u = o.length; const h = u > 0 ? o[0].replace(y, '') : ''; return u ? r = e ? function (t) { let e, p, d, f; if (typeof t === 'number')t += h; else if (i && E.test(t)) { for (f = t.replace(E, '|').split('|'), d = 0; d < f.length; d++)f[d] = r(f[d]); return f.join(',') } if (e = (t.match(ct) || [a])[0], p = t.split(e).join('').match(x) || [], d = p.length, u > d--) for (;++d < u;)p[d] = n ? p[(d - 1) / 2 | 0] : o[d]; return s + p.join(c) + c + e + l + (t.indexOf('inset') !== -1 ? ' inset' : '') } : function (t) { let e, a, p; if (typeof t === 'number')t += h; else if (i && E.test(t)) { for (a = t.replace(E, '|').split('|'), p = 0; p < a.length; p++)a[p] = r(a[p]); return a.join(',') } if (e = t.match(x) || [], p = e.length, u > p--) for (;++p < u;)e[p] = n ? e[(p - 1) / 2 | 0] : o[p]; return s + e.join(c) + l } : function (t) { return t } }; const ht = function (t) { return t = t.split(','), function (e, n, i, r, a, o, s) { let l; const c = (n + '').split(' '); for (s = {}, l = 0; l < 4; l++)s[t[l]] = c[l] = c[l] || c[(l - 1) / 2 >> 0]; return r.parse(e, s, a, o) } }; var pt = (F._setPluginRatio = function (t) { this.plugin.setRatio(t); for (var e, n, i, r, a, o = this.data, s = o.proxy, l = o.firstMPT; l;)e = s[l.v], l.r ? e = Math.round(e) : e < 1e-6 && e > -1e-6 && (e = 0), l.t[l.p] = e, l = l._next; if (o.autoRotate && (o.autoRotate.rotation = o.mod ? o.mod(s.rotation, this.t) : s.rotation), t === 1 || t === 0) for (l = o.firstMPT, a = t === 1 ? 'e' : 'b'; l;) { if (n = l.t, n.type) { if (n.type === 1) { for (r = n.xs0 + n.s + n.xs1, i = 1; i < n.l; i++)r += n['xn' + i] + n['xs' + (i + 1)]; n[a] = r } } else n[a] = n.s + n.xs0; l = l._next } }, function (t, e, n, i, r) { this.t = t, this.p = e, this.v = n, this.r = r, i && (i._prev = this, this._next = i) }); var dt = (F._parseToProxy = function (t, e, n, i, r, a) { let o; let s; let l; let c; let u; const h = i; const p = {}; const d = {}; const f = n._transform; const m = D; for (n._transform = null, D = e, i = u = n.parse(t, e, i, r), D = m, a && (n._transform = f, h && (h._prev = null, h._prev && (h._prev._next = null))); i && i !== h;) { if (i.type <= 1 && (s = i.p, d[s] = i.s + i.c, p[s] = i.s, a || (c = new pt(i, 's', s, c, i.r), i.c = 0), i.type === 1)) for (o = i.l; --o > 0;)l = 'xn' + o, s = i.p + '_' + l, d[s] = i.data[l], p[s] = i[l], a || (c = new pt(i, l, s, c, i.rxp[l])); i = i._next } return { proxy: p, end: d, firstMPT: c, pt: u } }, F.CSSPropTween = function (t, e, i, r, o, s, l, c, u, h, p) { this.t = t, this.p = e, this.s = i, this.c = r, this.n = l || e, t instanceof dt || a.push(this.n), this.r = c, this.type = s || 0, u && (this.pr = u, n = !0), this.b = void 0 === h ? i : h, this.e = void 0 === p ? i + r : p, o && (this._next = o, o._prev = this) }); const ft = function (t, e, n, i, r, a) { const o = new dt(t, e, n, i - n, r, -1, a); return o.b = n, o.e = o.xs0 = i, o }; const mt = o.parseComplex = function (t, e, n, i, r, a, s, l, c, h) { n = n || a || '', typeof i === 'function' && (i = i(v, g)), s = new dt(t, e, 0, 0, s, h ? 2 : 1, null, !1, l, n, i), i += '', r && ct.test(i + n) && (i = [n, i], o.colorStringFilter(i), n = i[0], i = i[1]); let p; let d; let f; let m; let x; let w; let _; let $; let T; let S; let M; let C; let A; let P = n.split(', ').join(',').split(' '); let k = i.split(', ').join(',').split(' '); let D = P.length; const O = !1 !== u; for (i.indexOf(',') === -1 && n.indexOf(',') === -1 || (P = P.join(' ').replace(E, ', ').split(' '), k = k.join(' ').replace(E, ', ').split(' '), D = P.length), D !== k.length && (P = (a || '').split(' '), D = P.length), s.plugin = c, s.setRatio = h, ct.lastIndex = 0, p = 0; p < D; p++) if (m = P[p], x = k[p], ($ = parseFloat(m)) || $ === 0)s.appendXtra('', $, nt(x, $), x.replace(b, ''), O && x.indexOf('px') !== -1, !0); else if (r && ct.test(m))C = x.indexOf(')') + 1, C = ')' + (C ? x.substr(C) : ''), A = x.indexOf('hsl') !== -1 && z, m = st(m, A), x = st(x, A), T = m.length + x.length > 6, T && !z && x[3] === 0 ? (s['xs' + s.l] += s.l ? ' transparent' : 'transparent', s.e = s.e.split(k[p]).join('transparent')) : (z || (T = !1), A ? s.appendXtra(T ? 'hsla(' : 'hsl(', m[0], nt(x[0], m[0]), ',', !1, !0).appendXtra('', m[1], nt(x[1], m[1]), '%,', !1).appendXtra('', m[2], nt(x[2], m[2]), T ? '%,' : '%' + C, !1) : s.appendXtra(T ? 'rgba(' : 'rgb(', m[0], x[0] - m[0], ',', !0, !0).appendXtra('', m[1], x[1] - m[1], ',', !0).appendXtra('', m[2], x[2] - m[2], T ? ',' : C, !0), T && (m = m.length < 4 ? 1 : m[3], s.appendXtra('', m, (x.length < 4 ? 1 : x[3]) - m, C, !1))), ct.lastIndex = 0; else if (w = m.match(y)) { if (!(_ = x.match(b)) || _.length !== w.length) return s; for (f = 0, d = 0; d < w.length; d++)M = w[d], S = m.indexOf(M, f), s.appendXtra(m.substr(f, S - f), Number(M), nt(_[d], M), '', O && m.substr(S + M.length, 2) === 'px', d === 0), f = S + M.length; s['xs' + s.l] += m.substr(f) } else s['xs' + s.l] += s.l || s['xs' + s.l] ? ' ' + x : x; if (i.indexOf('=') !== -1 && s.data) { for (C = s.xs0 + s.data.s, p = 1; p < s.l; p++)C += s['xs' + p] + s.data['xn' + p]; s.e = C + s['xs' + p] } return s.l || (s.type = -1, s.xs0 = s.e), s.xfirst || s }; let gt = 9; for (c = dt.prototype, c.l = c.pr = 0; --gt > 0;)c['xn' + gt] = 0, c['xs' + gt] = ''; c.xs0 = '', c._next = c._prev = c.xfirst = c.data = c.plugin = c.setRatio = c.rxp = null, c.appendXtra = function (t, e, n, i, r, a) { const o = this; const s = o.l; return o['xs' + s] += a && (s || o['xs' + s]) ? ' ' + t : t || '', n || s === 0 || o.plugin ? (o.l++, o.type = o.setRatio ? 2 : 1, o['xs' + o.l] = i || '', s > 0 ? (o.data['xn' + s] = e + n, o.rxp['xn' + s] = r, o['xn' + s] = e, o.plugin || (o.xfirst = new dt(o, 'xn' + s, e, n, o.xfirst || o, 0, o.n, r, o.pr), o.xfirst.xs0 = 0), o) : (o.data = { s: e + n }, o.rxp = {}, o.s = e, o.c = n, o.r = r, o)) : (o['xs' + s] += e + (i || ''), o) }; const vt = function (t, e) { e = e || {}, this.p = e.prefix ? H(t) || t : t, l[t] = l[this.p] = this, this.format = e.formatter || ut(e.defaultValue, e.color, e.collapsible, e.multi), e.parser && (this.parse = e.parser), this.clrs = e.color, this.multi = e.multi, this.keyword = e.keyword, this.dflt = e.defaultValue, this.pr = e.priority || 0 }; const yt = F._registerComplexSpecialProp = function (t, e, n) { typeof e !== 'object' && (e = { parser: n }); let i; const r = t.split(','); const a = e.defaultValue; for (n = n || [a], i = 0; i < r.length; i++)e.prefix = i === 0 && e.prefix, e.defaultValue = n[i] || a, new vt(r[i], e) }; const bt = F._registerPluginProp = function (t) { if (!l[t]) { const e = t.charAt(0).toUpperCase() + t.substr(1) + 'Plugin'; yt(t, { parser: function (t, n, i, r, a, o, c) { const u = s.com.greensock.plugins[e]; return u ? (u._cssRegister(), l[i].parse(t, n, i, r, a, o, c)) : (j(), a) } }) } }; c = vt.prototype, c.parseComplex = function (t, e, n, i, r, a) { let o; let s; let l; let c; let u; let h; const p = this.keyword; if (this.multi && (E.test(n) || E.test(e) ? (s = e.replace(E, '|').split('|'), l = n.replace(E, '|').split('|')) : p && (s = [e], l = [n])), l) { for (c = l.length > s.length ? l.length : s.length, o = 0; o < c; o++)e = s[o] = s[o] || this.dflt, n = l[o] = l[o] || this.dflt, p && (u = e.indexOf(p), h = n.indexOf(p), u !== h && (h === -1 ? s[o] = s[o].split(p).join('') : u === -1 && (s[o] += ' ' + p))); e = s.join(', '), n = l.join(', ') } return mt(t, this.p, e, n, this.clrs, this.dflt, i, this.pr, r, a) }, c.parse = function (t, e, n, i, a, o, s) { return this.parseComplex(t.style, this.format(q(t, this.p, r, !1, this.dflt)), this.format(e), a, o) }, o.registerSpecialProp = function (t, e, n) { yt(t, { parser: function (t, i, r, a, o, s, l) { const c = new dt(t, r, 0, 0, o, 2, r, !1, n); return c.plugin = s, c.setRatio = e(t, i, a._tween, r), c }, priority: n }) }, o.useSVGTransformAttr = !0; let xt; const wt = 'scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent'.split(','); var _t = H('transform'); var $t = V + 'transform'; const Tt = H('transformOrigin'); var St = H('perspective') !== null; const Mt = F.Transform = function () { this.perspective = parseFloat(o.defaultTransformPerspective) || 0, this.force3D = !(!1 === o.defaultForce3D || !St) && (o.defaultForce3D || 'auto') }; const Ct = _gsScope.SVGElement; const Et = function (t, e, n) { let i; const r = L.createElementNS('http://www.w3.org/2000/svg', t); for (i in n)r.setAttributeNS(null, i.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase(), n[i]); return e.appendChild(r), r }; const At = L.documentElement || {}; const Pt = (function () { let t; let e; let n; let i = m || /Android/i.test(U) && !_gsScope.chrome; return L.createElementNS && !i && (t = Et('svg', At), e = Et('rect', t, { width: 100, height: 50, x: 100 }), n = e.getBoundingClientRect().width, e.style[Tt] = '50% 50%', e.style[_t] = 'scaleX(0.5)', i = n === e.getBoundingClientRect().width && !(d && St), At.removeChild(t)), i }()); const kt = function (t, e, n, i, r, a) { let s; let l; let c; let u; let h; let p; let d; let f; let m; let g; let v; let y; let b; let x; let w = t._gsTransform; const _ = Rt(t, !0); w && (b = w.xOrigin, x = w.yOrigin), (!i || (s = i.split(' ')).length < 2) && (d = t.getBBox(), d.x === 0 && d.y === 0 && d.width + d.height === 0 && (d = { x: parseFloat(t.hasAttribute('x') ? t.getAttribute('x') : t.hasAttribute('cx') ? t.getAttribute('cx') : 0) || 0, y: parseFloat(t.hasAttribute('y') ? t.getAttribute('y') : t.hasAttribute('cy') ? t.getAttribute('cy') : 0) || 0, width: 0, height: 0 }), e = et(e).split(' '), s = [(e[0].indexOf('%') !== -1 ? parseFloat(e[0]) / 100 * d.width : parseFloat(e[0])) + d.x, (e[1].indexOf('%') !== -1 ? parseFloat(e[1]) / 100 * d.height : parseFloat(e[1])) + d.y]), n.xOrigin = u = parseFloat(s[0]), n.yOrigin = h = parseFloat(s[1]), i && _ !== It && (p = _[0], d = _[1], f = _[2], m = _[3], g = _[4], v = _[5], (y = p * m - d * f) && (l = u * (m / y) + h * (-f / y) + (f * v - m * g) / y, c = u * (-d / y) + h * (p / y) - (p * v - d * g) / y, u = n.xOrigin = s[0] = l, h = n.yOrigin = s[1] = c)), w && (a && (n.xOffset = w.xOffset, n.yOffset = w.yOffset, w = n), r || !1 !== r && !1 !== o.defaultSmoothOrigin ? (l = u - b, c = h - x, w.xOffset += l * _[0] + c * _[2] - l, w.yOffset += l * _[1] + c * _[3] - c) : w.xOffset = w.yOffset = 0), a || t.setAttribute('data-svg-origin', s.join(' ')) }; const Dt = function (t) { let e; const n = I('svg', this.ownerSVGElement.getAttribute('xmlns') || 'http://www.w3.org/2000/svg'); const i = this.parentNode; const r = this.nextSibling; const a = this.style.cssText; if (At.appendChild(n), n.appendChild(this), this.style.display = 'block', t) try { e = this.getBBox(), this._originalGetBBox = this.getBBox, this.getBBox = Dt } catch (t) {} else this._originalGetBBox && (e = this._originalGetBBox()); return r ? i.insertBefore(this, r) : i.appendChild(this), At.removeChild(n), this.style.cssText = a, e }; const Ot = function (t) { try { return t.getBBox() } catch (e) { return Dt.call(t, !0) } }; var Lt = function (t) { return !(!(Ct && t.getCTM && Ot(t)) || t.parentNode && !t.ownerSVGElement) }; var It = [1, 0, 0, 1, 0, 0]; var Rt = function (t, e) { let n; let i; let r; let a; let o; let s; const l = t._gsTransform || new Mt(); const c = t.style; if (_t ? i = q(t, $t, null, !0) : t.currentStyle && (i = t.currentStyle.filter.match(/(M11|M12|M21|M22)=[\d\-\.e]+/gi), i = i && i.length === 4 ? [i[0].substr(4), Number(i[2].substr(4)), Number(i[1].substr(4)), i[3].substr(4), l.x || 0, l.y || 0].join(',') : ''), n = !i || i === 'none' || i === 'matrix(1, 0, 0, 1, 0, 0)', n && _t && ((s = W(t).display === 'none') || !t.parentNode) && (s && (a = c.display, c.display = 'block'), t.parentNode || (o = 1, At.appendChild(t)), i = q(t, $t, null, !0), n = !i || i === 'none' || i === 'matrix(1, 0, 0, 1, 0, 0)', a ? c.display = a : s && Bt(c, 'display'), o && At.removeChild(t)), (l.svg || t.getCTM && Lt(t)) && (n && (c[_t] + '').indexOf('matrix') !== -1 && (i = c[_t], n = 0), r = t.getAttribute('transform'), n && r && (r.indexOf('matrix') !== -1 ? (i = r, n = 0) : r.indexOf('translate') !== -1 && (i = 'matrix(1,0,0,1,' + r.match(/(?:\-|\b)[\d\-\.e]+\b/gi).join(',') + ')', n = 0))), n) return It; for (r = (i || '').match(y) || [], gt = r.length; --gt > -1;)a = Number(r[gt]), r[gt] = (o = a - (a |= 0)) ? (1e5 * o + (o < 0 ? -0.5 : 0.5) | 0) / 1e5 + a : a; return e && r.length > 6 ? [r[0], r[1], r[4], r[5], r[12], r[13]] : r }; var Nt = F.getTransform = function (t, n, i, r) { if (t._gsTransform && i && !r) return t._gsTransform; let a; let s; let l; let c; let u; let h; const p = i ? t._gsTransform || new Mt() : new Mt(); const d = p.scaleX < 0; const f = St ? parseFloat(q(t, Tt, n, !1, '0 0 0').split(' ')[2]) || p.zOrigin || 0 : 0; const m = parseFloat(o.defaultTransformPerspective) || 0; if (p.svg = !(!t.getCTM || !Lt(t)), p.svg && (kt(t, q(t, Tt, n, !1, '50% 50%') + '', p, t.getAttribute('data-svg-origin')), xt = o.useSVGTransformAttr || Pt), (a = Rt(t)) !== It) { if (a.length === 16) { let g; let v; let y; let b; let x; let w = a[0]; let _ = a[1]; let $ = a[2]; const T = a[3]; let S = a[4]; let M = a[5]; let C = a[6]; const E = a[7]; let A = a[8]; let P = a[9]; let D = a[10]; let O = a[12]; let L = a[13]; let I = a[14]; let R = a[11]; let N = Math.atan2(C, D); p.zOrigin && (I = -p.zOrigin, O = A * I - a[12], L = P * I - a[13], I = D * I + p.zOrigin - a[14]), p.rotationX = N * k, N && (b = Math.cos(-N), x = Math.sin(-N), g = S * b + A * x, v = M * b + P * x, y = C * b + D * x, A = S * -x + A * b, P = M * -x + P * b, D = C * -x + D * b, R = E * -x + R * b, S = g, M = v, C = y), N = Math.atan2(-$, D), p.rotationY = N * k, N && (b = Math.cos(-N), x = Math.sin(-N), g = w * b - A * x, v = _ * b - P * x, y = $ * b - D * x, P = _ * x + P * b, D = $ * x + D * b, R = T * x + R * b, w = g, _ = v, $ = y), N = Math.atan2(_, w), p.rotation = N * k, N && (b = Math.cos(-N), x = Math.sin(-N), w = w * b + S * x, v = _ * b + M * x, M = _ * -x + M * b, C = $ * -x + C * b, _ = v), p.rotationX && Math.abs(p.rotationX) + Math.abs(p.rotation) > 359.9 && (p.rotationX = p.rotation = 0, p.rotationY = 180 - p.rotationY), p.scaleX = (1e5 * Math.sqrt(w * w + _ * _) + 0.5 | 0) / 1e5, p.scaleY = (1e5 * Math.sqrt(M * M + P * P) + 0.5 | 0) / 1e5, p.scaleZ = (1e5 * Math.sqrt(C * C + D * D) + 0.5 | 0) / 1e5, p.rotationX || p.rotationY ? p.skewX = 0 : (p.skewX = S || M ? Math.atan2(S, M) * k + p.rotation : p.skewX || 0, Math.abs(p.skewX) > 90 && Math.abs(p.skewX) < 270 && (d ? (p.scaleX *= -1, p.skewX += p.rotation <= 0 ? 180 : -180, p.rotation += p.rotation <= 0 ? 180 : -180) : (p.scaleY *= -1, p.skewX += p.skewX <= 0 ? 180 : -180))), p.perspective = R ? 1 / (R < 0 ? -R : R) : 0, p.x = O, p.y = L, p.z = I, p.svg && (p.x -= p.xOrigin - (p.xOrigin * w - p.yOrigin * S), p.y -= p.yOrigin - (p.yOrigin * _ - p.xOrigin * M)) } else if (!St || r || !a.length || p.x !== a[4] || p.y !== a[5] || !p.rotationX && !p.rotationY) { const F = a.length >= 6; const U = F ? a[0] : 1; const z = a[1] || 0; const B = a[2] || 0; const j = F ? a[3] : 1; p.x = a[4] || 0, p.y = a[5] || 0, l = Math.sqrt(U * U + z * z), c = Math.sqrt(j * j + B * B), u = U || z ? Math.atan2(z, U) * k : p.rotation || 0, h = B || j ? Math.atan2(B, j) * k + u : p.skewX || 0, Math.abs(h) > 90 && Math.abs(h) < 270 && (d ? (l *= -1, h += u <= 0 ? 180 : -180, u += u <= 0 ? 180 : -180) : (c *= -1, h += h <= 0 ? 180 : -180)), p.scaleX = l, p.scaleY = c, p.rotation = u, p.skewX = h, St && (p.rotationX = p.rotationY = p.z = 0, p.perspective = m, p.scaleZ = 1), p.svg && (p.x -= p.xOrigin - (p.xOrigin * U + p.yOrigin * B), p.y -= p.yOrigin - (p.xOrigin * z + p.yOrigin * j)) }p.zOrigin = f; for (s in p)p[s] < 2e-5 && p[s] > -2e-5 && (p[s] = 0) } return i && (t._gsTransform = p, p.svg && (xt && t.style[_t] ? e.delayedCall(0.001, function () { Bt(t.style, _t) }) : !xt && t.getAttribute('transform') && e.delayedCall(0.001, function () { t.removeAttribute('transform') }))), p }; const Ft = function (t) { let e; let n; const i = this.data; const r = -i.rotation * P; const a = r + i.skewX * P; const o = (Math.cos(r) * i.scaleX * 1e5 | 0) / 1e5; let s = (Math.sin(r) * i.scaleX * 1e5 | 0) / 1e5; let l = (Math.sin(a) * -i.scaleY * 1e5 | 0) / 1e5; const c = (Math.cos(a) * i.scaleY * 1e5 | 0) / 1e5; const u = this.t.style; const h = this.t.currentStyle; if (h) { n = s, s = -l, l = -n, e = h.filter, u.filter = ''; let p; let d; const f = this.t.offsetWidth; const g = this.t.offsetHeight; const v = h.position !== 'absolute'; let y = 'progid:DXImageTransform.Microsoft.Matrix(M11=' + o + ', M12=' + s + ', M21=' + l + ', M22=' + c; let b = i.x + f * i.xPercent / 100; let x = i.y + g * i.yPercent / 100; if (i.ox != null && (p = (i.oxp ? f * i.ox * 0.01 : i.ox) - f / 2, d = (i.oyp ? g * i.oy * 0.01 : i.oy) - g / 2, b += p - (p * o + d * s), x += d - (p * l + d * c)), v ? (p = f / 2, d = g / 2, y += ', Dx=' + (p - (p * o + d * s) + b) + ', Dy=' + (d - (p * l + d * c) + x) + ')') : y += ", sizingMethod='auto expand')", e.indexOf('DXImageTransform.Microsoft.Matrix(') !== -1 ? u.filter = e.replace(/progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i, y) : u.filter = y + ' ' + e, t !== 0 && t !== 1 || o === 1 && s === 0 && l === 0 && c === 1 && (v && y.indexOf('Dx=0, Dy=0') === -1 || $.test(e) && parseFloat(RegExp.$1) !== 100 || e.indexOf(e.indexOf('Alpha')) === -1 && u.removeAttribute('filter')), !v) { let w; let T; let S; const M = m < 8 ? 1 : -1; for (p = i.ieOffsetX || 0, d = i.ieOffsetY || 0, i.ieOffsetX = Math.round((f - ((o < 0 ? -o : o) * f + (s < 0 ? -s : s) * g)) / 2 + b), i.ieOffsetY = Math.round((g - ((c < 0 ? -c : c) * g + (l < 0 ? -l : l) * f)) / 2 + x), gt = 0; gt < 4; gt++)T = Q[gt], w = h[T], n = w.indexOf('px') !== -1 ? parseFloat(w) : X(this.t, T, parseFloat(w), w.replace(_, '')) || 0, S = n !== i[T] ? gt < 2 ? -i.ieOffsetX : -i.ieOffsetY : gt < 2 ? p - i.ieOffsetX : d - i.ieOffsetY, u[T] = (i[T] = Math.round(n - S * (gt === 0 || gt === 2 ? 1 : M))) + 'px' } } }; const Ut = F.set3DTransformRatio = F.setTransformRatio = function (t) { let e; let n; let i; let r; let a; let o; let s; let l; let c; let u; let h; let p; let f; let m; let g; let v; let y; let b; let x; let w; let _; let $; let T; const S = this.data; const M = this.t.style; let C = S.rotation; const E = S.rotationX; const A = S.rotationY; let k = S.scaleX; let D = S.scaleY; let O = S.scaleZ; let L = S.x; let I = S.y; let R = S.z; const N = S.svg; let F = S.perspective; const U = S.force3D; const z = S.skewY; let B = S.skewX; if (z && (B += z, C += z), ((t === 1 || t === 0) && U === 'auto' && (this.tween._totalTime === this.tween._totalDuration || !this.tween._totalTime) || !U) && !R && !F && !A && !E && O === 1 || xt && N || !St) return void (C || B || N ? (C *= P, $ = B * P, T = 1e5, n = Math.cos(C) * k, a = Math.sin(C) * k, i = Math.sin(C - $) * -D, o = Math.cos(C - $) * D, $ && S.skewType === 'simple' && (e = Math.tan($ - z * P), e = Math.sqrt(1 + e * e), i *= e, o *= e, z && (e = Math.tan(z * P), e = Math.sqrt(1 + e * e), n *= e, a *= e)), N && (L += S.xOrigin - (S.xOrigin * n + S.yOrigin * i) + S.xOffset, I += S.yOrigin - (S.xOrigin * a + S.yOrigin * o) + S.yOffset, xt && (S.xPercent || S.yPercent) && (g = this.t.getBBox(), L += 0.01 * S.xPercent * g.width, I += 0.01 * S.yPercent * g.height), g = 1e-6, L < g && L > -g && (L = 0), I < g && I > -g && (I = 0)), x = (n * T | 0) / T + ',' + (a * T | 0) / T + ',' + (i * T | 0) / T + ',' + (o * T | 0) / T + ',' + L + ',' + I + ')', N && xt ? this.t.setAttribute('transform', 'matrix(' + x) : M[_t] = (S.xPercent || S.yPercent ? 'translate(' + S.xPercent + '%,' + S.yPercent + '%) matrix(' : 'matrix(') + x) : M[_t] = (S.xPercent || S.yPercent ? 'translate(' + S.xPercent + '%,' + S.yPercent + '%) matrix(' : 'matrix(') + k + ',0,0,' + D + ',' + L + ',' + I + ')'); if (d && (g = 1e-4, k < g && k > -g && (k = O = 2e-5), D < g && D > -g && (D = O = 2e-5), !F || S.z || S.rotationX || S.rotationY || (F = 0)), C || B)C *= P, v = n = Math.cos(C), y = a = Math.sin(C), B && (C -= B * P, v = Math.cos(C), y = Math.sin(C), S.skewType === 'simple' && (e = Math.tan((B - z) * P), e = Math.sqrt(1 + e * e), v *= e, y *= e, S.skewY && (e = Math.tan(z * P), e = Math.sqrt(1 + e * e), n *= e, a *= e))), i = -y, o = v; else { if (!(A || E || O !== 1 || F || N)) return void (M[_t] = (S.xPercent || S.yPercent ? 'translate(' + S.xPercent + '%,' + S.yPercent + '%) translate3d(' : 'translate3d(') + L + 'px,' + I + 'px,' + R + 'px)' + (k !== 1 || D !== 1 ? ' scale(' + k + ',' + D + ')' : '')); n = o = 1, i = a = 0 }u = 1, r = s = l = c = h = p = 0, f = F ? -1 / F : 0, m = S.zOrigin, g = 1e-6, w = ',', _ = '0', C = A * P, C && (v = Math.cos(C), y = Math.sin(C), l = -y, h = f * -y, r = n * y, s = a * y, u = v, f *= v, n *= v, a *= v), C = E * P, C && (v = Math.cos(C), y = Math.sin(C), e = i * v + r * y, b = o * v + s * y, c = u * y, p = f * y, r = i * -y + r * v, s = o * -y + s * v, u *= v, f *= v, i = e, o = b), O !== 1 && (r *= O, s *= O, u *= O, f *= O), D !== 1 && (i *= D, o *= D, c *= D, p *= D), k !== 1 && (n *= k, a *= k, l *= k, h *= k), (m || N) && (m && (L += r * -m, I += s * -m, R += u * -m + m), N && (L += S.xOrigin - (S.xOrigin * n + S.yOrigin * i) + S.xOffset, I += S.yOrigin - (S.xOrigin * a + S.yOrigin * o) + S.yOffset), L < g && L > -g && (L = _), I < g && I > -g && (I = _), R < g && R > -g && (R = 0)), x = S.xPercent || S.yPercent ? 'translate(' + S.xPercent + '%,' + S.yPercent + '%) matrix3d(' : 'matrix3d(', x += (n < g && n > -g ? _ : n) + w + (a < g && a > -g ? _ : a) + w + (l < g && l > -g ? _ : l), x += w + (h < g && h > -g ? _ : h) + w + (i < g && i > -g ? _ : i) + w + (o < g && o > -g ? _ : o), E || A || O !== 1 ? (x += w + (c < g && c > -g ? _ : c) + w + (p < g && p > -g ? _ : p) + w + (r < g && r > -g ? _ : r), x += w + (s < g && s > -g ? _ : s) + w + (u < g && u > -g ? _ : u) + w + (f < g && f > -g ? _ : f) + w) : x += ',0,0,0,0,1,0,', x += L + w + I + w + R + w + (F ? 1 + -R / F : 1) + ')', M[_t] = x }; c = Mt.prototype, c.x = c.y = c.z = c.skewX = c.skewY = c.rotation = c.rotationX = c.rotationY = c.zOrigin = c.xPercent = c.yPercent = c.xOffset = c.yOffset = 0, c.scaleX = c.scaleY = c.scaleZ = 1, yt('transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin', { parser: function (t, e, n, i, a, s, l) { if (i._lastParsedTransform === l) return a; i._lastParsedTransform = l; let c; const u = l.scale && typeof l.scale === 'function' ? l.scale : 0; typeof l[n] === 'function' && (c = l[n], l[n] = e), u && (l.scale = u(v, t)); let h; let p; let d; let f; let m; let y; let b; let x; let w; const _ = t._gsTransform; const $ = t.style; let T = wt.length; const S = l; const M = {}; const C = Nt(t, r, !0, S.parseTransform); let E = S.transform && (typeof S.transform === 'function' ? S.transform(v, g) : S.transform); if (i._transform = C, E && typeof E === 'string' && _t)p = R.style, p[_t] = E, p.display = 'block', p.position = 'absolute', L.body.appendChild(R), h = Nt(R, null, !1), C.svg && (y = C.xOrigin, b = C.yOrigin, h.x -= C.xOffset, h.y -= C.yOffset, (S.transformOrigin || S.svgOrigin) && (E = {}, kt(t, et(S.transformOrigin), E, S.svgOrigin, S.smoothOrigin, !0), y = E.xOrigin, b = E.yOrigin, h.x -= E.xOffset - C.xOffset, h.y -= E.yOffset - C.yOffset), (y || b) && (x = Rt(R, !0), h.x -= y - (y * x[0] + b * x[2]), h.y -= b - (y * x[1] + b * x[3]))), L.body.removeChild(R), h.perspective || (h.perspective = C.perspective), S.xPercent != null && (h.xPercent = it(S.xPercent, C.xPercent)), S.yPercent != null && (h.yPercent = it(S.yPercent, C.yPercent)); else if (typeof S === 'object') { if (h = { scaleX: it(S.scaleX != null ? S.scaleX : S.scale, C.scaleX), scaleY: it(S.scaleY != null ? S.scaleY : S.scale, C.scaleY), scaleZ: it(S.scaleZ, C.scaleZ), x: it(S.x, C.x), y: it(S.y, C.y), z: it(S.z, C.z), xPercent: it(S.xPercent, C.xPercent), yPercent: it(S.yPercent, C.yPercent), perspective: it(S.transformPerspective, C.perspective) }, (m = S.directionalRotation) != null) if (typeof m === 'object') for (p in m)S[p] = m[p]; else S.rotation = m; typeof S.x === 'string' && S.x.indexOf('%') !== -1 && (h.x = 0, h.xPercent = it(S.x, C.xPercent)), typeof S.y === 'string' && S.y.indexOf('%') !== -1 && (h.y = 0, h.yPercent = it(S.y, C.yPercent)), h.rotation = rt('rotation' in S ? S.rotation : 'shortRotation' in S ? S.shortRotation + '_short' : 'rotationZ' in S ? S.rotationZ : C.rotation, C.rotation, 'rotation', M), St && (h.rotationX = rt('rotationX' in S ? S.rotationX : 'shortRotationX' in S ? S.shortRotationX + '_short' : C.rotationX || 0, C.rotationX, 'rotationX', M), h.rotationY = rt('rotationY' in S ? S.rotationY : 'shortRotationY' in S ? S.shortRotationY + '_short' : C.rotationY || 0, C.rotationY, 'rotationY', M)), h.skewX = rt(S.skewX, C.skewX), h.skewY = rt(S.skewY, C.skewY) } for (St && S.force3D != null && (C.force3D = S.force3D, f = !0), C.skewType = S.skewType || C.skewType || o.defaultSkewType, d = C.force3D || C.z || C.rotationX || C.rotationY || h.z || h.rotationX || h.rotationY || h.perspective, d || S.scale == null || (h.scaleZ = 1); --T > -1;)w = wt[T], ((E = h[w] - C[w]) > 1e-6 || E < -1e-6 || S[w] != null || D[w] != null) && (f = !0, a = new dt(C, w, C[w], E, a), w in M && (a.e = M[w]), a.xs0 = 0, a.plugin = s, i._overwriteProps.push(a.n)); return E = S.transformOrigin, C.svg && (E || S.svgOrigin) && (y = C.xOffset, b = C.yOffset, kt(t, et(E), h, S.svgOrigin, S.smoothOrigin), a = ft(C, 'xOrigin', (_ ? C : h).xOrigin, h.xOrigin, a, 'transformOrigin'), a = ft(C, 'yOrigin', (_ ? C : h).yOrigin, h.yOrigin, a, 'transformOrigin'), y === C.xOffset && b === C.yOffset || (a = ft(C, 'xOffset', _ ? y : C.xOffset, C.xOffset, a, 'transformOrigin'), a = ft(C, 'yOffset', _ ? b : C.yOffset, C.yOffset, a, 'transformOrigin')), E = '0px 0px'), (E || St && d && C.zOrigin) && (_t ? (f = !0, w = Tt, E = (E || q(t, w, r, !1, '50% 50%')) + '', a = new dt($, w, 0, 0, a, -1, 'transformOrigin'), a.b = $[w], a.plugin = s, St ? (p = C.zOrigin, E = E.split(' '), C.zOrigin = (E.length > 2 && (p === 0 || E[2] !== '0px') ? parseFloat(E[2]) : p) || 0, a.xs0 = a.e = E[0] + ' ' + (E[1] || '50%') + ' 0px', a = new dt(C, 'zOrigin', 0, 0, a, -1, a.n), a.b = p, a.xs0 = a.e = C.zOrigin) : a.xs0 = a.e = E) : et(E + '', C)), f && (i._transformType = C.svg && xt || !d && this._transformType !== 3 ? 2 : 3), c && (l[n] = c), u && (l.scale = u), a }, prefix: !0 }), yt('boxShadow', { defaultValue: '0px 0px 0px 0px #999', prefix: !0, color: !0, multi: !0, keyword: 'inset' }), yt('borderRadius', { defaultValue: '0px', parser: function (t, e, n, a, o, s) { e = this.format(e); let l; let c; let u; let h; let p; let d; let f; let m; let g; let v; let y; let b; let x; let w; let _; let $; const T = ['borderTopLeftRadius', 'borderTopRightRadius', 'borderBottomRightRadius', 'borderBottomLeftRadius']; const S = t.style; for (g = parseFloat(t.offsetWidth), v = parseFloat(t.offsetHeight), l = e.split(' '), c = 0; c < T.length; c++) this.p.indexOf('border') && (T[c] = H(T[c])), p = h = q(t, T[c], r, !1, '0px'), p.indexOf(' ') !== -1 && (h = p.split(' '), p = h[0], h = h[1]), d = u = l[c], f = parseFloat(p), b = p.substr((f + '').length), x = d.charAt(1) === '=', x ? (m = parseInt(d.charAt(0) + '1', 10), d = d.substr(2), m *= parseFloat(d), y = d.substr((m + '').length - (m < 0 ? 1 : 0)) || '') : (m = parseFloat(d), y = d.substr((m + '').length)), y === '' && (y = i[n] || b), y !== b && (w = X(t, 'borderLeft', f, b), _ = X(t, 'borderTop', f, b), y === '%' ? (p = w / g * 100 + '%', h = _ / v * 100 + '%') : y === 'em' ? ($ = X(t, 'borderLeft', 1, 'em'), p = w / $ + 'em', h = _ / $ + 'em') : (p = w + 'px', h = _ + 'px'), x && (d = parseFloat(p) + m + y, u = parseFloat(h) + m + y)), o = mt(S, T[c], p + ' ' + h, d + ' ' + u, !1, '0px', o); return o }, prefix: !0, formatter: ut('0px 0px 0px 0px', !1, !0) }), yt('borderBottomLeftRadius,borderBottomRightRadius,borderTopLeftRadius,borderTopRightRadius', { defaultValue: '0px', parser: function (t, e, n, i, a, o) { return mt(t.style, n, this.format(q(t, n, r, !1, '0px 0px')), this.format(e), !1, '0px', a) }, prefix: !0, formatter: ut('0px 0px', !1, !0) }), yt('backgroundPosition', { defaultValue: '0 0', parser: function (t, e, n, i, a, o) { let s; let l; let c; let u; let h; let p; const d = 'background-position'; const f = r || W(t, null); let g = this.format((f ? m ? f.getPropertyValue(d + '-x') + ' ' + f.getPropertyValue(d + '-y') : f.getPropertyValue(d) : t.currentStyle.backgroundPositionX + ' ' + t.currentStyle.backgroundPositionY) || '0 0'); const v = this.format(e); if (g.indexOf('%') !== -1 != (v.indexOf('%') !== -1) && v.split(',').length < 2 && (p = q(t, 'backgroundImage').replace(/(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi, '')) && p !== 'none') { for (s = g.split(' '), l = v.split(' '), N.setAttribute('src', p), c = 2; --c > -1;)g = s[c], (u = g.indexOf('%') !== -1) !== (l[c].indexOf('%') !== -1) && (h = c === 0 ? t.offsetWidth - N.width : t.offsetHeight - N.height, s[c] = u ? parseFloat(g) / 100 * h + 'px' : parseFloat(g) / h * 100 + '%'); g = s.join(' ') } return this.parseComplex(t.style, g, v, a, o) }, formatter: et }), yt('backgroundSize', { defaultValue: '0 0', formatter: function (t) { return t += '', et(t.indexOf(' ') === -1 ? t + ' ' + t : t) } }), yt('perspective', { defaultValue: '0px', prefix: !0 }), yt('perspectiveOrigin', { defaultValue: '50% 50%', prefix: !0 }), yt('transformStyle', { prefix: !0 }), yt('backfaceVisibility', { prefix: !0 }), yt('userSelect', { prefix: !0 }), yt('margin', { parser: ht('marginTop,marginRight,marginBottom,marginLeft') }), yt('padding', { parser: ht('paddingTop,paddingRight,paddingBottom,paddingLeft') }), yt('clip', { defaultValue: 'rect(0px,0px,0px,0px)', parser: function (t, e, n, i, a, o) { let s, l, c; return m < 9 ? (l = t.currentStyle, c = m < 8 ? ' ' : ',', s = 'rect(' + l.clipTop + c + l.clipRight + c + l.clipBottom + c + l.clipLeft + ')', e = this.format(e).split(',').join(c)) : (s = this.format(q(t, this.p, r, !1, this.dflt)), e = this.format(e)), this.parseComplex(t.style, s, e, a, o) } }), yt('textShadow', { defaultValue: '0px 0px 0px #999', color: !0, multi: !0 }), yt('autoRound,strictUnits', { parser: function (t, e, n, i, r) { return r } }), yt('border', { defaultValue: '0px solid #000', parser: function (t, e, n, i, a, o) { let s = q(t, 'borderTopWidth', r, !1, '0px'); const l = this.format(e).split(' '); const c = l[0].replace(_, ''); return c !== 'px' && (s = parseFloat(s) / X(t, 'borderTopWidth', 1, c) + c), this.parseComplex(t.style, this.format(s + ' ' + q(t, 'borderTopStyle', r, !1, 'solid') + ' ' + q(t, 'borderTopColor', r, !1, '#000')), l.join(' '), a, o) }, color: !0, formatter: function (t) { const e = t.split(' '); return e[0] + ' ' + (e[1] || 'solid') + ' ' + (t.match(ct) || ['#000'])[0] } }), yt('borderWidth', { parser: ht('borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth') }), yt('float,cssFloat,styleFloat', { parser: function (t, e, n, i, r, a) { const o = t.style; const s = 'cssFloat' in o ? 'cssFloat' : 'styleFloat'; return new dt(o, s, 0, 0, r, -1, n, !1, 0, o[s], e) } }); const zt = function (t) { let e; const n = this.t; let i = n.filter || q(this.data, 'filter') || ''; const r = this.s + this.c * t | 0; r === 100 && (i.indexOf('atrix(') === -1 && i.indexOf('radient(') === -1 && i.indexOf('oader(') === -1 ? (n.removeAttribute('filter'), e = !q(this.data, 'filter')) : (n.filter = i.replace(/alpha\(opacity *=.+?\)/i, ''), e = !0)), e || (this.xn1 && (n.filter = i = i || 'alpha(opacity=' + r + ')'), i.indexOf('pacity') === -1 ? r === 0 && this.xn1 || (n.filter = i + ' alpha(opacity=' + r + ')') : n.filter = i.replace($, 'opacity=' + r)) }; yt('opacity,alpha,autoAlpha', { defaultValue: '1', parser: function (t, e, n, i, a, o) { let s = parseFloat(q(t, 'opacity', r, !1, '1')); const l = t.style; const c = n === 'autoAlpha'; return typeof e === 'string' && e.charAt(1) === '=' && (e = (e.charAt(0) === '-' ? -1 : 1) * parseFloat(e.substr(2)) + s), c && s === 1 && q(t, 'visibility', r) === 'hidden' && e !== 0 && (s = 0), z ? a = new dt(l, 'opacity', s, e - s, a) : (a = new dt(l, 'opacity', 100 * s, 100 * (e - s), a), a.xn1 = c ? 1 : 0, l.zoom = 1, a.type = 2, a.b = 'alpha(opacity=' + a.s + ')', a.e = 'alpha(opacity=' + (a.s + a.c) + ')', a.data = t, a.plugin = o, a.setRatio = zt), c && (a = new dt(l, 'visibility', 0, 0, a, -1, null, !1, 0, s !== 0 ? 'inherit' : 'hidden', e === 0 ? 'hidden' : 'inherit'), a.xs0 = 'inherit', i._overwriteProps.push(a.n), i._overwriteProps.push(n)), a } }); var Bt = function (t, e) { e && (t.removeProperty ? (e.substr(0, 2) !== 'ms' && e.substr(0, 6) !== 'webkit' || (e = '-' + e), t.removeProperty(e.replace(/([A-Z])/g, '-$1').toLowerCase())) : t.removeAttribute(e)) }; const jt = function (t) {
      if (this.t._gsClassPT = this, t === 1 || t === 0) { this.t.setAttribute('class', t === 0 ? this.b : this.e); for (let e = this.data, n = this.t.style; e;)e.v ? n[e.p] = e.v : Bt(n, e.p), e = e._next; t === 1 && this.t._gsClassPT === this && (this.t._gsClassPT = null) } else this.t.getAttribute('class') !== this.e && this.t.setAttribute('class', this.e)
    }; yt('className', { parser: function (t, e, i, a, o, s, l) { let c; let u; let h; let p; let d; const f = t.getAttribute('class') || ''; const m = t.style.cssText; if (o = a._classNamePT = new dt(t, i, 0, 0, o, 2), o.setRatio = jt, o.pr = -11, n = !0, o.b = f, u = Z(t, r), h = t._gsClassPT) { for (p = {}, d = h.data; d;)p[d.p] = 1, d = d._next; h.setRatio(1) } return t._gsClassPT = o, o.e = e.charAt(1) !== '=' ? e : f.replace(new RegExp('(?:\\s|^)' + e.substr(2) + '(?![\\w-])'), '') + (e.charAt(0) === '+' ? ' ' + e.substr(2) : ''), t.setAttribute('class', o.e), c = K(t, u, Z(t), l, p), t.setAttribute('class', f), o.data = c.firstMPT, t.style.cssText = m, o = o.xfirst = a.parse(t, c.difs, o, s) } }); const Vt = function (t) { if ((t === 1 || t === 0) && this.data._totalTime === this.data._totalDuration && this.data.data !== 'isFromStart') { let e; let n; let i; let r; let a; const o = this.t.style; const s = l.transform.parse; if (this.e === 'all')o.cssText = '', r = !0; else for (e = this.e.split(' ').join('').split(','), i = e.length; --i > -1;)n = e[i], l[n] && (l[n].parse === s ? r = !0 : n = n === 'transformOrigin' ? Tt : l[n].p), Bt(o, n); r && (Bt(o, _t), (a = this.t._gsTransform) && (a.svg && (this.t.removeAttribute('data-svg-origin'), this.t.removeAttribute('transform')), delete this.t._gsTransform)) } }; for (yt('clearProps', { parser: function (t, e, i, r, a) { return a = new dt(t, i, 0, 0, a, 2), a.setRatio = Vt, a.e = e, a.pr = -10, a.data = r._tween, n = !0, a } }), c = 'bezier,throwProps,physicsProps,physics2D'.split(','), gt = c.length; gt--;)bt(c[gt]); c = o.prototype, c._firstPT = c._lastParsedTransform = c._transform = null, c._onInitTween = function (t, e, s, c) { if (!t.nodeType) return !1; this._target = g = t, this._tween = s, this._vars = e, v = c, u = e.autoRound, n = !1, i = e.suffixMap || o.suffixMap, r = W(t, ''), a = this._overwriteProps; let d; let m; let y; let b; let x; let w; let _; let $; let S; const M = t.style; if (h && M.zIndex === '' && ((d = q(t, 'zIndex', r)) !== 'auto' && d !== '' || this._addLazySet(M, 'zIndex', 0)), typeof e === 'string' && (b = M.cssText, d = Z(t, r), M.cssText = b + ';' + e, d = K(t, d, Z(t)).difs, !z && T.test(e) && (d.opacity = parseFloat(RegExp.$1)), e = d, M.cssText = b), e.className ? this._firstPT = m = l.className.parse(t, e.className, 'className', this, null, null, e) : this._firstPT = m = this.parse(t, e, null), this._transformType) { for (S = this._transformType === 3, _t ? p && (h = !0, M.zIndex === '' && ((_ = q(t, 'zIndex', r)) !== 'auto' && _ !== '' || this._addLazySet(M, 'zIndex', 0)), f && this._addLazySet(M, 'WebkitBackfaceVisibility', this._vars.WebkitBackfaceVisibility || (S ? 'visible' : 'hidden'))) : M.zoom = 1, y = m; y && y._next;)y = y._next; $ = new dt(t, 'transform', 0, 0, null, 2), this._linkCSSP($, null, y), $.setRatio = _t ? Ut : Ft, $.data = this._transform || Nt(t, r, !0), $.tween = s, $.pr = -1, a.pop() } if (n) { for (;m;) { for (w = m._next, y = b; y && y.pr > m.pr;)y = y._next; (m._prev = y ? y._prev : x) ? m._prev._next = m : b = m, (m._next = y) ? y._prev = m : x = m, m = w } this._firstPT = b } return !0 }, c.parse = function (t, e, n, a) { let o; let s; let c; let h; let p; let d; let f; let m; let y; let b; const x = t.style; for (o in e)d = e[o], typeof d === 'function' && (d = d(v, g)), s = l[o], s ? n = s.parse(t, d, o, this, n, a, e) : (p = q(t, o, r) + '', y = typeof d === 'string', o === 'color' || o === 'fill' || o === 'stroke' || o.indexOf('Color') !== -1 || y && S.test(d) ? (y || (d = st(d), d = (d.length > 3 ? 'rgba(' : 'rgb(') + d.join(',') + ')'), n = mt(x, o, p, d, !0, 'transparent', n, 0, a)) : y && A.test(d) ? n = mt(x, o, p, d, !0, null, n, 0, a) : (c = parseFloat(p), f = c || c === 0 ? p.substr((c + '').length) : '', p !== '' && p !== 'auto' || (o === 'width' || o === 'height' ? (c = tt(t, o, r), f = 'px') : o === 'left' || o === 'top' ? (c = Y(t, o, r), f = 'px') : (c = o !== 'opacity' ? 0 : 1, f = '')), b = y && d.charAt(1) === '=', b ? (h = parseInt(d.charAt(0) + '1', 10), d = d.substr(2), h *= parseFloat(d), m = d.replace(_, '')) : (h = parseFloat(d), m = y ? d.replace(_, '') : ''), m === '' && (m = o in i ? i[o] : f), d = h || h === 0 ? (b ? h + c : h) + m : e[o], f !== m && m !== '' && (h || h === 0) && c && (c = X(t, o, c, f), m === '%' ? (c /= X(t, o, 100, '%') / 100, !0 !== e.strictUnits && (p = c + '%')) : m === 'em' || m === 'rem' || m === 'vw' || m === 'vh' ? c /= X(t, o, 1, m) : m !== 'px' && (h = X(t, o, h, m), m = 'px'), b && (h || h === 0) && (d = h + c + m)), b && (h += c), !c && c !== 0 || !h && h !== 0 ? void 0 !== x[o] && (d || d + '' != 'NaN' && d != null) ? (n = new dt(x, o, h || c || 0, 0, n, -1, o, !1, 0, p, d), n.xs0 = d !== 'none' || o !== 'display' && o.indexOf('Style') === -1 ? d : p) : j(e[o]) : (n = new dt(x, o, c, h - c, n, 0, o, !1 !== u && (m === 'px' || o === 'zIndex'), 0, p, d), n.xs0 = m))), a && n && !n.plugin && (n.plugin = a); return n }, c.setRatio = function (t) { let e; let n; let i; let r = this._firstPT; if (t !== 1 || this._tween._time !== this._tween._duration && this._tween._time !== 0) if (t || this._tween._time !== this._tween._duration && this._tween._time !== 0 || this._tween._rawPrevTime === -1e-6) for (;r;) { if (e = r.c * t + r.s, r.r ? e = Math.round(e) : e < 1e-6 && e > -1e-6 && (e = 0), r.type) if (r.type === 1) if ((i = r.l) === 2)r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2; else if (i === 3)r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3; else if (i === 4)r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3 + r.xn3 + r.xs4; else if (i === 5)r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3 + r.xn3 + r.xs4 + r.xn4 + r.xs5; else { for (n = r.xs0 + e + r.xs1, i = 1; i < r.l; i++)n += r['xn' + i] + r['xs' + (i + 1)]; r.t[r.p] = n } else r.type === -1 ? r.t[r.p] = r.xs0 : r.setRatio && r.setRatio(t); else r.t[r.p] = e + r.xs0; r = r._next } else for (;r;)r.type !== 2 ? r.t[r.p] = r.b : r.setRatio(t), r = r._next; else for (;r;) { if (r.type !== 2) if (r.r && r.type !== -1) if (e = Math.round(r.s + r.c), r.type) { if (r.type === 1) { for (i = r.l, n = r.xs0 + e + r.xs1, i = 1; i < r.l; i++)n += r['xn' + i] + r['xs' + (i + 1)]; r.t[r.p] = n } } else r.t[r.p] = e + r.xs0; else r.t[r.p] = r.e; else r.setRatio(t); r = r._next } }, c._enableTransforms = function (t) { this._transform = this._transform || Nt(this._target, r, !0), this._transformType = this._transform.svg && xt || !t && this._transformType !== 3 ? 2 : 3 }; const Gt = function (t) { this.t[this.p] = this.e, this.data._linkCSSP(this, this._next, null, !0) }; c._addLazySet = function (t, e, n) { const i = this._firstPT = new dt(t, e, 0, 0, this._firstPT, 2); i.e = n, i.setRatio = Gt, i.data = this }, c._linkCSSP = function (t, e, n, i) { return t && (e && (e._prev = t), t._next && (t._next._prev = t._prev), t._prev ? t._prev._next = t._next : this._firstPT === t && (this._firstPT = t._next, i = !0), n ? n._next = t : i || this._firstPT !== null || (this._firstPT = t), t._next = e, t._prev = n), t }, c._mod = function (t) { for (let e = this._firstPT; e;) typeof t[e.p] === 'function' && t[e.p] === Math.round && (e.r = 1), e = e._next }, c._kill = function (e) { let n; let i; let r; let a = e; if (e.autoAlpha || e.alpha) { a = {}; for (i in e)a[i] = e[i]; a.opacity = 1, a.autoAlpha && (a.visibility = 1) } for (e.className && (n = this._classNamePT) && (r = n.xfirst, r && r._prev ? this._linkCSSP(r._prev, n._next, r._prev._prev) : r === this._firstPT && (this._firstPT = n._next), n._next && this._linkCSSP(n._next, n._next._next, r._prev), this._classNamePT = null), n = this._firstPT; n;)n.plugin && n.plugin !== i && n.plugin._kill && (n.plugin._kill(e), i = n.plugin), n = n._next; return t.prototype._kill.call(this, a) }; const Ht = function (t, e, n) { let i, r, a, o; if (t.slice) for (r = t.length; --r > -1;)Ht(t[r], e, n); else for (i = t.childNodes, r = i.length; --r > -1;)a = i[r], o = a.type, a.style && (e.push(Z(a)), n && n.push(a)), o !== 1 && o !== 9 && o !== 11 || !a.childNodes.length || Ht(a, e, n) }; return o.cascadeTo = function (t, n, i) { let r; let a; let o; let s; const l = e.to(t, n, i); const c = [l]; const u = []; const h = []; const p = []; const d = e._internals.reservedProps; for (t = l._targets || l.target, Ht(t, u, p), l.render(n, !0, !0), Ht(t, h), l.render(0, !0, !0), l._enabled(!0), r = p.length; --r > -1;) if (a = K(p[r], u[r], h[r]), a.firstMPT) { a = a.difs; for (o in i)d[o] && (a[o] = i[o]); s = {}; for (o in a)s[o] = u[r][o]; c.push(e.fromTo(p[r], n, s, a)) } return c }, t.activate([o]), o
  }, !0), (function () { const t = _gsScope._gsDefine.plugin({ propName: 'roundProps', version: '1.6.0', priority: -1, API: 2, init: function (t, e, n) { return this._tween = n, !0 } }); const e = function (t) { for (;t;)t.f || t.blob || (t.m = Math.round), t = t._next }; const n = t.prototype; n._onInitAllProps = function () { for (var t, n, i, r = this._tween, a = r.vars.roundProps.join ? r.vars.roundProps : r.vars.roundProps.split(','), o = a.length, s = {}, l = r._propLookup.roundProps; --o > -1;)s[a[o]] = Math.round; for (o = a.length; --o > -1;) for (t = a[o], n = r._firstPT; n;)i = n._next, n.pg ? n.t._mod(s) : n.n === t && (n.f === 2 && n.t ? e(n.t._firstPT) : (this._add(n.t, t, n.s, n.c), i && (i._prev = n._prev), n._prev ? n._prev._next = i : r._firstPT === n && (r._firstPT = i), n._next = n._prev = null, r._propLookup[t] = l)), n = i; return !1 }, n._add = function (t, e, n, i) { this._addTween(t, e, n, n + i, e, Math.round), this._overwriteProps.push(e) } }()), (function () { _gsScope._gsDefine.plugin({ propName: 'attr', API: 2, version: '0.6.0', init: function (t, e, n, i) { let r, a; if (typeof t.setAttribute !== 'function') return !1; for (r in e)a = e[r], typeof a === 'function' && (a = a(i, t)), this._addTween(t, 'setAttribute', t.getAttribute(r) + '', a + '', r, !1, r), this._overwriteProps.push(r); return !0 } }) }()), _gsScope._gsDefine.plugin({ propName: 'directionalRotation', version: '0.3.0', API: 2, init: function (t, e, n, i) { typeof e !== 'object' && (e = { rotation: e }), this.finals = {}; let r; let a; let o; let s; let l; let c; const u = !0 === e.useRadians ? 2 * Math.PI : 360; for (r in e)r !== 'useRadians' && (s = e[r], typeof s === 'function' && (s = s(i, t)), c = (s + '').split('_'), a = c[0], o = parseFloat(typeof t[r] !== 'function' ? t[r] : t[r.indexOf('set') || typeof t['get' + r.substr(3)] !== 'function' ? r : 'get' + r.substr(3)]()), s = this.finals[r] = typeof a === 'string' && a.charAt(1) === '=' ? o + parseInt(a.charAt(0) + '1', 10) * Number(a.substr(2)) : Number(a) || 0, l = s - o, c.length && (a = c.join('_'), a.indexOf('short') !== -1 && (l %= u) !== l % (u / 2) && (l = l < 0 ? l + u : l - u), a.indexOf('_cw') !== -1 && l < 0 ? l = (l + 9999999999 * u) % u - (l / u | 0) * u : a.indexOf('ccw') !== -1 && l > 0 && (l = (l - 9999999999 * u) % u - (l / u | 0) * u)), (l > 1e-6 || l < -1e-6) && (this._addTween(t, r, o, o + l, r), this._overwriteProps.push(r))); return !0 }, set: function (t) { let e; if (t !== 1) this._super.setRatio.call(this, t); else for (e = this._firstPT; e;)e.f ? e.t[e.p](this.finals[e.p]) : e.t[e.p] = this.finals[e.p], e = e._next } })._autoCSS = !0, _gsScope._gsDefine('easing.Back', ['easing.Ease'], function (t) { let e; let n; let i; const r = _gsScope.GreenSockGlobals || _gsScope; const a = r.com.greensock; const o = 2 * Math.PI; const s = Math.PI / 2; const l = a._class; const c = function (e, n) { const i = l('easing.' + e, function () {}, !0); const r = i.prototype = new t(); return r.constructor = i, r.getRatio = n, i }; const u = t.register || function () {}; const h = function (t, e, n, i, r) { const a = l('easing.' + t, { easeOut: new e(), easeIn: new n(), easeInOut: new i() }, !0); return u(a, t), a }; const p = function (t, e, n) { this.t = t, this.v = e, n && (this.next = n, n.prev = this, this.c = n.v - e, this.gap = n.t - t) }; const d = function (e, n) { const i = l('easing.' + e, function (t) { this._p1 = t || t === 0 ? t : 1.70158, this._p2 = 1.525 * this._p1 }, !0); const r = i.prototype = new t(); return r.constructor = i, r.getRatio = n, r.config = function (t) { return new i(t) }, i }; const f = h('Back', d('BackOut', function (t) { return (t -= 1) * t * ((this._p1 + 1) * t + this._p1) + 1 }), d('BackIn', function (t) { return t * t * ((this._p1 + 1) * t - this._p1) }), d('BackInOut', function (t) { return (t *= 2) < 1 ? 0.5 * t * t * ((this._p2 + 1) * t - this._p2) : 0.5 * ((t -= 2) * t * ((this._p2 + 1) * t + this._p2) + 2) })); const m = l('easing.SlowMo', function (t, e, n) { e = e || e === 0 ? e : 0.7, t == null ? t = 0.7 : t > 1 && (t = 1), this._p = t !== 1 ? e : 0, this._p1 = (1 - t) / 2, this._p2 = t, this._p3 = this._p1 + this._p2, this._calcEnd = !0 === n }, !0); let g = m.prototype = new t(); return g.constructor = m, g.getRatio = function (t) { const e = t + (0.5 - t) * this._p; return t < this._p1 ? this._calcEnd ? 1 - (t = 1 - t / this._p1) * t : e - (t = 1 - t / this._p1) * t * t * t * e : t > this._p3 ? this._calcEnd ? 1 - (t = (t - this._p3) / this._p1) * t : e + (t - e) * (t = (t - this._p3) / this._p1) * t * t * t : this._calcEnd ? 1 : e }, m.ease = new m(0.7, 0.7), g.config = m.config = function (t, e, n) { return new m(t, e, n) }, e = l('easing.SteppedEase', function (t) { t = t || 1, this._p1 = 1 / t, this._p2 = t + 1 }, !0), g = e.prototype = new t(), g.constructor = e, g.getRatio = function (t) { return t < 0 ? t = 0 : t >= 1 && (t = 0.999999999), (this._p2 * t >> 0) * this._p1 }, g.config = e.config = function (t) { return new e(t) }, n = l('easing.RoughEase', function (e) { e = e || {}; for (var n, i, r, a, o, s, l = e.taper || 'none', c = [], u = 0, h = 0 | (e.points || 20), d = h, f = !1 !== e.randomize, m = !0 === e.clamp, g = e.template instanceof t ? e.template : null, v = typeof e.strength === 'number' ? 0.4 * e.strength : 0.4; --d > -1;)n = f ? Math.random() : 1 / h * d, i = g ? g.getRatio(n) : n, l === 'none' ? r = v : l === 'out' ? (a = 1 - n, r = a * a * v) : l === 'in' ? r = n * n * v : n < 0.5 ? (a = 2 * n, r = a * a * 0.5 * v) : (a = 2 * (1 - n), r = a * a * 0.5 * v), f ? i += Math.random() * r - 0.5 * r : d % 2 ? i += 0.5 * r : i -= 0.5 * r, m && (i > 1 ? i = 1 : i < 0 && (i = 0)), c[u++] = { x: n, y: i }; for (c.sort(function (t, e) { return t.x - e.x }), s = new p(1, 1, null), d = h; --d > -1;)o = c[d], s = new p(o.x, o.y, s); this._prev = new p(0, 0, s.t !== 0 ? s : s.next) }, !0), g = n.prototype = new t(), g.constructor = n, g.getRatio = function (t) { let e = this._prev; if (t > e.t) { for (;e.next && t >= e.t;)e = e.next; e = e.prev } else for (;e.prev && t <= e.t;)e = e.prev; return this._prev = e, e.v + (t - e.t) / e.gap * e.c }, g.config = function (t) { return new n(t) }, n.ease = new n(), h('Bounce', c('BounceOut', function (t) { return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375 : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375 }), c('BounceIn', function (t) { return (t = 1 - t) < 1 / 2.75 ? 1 - 7.5625 * t * t : t < 2 / 2.75 ? 1 - (7.5625 * (t -= 1.5 / 2.75) * t + 0.75) : t < 2.5 / 2.75 ? 1 - (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) : 1 - (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375) }), c('BounceInOut', function (t) { const e = t < 0.5; return t = e ? 1 - 2 * t : 2 * t - 1, t < 1 / 2.75 ? t *= 7.5625 * t : t = t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375 : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375, e ? 0.5 * (1 - t) : 0.5 * t + 0.5 })), h('Circ', c('CircOut', function (t) { return Math.sqrt(1 - (t -= 1) * t) }), c('CircIn', function (t) { return -(Math.sqrt(1 - t * t) - 1) }), c('CircInOut', function (t) { return (t *= 2) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1) })), i = function (e, n, i) { const r = l('easing.' + e, function (t, e) { this._p1 = t >= 1 ? t : 1, this._p2 = (e || i) / (t < 1 ? t : 1), this._p3 = this._p2 / o * (Math.asin(1 / this._p1) || 0), this._p2 = o / this._p2 }, !0); const a = r.prototype = new t(); return a.constructor = r, a.getRatio = n, a.config = function (t, e) { return new r(t, e) }, r }, h('Elastic', i('ElasticOut', function (t) { return this._p1 * Math.pow(2, -10 * t) * Math.sin((t - this._p3) * this._p2) + 1 }, 0.3), i('ElasticIn', function (t) { return -this._p1 * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - this._p3) * this._p2) }, 0.3), i('ElasticInOut', function (t) { return (t *= 2) < 1 ? this._p1 * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - this._p3) * this._p2) * -0.5 : this._p1 * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - this._p3) * this._p2) * 0.5 + 1 }, 0.45)), h('Expo', c('ExpoOut', function (t) { return 1 - Math.pow(2, -10 * t) }), c('ExpoIn', function (t) { return Math.pow(2, 10 * (t - 1)) - 0.001 }), c('ExpoInOut', function (t) { return (t *= 2) < 1 ? 0.5 * Math.pow(2, 10 * (t - 1)) : 0.5 * (2 - Math.pow(2, -10 * (t - 1))) })), h('Sine', c('SineOut', function (t) { return Math.sin(t * s) }), c('SineIn', function (t) { return 1 - Math.cos(t * s) }), c('SineInOut', function (t) { return -0.5 * (Math.cos(Math.PI * t) - 1) })), l('easing.EaseLookup', { find: function (e) { return t.map[e] } }, !0), u(r.SlowMo, 'SlowMo', 'ease,'), u(n, 'RoughEase', 'ease,'), u(e, 'SteppedEase', 'ease,'), f }, !0)
}), _gsScope._gsDefine && _gsScope._gsQueue.pop()(), (function (t, e) {
  'use strict'; const n = {}; const i = t.document; const r = t.GreenSockGlobals = t.GreenSockGlobals || t; if (!r.TweenLite) {
    let a; let o; let s; let l; let c; const u = function (t) { let e; const n = t.split('.'); let i = r; for (e = 0; e < n.length; e++)i[n[e]] = i = i[n[e]] || {}; return i }; const h = u('com.greensock'); const p = function (t) { let e; const n = []; const i = t.length; for (e = 0; e !== i; n.push(t[e++]));return n }; const d = function () {}; const f = (function () { const t = Object.prototype.toString; const e = t.call([]); return function (n) { return n != null && (n instanceof Array || typeof n === 'object' && !!n.push && t.call(n) === e) } }()); const m = {}; const g = function (e, i, a, o) { this.sc = m[e] ? m[e].sc : [], m[e] = this, this.gsClass = null, this.func = a; const s = []; this.check = function (l) { for (var c, h, p, d, f, v = i.length, y = v; --v > -1;)(c = m[i[v]] || new g(i[v], [])).gsClass ? (s[v] = c.gsClass, y--) : l && c.sc.push(this); if (y === 0 && a) { if (h = ('com.greensock.' + e).split('.'), p = h.pop(), d = u(h.join('.'))[p] = this.gsClass = a.apply(a, s), o) if (r[p] = n[p] = d, !(f = typeof module !== 'undefined' && module.exports) && typeof define === 'function' && define.amd)define((t.GreenSockAMDPath ? t.GreenSockAMDPath + '/' : '') + e.split('.').pop(), [], function () { return d }); else if (f) if (e === 'TweenMax') { module.exports = n.TweenMax = d; for (v in n)d[v] = n[v] } else n.TweenMax && (n.TweenMax[p] = d); for (v = 0; v < this.sc.length; v++) this.sc[v].check() } }, this.check(!0) }; const v = t._gsDefine = function (t, e, n, i) { return new g(t, e, n, i) }; const y = h._class = function (t, e, n) { return e = e || function () {}, v(t, [], function () { return e }, n), e }; v.globals = r; const b = [0, 0, 1, 1]; const x = y('easing.Ease', function (t, e, n, i) { this._func = t, this._type = n || 0, this._power = i || 0, this._params = e ? b.concat(e) : b }, !0); const w = x.map = {}; const _ = x.register = function (t, e, n, i) { for (var r, a, o, s, l = e.split(','), c = l.length, u = (n || 'easeIn,easeOut,easeInOut').split(','); --c > -1;) for (a = l[c], r = i ? y('easing.' + a, null, !0) : h.easing[a] || {}, o = u.length; --o > -1;)s = u[o], w[a + '.' + s] = w[s + a] = r[s] = t.getRatio ? t : t[s] || new t() }; for (s = x.prototype, s._calcEnd = !1, s.getRatio = function (t) { if (this._func) return this._params[0] = t, this._func.apply(null, this._params); const e = this._type; const n = this._power; let i = e === 1 ? 1 - t : e === 2 ? t : t < 0.5 ? 2 * t : 2 * (1 - t); return n === 1 ? i *= i : n === 2 ? i *= i * i : n === 3 ? i *= i * i * i : n === 4 && (i *= i * i * i * i), e === 1 ? 1 - i : e === 2 ? i : t < 0.5 ? i / 2 : 1 - i / 2 }, a = ['Linear', 'Quad', 'Cubic', 'Quart', 'Quint,Strong'], o = a.length; --o > -1;)s = a[o] + ',Power' + o, _(new x(null, null, 1, o), s, 'easeOut', !0), _(new x(null, null, 2, o), s, 'easeIn' + (o === 0 ? ',easeNone' : '')), _(new x(null, null, 3, o), s, 'easeInOut'); w.linear = h.easing.Linear.easeIn, w.swing = h.easing.Quad.easeInOut; const $ = y('events.EventDispatcher', function (t) { this._listeners = {}, this._eventTarget = t || this }); s = $.prototype, s.addEventListener = function (t, e, n, i, r) { r = r || 0; let a; let o; let s = this._listeners[t]; let u = 0; for (this !== l || c || l.wake(), s == null && (this._listeners[t] = s = []), o = s.length; --o > -1;)a = s[o], a.c === e && a.s === n ? s.splice(o, 1) : u === 0 && a.pr < r && (u = o + 1); s.splice(u, 0, { c: e, s: n, up: i, pr: r }) }, s.removeEventListener = function (t, e) { let n; const i = this._listeners[t]; if (i) for (n = i.length; --n > -1;) if (i[n].c === e) return void i.splice(n, 1) }, s.dispatchEvent = function (t) { let e; let n; let i; let r = this._listeners[t]; if (r) for (e = r.length, e > 1 && (r = r.slice(0)), n = this._eventTarget; --e > -1;)(i = r[e]) && (i.up ? i.c.call(i.s || n, { type: t, target: n }) : i.c.call(i.s || n)) }; let T = t.requestAnimationFrame; let S = t.cancelAnimationFrame; const M = Date.now || function () { return (new Date()).getTime() }; let C = M(); for (a = ['ms', 'moz', 'webkit', 'o'], o = a.length; --o > -1 && !T;)T = t[a[o] + 'RequestAnimationFrame'], S = t[a[o] + 'CancelAnimationFrame'] || t[a[o] + 'CancelRequestAnimationFrame']; y('Ticker', function (t, e) { let n; let r; let a; let o; let s; const u = this; let h = M(); let p = !(!1 === e || !T) && 'auto'; let f = 500; let m = 33; const g = function (t) { let e; let i; const l = M() - C; l > f && (h += l - m), C += l, u.time = (C - h) / 1e3, e = u.time - s, (!n || e > 0 || !0 === t) && (u.frame++, s += e + (e >= o ? 0.004 : o - e), i = !0), !0 !== t && (a = r(g)), i && u.dispatchEvent('tick') }; $.call(u), u.time = u.frame = 0, u.tick = function () { g(!0) }, u.lagSmoothing = function (t, e) { f = t || 1e10, m = Math.min(e, f, 0) }, u.sleep = function () { a != null && (p && S ? S(a) : clearTimeout(a), r = d, a = null, u === l && (c = !1)) }, u.wake = function (t) { a !== null ? u.sleep() : t ? h += -C + (C = M()) : u.frame > 10 && (C = M() - f + 5), r = n === 0 ? d : p && T ? T : function (t) { return setTimeout(t, 1e3 * (s - u.time) + 1 | 0) }, u === l && (c = !0), g(2) }, u.fps = function (t) { if (!arguments.length) return n; n = t, o = 1 / (n || 60), s = this.time + o, u.wake() }, u.useRAF = function (t) { if (!arguments.length) return p; u.sleep(), p = t, u.fps(n) }, u.fps(t), setTimeout(function () { p === 'auto' && u.frame < 5 && i.visibilityState !== 'hidden' && u.useRAF(!1) }, 1500) }), s = h.Ticker.prototype = new h.events.EventDispatcher(), s.constructor = h.Ticker; const E = y('core.Animation', function (t, e) { if (this.vars = e = e || {}, this._duration = this._totalDuration = t || 0, this._delay = Number(e.delay) || 0, this._timeScale = 1, this._active = !0 === e.immediateRender, this.data = e.data, this._reversed = !0 === e.reversed, q) { c || l.wake(); const n = this.vars.useFrames ? W : q; n.add(this, n._time), this.vars.paused && this.paused(!0) } }); l = E.ticker = new h.Ticker(), s = E.prototype, s._dirty = s._gc = s._initted = s._paused = !1, s._totalTime = s._time = 0, s._rawPrevTime = -1, s._next = s._last = s._onUpdate = s._timeline = s.timeline = null, s._paused = !1; const A = function () { c && M() - C > 2e3 && l.wake(), setTimeout(A, 2e3) }; A(), s.play = function (t, e) { return t != null && this.seek(t, e), this.reversed(!1).paused(!1) }, s.pause = function (t, e) { return t != null && this.seek(t, e), this.paused(!0) }, s.resume = function (t, e) { return t != null && this.seek(t, e), this.paused(!1) }, s.seek = function (t, e) { return this.totalTime(Number(t), !1 !== e) }, s.restart = function (t, e) { return this.reversed(!1).paused(!1).totalTime(t ? -this._delay : 0, !1 !== e, !0) }, s.reverse = function (t, e) { return t != null && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1) }, s.render = function (t, e, n) {}, s.invalidate = function () { return this._time = this._totalTime = 0, this._initted = this._gc = !1, this._rawPrevTime = -1, !this._gc && this.timeline || this._enabled(!0), this }, s.isActive = function () { let t; const e = this._timeline; const n = this._startTime; return !e || !this._gc && !this._paused && e.isActive() && (t = e.rawTime(!0)) >= n && t < n + this.totalDuration() / this._timeScale }, s._enabled = function (t, e) { return c || l.wake(), this._gc = !t, this._active = this.isActive(), !0 !== e && (t && !this.timeline ? this._timeline.add(this, this._startTime - this._delay) : !t && this.timeline && this._timeline._remove(this, !0)), !1 }, s._kill = function (t, e) { return this._enabled(!1, !1) }, s.kill = function (t, e) { return this._kill(t, e), this }, s._uncache = function (t) { for (let e = t ? this : this.timeline; e;)e._dirty = !0, e = e.timeline; return this }, s._swapSelfInParams = function (t) { for (var e = t.length, n = t.concat(); --e > -1;)t[e] === '{self}' && (n[e] = this); return n }, s._callback = function (t) { const e = this.vars; const n = e[t]; const i = e[t + 'Params']; const r = e[t + 'Scope'] || e.callbackScope || this; switch (i ? i.length : 0) { case 0:n.call(r); break; case 1:n.call(r, i[0]); break; case 2:n.call(r, i[0], i[1]); break; default:n.apply(r, i) } }, s.eventCallback = function (t, e, n, i) { if ((t || '').substr(0, 2) === 'on') { const r = this.vars; if (arguments.length === 1) return r[t]; e == null ? delete r[t] : (r[t] = e, r[t + 'Params'] = f(n) && n.join('').indexOf('{self}') !== -1 ? this._swapSelfInParams(n) : n, r[t + 'Scope'] = i), t === 'onUpdate' && (this._onUpdate = e) } return this }, s.delay = function (t) { return arguments.length ? (this._timeline.smoothChildTiming && this.startTime(this._startTime + t - this._delay), this._delay = t, this) : this._delay }, s.duration = function (t) { return arguments.length ? (this._duration = this._totalDuration = t, this._uncache(!0), this._timeline.smoothChildTiming && this._time > 0 && this._time < this._duration && t !== 0 && this.totalTime(this._totalTime * (t / this._duration), !0), this) : (this._dirty = !1, this._duration) }, s.totalDuration = function (t) { return this._dirty = !1, arguments.length ? this.duration(t) : this._totalDuration }, s.time = function (t, e) { return arguments.length ? (this._dirty && this.totalDuration(), this.totalTime(t > this._duration ? this._duration : t, e)) : this._time }, s.totalTime = function (t, e, n) { if (c || l.wake(), !arguments.length) return this._totalTime; if (this._timeline) { if (t < 0 && !n && (t += this.totalDuration()), this._timeline.smoothChildTiming) { this._dirty && this.totalDuration(); const i = this._totalDuration; let r = this._timeline; if (t > i && !n && (t = i), this._startTime = (this._paused ? this._pauseTime : r._time) - (this._reversed ? i - t : t) / this._timeScale, r._dirty || this._uncache(!1), r._timeline) for (;r._timeline;)r._timeline._time !== (r._startTime + r._totalTime) / r._timeScale && r.totalTime(r._totalTime, !0), r = r._timeline } this._gc && this._enabled(!0, !1), this._totalTime === t && this._duration !== 0 || (L.length && Y(), this.render(t, e, !1), L.length && Y()) } return this }, s.progress = s.totalProgress = function (t, e) { const n = this.duration(); return arguments.length ? this.totalTime(n * t, e) : n ? this._time / n : this.ratio }, s.startTime = function (t) { return arguments.length ? (t !== this._startTime && (this._startTime = t, this.timeline && this.timeline._sortChildren && this.timeline.add(this, t - this._delay)), this) : this._startTime }, s.endTime = function (t) { return this._startTime + (t != 0 ? this.totalDuration() : this.duration()) / this._timeScale }, s.timeScale = function (t) { if (!arguments.length) return this._timeScale; if (t = t || 1e-10, this._timeline && this._timeline.smoothChildTiming) { const e = this._pauseTime; const n = e || e === 0 ? e : this._timeline.totalTime(); this._startTime = n - (n - this._startTime) * this._timeScale / t } return this._timeScale = t, this._uncache(!1) }, s.reversed = function (t) { return arguments.length ? (t != this._reversed && (this._reversed = t, this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, !0)), this) : this._reversed }, s.paused = function (t) { if (!arguments.length) return this._paused; let e; let n; const i = this._timeline; return t != this._paused && i && (c || t || l.wake(), e = i.rawTime(), n = e - this._pauseTime, !t && i.smoothChildTiming && (this._startTime += n, this._uncache(!1)), this._pauseTime = t ? e : null, this._paused = t, this._active = this.isActive(), !t && n !== 0 && this._initted && this.duration() && (e = i.smoothChildTiming ? this._totalTime : (e - this._startTime) / this._timeScale, this.render(e, e === this._totalTime, !0))), this._gc && !t && this._enabled(!0, !1), this }; const P = y('core.SimpleTimeline', function (t) { E.call(this, 0, t), this.autoRemoveChildren = this.smoothChildTiming = !0 }); s = P.prototype = new E(), s.constructor = P, s.kill()._gc = !1, s._first = s._last = s._recent = null, s._sortChildren = !1, s.add = s.insert = function (t, e, n, i) { let r, a; if (t._startTime = Number(e || 0) + t._delay, t._paused && this !== t._timeline && (t._pauseTime = t._startTime + (this.rawTime() - t._startTime) / t._timeScale), t.timeline && t.timeline._remove(t, !0), t.timeline = t._timeline = this, t._gc && t._enabled(!0, !0), r = this._last, this._sortChildren) for (a = t._startTime; r && r._startTime > a;)r = r._prev; return r ? (t._next = r._next, r._next = t) : (t._next = this._first, this._first = t), t._next ? t._next._prev = t : this._last = t, t._prev = r, this._recent = t, this._timeline && this._uncache(!0), this }, s._remove = function (t, e) { return t.timeline === this && (e || t._enabled(!1, !0), t._prev ? t._prev._next = t._next : this._first === t && (this._first = t._next), t._next ? t._next._prev = t._prev : this._last === t && (this._last = t._prev), t._next = t._prev = t.timeline = null, t === this._recent && (this._recent = this._last), this._timeline && this._uncache(!0)), this }, s.render = function (t, e, n) { let i; let r = this._first; for (this._totalTime = this._time = this._rawPrevTime = t; r;)i = r._next, (r._active || t >= r._startTime && !r._paused) && (r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (t - r._startTime) * r._timeScale, e, n) : r.render((t - r._startTime) * r._timeScale, e, n)), r = i }, s.rawTime = function () { return c || l.wake(), this._totalTime }; var k = y('TweenLite', function (e, n, i) { if (E.call(this, n, i), this.render = k.prototype.render, e == null) throw 'Cannot tween a null target.'; this.target = e = typeof e !== 'string' ? e : k.selector(e) || e; let r; let a; let o; const s = e.jquery || e.length && e !== t && e[0] && (e[0] === t || e[0].nodeType && e[0].style && !e.nodeType); let l = this.vars.overwrite; if (this._overwrite = l = l == null ? H[k.defaultOverwrite] : typeof l === 'number' ? l >> 0 : H[l], (s || e instanceof Array || e.push && f(e)) && typeof e[0] !== 'number') for (this._targets = o = p(e), this._propLookup = [], this._siblings = [], r = 0; r < o.length; r++)a = o[r], a ? typeof a !== 'string' ? a.length && a !== t && a[0] && (a[0] === t || a[0].nodeType && a[0].style && !a.nodeType) ? (o.splice(r--, 1), this._targets = o = o.concat(p(a))) : (this._siblings[r] = Z(a, this, !1), l === 1 && this._siblings[r].length > 1 && J(a, this, null, 1, this._siblings[r])) : typeof (a = o[r--] = k.selector(a)) === 'string' && o.splice(r + 1, 1) : o.splice(r--, 1); else this._propLookup = {}, this._siblings = Z(e, this, !1), l === 1 && this._siblings.length > 1 && J(e, this, null, 1, this._siblings); (this.vars.immediateRender || n === 0 && this._delay === 0 && !1 !== this.vars.immediateRender) && (this._time = -1e-10, this.render(Math.min(0, -this._delay))) }, !0); const D = function (e) { return e && e.length && e !== t && e[0] && (e[0] === t || e[0].nodeType && e[0].style && !e.nodeType) }; const O = function (t, e) { let n; const i = {}; for (n in t)G[n] || n in e && n !== 'transform' && n !== 'x' && n !== 'y' && n !== 'width' && n !== 'height' && n !== 'className' && n !== 'border' || !(!B[n] || B[n] && B[n]._autoCSS) || (i[n] = t[n], delete t[n]); t.css = i }; s = k.prototype = new E(), s.constructor = k, s.kill()._gc = !1, s.ratio = 0, s._firstPT = s._targets = s._overwrittenProps = s._startAt = null, s._notifyPluginsOfEnabled = s._lazy = !1, k.version = '1.19.1', k.defaultEase = s._ease = new x(null, null, 1, 1), k.defaultOverwrite = 'auto', k.ticker = l, k.autoSleep = 120, k.lagSmoothing = function (t, e) { l.lagSmoothing(t, e) }, k.selector = t.$ || t.jQuery || function (e) { const n = t.$ || t.jQuery; return n ? (k.selector = n, n(e)) : void 0 === i ? e : i.querySelectorAll ? i.querySelectorAll(e) : i.getElementById(e.charAt(0) === '#' ? e.substr(1) : e) }; var L = []; let I = {}; const R = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi; const N = function (t) { for (var e, n = this._firstPT; n;)e = n.blob ? t === 1 ? this.end : t ? this.join('') : this.start : n.c * t + n.s, n.m ? e = n.m(e, this._target || n.t) : e < 1e-6 && e > -1e-6 && !n.blob && (e = 0), n.f ? n.fp ? n.t[n.p](n.fp, e) : n.t[n.p](e) : n.t[n.p] = e, n = n._next }; const F = function (t, e, n, i) { let r; let a; let o; let s; let l; let c; let u; const h = []; let p = 0; let d = ''; let f = 0; for (h.start = t, h.end = e, t = h[0] = t + '', e = h[1] = e + '', n && (n(h), t = h[0], e = h[1]), h.length = 0, r = t.match(R) || [], a = e.match(R) || [], i && (i._next = null, i.blob = 1, h._firstPT = h._applyPT = i), l = a.length, s = 0; s < l; s++)u = a[s], c = e.substr(p, e.indexOf(u, p) - p), d += c || !s ? c : ',', p += c.length, f ? f = (f + 1) % 5 : c.substr(-5) === 'rgba(' && (f = 1), u === r[s] || r.length <= s ? d += u : (d && (h.push(d), d = ''), o = parseFloat(r[s]), h.push(o), h._firstPT = { _next: h._firstPT, t: h, p: h.length - 1, s: o, c: (u.charAt(1) === '=' ? parseInt(u.charAt(0) + '1', 10) * parseFloat(u.substr(2)) : parseFloat(u) - o) || 0, f: 0, m: f && f < 4 ? Math.round : 0 }), p += u.length; return d += e.substr(p), d && h.push(d), h.setRatio = N, h }; const U = function (t, e, n, i, r, a, o, s, l) { typeof i === 'function' && (i = i(l || 0, t)); let c; const u = typeof t[e]; const h = u !== 'function' ? '' : e.indexOf('set') || typeof t['get' + e.substr(3)] !== 'function' ? e : 'get' + e.substr(3); const p = n !== 'get' ? n : h ? o ? t[h](o) : t[h]() : t[e]; const d = typeof i === 'string' && i.charAt(1) === '='; let f = { t, p: e, s: p, f: u === 'function', pg: 0, n: r || e, m: a ? typeof a === 'function' ? a : Math.round : 0, pr: 0, c: d ? parseInt(i.charAt(0) + '1', 10) * parseFloat(i.substr(2)) : parseFloat(i) - p || 0 }; if ((typeof p !== 'number' || typeof i !== 'number' && !d) && (o || isNaN(p) || !d && isNaN(i) || typeof p === 'boolean' || typeof i === 'boolean' ? (f.fp = o, c = F(p, d ? f.s + f.c : i, s || k.defaultStringFilter, f), f = { t: c, p: 'setRatio', s: 0, c: 1, f: 2, pg: 0, n: r || e, pr: 0, m: 0 }) : (f.s = parseFloat(p), d || (f.c = parseFloat(i) - f.s || 0))), f.c) return (f._next = this._firstPT) && (f._next._prev = f), this._firstPT = f, f }; const z = k._internals = { isArray: f, isSelector: D, lazyTweens: L, blobDif: F }; var B = k._plugins = {}; const j = z.tweenLookup = {}; let V = 0; var G = z.reservedProps = { ease: 1, delay: 1, overwrite: 1, onComplete: 1, onCompleteParams: 1, onCompleteScope: 1, useFrames: 1, runBackwards: 1, startAt: 1, onUpdate: 1, onUpdateParams: 1, onUpdateScope: 1, onStart: 1, onStartParams: 1, onStartScope: 1, onReverseComplete: 1, onReverseCompleteParams: 1, onReverseCompleteScope: 1, onRepeat: 1, onRepeatParams: 1, onRepeatScope: 1, easeParams: 1, yoyo: 1, immediateRender: 1, repeat: 1, repeatDelay: 1, data: 1, paused: 1, reversed: 1, autoCSS: 1, lazy: 1, onOverwrite: 1, callbackScope: 1, stringFilter: 1, id: 1 }; var H = { none: 0, all: 1, auto: 2, concurrent: 3, allOnStart: 4, preexisting: 5, true: 1, false: 0 }; var W = E._rootFramesTimeline = new P(); var q = E._rootTimeline = new P(); let X = 30; var Y = z.lazyRender = function () { let t; let e = L.length; for (I = {}; --e > -1;)(t = L[e]) && !1 !== t._lazy && (t.render(t._lazy[0], t._lazy[1], !0), t._lazy = !1); L.length = 0 }; q._startTime = l.time, W._startTime = l.frame, q._active = W._active = !0, setTimeout(Y, 1), E._updateRoot = k.render = function () { let t, e, n; if (L.length && Y(), q.render((l.time - q._startTime) * q._timeScale, !1, !1), W.render((l.frame - W._startTime) * W._timeScale, !1, !1), L.length && Y(), l.frame >= X) { X = l.frame + (parseInt(k.autoSleep, 10) || 120); for (n in j) { for (e = j[n].tweens, t = e.length; --t > -1;)e[t]._gc && e.splice(t, 1); e.length === 0 && delete j[n] } if ((!(n = q._first) || n._paused) && k.autoSleep && !W._first && l._listeners.tick.length === 1) { for (;n && n._paused;)n = n._next; n || l.sleep() } } }, l.addEventListener('tick', E._updateRoot); var Z = function (t, e, n) { let i; let r; let a = t._gsTweenID; if (j[a || (t._gsTweenID = a = 't' + V++)] || (j[a] = { target: t, tweens: [] }), e && (i = j[a].tweens, i[r = i.length] = e, n)) for (;--r > -1;)i[r] === e && i.splice(r, 1); return j[a].tweens }; const K = function (t, e, n, i) { let r; let a; let o = t.vars.onOverwrite; return o && (r = o(t, e, n, i)), o = k.onOverwrite, o && (a = o(t, e, n, i)), !1 !== r && !1 !== a }; var J = function (t, e, n, i, r) { let a, o, s, l; if (i === 1 || i >= 4) { for (l = r.length, a = 0; a < l; a++) if ((s = r[a]) !== e)s._gc || s._kill(null, t, e) && (o = !0); else if (i === 5) break; return o } let c; const u = e._startTime + 1e-10; const h = []; let p = 0; const d = e._duration === 0; for (a = r.length; --a > -1;)(s = r[a]) === e || s._gc || s._paused || (s._timeline !== e._timeline ? (c = c || Q(e, 0, d), Q(s, c, d) === 0 && (h[p++] = s)) : s._startTime <= u && s._startTime + s.totalDuration() / s._timeScale > u && ((d || !s._initted) && u - s._startTime <= 2e-10 || (h[p++] = s))); for (a = p; --a > -1;) if (s = h[a], i === 2 && s._kill(n, t, e) && (o = !0), i !== 2 || !s._firstPT && s._initted) { if (i !== 2 && !K(s, e)) continue; s._enabled(!1, !1) && (o = !0) } return o }; var Q = function (t, e, n) { for (var i = t._timeline, r = i._timeScale, a = t._startTime; i._timeline;) { if (a += i._startTime, r *= i._timeScale, i._paused) return -100; i = i._timeline } return a /= r, a > e ? a - e : n && a === e || !t._initted && a - e < 2e-10 ? 1e-10 : (a += t.totalDuration() / t._timeScale / r) > e + 1e-10 ? 0 : a - e - 1e-10 }; s._init = function () {
      let t; let e; let n; let i; let r; let a; const o = this.vars; const s = this._overwrittenProps; const l = this._duration; let c = !!o.immediateRender; let u = o.ease; if (o.startAt) { this._startAt && (this._startAt.render(-1, !0), this._startAt.kill()), r = {}; for (i in o.startAt)r[i] = o.startAt[i]; if (r.overwrite = !1, r.immediateRender = !0, r.lazy = c && !1 !== o.lazy, r.startAt = r.delay = null, this._startAt = k.to(this.target, 0, r), c) if (this._time > 0) this._startAt = null; else if (l !== 0) return } else if (o.runBackwards && l !== 0) {
        if (this._startAt) this._startAt.render(-1, !0), this._startAt.kill(), this._startAt = null; else {
          this._time !== 0 && (c = !1), n = {}; for (i in o)G[i] && i !== 'autoCSS' || (n[i] = o[i]); if (n.overwrite = 0, n.data = 'isFromStart', n.lazy = c && !1 !== o.lazy, n.immediateRender = c, this._startAt = k.to(this.target, 0, n), c) { if (this._time === 0) return } else {
            this._startAt._init(), this._startAt._enabled(!1),
            this.vars.immediateRender && (this._startAt = null)
          }
        }
      } if (this._ease = u = u ? u instanceof x ? u : typeof u === 'function' ? new x(u, o.easeParams) : w[u] || k.defaultEase : k.defaultEase, o.easeParams instanceof Array && u.config && (this._ease = u.config.apply(u, o.easeParams)), this._easeType = this._ease._type, this._easePower = this._ease._power, this._firstPT = null, this._targets) for (a = this._targets.length, t = 0; t < a; t++) this._initProps(this._targets[t], this._propLookup[t] = {}, this._siblings[t], s ? s[t] : null, t) && (e = !0); else e = this._initProps(this.target, this._propLookup, this._siblings, s, 0); if (e && k._onPluginEvent('_onInitAllProps', this), s && (this._firstPT || typeof this.target !== 'function' && this._enabled(!1, !1)), o.runBackwards) for (n = this._firstPT; n;)n.s += n.c, n.c = -n.c, n = n._next; this._onUpdate = o.onUpdate, this._initted = !0
    }, s._initProps = function (e, n, i, r, a) { let o, s, l, c, u, h; if (e == null) return !1; I[e._gsTweenID] && Y(), this.vars.css || e.style && e !== t && e.nodeType && B.css && !1 !== this.vars.autoCSS && O(this.vars, e); for (o in this.vars) if (h = this.vars[o], G[o])h && (h instanceof Array || h.push && f(h)) && h.join('').indexOf('{self}') !== -1 && (this.vars[o] = h = this._swapSelfInParams(h, this)); else if (B[o] && (c = new B[o]())._onInitTween(e, this.vars[o], this, a)) { for (this._firstPT = u = { _next: this._firstPT, t: c, p: 'setRatio', s: 0, c: 1, f: 1, n: o, pg: 1, pr: c._priority, m: 0 }, s = c._overwriteProps.length; --s > -1;)n[c._overwriteProps[s]] = this._firstPT; (c._priority || c._onInitAllProps) && (l = !0), (c._onDisable || c._onEnable) && (this._notifyPluginsOfEnabled = !0), u._next && (u._next._prev = u) } else n[o] = U.call(this, e, o, 'get', h, o, 0, null, this.vars.stringFilter, a); return r && this._kill(r, e) ? this._initProps(e, n, i, r, a) : this._overwrite > 1 && this._firstPT && i.length > 1 && J(e, this, n, this._overwrite, i) ? (this._kill(n, e), this._initProps(e, n, i, r, a)) : (this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration) && (I[e._gsTweenID] = !0), l) }, s.render = function (t, e, n) { let i; let r; let a; let o; const s = this._time; const l = this._duration; const c = this._rawPrevTime; if (t >= l - 1e-7 && t >= 0) this._totalTime = this._time = l, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1, this._reversed || (i = !0, r = 'onComplete', n = n || this._timeline.autoRemoveChildren), l === 0 && (this._initted || !this.vars.lazy || n) && (this._startTime === this._timeline._duration && (t = 0), (c < 0 || t <= 0 && t >= -1e-7 || c === 1e-10 && this.data !== 'isPause') && c !== t && (n = !0, c > 1e-10 && (r = 'onReverseComplete')), this._rawPrevTime = o = !e || t || c === t ? t : 1e-10); else if (t < 1e-7) this._totalTime = this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (s !== 0 || l === 0 && c > 0) && (r = 'onReverseComplete', i = this._reversed), t < 0 && (this._active = !1, l === 0 && (this._initted || !this.vars.lazy || n) && (c >= 0 && (c !== 1e-10 || this.data !== 'isPause') && (n = !0), this._rawPrevTime = o = !e || t || c === t ? t : 1e-10)), this._initted || (n = !0); else if (this._totalTime = this._time = t, this._easeType) { let u = t / l; const h = this._easeType; const p = this._easePower; (h === 1 || h === 3 && u >= 0.5) && (u = 1 - u), h === 3 && (u *= 2), p === 1 ? u *= u : p === 2 ? u *= u * u : p === 3 ? u *= u * u * u : p === 4 && (u *= u * u * u * u), this.ratio = h === 1 ? 1 - u : h === 2 ? u : t / l < 0.5 ? u / 2 : 1 - u / 2 } else this.ratio = this._ease.getRatio(t / l); if (this._time !== s || n) { if (!this._initted) { if (this._init(), !this._initted || this._gc) return; if (!n && this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration)) return this._time = this._totalTime = s, this._rawPrevTime = c, L.push(this), void (this._lazy = [t, e]); this._time && !i ? this.ratio = this._ease.getRatio(this._time / l) : i && this._ease._calcEnd && (this.ratio = this._ease.getRatio(this._time === 0 ? 0 : 1)) } for (!1 !== this._lazy && (this._lazy = !1), this._active || !this._paused && this._time !== s && t >= 0 && (this._active = !0), s === 0 && (this._startAt && (t >= 0 ? this._startAt.render(t, e, n) : r || (r = '_dummyGS')), this.vars.onStart && (this._time === 0 && l !== 0 || e || this._callback('onStart'))), a = this._firstPT; a;)a.f ? a.t[a.p](a.c * this.ratio + a.s) : a.t[a.p] = a.c * this.ratio + a.s, a = a._next; this._onUpdate && (t < 0 && this._startAt && t !== -1e-4 && this._startAt.render(t, e, n), e || (this._time !== s || i || n) && this._callback('onUpdate')), r && (this._gc && !n || (t < 0 && this._startAt && !this._onUpdate && t !== -1e-4 && this._startAt.render(t, e, n), i && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[r] && this._callback(r), l === 0 && this._rawPrevTime === 1e-10 && o !== 1e-10 && (this._rawPrevTime = 0))) } }, s._kill = function (t, e, n) { if (t === 'all' && (t = null), t == null && (e == null || e === this.target)) return this._lazy = !1, this._enabled(!1, !1); e = typeof e !== 'string' ? e || this._targets || this.target : k.selector(e) || e; let i; let r; let a; let o; let s; let l; let c; let u; let h; const p = n && this._time && n._startTime === this._startTime && this._timeline === n._timeline; if ((f(e) || D(e)) && typeof e[0] !== 'number') for (i = e.length; --i > -1;) this._kill(t, e[i], n) && (l = !0); else { if (this._targets) { for (i = this._targets.length; --i > -1;) if (e === this._targets[i]) { s = this._propLookup[i] || {}, this._overwrittenProps = this._overwrittenProps || [], r = this._overwrittenProps[i] = t ? this._overwrittenProps[i] || {} : 'all'; break } } else { if (e !== this.target) return !1; s = this._propLookup, r = this._overwrittenProps = t ? this._overwrittenProps || {} : 'all' } if (s) { if (c = t || s, u = t !== r && r !== 'all' && t !== s && (typeof t !== 'object' || !t._tempKill), n && (k.onOverwrite || this.vars.onOverwrite)) { for (a in c)s[a] && (h || (h = []), h.push(a)); if ((h || !t) && !K(this, n, e, h)) return !1 } for (a in c)(o = s[a]) && (p && (o.f ? o.t[o.p](o.s) : o.t[o.p] = o.s, l = !0), o.pg && o.t._kill(c) && (l = !0), o.pg && o.t._overwriteProps.length !== 0 || (o._prev ? o._prev._next = o._next : o === this._firstPT && (this._firstPT = o._next), o._next && (o._next._prev = o._prev), o._next = o._prev = null), delete s[a]), u && (r[a] = 1); !this._firstPT && this._initted && this._enabled(!1, !1) } } return l }, s.invalidate = function () { return this._notifyPluginsOfEnabled && k._onPluginEvent('_onDisable', this), this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null, this._notifyPluginsOfEnabled = this._active = this._lazy = !1, this._propLookup = this._targets ? {} : [], E.prototype.invalidate.call(this), this.vars.immediateRender && (this._time = -1e-10, this.render(Math.min(0, -this._delay))), this }, s._enabled = function (t, e) { if (c || l.wake(), t && this._gc) { let n; const i = this._targets; if (i) for (n = i.length; --n > -1;) this._siblings[n] = Z(i[n], this, !0); else this._siblings = Z(this.target, this, !0) } return E.prototype._enabled.call(this, t, e), !(!this._notifyPluginsOfEnabled || !this._firstPT) && k._onPluginEvent(t ? '_onEnable' : '_onDisable', this) }, k.to = function (t, e, n) { return new k(t, e, n) }, k.from = function (t, e, n) { return n.runBackwards = !0, n.immediateRender = n.immediateRender != 0, new k(t, e, n) }, k.fromTo = function (t, e, n, i) { return i.startAt = n, i.immediateRender = i.immediateRender != 0 && n.immediateRender != 0, new k(t, e, i) }, k.delayedCall = function (t, e, n, i, r) { return new k(e, 0, { delay: t, onComplete: e, onCompleteParams: n, callbackScope: i, onReverseComplete: e, onReverseCompleteParams: n, immediateRender: !1, lazy: !1, useFrames: r, overwrite: 0 }) }, k.set = function (t, e) { return new k(t, 0, e) }, k.getTweensOf = function (t, e) { if (t == null) return []; t = typeof t !== 'string' ? t : k.selector(t) || t; let n, i, r, a; if ((f(t) || D(t)) && typeof t[0] !== 'number') { for (n = t.length, i = []; --n > -1;)i = i.concat(k.getTweensOf(t[n], e)); for (n = i.length; --n > -1;) for (a = i[n], r = n; --r > -1;)a === i[r] && i.splice(n, 1) } else for (i = Z(t).concat(), n = i.length; --n > -1;)(i[n]._gc || e && !i[n].isActive()) && i.splice(n, 1); return i }, k.killTweensOf = k.killDelayedCallsTo = function (t, e, n) { typeof e === 'object' && (n = e, e = !1); for (let i = k.getTweensOf(t, e), r = i.length; --r > -1;)i[r]._kill(n, t) }; var tt = y('plugins.TweenPlugin', function (t, e) { this._overwriteProps = (t || '').split(','), this._propName = this._overwriteProps[0], this._priority = e || 0, this._super = tt.prototype }, !0); if (s = tt.prototype, tt.version = '1.19.0', tt.API = 2, s._firstPT = null, s._addTween = U, s.setRatio = N, s._kill = function (t) { let e; const n = this._overwriteProps; let i = this._firstPT; if (t[this._propName] != null) this._overwriteProps = []; else for (e = n.length; --e > -1;)t[n[e]] != null && n.splice(e, 1); for (;i;)t[i.n] != null && (i._next && (i._next._prev = i._prev), i._prev ? (i._prev._next = i._next, i._prev = null) : this._firstPT === i && (this._firstPT = i._next)), i = i._next; return !1 }, s._mod = s._roundProps = function (t) { for (var e, n = this._firstPT; n;)e = t[this._propName] || n.n != null && t[n.n.split(this._propName + '_').join('')], e && typeof e === 'function' && (n.f === 2 ? n.t._applyPT.m = e : n.m = e), n = n._next }, k._onPluginEvent = function (t, e) { let n; let i; let r; let a; let o; let s = e._firstPT; if (t === '_onInitAllProps') { for (;s;) { for (o = s._next, i = r; i && i.pr > s.pr;)i = i._next; (s._prev = i ? i._prev : a) ? s._prev._next = s : r = s, (s._next = i) ? i._prev = s : a = s, s = o }s = e._firstPT = r } for (;s;)s.pg && typeof s.t[t] === 'function' && s.t[t]() && (n = !0), s = s._next; return n }, tt.activate = function (t) { for (let e = t.length; --e > -1;)t[e].API === tt.API && (B[(new t[e]())._propName] = t[e]); return !0 }, v.plugin = function (t) { if (!(t && t.propName && t.init && t.API)) throw 'illegal plugin definition.'; let e; const n = t.propName; const i = t.priority || 0; const r = t.overwriteProps; const a = { init: '_onInitTween', set: 'setRatio', kill: '_kill', round: '_mod', mod: '_mod', initAll: '_onInitAllProps' }; const o = y('plugins.' + n.charAt(0).toUpperCase() + n.substr(1) + 'Plugin', function () { tt.call(this, n, i), this._overwriteProps = r || [] }, !0 === t.global); const s = o.prototype = new tt(n); s.constructor = o, o.API = t.API; for (e in a) typeof t[e] === 'function' && (s[a[e]] = t[e]); return o.version = t.version, tt.activate([o]), o }, a = t._gsQueue) { for (o = 0; o < a.length; o++)a[o](); for (s in m)m[s].func || t.console.log('GSAP encountered missing dependency: ' + s) }c = !1
  }
}(typeof module !== 'undefined' && module.exports && typeof global !== 'undefined' ? global : this || window)), (function (t, e) {
  'use strict'; function n (t, e, n) { if (!t) throw lt('areq', "Argument '{0}' is {1}", e || '?', n || 'required'); return t } function i (t, e) { return t || e ? t ? e ? (W(t) && (t = t.join(' ')), W(e) && (e = e.join(' ')), t + ' ' + e) : t : e : '' } function r (t) { const e = {}; return t && (t.to || t.from) && (e.to = t.to, e.from = t.from), e } function a (t, e, n) { let i = ''; return t = W(t) ? t : t && K(t) && t.length ? t.split(/\s+/) : [], H(t, function (t, r) { t && t.length > 0 && (i += r > 0 ? ' ' : '', i += n ? e + t : t + e) }), i } function o (t, e) { const n = t.indexOf(e); e >= 0 && t.splice(n, 1) } function s (t) { if (t instanceof Q) switch (t.length) { case 0:return t; case 1:if (t[0].nodeType === N) return t; break; default:return Q(l(t)) } if (t.nodeType === N) return Q(t) } function l (t) { if (!t[0]) return t; for (let e = 0; e < t.length; e++) { const n = t[e]; if (n.nodeType === N) return n } } function c (t, e, n) { H(e, function (e) { t.addClass(e, n) }) } function u (t, e, n) { H(e, function (e) { t.removeClass(e, n) }) } function h (t) { return function (e, n) { n.addClass && (c(t, e, n.addClass), n.addClass = null), n.removeClass && (u(t, e, n.removeClass), n.removeClass = null) } } function p (t) { if (t = t || {}, !t.$$prepared) { let e = t.domOperation || tt; t.domOperation = function () { t.$$domOperationFired = !0, e(), e = tt }, t.$$prepared = !0 } return t } function d (t, e) { f(t, e), m(t, e) } function f (t, e) { e.from && (t.css(e.from), e.from = null) } function m (t, e) { e.to && (t.css(e.to), e.to = null) } function g (t, e, n) { const i = e.options || {}; const r = n.options || {}; const a = (i.addClass || '') + ' ' + (r.addClass || ''); const o = (i.removeClass || '') + ' ' + (r.removeClass || ''); const s = v(t.attr('class'), a, o); r.preparationClasses && (i.preparationClasses = T(r.preparationClasses, i.preparationClasses), delete r.preparationClasses); const l = i.domOperation !== tt ? i.domOperation : null; return G(i, r), l && (i.domOperation = l), s.addClass ? i.addClass = s.addClass : i.addClass = null, s.removeClass ? i.removeClass = s.removeClass : i.removeClass = null, e.addClass = i.addClass, e.removeClass = i.removeClass, i } function v (t, e, n) { function i (t) { K(t) && (t = t.split(' ')); const e = {}; return H(t, function (t) { t.length && (e[t] = !0) }), e } const r = {}; t = i(t), e = i(e), H(e, function (t, e) { r[e] = 1 }), n = i(n), H(n, function (t, e) { r[e] = r[e] === 1 ? null : -1 }); const a = { addClass: '', removeClass: '' }; return H(r, function (e, n) { let i, r; e === 1 ? (i = 'addClass', r = !t[n] || t[n + U]) : e === -1 && (i = 'removeClass', r = t[n] || t[n + F]), r && (a[i].length && (a[i] += ' '), a[i] += n) }), a } function y (t) { return t instanceof Q ? t[0] : t } function b (t, e, n) { let i = ''; e && (i = a(e, z, !0)), n.addClass && (i = T(i, a(n.addClass, F))), n.removeClass && (i = T(i, a(n.removeClass, U))), i.length && (n.preparationClasses = i, t.addClass(i)) } function x (t, e) { e.preparationClasses && (t.removeClass(e.preparationClasses), e.preparationClasses = null), e.activeClasses && (t.removeClass(e.activeClasses), e.activeClasses = null) } function w (t, e) { const n = e ? '-' + e + 's' : ''; return $(t, [ot, n]), [ot, n] } function _ (t, e) { const n = e ? 'paused' : ''; const i = I + it; return $(t, [i, n]), [i, n] } function $ (t, e) { const n = e[0]; const i = e[1]; t.style[n] = i } function T (t, e) { return t ? e ? t + ' ' + e : t : e } function S (t) { return [at, t + 's'] } function M (t, e) { return [e ? rt : ot, t + 's'] } function C (t, e, n) { const i = Object.create(null); const r = t.getComputedStyle(e) || {}; return H(n, function (t, e) { let n = r[t]; if (n) { const a = n.charAt(0); (a === '-' || a === '+' || a >= 0) && (n = E(n)), n === 0 && (n = null), i[e] = n } }), i } function E (t) { let e = 0; const n = t.split(/\s*,\s*/); return H(n, function (t) { t.charAt(t.length - 1) === 's' && (t = t.substring(0, t.length - 1)), t = parseFloat(t) || 0, e = e ? Math.max(t, e) : t }), e } function A (t) { return t === 0 || t != null } function P (t, e) { let n = O; let i = t + 's'; return e ? n += et : i += ' linear all', [n, i] } function k () { let t = Object.create(null); return { flush: function () { t = Object.create(null) }, count: function (e) { const n = t[e]; return n ? n.total : 0 }, get: function (e) { const n = t[e]; return n && n.value }, put: function (e, n) { t[e] ? t[e].total++ : t[e] = { total: 1, value: n } } } } function D (t, e, n) { H(n, function (n) { t[n] = q(t[n]) ? t[n] : e.style.getPropertyValue(n) }) } let O; let L; let I; let R; var N = 1; var F = '-add'; var U = '-remove'; var z = 'ng-'; const B = 'ng-animate'; const j = '$$ngAnimateChildren'; void 0 === t.ontransitionend && void 0 !== t.onwebkittransitionend ? ('-webkit-', O = 'WebkitTransition', L = 'webkitTransitionEnd transitionend') : (O = 'transition', L = 'transitionend'), void 0 === t.onanimationend && void 0 !== t.onwebkitanimationend ? ('-webkit-', I = 'WebkitAnimation', R = 'webkitAnimationEnd animationend') : (I = 'animation', R = 'animationend'); let V; let G; let H; let W; let q; let X; let Y; let Z; let K; let J; let Q; let tt; var et = 'Duration'; const nt = 'TimingFunction'; var it = 'PlayState'; var rt = I + 'Delay'; var at = I + et; var ot = O + 'Delay'; const st = O + et; var lt = e.$$minErr('ng'); const ct = ['$$rAF', function (t) { function e (t) { i = i.concat(t), n() } function n () { if (i.length) { for (let e = i.shift(), a = 0; a < e.length; a++)e[a](); r || t(function () { r || n() }) } } let i, r; return i = e.queue = [], e.waitUntilQuiet = function (e) { r && r(), r = t(function () { r = null, e(), n() }) }, e }]; const ut = ['$interpolate', function (t) { return { link: function (e, n, i) { function r (t) { t = t === 'on' || t === 'true', n.data(j, t) } const a = i.ngAnimateChildren; K(a) && a.length === 0 ? n.data(j, !0) : (r(t(a)(e)), i.$observe('ngAnimateChildren', r)) } } }]; const ht = '$$animateCss'; const pt = 1e3; const dt = 3; const ft = 1.5; const mt = { transitionDuration: st, transitionDelay: ot, transitionProperty: O + 'Property', animationDuration: at, animationDelay: rt, animationIterationCount: I + 'IterationCount' }; const gt = { transitionDuration: st, transitionDelay: ot, animationDuration: at, animationDelay: rt }; const vt = ['$animateProvider', function (t) { const e = k(); const n = k(); this.$get = ['$window', '$$jqLite', '$$AnimateRunner', '$timeout', '$$forceReflow', '$sniffer', '$$rAFScheduler', '$$animateQueue', function (t, i, s, l, c, u, g, v) { function b (t, e) { const n = '$$ngAnimateParentKey'; const i = t.parentNode; return (i[n] || (i[n] = ++B)) + '-' + t.getAttribute('class') + '-' + e } function x (n, i, r, a) { let o = e.get(r); return o || (o = C(t, n, a), o.animationIterationCount === 'infinite' && (o.animationIterationCount = 1)), e.put(r, o), o } function T (r, o, s, l) { let c; if (e.count(s) > 0 && !(c = n.get(s))) { const u = a(o, '-stagger'); i.addClass(r, u), c = C(t, r, l), c.animationDuration = Math.max(c.animationDuration, 0), c.transitionDuration = Math.max(c.transitionDuration, 0), i.removeClass(r, u), n.put(s, c) } return c || {} } function E (t) { j.push(t), g.waitUntilQuiet(function () { e.flush(), n.flush(); for (let t = c(), i = 0; i < j.length; i++)j[i](t); j.length = 0 }) } function k (t, e, n) { const i = x(t, e, n, mt); const r = i.animationDelay; const a = i.transitionDelay; return i.maxDelay = r && a ? Math.max(r, a) : r || a, i.maxDuration = Math.max(i.animationDuration * i.animationIterationCount, i.transitionDuration), i } const N = h(i); var B = 0; var j = []; return function (t, n) { function c () { g() } function h () { g(!0) } function g (e) { if (!(Y || K && Z)) { Y = !0, Z = !1, G.$$skipPreparationClasses || i.removeClass(t, xt), i.removeClass(t, _t), _(X, !1), w(X, !1), H(st, function (t) { X.style[t[0]] = '' }), N(t, G), d(t, G), Object.keys(q).length && H(q, function (t, e) { t ? X.style.setProperty(e, t) : X.style.removeProperty(e) }), G.onDone && G.onDone(), ut && ut.length && t.off(ut.join(' '), B); const n = t.data(ht); n && (l.cancel(n[0].timer), t.removeData(ht)), J && J.complete(!e) } } function x (t) { It.blockTransition && w(X, t), It.blockKeyframeAnimation && _(X, !!t) } function C () { return J = new s({ end: c, cancel: h }), E(tt), g(), { $$willAnimate: !1, start: function () { return J }, end: c } } function B (t) { t.stopPropagation(); const e = t.originalEvent || t; const n = e.$manualTimeStamp || Date.now(); const i = parseFloat(e.elapsedTime.toFixed(dt)); Math.max(n - ot, 0) >= it && i >= rt && (K = !0, g()) } function j () { function e () { if (!Y) { if (x(!1), H(st, function (t) { const e = t[0]; const n = t[1]; X.style[e] = n }), N(t, G), i.addClass(t, _t), It.recalculateTimingStyles) { if (wt = X.getAttribute('class') + ' ' + xt, Tt = b(X, wt), Ot = k(X, wt, Tt), Lt = Ot.maxDelay, et = Math.max(Lt, 0), (rt = Ot.maxDuration) === 0) return void g(); It.hasTransitions = Ot.transitionDuration > 0, It.hasAnimations = Ot.animationDuration > 0 } if (It.applyAnimationDelay && (Lt = typeof G.delay !== 'boolean' && A(G.delay) ? parseFloat(G.delay) : Lt, et = Math.max(Lt, 0), Ot.animationDelay = Lt, Rt = M(Lt, !0), st.push(Rt), X.style[Rt[0]] = Rt[1]), it = et * pt, at = rt * pt, G.easing) { let e; const r = G.easing; It.hasTransitions && (e = O + nt, st.push([e, r]), X.style[e] = r), It.hasAnimations && (e = I + nt, st.push([e, r]), X.style[e] = r) }Ot.transitionDuration && ut.push(L), Ot.animationDuration && ut.push(R), ot = Date.now(); const a = it + ft * at; const o = ot + a; const s = t.data(ht) || []; let c = !0; if (s.length) { const u = s[0]; c = o > u.expectedEndTime, c ? l.cancel(u.timer) : s.push(g) } if (c) { const h = l(n, a, !1); s[0] = { timer: h, expectedEndTime: o }, s.push(g), t.data(ht, s) }ut.length && t.on(ut.join(' '), B), G.to && (G.cleanupStyles && D(q, X, Object.keys(G.to)), m(t, G)) } } function n () { const e = t.data(ht); if (e) { for (let n = 1; n < e.length; n++)e[n](); t.removeData(ht) } } if (!Y) { if (!X.parentNode) return void g(); const r = function (t) { if (K)Z && t && (Z = !1, g()); else if (Z = !t, Ot.animationDuration) { const e = _(X, Z); Z ? st.push(e) : o(st, e) } }; const a = kt > 0 && (Ot.transitionDuration && St.transitionDuration === 0 || Ot.animationDuration && St.animationDuration === 0) && Math.max(St.animationDelay, St.transitionDelay); a ? l(e, Math.floor(a * kt * pt), !1) : e(), Q.resume = function () { r(!0) }, Q.pause = function () { r(!1) } } } var G = n || {}; G.$$prepared || (G = p(V(G))); var q = {}; var X = y(t); if (!X || !X.parentNode || !v.enabled()) return C(); let Y; let Z; let K; let J; let Q; let et; let it; let rt; let at; let ot; var st = []; const lt = t.attr('class'); const ct = r(G); var ut = []; if (G.duration === 0 || !u.animations && !u.transitions) return C(); const mt = G.event && W(G.event) ? G.event.join(' ') : G.event; const vt = mt && G.structural; let yt = ''; let bt = ''; vt ? yt = a(mt, z, !0) : mt && (yt = mt), G.addClass && (bt += a(G.addClass, F)), G.removeClass && (bt.length && (bt += ' '), bt += a(G.removeClass, U)), G.applyClassesEarly && bt.length && N(t, G); var xt = [yt, bt].join(' ').trim(); var wt = lt + ' ' + xt; var _t = a(xt, '-active'); const $t = ct.to && Object.keys(ct.to).length > 0; if (!((G.keyframeStyle || '').length > 0 || $t || xt)) return C(); let Tt, St; if (G.stagger > 0) { const Mt = parseFloat(G.stagger); St = { transitionDelay: Mt, animationDelay: Mt, transitionDuration: 0, animationDuration: 0 } } else Tt = b(X, wt), St = T(X, xt, Tt, gt); G.$$skipPreparationClasses || i.addClass(t, xt); let Ct; if (G.transitionStyle) { const Et = [O, G.transitionStyle]; $(X, Et), st.push(Et) } if (G.duration >= 0) { Ct = X.style[O].length > 0; const At = P(G.duration, Ct); $(X, At), st.push(At) } if (G.keyframeStyle) { const Pt = [I, G.keyframeStyle]; $(X, Pt), st.push(Pt) } var kt = St ? G.staggerIndex >= 0 ? G.staggerIndex : e.count(Tt) : 0; const Dt = kt === 0; Dt && !G.skipBlocking && w(X, 9999); var Ot = k(X, wt, Tt); var Lt = Ot.maxDelay; et = Math.max(Lt, 0), rt = Ot.maxDuration; var It = {}; if (It.hasTransitions = Ot.transitionDuration > 0, It.hasAnimations = Ot.animationDuration > 0, It.hasTransitionAll = It.hasTransitions && Ot.transitionProperty === 'all', It.applyTransitionDuration = $t && (It.hasTransitions && !It.hasTransitionAll || It.hasAnimations && !It.hasTransitions), It.applyAnimationDuration = G.duration && It.hasAnimations, It.applyTransitionDelay = A(G.delay) && (It.applyTransitionDuration || It.hasTransitions), It.applyAnimationDelay = A(G.delay) && It.hasAnimations, It.recalculateTimingStyles = bt.length > 0, (It.applyTransitionDuration || It.applyAnimationDuration) && (rt = G.duration ? parseFloat(G.duration) : rt, It.applyTransitionDuration && (It.hasTransitions = !0, Ot.transitionDuration = rt, Ct = X.style[O + 'Property'].length > 0, st.push(P(rt, Ct))), It.applyAnimationDuration && (It.hasAnimations = !0, Ot.animationDuration = rt, st.push(S(rt)))), rt === 0 && !It.recalculateTimingStyles) return C(); if (G.delay != null) { var Rt; typeof G.delay !== 'boolean' && (Rt = parseFloat(G.delay), et = Math.max(Rt, 0)), It.applyTransitionDelay && st.push(M(Rt)), It.applyAnimationDelay && st.push(M(Rt, !0)) } return G.duration == null && Ot.transitionDuration > 0 && (It.recalculateTimingStyles = It.recalculateTimingStyles || Dt), it = et * pt, at = rt * pt, G.skipBlocking || (It.blockTransition = Ot.transitionDuration > 0, It.blockKeyframeAnimation = Ot.animationDuration > 0 && St.animationDelay > 0 && St.animationDuration === 0), G.from && (G.cleanupStyles && D(q, X, Object.keys(G.from)), f(t, G)), It.blockTransition || It.blockKeyframeAnimation ? x(rt) : G.skipBlocking || w(X, !1), { $$willAnimate: !0, end: c, start: function () { if (!Y) return Q = { end: c, cancel: h, resume: null, pause: null }, J = new s(Q), E(j), J } } } }] }]; const yt = ['$$animationProvider', function (t) { function e (t) { return t.parentNode && t.parentNode.nodeType === 11 }t.drivers.push('$$animateCssDriver'); const n = 'ng-animate-shim'; const i = 'ng-anchor-out'; this.$get = ['$animateCss', '$rootScope', '$$AnimateRunner', '$rootElement', '$sniffer', '$$jqLite', '$document', function (t, r, a, o, s, l, c) { function u (t) { return t.replace(/\bng-\S+\b/g, '') } function h (t, e) { return K(t) && (t = t.split(' ')), K(e) && (e = e.split(' ')), t.filter(function (t) { return e.indexOf(t) === -1 }).join(' ') } function p (e, r, o) { function s (t) { const e = {}; const n = y(t).getBoundingClientRect(); return H(['width', 'height', 'top', 'left'], function (t) { let i = n[t]; switch (t) { case 'top':i += m.scrollTop; break; case 'left':i += m.scrollLeft }e[t] = Math.floor(i) + 'px' }), e } function l (t) { return t.attr('class') || '' } function c () { const e = u(l(o)); const n = h(e, f); const r = h(f, e); const a = t(d, { to: s(o), addClass: 'ng-anchor-in ' + n, removeClass: i + ' ' + r, delay: !0 }); return a.$$willAnimate ? a : null } function p () { d.remove(), r.removeClass(n), o.removeClass(n) } var d = Q(y(r).cloneNode(!0)); var f = u(l(d)); r.addClass(n), o.addClass(n), d.addClass('ng-anchor'), v.append(d); let g; const b = (function () { const e = t(d, { addClass: i, delay: !0, from: s(r) }); return e.$$willAnimate ? e : null }()); if (!b && !(g = c())) return p(); const x = b || g; return { start: function () { function t () { n && n.end() } let e; var n = x.start(); return n.done(function () { if (n = null, !g && (g = c())) return n = g.start(), n.done(function () { n = null, p(), e.complete() }), n; p(), e.complete() }), e = new a({ end: t, cancel: t }) } } } function d (t, e, n, i) { const r = f(t); const o = f(e); const s = []; if (H(i, function (t) { const e = t.out; const i = t.in; const r = p(n, e, i); r && s.push(r) }), r || o || s.length !== 0) return { start: function () { function t () { H(e, function (t) { t.end() }) } var e = []; r && e.push(r.start()), o && e.push(o.start()), H(s, function (t) { e.push(t.start()) }); const n = new a({ end: t, cancel: t }); return a.all(e, function (t) { n.complete(t) }), n } } } function f (e) { const n = e.element; const i = e.options || {}; e.structural && (i.event = e.event, i.structural = !0, i.applyClassesEarly = !0, e.event === 'leave' && (i.onDone = i.domOperation)), i.preparationClasses && (i.event = T(i.event, i.preparationClasses)); const r = t(n, i); return r.$$willAnimate ? r : null } if (!s.animations && !s.transitions) return tt; var m = c[0].body; const g = y(o); var v = Q(e(g) || m.contains(g) ? g : m); return function (t) { return t.from && t.to ? d(t.from, t.to, t.classes, t.anchors) : f(t) } }] }]; const bt = ['$animateProvider', function (t) { this.$get = ['$injector', '$$AnimateRunner', '$$jqLite', function (e, n, i) { function r (n) { n = W(n) ? n : n.split(' '); for (var i = [], r = {}, a = 0; a < n.length; a++) { const o = n[a]; const s = t.$$registeredAnimations[o]; s && !r[o] && (i.push(e.get(s)), r[o] = !0) } return i } const a = h(i); return function (t, e, i, o) { function s () { o.domOperation(), a(t, o) } function l () { f = !0, s(), d(t, o) } function c (t, e, i, r, a) { let o; switch (i) { case 'animate':o = [e, r.from, r.to, a]; break; case 'setClass':o = [e, v, y, a]; break; case 'addClass':o = [e, v, a]; break; case 'removeClass':o = [e, y, a]; break; default:o = [e, a] }o.push(r); let s = t.apply(t, o); if (s) if (Y(s.start) && (s = s.start()), s instanceof n)s.done(a); else if (Y(s)) return s; return tt } function u (t, e, i, r, a) { const o = []; return H(r, function (r) { const s = r[a]; s && o.push(function () { let r; let a; let o = !1; const l = function (t) { o || (o = !0, (a || tt)(t), r.complete(!t)) }; return r = new n({ end: function () { l() }, cancel: function () { l(!0) } }), a = c(s, t, e, i, function (t) { l(!1 === t) }), r }) }), o } function h (t, e, i, r, a) { let o = u(t, e, i, r, a); if (o.length === 0) { let s, l; a === 'beforeSetClass' ? (s = u(t, 'removeClass', i, r, 'beforeRemoveClass'), l = u(t, 'addClass', i, r, 'beforeAddClass')) : a === 'setClass' && (s = u(t, 'removeClass', i, r, 'removeClass'), l = u(t, 'addClass', i, r, 'addClass')), s && (o = o.concat(s)), l && (o = o.concat(l)) } if (o.length !== 0) return function (t) { const e = []; return o.length && H(o, function (t) { e.push(t()) }), e.length ? n.all(e, t) : t(), function (t) { H(e, function (e) { t ? e.cancel() : e.end() }) } } } var f = !1; arguments.length === 3 && Z(i) && (o = i, i = null), o = p(o), i || (i = t.attr('class') || '', o.addClass && (i += ' ' + o.addClass), o.removeClass && (i += ' ' + o.removeClass)); let m; let g; var v = o.addClass; var y = o.removeClass; const b = r(i); if (b.length) { let x, w; e === 'leave' ? (w = 'leave', x = 'afterLeave') : (w = 'before' + e.charAt(0).toUpperCase() + e.substr(1), x = e), e !== 'enter' && e !== 'move' && (m = h(t, e, o, b, w)), g = h(t, e, o, b, x) } if (m || g) { let _; return { $$willAnimate: !0, end: function () { return _ ? _.end() : (l(), _ = new n(), _.complete(!0)), _ }, start: function () { function t (t) { l(t), _.complete(t) } function e (e) { f || ((i || tt)(e), t(e)) } if (_) return _; _ = new n(); let i; const r = []; return m && r.push(function (t) { i = m(t) }), r.length ? r.push(function (t) { s(), t(!0) }) : s(), g && r.push(function (t) { i = g(t) }), _.setHost({ end: function () { e() }, cancel: function () { e(!0) } }), n.chain(r, t), _ } } } } }] }]; const xt = ['$$animationProvider', function (t) { t.drivers.push('$$animateJsDriver'), this.$get = ['$$animateJs', '$$AnimateRunner', function (t, e) { function n (e) { const n = e.element; const i = e.event; const r = e.options; const a = e.classes; return t(n, i, a, r) } return function (t) { if (t.from && t.to) { const i = n(t.from); const r = n(t.to); if (!i && !r) return; return { start: function () { function t () { return function () { H(a, function (t) { t.end() }) } } function n (t) { o.complete(t) } var a = []; i && a.push(i.start()), r && a.push(r.start()), e.all(a, n); var o = new e({ end: t(), cancel: t() }); return o } } } return n(t) } }] }]; const wt = 'data-ng-animate'; const _t = '$ngAnimatePin'; const $t = ['$animateProvider', function (e) { function i (t) { if (!t) return null; const e = t.split(f); const n = Object.create(null); return H(e, function (t) { n[t] = !0 }), n } function r (t, e) { if (t && e) { const n = i(e); return t.split(f).some(function (t) { return n[t] }) } } function a (t, e, n) { return m[t].some(function (t) { return t(e, n) }) } function o (t, e) { const n = (t.addClass || '').length > 0; const i = (t.removeClass || '').length > 0; return e ? n && i : n || i } const c = 1; const u = 2; var f = ' '; var m = this.rules = { skip: [], cancel: [], join: [] }; m.join.push(function (t, e) { return !t.structural && o(t) }), m.skip.push(function (t, e) { return !t.structural && !o(t) }), m.skip.push(function (t, e) { return e.event === 'leave' && t.structural }), m.skip.push(function (t, e) { return e.structural && e.state === u && !t.structural }), m.cancel.push(function (t, e) { return e.structural && t.structural }), m.cancel.push(function (t, e) { return e.state === u && t.structural }), m.cancel.push(function (t, e) { if (e.structural) return !1; const n = t.addClass; const i = t.removeClass; const a = e.addClass; const o = e.removeClass; return !(J(n) && J(i) || J(a) && J(o)) && (r(n, o) || r(i, a)) }), this.$get = ['$$rAF', '$rootScope', '$rootElement', '$document', '$$Map', '$$animation', '$$AnimateRunner', '$templateRequest', '$$jqLite', '$$forceReflow', '$$isDocumentHidden', function (i, r, f, m, v, w, _, $, T, S, M) { function C () { let t = !1; return function (e) { t ? e() : r.$$postDigest(function () { t = !0, e() }) } } function E (t, e) { return g(t, e, {}) } function A (t, e, n) { const i = []; const r = Y[n]; return r && H(r, function (r) { it.call(r.node, e) ? i.push(r.callback) : n === 'leave' && it.call(r.node, t) && i.push(r.callback) }), i } function P (t, e, n) { const i = l(e); return t.filter(function (t) { return !(t.node === i && (!n || t.callback === n)) }) } function k (t, e) { t !== 'close' || e.parentNode || rt.off(e) } function D (t, e, n) { function l (t, e, n, r) { S(function () { const t = A($, v, e); t.length ? i(function () { H(t, function (t) { t(m, n, r) }), k(n, v) }) : k(n, v) }), t.progress(e, n, r) } function h (t) { x(m, f), nt(m, f), d(m, f), f.domOperation(), T.complete(!t) } var f = V(n); var m = s(t); var v = y(m); var $ = v && v.parentNode; f = p(f); var T = new _(); var S = C(); if (W(f.addClass) && (f.addClass = f.addClass.join(' ')), f.addClass && !K(f.addClass) && (f.addClass = null), W(f.removeClass) && (f.removeClass = f.removeClass.join(' ')), f.removeClass && !K(f.removeClass) && (f.removeClass = null), f.from && !Z(f.from) && (f.from = null), f.to && !Z(f.to) && (f.to = null), !v) return h(), T; const P = [v.getAttribute('class'), f.addClass, f.removeClass].join(' '); if (!et(P)) return h(), T; const D = ['enter', 'move', 'leave'].indexOf(e) >= 0; const N = M(); let B = !z || N || U.get(v); const j = !B && F.get(v) || {}; const G = !!j.state; if (B || G && j.state === c || (B = !I(v, $, e)), B) return N && l(T, e, 'start'), h(), N && l(T, e, 'close'), T; D && O(v); const q = { structural: D, element: m, event: e, addClass: f.addClass, removeClass: f.removeClass, close: h, options: f, runner: T }; if (G) { if (a('skip', q, j)) return j.state === u ? (h(), T) : (g(m, j, q), j.runner); if (a('cancel', q, j)) if (j.state === u)j.runner.end(); else { if (!j.structural) return g(m, j, q), j.runner; j.close() } else { if (a('join', q, j)) { if (j.state !== u) return b(m, D ? e : null, f), e = q.event = j.event, f = g(m, j, q), j.runner; E(m, q) } } } else E(m, q); let X = q.structural; if (X || (X = q.event === 'animate' && Object.keys(q.options.to || {}).length > 0 || o(q)), !X) return h(), L(v), T; const Y = (j.counter || 0) + 1; return q.counter = Y, R(v, c, q), r.$$postDigest(function () { m = s(t); let n = F.get(v); const i = !n; n = n || {}; const r = m.parent() || []; const a = r.length > 0 && (n.event === 'animate' || n.structural || o(n)); if (i || n.counter !== Y || !a) return i && (nt(m, f), d(m, f)), (i || D && n.event !== e) && (f.domOperation(), T.end()), void (a || L(v)); e = !n.structural && o(n, !0) ? 'setClass' : n.event, R(v, u); const c = w(m, e, n.options); T.setHost(c), l(T, e, 'start', {}), c.done(function (t) { h(!t); const n = F.get(v); n && n.counter === Y && L(v), l(T, e, 'close', {}) }) }), T } function O (t) { const e = t.querySelectorAll('[' + wt + ']'); H(e, function (t) { const e = parseInt(t.getAttribute(wt), 10); const n = F.get(t); if (n) switch (e) { case u:n.runner.end(); case c:F.delete(t) } }) } function L (t) { t.removeAttribute(wt), F.delete(t) } function I (t, e, n) { let i; const r = m[0].body; const a = y(f); let o = t === r || t.nodeName === 'HTML'; let s = t === a; let l = !1; let c = U.get(t); let u = Q.data(t, _t); for (u && (e = y(u)); e && (s || (s = e === a), e.nodeType === N);) { const h = F.get(e) || {}; if (!l) { const p = U.get(e); if (!0 === p && !1 !== c) { c = !0; break }!1 === p && (c = !1), l = h.structural } if (J(i) || !0 === i) { const d = Q.data(e, j); q(d) && (i = d) } if (l && !1 === i) break; if (o || (o = e === r), o && s) break; e = s || !(u = Q.data(e, _t)) ? e.parentNode : y(u) } return (!l || i) && !0 !== c && s && o } function R (t, e, n) { n = n || {}, n.state = e, t.setAttribute(wt, e); const i = F.get(t); const r = i ? G(i, n) : n; F.set(t, r) } var F = new v(); var U = new v(); var z = null; var B = r.$watch(function () { return $.totalPendingRequests === 0 }, function (t) { t && (B(), r.$$postDigest(function () { r.$$postDigest(function () { z === null && (z = !0) }) })) }); var Y = Object.create(null); const tt = e.classNameFilter(); var et = tt ? function (t) { return tt.test(t) } : function () { return !0 }; var nt = h(T); var it = t.Node.prototype.contains || function (t) { return this === t || !!(16 & this.compareDocumentPosition(t)) }; var rt = { on: function (t, e, n) { const i = l(e); Y[t] = Y[t] || [], Y[t].push({ node: i, callback: n }), Q(e).on('$destroy', function () { F.get(i) || rt.off(t, e, n) }) }, off: function (t, e, n) { if (arguments.length !== 1 || K(arguments[0])) { const i = Y[t]; i && (Y[t] = arguments.length === 1 ? null : P(i, e, n)) } else { e = arguments[0]; for (const r in Y)Y[r] = P(Y[r], e) } }, pin: function (t, e) { n(X(t), 'element', 'not an element'), n(X(e), 'parentElement', 'not an element'), t.data(_t, e) }, push: function (t, e, n, i) { return n = n || {}, n.domOperation = i, D(t, e, n) }, enabled: function (t, e) { const n = arguments.length; if (n === 0)e = !!z; else { if (X(t)) { const i = y(t); n === 1 ? e = !U.get(i) : U.set(i, !e) } else e = z = !!t } return e } }; return rt }] }]; const Tt = ['$animateProvider', function (t) { function e (t, e) { t.data(s, e) } function n (t) { t.removeData(s) } function r (t) { return t.data(s) } const a = 'ng-animate-ref'; const o = this.drivers = []; var s = '$$animationRunner'; this.$get = ['$$jqLite', '$rootScope', '$injector', '$$AnimateRunner', '$$Map', '$$rAFScheduler', function (t, s, l, c, u, f) { function m (t) { function e (t) { if (t.processed) return t; t.processed = !0; const n = t.domNode; let a = n.parentNode; r.set(n, t); for (var o; a;) { if (o = r.get(a)) { o.processed || (o = e(o)); break }a = a.parentNode } return (o || i).children.push(t), t } let n; var i = { children: [] }; var r = new u(); for (n = 0; n < t.length; n++) { const a = t[n]; r.set(a.domNode, t[n] = { domNode: a.domNode, fn: a.fn, children: [] }) } for (n = 0; n < t.length; n++)e(t[n]); return (function (t) { let e; const n = []; const i = []; for (e = 0; e < t.children.length; e++)i.push(t.children[e]); let r = i.length; let a = 0; let o = []; for (e = 0; e < i.length; e++) { const s = i[e]; r <= 0 && (r = a, a = 0, n.push(o), o = []), o.push(s.fn), s.children.forEach(function (t) { a++, i.push(t) }), r-- } return o.length && n.push(o), n }(i)) } const g = []; const v = h(t); return function (u, h, b) { function x (t) { const e = '[' + a + ']'; const n = t.hasAttribute(a) ? [t] : t.querySelectorAll(e); const i = []; return H(n, function (t) { const e = t.getAttribute(a); e && e.length && i.push(t) }), i } function w (t) { const e = []; const n = {}; H(t, function (t, i) { const r = t.element; const o = y(r); const s = t.event; const l = ['enter', 'move'].indexOf(s) >= 0; const c = t.structural ? x(o) : []; if (c.length) { const u = l ? 'to' : 'from'; H(c, function (t) { const e = t.getAttribute(a); n[e] = n[e] || {}, n[e][u] = { animationID: i, element: Q(t) } }) } else e.push(t) }); const i = {}; const r = {}; return H(n, function (n, a) { const o = n.from; const s = n.to; if (!o || !s) { const l = o ? o.animationID : s.animationID; const c = l.toString(); return void (i[c] || (i[c] = !0, e.push(t[l]))) } const u = t[o.animationID]; const h = t[s.animationID]; const p = o.animationID.toString(); if (!r[p]) { const d = r[p] = { structural: !0, beforeStart: function () { u.beforeStart(), h.beforeStart() }, close: function () { u.close(), h.close() }, classes: _(u.classes, h.classes), from: u, to: h, anchors: [] }; d.classes.length ? e.push(d) : (e.push(u), e.push(h)) }r[p].anchors.push({ out: o.element, in: s.element }) }), e } function _ (t, e) { t = t.split(' '), e = e.split(' '); for (var n = [], i = 0; i < t.length; i++) { const r = t[i]; if (r.substring(0, 3) !== 'ng-') for (let a = 0; a < e.length; a++) if (r === e[a]) { n.push(r); break } } return n.join(' ') } function $ (t) { for (let e = o.length - 1; e >= 0; e--) { const n = o[e]; const i = l.get(n); const r = i(t); if (r) return r } } function T () { u.addClass(B), k && t.addClass(u, k), D && (t.removeClass(u, D), D = null) } function S (t, e) { function n (t) { const n = r(t); n && n.setHost(e) }t.from && t.to ? (n(t.from.element), n(t.to.element)) : n(t.element) } function M () { const t = r(u); !t || h === 'leave' && b.$$domOperationFired || t.end() } function C (e) { u.off('$destroy', M), n(u), v(u, b), d(u, b), b.domOperation(), k && t.removeClass(u, k), u.removeClass(B), A.complete(!e) }b = p(b); const E = ['enter', 'move', 'leave'].indexOf(h) >= 0; var A = new c({ end: function () { C() }, cancel: function () { C(!0) } }); if (!o.length) return C(), A; e(u, A); let P = i(u.attr('class'), i(b.addClass, b.removeClass)); var k = b.tempClasses; k && (P += ' ' + k, b.tempClasses = null); let D; return E && (D = 'ng-' + h + '-prepare', t.addClass(u, D)), g.push({ element: u, classes: P, event: h, structural: E, options: b, beforeStart: T, close: C }), u.on('$destroy', M), g.length > 1 ? A : (s.$$postDigest(function () { const t = []; H(g, function (e) { r(e.element) ? t.push(e) : e.close() }), g.length = 0; const e = w(t); const n = []; H(e, function (t) { n.push({ domNode: y(t.from ? t.from.element : t.element), fn: function () { t.beforeStart(); let e; const n = t.close; if (r(t.anchors ? t.from.element || t.to.element : t.element)) { const i = $(t); i && (e = i.start) } if (e) { const a = e(); a.done(function (t) { n(!t) }), S(t, a) } else n() } }) }), f(m(n)) }), A) } }] }]; const St = ['$animate', '$rootScope', function (t, e) { return { restrict: 'A', transclude: 'element', terminal: !0, priority: 600, link: function (e, n, i, r, a) { let o, s; e.$watchCollection(i.ngAnimateSwap || i.for, function (i) { o && t.leave(o), s && (s.$destroy(), s = null), (i || i === 0) && (s = e.$new(), a(s, function (e) { o = e, t.enter(e, null, n) })) }) } } }]; e.module('ngAnimate', [], function () { tt = e.noop, V = e.copy, G = e.extend, Q = e.element, H = e.forEach, W = e.isArray, K = e.isString, Z = e.isObject, J = e.isUndefined, q = e.isDefined, Y = e.isFunction, X = e.isElement }).directive('ngAnimateSwap', St).directive('ngAnimateChildren', ut).factory('$$rAFScheduler', ct).provider('$$animateQueue', $t).provider('$$animation', Tt).provider('$animateCss', vt).provider('$$animateCssDriver', yt).provider('$$animateJs', bt).provider('$$animateJsDriver', xt)
}(window, window.angular)), (function () {
  'use strict'; const t = function (n, i) {
    function r () { return g.params.direction === 'horizontal' } function a () { g.autoplayTimeoutId = setTimeout(function () { g.params.loop ? (g.fixLoop(), g._slideNext()) : g.isEnd ? i.autoplayStopOnLast ? g.stopAutoplay() : g._slideTo(0) : g._slideNext() }, g.params.autoplay) } function o (t, e) { let n = v(t.target); if (!n.is(e)) if (typeof e === 'string')n = n.parents(e); else if (e.nodeType) { let i; return n.parents().each(function (t, n) { n === e && (i = e) }), i ? e : void 0 } if (n.length !== 0) return n[0] } function s (t, e) { e = e || {}; const n = window.MutationObserver || window.WebkitMutationObserver; const i = new n(function (t) { t.forEach(function (t) { g.onResize(!0), g.emit('onObserverUpdate', g, t) }) }); i.observe(t, { attributes: void 0 === e.attributes || e.attributes, childList: void 0 === e.childList || e.childList, characterData: void 0 === e.characterData || e.characterData }), g.observers.push(i) } function l (t) { t.originalEvent && (t = t.originalEvent); const e = t.keyCode || t.charCode; if (!g.params.allowSwipeToNext && (r() && e === 39 || !r() && e === 40)) return !1; if (!g.params.allowSwipeToPrev && (r() && e === 37 || !r() && e === 38)) return !1; if (!(t.shiftKey || t.altKey || t.ctrlKey || t.metaKey || document.activeElement && document.activeElement.nodeName && (document.activeElement.nodeName.toLowerCase() === 'input' || document.activeElement.nodeName.toLowerCase() === 'textarea'))) { if (e === 37 || e === 39 || e === 38 || e === 40) { let n = !1; if (g.container.parents('.swiper-slide').length > 0 && g.container.parents('.swiper-slide-active').length === 0) return; const i = { left: window.pageXOffset, top: window.pageYOffset }; const a = window.innerWidth; const o = window.innerHeight; const s = g.container.offset(); g.rtl && (s.left = s.left - g.container[0].scrollLeft); for (let l = [[s.left, s.top], [s.left + g.width, s.top], [s.left, s.top + g.height], [s.left + g.width, s.top + g.height]], c = 0; c < l.length; c++) { const u = l[c]; u[0] >= i.left && u[0] <= i.left + a && u[1] >= i.top && u[1] <= i.top + o && (n = !0) } if (!n) return }r() ? (e !== 37 && e !== 39 || (t.preventDefault ? t.preventDefault() : t.returnValue = !1), (e === 39 && !g.rtl || e === 37 && g.rtl) && g.slideNext(), (e === 37 && !g.rtl || e === 39 && g.rtl) && g.slidePrev()) : (e !== 38 && e !== 40 || (t.preventDefault ? t.preventDefault() : t.returnValue = !1), e === 40 && g.slideNext(), e === 38 && g.slidePrev()) } } function c (t) { t.originalEvent && (t = t.originalEvent); const e = g.mousewheel.event; let n = 0; if (t.detail)n = -t.detail; else if (e === 'mousewheel') if (g.params.mousewheelForceToAxis) if (r()) { if (!(Math.abs(t.wheelDeltaX) > Math.abs(t.wheelDeltaY))) return; n = t.wheelDeltaX } else { if (!(Math.abs(t.wheelDeltaY) > Math.abs(t.wheelDeltaX))) return; n = t.wheelDeltaY } else n = t.wheelDelta; else if (e === 'DOMMouseScroll')n = -t.detail; else if (e === 'wheel') if (g.params.mousewheelForceToAxis) if (r()) { if (!(Math.abs(t.deltaX) > Math.abs(t.deltaY))) return; n = -t.deltaX } else { if (!(Math.abs(t.deltaY) > Math.abs(t.deltaX))) return; n = -t.deltaY } else n = Math.abs(t.deltaX) > Math.abs(t.deltaY) ? -t.deltaX : -t.deltaY; if (g.params.mousewheelInvert && (n = -n), g.params.freeMode) { let i = g.getWrapperTranslate() + n; if (i > 0 && (i = 0), i < g.maxTranslate() && (i = g.maxTranslate()), g.setWrapperTransition(0), g.setWrapperTranslate(i), g.updateProgress(), g.updateActiveIndex(), g.params.freeModeSticky && (clearTimeout(g.mousewheel.timeout), g.mousewheel.timeout = setTimeout(function () { g.slideReset() }, 300)), i === 0 || i === g.maxTranslate()) return } else { if ((new window.Date()).getTime() - g.mousewheel.lastScrollTime > 60) if (n < 0) if (g.isEnd) { if (g.params.mousewheelReleaseOnEdges) return !0 } else g.slideNext(); else if (g.isBeginning) { if (g.params.mousewheelReleaseOnEdges) return !0 } else g.slidePrev(); g.mousewheel.lastScrollTime = (new window.Date()).getTime() } return g.params.autoplay && g.stopAutoplay(), t.preventDefault ? t.preventDefault() : t.returnValue = !1, !1 } function u (t, e) { t = v(t); let n, i, a; n = t.attr('data-swiper-parallax') || '0', i = t.attr('data-swiper-parallax-x'), a = t.attr('data-swiper-parallax-y'), i || a ? (i = i || '0', a = a || '0') : r() ? (i = n, a = '0') : (a = n, i = '0'), i = i.indexOf('%') >= 0 ? parseInt(i, 10) * e + '%' : i * e + 'px', a = a.indexOf('%') >= 0 ? parseInt(a, 10) * e + '%' : a * e + 'px', t.transform('translate3d(' + i + ', ' + a + ',0px)') } function h (t) { return t.indexOf('on') !== 0 && (t = t[0] !== t[0].toUpperCase() ? 'on' + t[0].toUpperCase() + t.substring(1) : 'on' + t), t } if (!(this instanceof t)) return new t(n, i); const p = { direction: 'horizontal', touchEventsTarget: 'container', initialSlide: 0, speed: 300, autoplay: !1, autoplayDisableOnInteraction: !0, freeMode: !1, freeModeMomentum: !0, freeModeMomentumRatio: 1, freeModeMomentumBounce: !0, freeModeMomentumBounceRatio: 1, freeModeSticky: !1, setWrapperSize: !1, virtualTranslate: !1, effect: 'slide', coverflow: { rotate: 50, stretch: 0, depth: 100, modifier: 1, slideShadows: !0 }, cube: { slideShadows: !0, shadow: !0, shadowOffset: 20, shadowScale: 0.94 }, fade: { crossFade: !1 }, parallax: !1, scrollbar: null, scrollbarHide: !0, keyboardControl: !1, mousewheelControl: !1, mousewheelReleaseOnEdges: !1, mousewheelInvert: !1, mousewheelForceToAxis: !1, hashnav: !1, spaceBetween: 0, slidesPerView: 1, slidesPerColumn: 1, slidesPerColumnFill: 'column', slidesPerGroup: 1, centeredSlides: !1, touchRatio: 1, touchAngle: 45, simulateTouch: !0, shortSwipes: !0, longSwipes: !0, longSwipesRatio: 0.5, longSwipesMs: 300, followFinger: !0, onlyExternal: !1, threshold: 0, touchMoveStopPropagation: !0, pagination: null, paginationClickable: !1, paginationHide: !1, paginationBulletRender: null, resistance: !0, resistanceRatio: 0.85, nextButton: null, prevButton: null, watchSlidesProgress: !1, watchSlidesVisibility: !1, grabCursor: !1, preventClicks: !0, preventClicksPropagation: !0, slideToClickedSlide: !1, lazyLoading: !1, lazyLoadingInPrevNext: !1, lazyLoadingOnTransitionStart: !1, preloadImages: !0, updateOnImagesReady: !0, loop: !1, loopAdditionalSlides: 0, loopedSlides: null, control: void 0, controlInverse: !1, allowSwipeToPrev: !0, allowSwipeToNext: !0, swipeHandler: null, noSwiping: !0, noSwipingClass: 'swiper-no-swiping', slideClass: 'swiper-slide', slideActiveClass: 'swiper-slide-active', slideVisibleClass: 'swiper-slide-visible', slideDuplicateClass: 'swiper-slide-duplicate', slideNextClass: 'swiper-slide-next', slidePrevClass: 'swiper-slide-prev', wrapperClass: 'swiper-wrapper', bulletClass: 'swiper-pagination-bullet', bulletActiveClass: 'swiper-pagination-bullet-active', buttonDisabledClass: 'swiper-button-disabled', paginationHiddenClass: 'swiper-pagination-hidden', observer: !1, observeParents: !1, a11y: !1, prevSlideMessage: 'Previous slide', nextSlideMessage: 'Next slide', firstSlideMessage: 'This is the first slide', lastSlideMessage: 'This is the last slide', runCallbacksOnInit: !0 }; const d = i && i.virtualTranslate; i = i || {}; for (const f in p) if (void 0 === i[f])i[f] = p[f]; else if (typeof i[f] === 'object') for (const m in p[f]) void 0 === i[f][m] && (i[f][m] = p[f][m]); var g = this; g.version = '3.0.8', g.params = i, g.classNames = []; let v; if ((v = void 0 === e ? window.Dom7 || window.Zepto || window.jQuery : e) && (g.$ = v, g.container = v(n), g.container.length !== 0)) {
      if (g.container.length > 1) return void g.container.each(function () { new t(this, i) }); g.container[0].swiper = g, g.container.data('swiper', g), g.classNames.push('swiper-container-' + g.params.direction), g.params.freeMode && g.classNames.push('swiper-container-free-mode'), g.support.flexbox || (g.classNames.push('swiper-container-no-flexbox'), g.params.slidesPerColumn = 1), (g.params.parallax || g.params.watchSlidesVisibility) && (g.params.watchSlidesProgress = !0), ['cube', 'coverflow'].indexOf(g.params.effect) >= 0 && (g.support.transforms3d ? (g.params.watchSlidesProgress = !0, g.classNames.push('swiper-container-3d')) : g.params.effect = 'slide'), g.params.effect !== 'slide' && g.classNames.push('swiper-container-' + g.params.effect), g.params.effect === 'cube' && (g.params.resistanceRatio = 0, g.params.slidesPerView = 1, g.params.slidesPerColumn = 1, g.params.slidesPerGroup = 1, g.params.centeredSlides = !1, g.params.spaceBetween = 0, g.params.virtualTranslate = !0, g.params.setWrapperSize = !1), g.params.effect === 'fade' && (g.params.slidesPerView = 1, g.params.slidesPerColumn = 1, g.params.slidesPerGroup = 1, g.params.watchSlidesProgress = !0, g.params.spaceBetween = 0, void 0 === d && (g.params.virtualTranslate = !0)), g.params.grabCursor && g.support.touch && (g.params.grabCursor = !1), g.wrapper = g.container.children('.' + g.params.wrapperClass), g.params.pagination && (g.paginationContainer = v(g.params.pagination), g.params.paginationClickable && g.paginationContainer.addClass('swiper-pagination-clickable')), g.rtl = r() && (g.container[0].dir.toLowerCase() === 'rtl' || g.container.css('direction') === 'rtl'), g.rtl && g.classNames.push('swiper-container-rtl'), g.rtl && (g.wrongRTL = g.wrapper.css('display') === '-webkit-box'), g.params.slidesPerColumn > 1 && g.classNames.push('swiper-container-multirow'), g.device.android && g.classNames.push('swiper-container-android'), g.container.addClass(g.classNames.join(' ')), g.translate = 0, g.progress = 0, g.velocity = 0, g.lockSwipeToNext = function () { g.params.allowSwipeToNext = !1 }, g.lockSwipeToPrev = function () { g.params.allowSwipeToPrev = !1 }, g.lockSwipes = function () { g.params.allowSwipeToNext = g.params.allowSwipeToPrev = !1 }, g.unlockSwipeToNext = function () { g.params.allowSwipeToNext = !0 }, g.unlockSwipeToPrev = function () { g.params.allowSwipeToPrev = !0 }, g.unlockSwipes = function () { g.params.allowSwipeToNext = g.params.allowSwipeToPrev = !0 }, g.params.grabCursor && (g.container[0].style.cursor = 'move', g.container[0].style.cursor = '-webkit-grab', g.container[0].style.cursor = '-moz-grab', g.container[0].style.cursor = 'grab'), g.imagesToLoad = [], g.imagesLoaded = 0, g.loadImage = function (t, e, n, i) { function r () { i && i() } let a; t.complete && n ? r() : e ? (a = new window.Image(), a.onload = r, a.onerror = r, a.src = e) : r() }, g.preloadImages = function () { function t () { void 0 !== g && g !== null && (void 0 !== g.imagesLoaded && g.imagesLoaded++, g.imagesLoaded === g.imagesToLoad.length && (g.params.updateOnImagesReady && g.update(), g.emit('onImagesReady', g))) }g.imagesToLoad = g.container.find('img'); for (let e = 0; e < g.imagesToLoad.length; e++)g.loadImage(g.imagesToLoad[e], g.imagesToLoad[e].currentSrc || g.imagesToLoad[e].getAttribute('src'), !0, t) }, g.autoplayTimeoutId = void 0, g.autoplaying = !1, g.autoplayPaused = !1, g.startAutoplay = function () { return void 0 === g.autoplayTimeoutId && (!!g.params.autoplay && (!g.autoplaying && (g.autoplaying = !0, g.emit('onAutoplayStart', g), void a()))) }, g.stopAutoplay = function (t) { g.autoplayTimeoutId && (g.autoplayTimeoutId && clearTimeout(g.autoplayTimeoutId), g.autoplaying = !1, g.autoplayTimeoutId = void 0, g.emit('onAutoplayStop', g)) }, g.pauseAutoplay = function (t) { g.autoplayPaused || (g.autoplayTimeoutId && clearTimeout(g.autoplayTimeoutId), g.autoplayPaused = !0, t === 0 ? (g.autoplayPaused = !1, a()) : g.wrapper.transitionEnd(function () { g && (g.autoplayPaused = !1, g.autoplaying ? a() : g.stopAutoplay()) })) }, g.minTranslate = function () { return -g.snapGrid[0] }, g.maxTranslate = function () { return -g.snapGrid[g.snapGrid.length - 1] }, g.updateContainerSize = function () { let t, e; t = void 0 !== g.params.width ? g.params.width : g.container[0].clientWidth, e = void 0 !== g.params.height ? g.params.height : g.container[0].clientHeight, t === 0 && r() || e === 0 && !r() || (g.width = t, g.height = e, g.size = r() ? g.width : g.height) }, g.updateSlidesSize = function () { g.slides = g.wrapper.children('.' + g.params.slideClass), g.snapGrid = [], g.slidesGrid = [], g.slidesSizesGrid = []; let t; let e = g.params.spaceBetween; let n = 0; let i = 0; let a = 0; typeof e === 'string' && e.indexOf('%') >= 0 && (e = parseFloat(e.replace('%', '')) / 100 * g.size), g.virtualSize = -e, g.rtl ? g.slides.css({ marginLeft: '', marginTop: '' }) : g.slides.css({ marginRight: '', marginBottom: '' }); let o; g.params.slidesPerColumn > 1 && (o = Math.floor(g.slides.length / g.params.slidesPerColumn) === g.slides.length / g.params.slidesPerColumn ? g.slides.length : Math.ceil(g.slides.length / g.params.slidesPerColumn) * g.params.slidesPerColumn); let s; const l = g.params.slidesPerColumn; const c = o / l; const u = c - (g.params.slidesPerColumn * c - g.slides.length); for (t = 0; t < g.slides.length; t++) { s = 0; const h = g.slides.eq(t); if (g.params.slidesPerColumn > 1) { var p, d, f; g.params.slidesPerColumnFill === 'column' ? (d = Math.floor(t / l), f = t - d * l, (d > u || d === u && f === l - 1) && ++f >= l && (f = 0, d++), p = d + f * o / l, h.css({ '-webkit-box-ordinal-group': p, '-moz-box-ordinal-group': p, '-ms-flex-order': p, '-webkit-order': p, order: p })) : (f = Math.floor(t / c), d = t - f * c), h.css({ 'margin-top': f !== 0 && g.params.spaceBetween && g.params.spaceBetween + 'px' }).attr('data-swiper-column', d).attr('data-swiper-row', f) }h.css('display') !== 'none' && (g.params.slidesPerView === 'auto' ? s = r() ? h.outerWidth(!0) : h.outerHeight(!0) : (s = (g.size - (g.params.slidesPerView - 1) * e) / g.params.slidesPerView, r() ? g.slides[t].style.width = s + 'px' : g.slides[t].style.height = s + 'px'), g.slides[t].swiperSlideSize = s, g.slidesSizesGrid.push(s), g.params.centeredSlides ? (n = n + s / 2 + i / 2 + e, t === 0 && (n = n - g.size / 2 - e), Math.abs(n) < 0.001 && (n = 0), a % g.params.slidesPerGroup == 0 && g.snapGrid.push(n), g.slidesGrid.push(n)) : (a % g.params.slidesPerGroup == 0 && g.snapGrid.push(n), g.slidesGrid.push(n), n = n + s + e), g.virtualSize += s + e, i = s, a++) }g.virtualSize = Math.max(g.virtualSize, g.size); let m; if (g.rtl && g.wrongRTL && (g.params.effect === 'slide' || g.params.effect === 'coverflow') && g.wrapper.css({ width: g.virtualSize + g.params.spaceBetween + 'px' }), g.support.flexbox && !g.params.setWrapperSize || (r() ? g.wrapper.css({ width: g.virtualSize + g.params.spaceBetween + 'px' }) : g.wrapper.css({ height: g.virtualSize + g.params.spaceBetween + 'px' })), g.params.slidesPerColumn > 1 && (g.virtualSize = (s + g.params.spaceBetween) * o, g.virtualSize = Math.ceil(g.virtualSize / g.params.slidesPerColumn) - g.params.spaceBetween, g.wrapper.css({ width: g.virtualSize + g.params.spaceBetween + 'px' }), g.params.centeredSlides)) { for (m = [], t = 0; t < g.snapGrid.length; t++)g.snapGrid[t] < g.virtualSize + g.snapGrid[0] && m.push(g.snapGrid[t]); g.snapGrid = m } if (!g.params.centeredSlides) { for (m = [], t = 0; t < g.snapGrid.length; t++)g.snapGrid[t] <= g.virtualSize - g.size && m.push(g.snapGrid[t]); g.snapGrid = m, Math.floor(g.virtualSize - g.size) > Math.floor(g.snapGrid[g.snapGrid.length - 1]) && g.snapGrid.push(g.virtualSize - g.size) }g.snapGrid.length === 0 && (g.snapGrid = [0]), g.params.spaceBetween !== 0 && (r() ? g.rtl ? g.slides.css({ marginLeft: e + 'px' }) : g.slides.css({ marginRight: e + 'px' }) : g.slides.css({ marginBottom: e + 'px' })), g.params.watchSlidesProgress && g.updateSlidesOffset() }, g.updateSlidesOffset = function () { for (let t = 0; t < g.slides.length; t++)g.slides[t].swiperSlideOffset = r() ? g.slides[t].offsetLeft : g.slides[t].offsetTop }, g.updateSlidesProgress = function (t) { if (void 0 === t && (t = g.translate || 0), g.slides.length !== 0) { void 0 === g.slides[0].swiperSlideOffset && g.updateSlidesOffset(); let e = g.params.centeredSlides ? -t + g.size / 2 : -t; g.rtl && (e = g.params.centeredSlides ? t - g.size / 2 : t); g.container[0].getBoundingClientRect(), r(), r(); g.slides.removeClass(g.params.slideVisibleClass); for (let n = 0; n < g.slides.length; n++) { const i = g.slides[n]; const a = !0 === g.params.centeredSlides ? i.swiperSlideSize / 2 : 0; const o = (e - i.swiperSlideOffset - a) / (i.swiperSlideSize + g.params.spaceBetween); if (g.params.watchSlidesVisibility) { const s = -(e - i.swiperSlideOffset - a); const l = s + g.slidesSizesGrid[n]; (s >= 0 && s < g.size || l > 0 && l <= g.size || s <= 0 && l >= g.size) && g.slides.eq(n).addClass(g.params.slideVisibleClass) }i.progress = g.rtl ? -o : o } } }, g.updateProgress = function (t) { void 0 === t && (t = g.translate || 0); const e = g.maxTranslate() - g.minTranslate(); e === 0 ? (g.progress = 0, g.isBeginning = g.isEnd = !0) : (g.progress = (t - g.minTranslate()) / e, g.isBeginning = g.progress <= 0, g.isEnd = g.progress >= 1), g.isBeginning && g.emit('onReachBeginning', g), g.isEnd && g.emit('onReachEnd', g), g.params.watchSlidesProgress && g.updateSlidesProgress(t), g.emit('onProgress', g, g.progress) }, g.updateActiveIndex = function () { let t; let e; let n; const i = g.rtl ? g.translate : -g.translate; for (e = 0; e < g.slidesGrid.length; e++) void 0 !== g.slidesGrid[e + 1] ? i >= g.slidesGrid[e] && i < g.slidesGrid[e + 1] - (g.slidesGrid[e + 1] - g.slidesGrid[e]) / 2 ? t = e : i >= g.slidesGrid[e] && i < g.slidesGrid[e + 1] && (t = e + 1) : i >= g.slidesGrid[e] && (t = e); (t < 0 || void 0 === t) && (t = 0), n = Math.floor(t / g.params.slidesPerGroup), n >= g.snapGrid.length && (n = g.snapGrid.length - 1), t !== g.activeIndex && (g.snapIndex = n, g.previousIndex = g.activeIndex, g.activeIndex = t, g.updateClasses()) }, g.updateClasses = function () { g.slides.removeClass(g.params.slideActiveClass + ' ' + g.params.slideNextClass + ' ' + g.params.slidePrevClass); const t = g.slides.eq(g.activeIndex); if (t.addClass(g.params.slideActiveClass), t.next('.' + g.params.slideClass).addClass(g.params.slideNextClass), t.prev('.' + g.params.slideClass).addClass(g.params.slidePrevClass), g.bullets && g.bullets.length > 0) { g.bullets.removeClass(g.params.bulletActiveClass); let e; g.params.loop ? (e = Math.ceil(g.activeIndex - g.loopedSlides) / g.params.slidesPerGroup, e > g.slides.length - 1 - 2 * g.loopedSlides && (e -= g.slides.length - 2 * g.loopedSlides), e > g.bullets.length - 1 && (e -= g.bullets.length)) : e = void 0 !== g.snapIndex ? g.snapIndex : g.activeIndex || 0, g.paginationContainer.length > 1 ? g.bullets.each(function () { v(this).index() === e && v(this).addClass(g.params.bulletActiveClass) }) : g.bullets.eq(e).addClass(g.params.bulletActiveClass) }g.params.loop || (g.params.prevButton && (g.isBeginning ? (v(g.params.prevButton).addClass(g.params.buttonDisabledClass), g.params.a11y && g.a11y && g.a11y.disable(v(g.params.prevButton))) : (v(g.params.prevButton).removeClass(g.params.buttonDisabledClass), g.params.a11y && g.a11y && g.a11y.enable(v(g.params.prevButton)))), g.params.nextButton && (g.isEnd ? (v(g.params.nextButton).addClass(g.params.buttonDisabledClass), g.params.a11y && g.a11y && g.a11y.disable(v(g.params.nextButton))) : (v(g.params.nextButton).removeClass(g.params.buttonDisabledClass), g.params.a11y && g.a11y && g.a11y.enable(v(g.params.nextButton))))) }, g.updatePagination = function () { if (g.params.pagination && g.paginationContainer && g.paginationContainer.length > 0) { for (var t = '', e = g.params.loop ? Math.ceil((g.slides.length - 2 * g.loopedSlides) / g.params.slidesPerGroup) : g.snapGrid.length, n = 0; n < e; n++)g.params.paginationBulletRender ? t += g.params.paginationBulletRender(n, g.params.bulletClass) : t += '<span class="' + g.params.bulletClass + '"></span>'; g.paginationContainer.html(t), g.bullets = g.paginationContainer.find('.' + g.params.bulletClass) } }, g.update = function (t) { function e () { n = Math.min(Math.max(g.translate, g.maxTranslate()), g.minTranslate()), g.setWrapperTranslate(n), g.updateActiveIndex(), g.updateClasses() } if (g.updateContainerSize(), g.updateSlidesSize(), g.updateProgress(), g.updatePagination(), g.updateClasses(), g.params.scrollbar && g.scrollbar && g.scrollbar.set(), t) { var n; g.params.freeMode ? e() : (g.params.slidesPerView === 'auto' && g.isEnd && !g.params.centeredSlides ? g.slideTo(g.slides.length - 1, 0, !1, !0) : g.slideTo(g.activeIndex, 0, !1, !0)) || e() } }, g.onResize = function (t) { if (g.updateContainerSize(), g.updateSlidesSize(), g.updateProgress(), (g.params.slidesPerView === 'auto' || g.params.freeMode || t) && g.updatePagination(), g.params.scrollbar && g.scrollbar && g.scrollbar.set(), g.params.freeMode) { const e = Math.min(Math.max(g.translate, g.maxTranslate()), g.minTranslate()); g.setWrapperTranslate(e), g.updateActiveIndex(), g.updateClasses() } else g.updateClasses(), g.params.slidesPerView === 'auto' && g.isEnd && !g.params.centeredSlides ? g.slideTo(g.slides.length - 1, 0, !1, !0) : g.slideTo(g.activeIndex, 0, !1, !0) }; let y = ['mousedown', 'mousemove', 'mouseup']; window.navigator.pointerEnabled ? y = ['pointerdown', 'pointermove', 'pointerup'] : window.navigator.msPointerEnabled && (y = ['MSPointerDown', 'MSPointerMove', 'MSPointerUp']), g.touchEvents = { start: g.support.touch || !g.params.simulateTouch ? 'touchstart' : y[0], move: g.support.touch || !g.params.simulateTouch ? 'touchmove' : y[1], end: g.support.touch || !g.params.simulateTouch ? 'touchend' : y[2] }, (window.navigator.pointerEnabled || window.navigator.msPointerEnabled) && (g.params.touchEventsTarget === 'container' ? g.container : g.wrapper).addClass('swiper-wp8-' + g.params.direction), g.initEvents = function (t) { const e = t ? 'off' : 'on'; const n = t ? 'removeEventListener' : 'addEventListener'; const r = g.params.touchEventsTarget === 'container' ? g.container[0] : g.wrapper[0]; const a = g.support.touch ? r : document; const o = !!g.params.nested; g.browser.ie ? (r[n](g.touchEvents.start, g.onTouchStart, !1), a[n](g.touchEvents.move, g.onTouchMove, o), a[n](g.touchEvents.end, g.onTouchEnd, !1)) : (g.support.touch && (r[n](g.touchEvents.start, g.onTouchStart, !1), r[n](g.touchEvents.move, g.onTouchMove, o), r[n](g.touchEvents.end, g.onTouchEnd, !1)), !i.simulateTouch || g.device.ios || g.device.android || (r[n]('mousedown', g.onTouchStart, !1), document[n]('mousemove', g.onTouchMove, o), document[n]('mouseup', g.onTouchEnd, !1))), window[n]('resize', g.onResize), g.params.nextButton && (v(g.params.nextButton)[e]('click', g.onClickNext), g.params.a11y && g.a11y && v(g.params.nextButton)[e]('keydown', g.a11y.onEnterKey)), g.params.prevButton && (v(g.params.prevButton)[e]('click', g.onClickPrev), g.params.a11y && g.a11y && v(g.params.prevButton)[e]('keydown', g.a11y.onEnterKey)), g.params.pagination && g.params.paginationClickable && v(g.paginationContainer)[e]('click', '.' + g.params.bulletClass, g.onClickIndex), (g.params.preventClicks || g.params.preventClicksPropagation) && r[n]('click', g.preventClicks, !0) }, g.attachEvents = function (t) { g.initEvents() }, g.detachEvents = function () { g.initEvents(!0) }, g.allowClick = !0, g.preventClicks = function (t) { g.allowClick || (g.params.preventClicks && t.preventDefault(), g.params.preventClicksPropagation && g.animating && (t.stopPropagation(), t.stopImmediatePropagation())) }, g.onClickNext = function (t) { t.preventDefault(), g.slideNext() }, g.onClickPrev = function (t) { t.preventDefault(), g.slidePrev() }, g.onClickIndex = function (t) { t.preventDefault(); let e = v(this).index() * g.params.slidesPerGroup; g.params.loop && (e += g.loopedSlides), g.slideTo(e) }, g.updateClickedSlide = function (t) { const e = o(t, '.' + g.params.slideClass); let n = !1; if (e) for (let i = 0; i < g.slides.length; i++)g.slides[i] === e && (n = !0); if (!e || !n) return g.clickedSlide = void 0, void (g.clickedIndex = void 0); if (g.clickedSlide = e, g.clickedIndex = v(e).index(), g.params.slideToClickedSlide && void 0 !== g.clickedIndex && g.clickedIndex !== g.activeIndex) { let r; let a = g.clickedIndex; if (g.params.loop) if (r = v(g.clickedSlide).attr('data-swiper-slide-index'), a > g.slides.length - g.params.slidesPerView)g.fixLoop(), a = g.wrapper.children('.' + g.params.slideClass + '[data-swiper-slide-index="' + r + '"]').eq(0).index(), setTimeout(function () { g.slideTo(a) }, 0); else if (a < g.params.slidesPerView - 1) { g.fixLoop(); const s = g.wrapper.children('.' + g.params.slideClass + '[data-swiper-slide-index="' + r + '"]'); a = s.eq(s.length - 1).index(), setTimeout(function () { g.slideTo(a) }, 0) } else g.slideTo(a); else g.slideTo(a) } }; let b; let x; let w; let _; let $; let T; let S; let M; let C; const E = 'input, select, textarea, button'; let A = Date.now(); const P = []; g.animating = !1, g.touches = { startX: 0, startY: 0, currentX: 0, currentY: 0, diff: 0 }; let k, D; if (g.onTouchStart = function (t) { if (t.originalEvent && (t = t.originalEvent), (k = t.type === 'touchstart') || !('which' in t) || t.which !== 3) { if (g.params.noSwiping && o(t, '.' + g.params.noSwipingClass)) return void (g.allowClick = !0); if (!g.params.swipeHandler || o(t, g.params.swipeHandler)) { if (b = !0, x = !1, _ = void 0, D = void 0, g.touches.startX = g.touches.currentX = t.type === 'touchstart' ? t.targetTouches[0].pageX : t.pageX, g.touches.startY = g.touches.currentY = t.type === 'touchstart' ? t.targetTouches[0].pageY : t.pageY, w = Date.now(), g.allowClick = !0, g.updateContainerSize(), g.swipeDirection = void 0, g.params.threshold > 0 && (S = !1), t.type !== 'touchstart') { let e = !0; v(t.target).is(E) && (e = !1), document.activeElement && v(document.activeElement).is(E) && document.activeElement.blur(), e && t.preventDefault() }g.emit('onTouchStart', g, t) } } }, g.onTouchMove = function (t) { if (t.originalEvent && (t = t.originalEvent), !(k && t.type === 'mousemove' || t.preventedByNestedSwiper)) { if (g.params.onlyExternal) return x = !0, void (g.allowClick = !1); if (k && document.activeElement && t.target === document.activeElement && v(t.target).is(E)) return x = !0, void (g.allowClick = !1); if (g.emit('onTouchMove', g, t), !(t.targetTouches && t.targetTouches.length > 1)) { if (g.touches.currentX = t.type === 'touchmove' ? t.targetTouches[0].pageX : t.pageX, g.touches.currentY = t.type === 'touchmove' ? t.targetTouches[0].pageY : t.pageY, void 0 === _) { const e = 180 * Math.atan2(Math.abs(g.touches.currentY - g.touches.startY), Math.abs(g.touches.currentX - g.touches.startX)) / Math.PI; _ = r() ? e > g.params.touchAngle : 90 - e > g.params.touchAngle } if (_ && g.emit('onTouchMoveOpposite', g, t), void 0 === D && g.browser.ieTouch && (g.touches.currentX === g.touches.startX && g.touches.currentY === g.touches.startY || (D = !0)), b) { if (_) return void (b = !1); if (D || !g.browser.ieTouch) { g.allowClick = !1, g.emit('onSliderMove', g, t), t.preventDefault(), g.params.touchMoveStopPropagation && !g.params.nested && t.stopPropagation(), x || (i.loop && g.fixLoop(), T = g.getWrapperTranslate(), g.setWrapperTransition(0), g.animating && g.wrapper.trigger('webkitTransitionEnd transitionend oTransitionEnd MSTransitionEnd msTransitionEnd'), g.params.autoplay && g.autoplaying && (g.params.autoplayDisableOnInteraction ? g.stopAutoplay() : g.pauseAutoplay()), C = !1, g.params.grabCursor && (g.container[0].style.cursor = 'move', g.container[0].style.cursor = '-webkit-grabbing', g.container[0].style.cursor = '-moz-grabbin', g.container[0].style.cursor = 'grabbing')), x = !0; let n = g.touches.diff = r() ? g.touches.currentX - g.touches.startX : g.touches.currentY - g.touches.startY; n *= g.params.touchRatio, g.rtl && (n = -n), g.swipeDirection = n > 0 ? 'prev' : 'next', $ = n + T; let a = !0; if (n > 0 && $ > g.minTranslate() ? (a = !1, g.params.resistance && ($ = g.minTranslate() - 1 + Math.pow(-g.minTranslate() + T + n, g.params.resistanceRatio))) : n < 0 && $ < g.maxTranslate() && (a = !1, g.params.resistance && ($ = g.maxTranslate() + 1 - Math.pow(g.maxTranslate() - T - n, g.params.resistanceRatio))), a && (t.preventedByNestedSwiper = !0), !g.params.allowSwipeToNext && g.swipeDirection === 'next' && $ < T && ($ = T), !g.params.allowSwipeToPrev && g.swipeDirection === 'prev' && $ > T && ($ = T), g.params.followFinger) { if (g.params.threshold > 0) { if (!(Math.abs(n) > g.params.threshold || S)) return void ($ = T); if (!S) return S = !0, g.touches.startX = g.touches.currentX, g.touches.startY = g.touches.currentY, $ = T, void (g.touches.diff = r() ? g.touches.currentX - g.touches.startX : g.touches.currentY - g.touches.startY) }(g.params.freeMode || g.params.watchSlidesProgress) && g.updateActiveIndex(), g.params.freeMode && (P.length === 0 && P.push({ position: g.touches[r() ? 'startX' : 'startY'], time: w }), P.push({ position: g.touches[r() ? 'currentX' : 'currentY'], time: (new window.Date()).getTime() })), g.updateProgress($), g.setWrapperTranslate($) } } } } } }, g.onTouchEnd = function (t) { if (t.originalEvent && (t = t.originalEvent), g.emit('onTouchEnd', g, t), b) { g.params.grabCursor && x && b && (g.container[0].style.cursor = 'move', g.container[0].style.cursor = '-webkit-grab', g.container[0].style.cursor = '-moz-grab', g.container[0].style.cursor = 'grab'); const e = Date.now(); const n = e - w; if (g.allowClick && (g.updateClickedSlide(t), g.emit('onTap', g, t), n < 300 && e - A > 300 && (M && clearTimeout(M), M = setTimeout(function () { g && (g.params.paginationHide && g.paginationContainer.length > 0 && !v(t.target).hasClass(g.params.bulletClass) && g.paginationContainer.toggleClass(g.params.paginationHiddenClass), g.emit('onClick', g, t)) }, 300)), n < 300 && e - A < 300 && (M && clearTimeout(M), g.emit('onDoubleTap', g, t))), A = Date.now(), setTimeout(function () { g && (g.allowClick = !0) }, 0), !b || !x || !g.swipeDirection || g.touches.diff === 0 || $ === T) return void (b = x = !1); b = x = !1; let i; if (i = g.params.followFinger ? g.rtl ? g.translate : -g.translate : -$, g.params.freeMode) { if (i < -g.minTranslate()) return void g.slideTo(g.activeIndex); if (i > -g.maxTranslate()) return void (g.slides.length < g.snapGrid.length ? g.slideTo(g.snapGrid.length - 1) : g.slideTo(g.slides.length - 1)); if (g.params.freeModeMomentum) { if (P.length > 1) { const r = P.pop(); const a = P.pop(); const o = r.position - a.position; const s = r.time - a.time; g.velocity = o / s, g.velocity = g.velocity / 2, Math.abs(g.velocity) < 0.02 && (g.velocity = 0), (s > 150 || (new window.Date()).getTime() - r.time > 300) && (g.velocity = 0) } else g.velocity = 0; P.length = 0; let l = 1e3 * g.params.freeModeMomentumRatio; const c = g.velocity * l; let u = g.translate + c; g.rtl && (u = -u); let h; let p = !1; const d = 20 * Math.abs(g.velocity) * g.params.freeModeMomentumBounceRatio; if (u < g.maxTranslate())g.params.freeModeMomentumBounce ? (u + g.maxTranslate() < -d && (u = g.maxTranslate() - d), h = g.maxTranslate(), p = !0, C = !0) : u = g.maxTranslate(); else if (u > g.minTranslate())g.params.freeModeMomentumBounce ? (u - g.minTranslate() > d && (u = g.minTranslate() + d), h = g.minTranslate(), p = !0, C = !0) : u = g.minTranslate(); else if (g.params.freeModeSticky) { let f; let m = 0; for (m = 0; m < g.snapGrid.length; m += 1) if (g.snapGrid[m] > -u) { f = m; break }u = Math.abs(g.snapGrid[f] - u) < Math.abs(g.snapGrid[f - 1] - u) || g.swipeDirection === 'next' ? g.snapGrid[f] : g.snapGrid[f - 1], g.rtl || (u = -u) } if (g.velocity !== 0)l = g.rtl ? Math.abs((-u - g.translate) / g.velocity) : Math.abs((u - g.translate) / g.velocity); else if (g.params.freeModeSticky) return void g.slideReset(); g.params.freeModeMomentumBounce && p ? (g.updateProgress(h), g.setWrapperTransition(l), g.setWrapperTranslate(u), g.onTransitionStart(), g.animating = !0, g.wrapper.transitionEnd(function () { g && C && (g.emit('onMomentumBounce', g), g.setWrapperTransition(g.params.speed), g.setWrapperTranslate(h), g.wrapper.transitionEnd(function () { g && g.onTransitionEnd() })) })) : g.velocity ? (g.updateProgress(u), g.setWrapperTransition(l), g.setWrapperTranslate(u), g.onTransitionStart(), g.animating || (g.animating = !0, g.wrapper.transitionEnd(function () { g && g.onTransitionEnd() }))) : g.updateProgress(u), g.updateActiveIndex() } return void ((!g.params.freeModeMomentum || n >= g.params.longSwipesMs) && (g.updateProgress(), g.updateActiveIndex())) } let y; let _ = 0; let S = g.slidesSizesGrid[0]; for (y = 0; y < g.slidesGrid.length; y += g.params.slidesPerGroup) void 0 !== g.slidesGrid[y + g.params.slidesPerGroup] ? i >= g.slidesGrid[y] && i < g.slidesGrid[y + g.params.slidesPerGroup] && (_ = y, S = g.slidesGrid[y + g.params.slidesPerGroup] - g.slidesGrid[y]) : i >= g.slidesGrid[y] && (_ = y, S = g.slidesGrid[g.slidesGrid.length - 1] - g.slidesGrid[g.slidesGrid.length - 2]); const E = (i - g.slidesGrid[_]) / S; if (n > g.params.longSwipesMs) { if (!g.params.longSwipes) return void g.slideTo(g.activeIndex); g.swipeDirection === 'next' && (E >= g.params.longSwipesRatio ? g.slideTo(_ + g.params.slidesPerGroup) : g.slideTo(_)), g.swipeDirection === 'prev' && (E > 1 - g.params.longSwipesRatio ? g.slideTo(_ + g.params.slidesPerGroup) : g.slideTo(_)) } else { if (!g.params.shortSwipes) return void g.slideTo(g.activeIndex); g.swipeDirection === 'next' && g.slideTo(_ + g.params.slidesPerGroup), g.swipeDirection === 'prev' && g.slideTo(_) } } }, g._slideTo = function (t, e) { return g.slideTo(t, e, !0, !0) }, g.slideTo = function (t, e, n, i) {
        void 0 === n && (n = !0), void 0 === t && (t = 0), t < 0 && (t = 0),
        g.snapIndex = Math.floor(t / g.params.slidesPerGroup), g.snapIndex >= g.snapGrid.length && (g.snapIndex = g.snapGrid.length - 1); const a = -g.snapGrid[g.snapIndex]; if (!g.params.allowSwipeToNext && a < g.translate && a < g.minTranslate()) return !1; if (!g.params.allowSwipeToPrev && a > g.translate && a > g.maxTranslate()) return !1; g.params.autoplay && g.autoplaying && (i || !g.params.autoplayDisableOnInteraction ? g.pauseAutoplay(e) : g.stopAutoplay()), g.updateProgress(a); for (let o = 0; o < g.slidesGrid.length; o++)-a >= g.slidesGrid[o] && (t = o); if (void 0 === e && (e = g.params.speed), g.previousIndex = g.activeIndex || 0, g.activeIndex = t, a === g.translate) return g.updateClasses(), !1; g.updateClasses(), g.onTransitionStart(n); r(), r(); return e === 0 ? (g.setWrapperTransition(0), g.setWrapperTranslate(a), g.onTransitionEnd(n)) : (g.setWrapperTransition(e), g.setWrapperTranslate(a), g.animating || (g.animating = !0, g.wrapper.transitionEnd(function () { g && g.onTransitionEnd(n) }))), !0
      }, g.onTransitionStart = function (t) { void 0 === t && (t = !0), g.lazy && g.lazy.onTransitionStart(), t && (g.emit('onTransitionStart', g), g.activeIndex !== g.previousIndex && g.emit('onSlideChangeStart', g)) }, g.onTransitionEnd = function (t) { g.animating = !1, g.setWrapperTransition(0), void 0 === t && (t = !0), g.lazy && g.lazy.onTransitionEnd(), t && (g.emit('onTransitionEnd', g), g.activeIndex !== g.previousIndex && g.emit('onSlideChangeEnd', g)), g.params.hashnav && g.hashnav && g.hashnav.setHash() }, g.slideNext = function (t, e, n) { if (g.params.loop) { if (g.animating) return !1; g.fixLoop(); g.container[0].clientLeft; return g.slideTo(g.activeIndex + g.params.slidesPerGroup, e, t, n) } return g.slideTo(g.activeIndex + g.params.slidesPerGroup, e, t, n) }, g._slideNext = function (t) { return g.slideNext(!0, t, !0) }, g.slidePrev = function (t, e, n) { if (g.params.loop) { if (g.animating) return !1; g.fixLoop(); g.container[0].clientLeft; return g.slideTo(g.activeIndex - 1, e, t, n) } return g.slideTo(g.activeIndex - 1, e, t, n) }, g._slidePrev = function (t) { return g.slidePrev(!0, t, !0) }, g.slideReset = function (t, e, n) { return g.slideTo(g.activeIndex, e, t) }, g.setWrapperTransition = function (t, e) { g.wrapper.transition(t), g.params.effect !== 'slide' && g.effects[g.params.effect] && g.effects[g.params.effect].setTransition(t), g.params.parallax && g.parallax && g.parallax.setTransition(t), g.params.scrollbar && g.scrollbar && g.scrollbar.setTransition(t), g.params.control && g.controller && g.controller.setTransition(t, e), g.emit('onSetTransition', g, t) }, g.setWrapperTranslate = function (t, e, n) { let i = 0; let a = 0; r() ? i = g.rtl ? -t : t : a = t, g.params.virtualTranslate || (g.support.transforms3d ? g.wrapper.transform('translate3d(' + i + 'px, ' + a + 'px, 0px)') : g.wrapper.transform('translate(' + i + 'px, ' + a + 'px)')), g.translate = r() ? i : a, e && g.updateActiveIndex(), g.params.effect !== 'slide' && g.effects[g.params.effect] && g.effects[g.params.effect].setTranslate(g.translate), g.params.parallax && g.parallax && g.parallax.setTranslate(g.translate), g.params.scrollbar && g.scrollbar && g.scrollbar.setTranslate(g.translate), g.params.control && g.controller && g.controller.setTranslate(g.translate, n), g.emit('onSetTranslate', g, g.translate) }, g.getTranslate = function (t, e) { let n, i, r, a; return void 0 === e && (e = 'x'), g.params.virtualTranslate ? g.rtl ? -g.translate : g.translate : (r = window.getComputedStyle(t, null), window.WebKitCSSMatrix ? a = new window.WebKitCSSMatrix(r.webkitTransform === 'none' ? '' : r.webkitTransform) : (a = r.MozTransform || r.OTransform || r.MsTransform || r.msTransform || r.transform || r.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,'), n = a.toString().split(',')), e === 'x' && (i = window.WebKitCSSMatrix ? a.m41 : n.length === 16 ? parseFloat(n[12]) : parseFloat(n[4])), e === 'y' && (i = window.WebKitCSSMatrix ? a.m42 : n.length === 16 ? parseFloat(n[13]) : parseFloat(n[5])), g.rtl && i && (i = -i), i || 0) }, g.getWrapperTranslate = function (t) { return void 0 === t && (t = r() ? 'x' : 'y'), g.getTranslate(g.wrapper[0], t) }, g.observers = [], g.initObservers = function () { if (g.params.observeParents) for (let t = g.container.parents(), e = 0; e < t.length; e++)s(t[e]); s(g.container[0], { childList: !1 }), s(g.wrapper[0], { attributes: !1 }) }, g.disconnectObservers = function () { for (let t = 0; t < g.observers.length; t++)g.observers[t].disconnect(); g.observers = [] }, g.createLoop = function () { g.wrapper.children('.' + g.params.slideClass + '.' + g.params.slideDuplicateClass).remove(); const t = g.wrapper.children('.' + g.params.slideClass); g.loopedSlides = parseInt(g.params.loopedSlides || g.params.slidesPerView, 10), g.loopedSlides = g.loopedSlides + g.params.loopAdditionalSlides, g.loopedSlides > t.length && (g.loopedSlides = t.length); let e; const n = []; const i = []; for (t.each(function (e, r) { const a = v(this); e < g.loopedSlides && i.push(r), e < t.length && e >= t.length - g.loopedSlides && n.push(r), a.attr('data-swiper-slide-index', e) }), e = 0; e < i.length; e++)g.wrapper.append(v(i[e].cloneNode(!0)).addClass(g.params.slideDuplicateClass)); for (e = n.length - 1; e >= 0; e--)g.wrapper.prepend(v(n[e].cloneNode(!0)).addClass(g.params.slideDuplicateClass)) }, g.destroyLoop = function () { g.wrapper.children('.' + g.params.slideClass + '.' + g.params.slideDuplicateClass).remove(), g.slides.removeAttr('data-swiper-slide-index') }, g.fixLoop = function () { let t; g.activeIndex < g.loopedSlides ? (t = g.slides.length - 3 * g.loopedSlides + g.activeIndex, t += g.loopedSlides, g.slideTo(t, 0, !1, !0)) : (g.params.slidesPerView === 'auto' && g.activeIndex >= 2 * g.loopedSlides || g.activeIndex > g.slides.length - 2 * g.params.slidesPerView) && (t = -g.slides.length + g.activeIndex + g.loopedSlides, t += g.loopedSlides, g.slideTo(t, 0, !1, !0)) }, g.appendSlide = function (t) { if (g.params.loop && g.destroyLoop(), typeof t === 'object' && t.length) for (let e = 0; e < t.length; e++)t[e] && g.wrapper.append(t[e]); else g.wrapper.append(t); g.params.loop && g.createLoop(), g.params.observer && g.support.observer || g.update(!0) }, g.prependSlide = function (t) { g.params.loop && g.destroyLoop(); let e = g.activeIndex + 1; if (typeof t === 'object' && t.length) { for (let n = 0; n < t.length; n++)t[n] && g.wrapper.prepend(t[n]); e = g.activeIndex + t.length } else g.wrapper.prepend(t); g.params.loop && g.createLoop(), g.params.observer && g.support.observer || g.update(!0), g.slideTo(e, 0, !1) }, g.removeSlide = function (t) { g.params.loop && (g.destroyLoop(), g.slides = g.wrapper.children('.' + g.params.slideClass)); let e; let n = g.activeIndex; if (typeof t === 'object' && t.length) { for (let i = 0; i < t.length; i++)e = t[i], g.slides[e] && g.slides.eq(e).remove(), e < n && n--; n = Math.max(n, 0) } else e = t, g.slides[e] && g.slides.eq(e).remove(), e < n && n--, n = Math.max(n, 0); g.params.loop && g.createLoop(), g.params.observer && g.support.observer || g.update(!0), g.params.loop ? g.slideTo(n + g.loopedSlides, 0, !1) : g.slideTo(n, 0, !1) }, g.removeAllSlides = function () { for (var t = [], e = 0; e < g.slides.length; e++)t.push(e); g.removeSlide(t) }, g.effects = { fade: { setTranslate: function () { for (let t = 0; t < g.slides.length; t++) { const e = g.slides.eq(t); const n = e[0].swiperSlideOffset; let i = -n; g.params.virtualTranslate || (i -= g.translate); let a = 0; r() || (a = i, i = 0); const o = g.params.fade.crossFade ? Math.max(1 - Math.abs(e[0].progress), 0) : 1 + Math.min(Math.max(e[0].progress, -1), 0); e.css({ opacity: o }).transform('translate3d(' + i + 'px, ' + a + 'px, 0px)') } }, setTransition: function (t) { if (g.slides.transition(t), g.params.virtualTranslate && t !== 0) { let e = !1; g.slides.transitionEnd(function () { if (!e && g) { e = !0, g.animating = !1; for (let t = ['webkitTransitionEnd', 'transitionend', 'oTransitionEnd', 'MSTransitionEnd', 'msTransitionEnd'], n = 0; n < t.length; n++)g.wrapper.trigger(t[n]) } }) } } }, cube: { setTranslate: function () { let t; let e = 0; g.params.cube.shadow && (r() ? (t = g.wrapper.find('.swiper-cube-shadow'), t.length === 0 && (t = v('<div class="swiper-cube-shadow"></div>'), g.wrapper.append(t)), t.css({ height: g.width + 'px' })) : (t = g.container.find('.swiper-cube-shadow'), t.length === 0 && (t = v('<div class="swiper-cube-shadow"></div>'), g.container.append(t)))); for (let n = 0; n < g.slides.length; n++) { const i = g.slides.eq(n); let a = 90 * n; let o = Math.floor(a / 360); g.rtl && (a = -a, o = Math.floor(-a / 360)); const s = Math.max(Math.min(i[0].progress, 1), -1); let l = 0; let c = 0; let u = 0; n % 4 == 0 ? (l = 4 * -o * g.size, u = 0) : (n - 1) % 4 == 0 ? (l = 0, u = 4 * -o * g.size) : (n - 2) % 4 == 0 ? (l = g.size + 4 * o * g.size, u = g.size) : (n - 3) % 4 == 0 && (l = -g.size, u = 3 * g.size + 4 * g.size * o), g.rtl && (l = -l), r() || (c = l, l = 0); const h = 'rotateX(' + (r() ? 0 : -a) + 'deg) rotateY(' + (r() ? a : 0) + 'deg) translate3d(' + l + 'px, ' + c + 'px, ' + u + 'px)'; if (s <= 1 && s > -1 && (e = 90 * n + 90 * s, g.rtl && (e = 90 * -n - 90 * s)), i.transform(h), g.params.cube.slideShadows) { let p = r() ? i.find('.swiper-slide-shadow-left') : i.find('.swiper-slide-shadow-top'); let d = r() ? i.find('.swiper-slide-shadow-right') : i.find('.swiper-slide-shadow-bottom'); p.length === 0 && (p = v('<div class="swiper-slide-shadow-' + (r() ? 'left' : 'top') + '"></div>'), i.append(p)), d.length === 0 && (d = v('<div class="swiper-slide-shadow-' + (r() ? 'right' : 'bottom') + '"></div>'), i.append(d)); i[0].progress; p.length && (p[0].style.opacity = -i[0].progress), d.length && (d[0].style.opacity = i[0].progress) } } if (g.wrapper.css({ '-webkit-transform-origin': '50% 50% -' + g.size / 2 + 'px', '-moz-transform-origin': '50% 50% -' + g.size / 2 + 'px', '-ms-transform-origin': '50% 50% -' + g.size / 2 + 'px', 'transform-origin': '50% 50% -' + g.size / 2 + 'px' }), g.params.cube.shadow) if (r())t.transform('translate3d(0px, ' + (g.width / 2 + g.params.cube.shadowOffset) + 'px, ' + -g.width / 2 + 'px) rotateX(90deg) rotateZ(0deg) scale(' + g.params.cube.shadowScale + ')'); else { const f = Math.abs(e) - 90 * Math.floor(Math.abs(e) / 90); const m = 1.5 - (Math.sin(2 * f * Math.PI / 360) / 2 + Math.cos(2 * f * Math.PI / 360) / 2); const y = g.params.cube.shadowScale; const b = g.params.cube.shadowScale / m; const x = g.params.cube.shadowOffset; t.transform('scale3d(' + y + ', 1, ' + b + ') translate3d(0px, ' + (g.height / 2 + x) + 'px, ' + -g.height / 2 / b + 'px) rotateX(-90deg)') } const w = g.isSafari || g.isUiWebView ? -g.size / 2 : 0; g.wrapper.transform('translate3d(0px,0,' + w + 'px) rotateX(' + (r() ? 0 : e) + 'deg) rotateY(' + (r() ? -e : 0) + 'deg)') }, setTransition: function (t) { g.slides.transition(t).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(t), g.params.cube.shadow && !r() && g.container.find('.swiper-cube-shadow').transition(t) } }, coverflow: { setTranslate: function () { for (var t = g.translate, e = r() ? -t + g.width / 2 : -t + g.height / 2, n = r() ? g.params.coverflow.rotate : -g.params.coverflow.rotate, i = g.params.coverflow.depth, a = 0, o = g.slides.length; a < o; a++) { const s = g.slides.eq(a); const l = g.slidesSizesGrid[a]; const c = s[0].swiperSlideOffset; const u = (e - c - l / 2) / l * g.params.coverflow.modifier; let h = r() ? n * u : 0; let p = r() ? 0 : n * u; let d = -i * Math.abs(u); let f = r() ? 0 : g.params.coverflow.stretch * u; let m = r() ? g.params.coverflow.stretch * u : 0; Math.abs(m) < 0.001 && (m = 0), Math.abs(f) < 0.001 && (f = 0), Math.abs(d) < 0.001 && (d = 0), Math.abs(h) < 0.001 && (h = 0), Math.abs(p) < 0.001 && (p = 0); const y = 'translate3d(' + m + 'px,' + f + 'px,' + d + 'px)  rotateX(' + p + 'deg) rotateY(' + h + 'deg)'; if (s.transform(y), s[0].style.zIndex = 1 - Math.abs(Math.round(u)), g.params.coverflow.slideShadows) { let b = r() ? s.find('.swiper-slide-shadow-left') : s.find('.swiper-slide-shadow-top'); let x = r() ? s.find('.swiper-slide-shadow-right') : s.find('.swiper-slide-shadow-bottom'); b.length === 0 && (b = v('<div class="swiper-slide-shadow-' + (r() ? 'left' : 'top') + '"></div>'), s.append(b)), x.length === 0 && (x = v('<div class="swiper-slide-shadow-' + (r() ? 'right' : 'bottom') + '"></div>'), s.append(x)), b.length && (b[0].style.opacity = u > 0 ? u : 0), x.length && (x[0].style.opacity = -u > 0 ? -u : 0) } } if (g.browser.ie) { g.wrapper[0].style.perspectiveOrigin = e + 'px 50%' } }, setTransition: function (t) { g.slides.transition(t).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(t) } } }, g.lazy = { initialImageLoaded: !1, loadImageInSlide: function (t, e) { if (void 0 !== t && (void 0 === e && (e = !0), g.slides.length !== 0)) { const n = g.slides.eq(t); const i = n.find('.swiper-lazy:not(.swiper-lazy-loaded):not(.swiper-lazy-loading)'); !n.hasClass('swiper-lazy') || n.hasClass('swiper-lazy-loaded') || n.hasClass('swiper-lazy-loading') || i.add(n[0]), i.length !== 0 && i.each(function () { const t = v(this); t.addClass('swiper-lazy-loading'); const i = t.attr('data-background'); const r = t.attr('data-src'); g.loadImage(t[0], r || i, !1, function () { if (i ? (t.css('background-image', 'url(' + i + ')'), t.removeAttr('data-background')) : (t.attr('src', r), t.removeAttr('data-src')), t.addClass('swiper-lazy-loaded').removeClass('swiper-lazy-loading'), n.find('.swiper-lazy-preloader, .preloader').remove(), g.params.loop && e) { const a = n.attr('data-swiper-slide-index'); if (n.hasClass(g.params.slideDuplicateClass)) { const o = g.wrapper.children('[data-swiper-slide-index="' + a + '"]:not(.' + g.params.slideDuplicateClass + ')'); g.lazy.loadImageInSlide(o.index(), !1) } else { const s = g.wrapper.children('.' + g.params.slideDuplicateClass + '[data-swiper-slide-index="' + a + '"]'); g.lazy.loadImageInSlide(s.index(), !1) } }g.emit('onLazyImageReady', g, n[0], t[0]) }), g.emit('onLazyImageLoad', g, n[0], t[0]) }) } }, load: function () { let t; if (g.params.watchSlidesVisibility)g.wrapper.children('.' + g.params.slideVisibleClass).each(function () { g.lazy.loadImageInSlide(v(this).index()) }); else if (g.params.slidesPerView > 1) for (t = g.activeIndex; t < g.activeIndex + g.params.slidesPerView; t++)g.slides[t] && g.lazy.loadImageInSlide(t); else g.lazy.loadImageInSlide(g.activeIndex); if (g.params.lazyLoadingInPrevNext) if (g.params.slidesPerView > 1) { for (t = g.activeIndex + g.params.slidesPerView; t < g.activeIndex + g.params.slidesPerView + g.params.slidesPerView; t++)g.slides[t] && g.lazy.loadImageInSlide(t); for (t = g.activeIndex - g.params.slidesPerView; t < g.activeIndex; t++)g.slides[t] && g.lazy.loadImageInSlide(t) } else { const e = g.wrapper.children('.' + g.params.slideNextClass); e.length > 0 && g.lazy.loadImageInSlide(e.index()); const n = g.wrapper.children('.' + g.params.slidePrevClass); n.length > 0 && g.lazy.loadImageInSlide(n.index()) } }, onTransitionStart: function () { g.params.lazyLoading && (g.params.lazyLoadingOnTransitionStart || !g.params.lazyLoadingOnTransitionStart && !g.lazy.initialImageLoaded) && g.lazy.load() }, onTransitionEnd: function () { g.params.lazyLoading && !g.params.lazyLoadingOnTransitionStart && g.lazy.load() } }, g.scrollbar = { set: function () { if (g.params.scrollbar) { const t = g.scrollbar; t.track = v(g.params.scrollbar), t.drag = t.track.find('.swiper-scrollbar-drag'), t.drag.length === 0 && (t.drag = v('<div class="swiper-scrollbar-drag"></div>'), t.track.append(t.drag)), t.drag[0].style.width = '', t.drag[0].style.height = '', t.trackSize = r() ? t.track[0].offsetWidth : t.track[0].offsetHeight, t.divider = g.size / g.virtualSize, t.moveDivider = t.divider * (t.trackSize / g.size), t.dragSize = t.trackSize * t.divider, r() ? t.drag[0].style.width = t.dragSize + 'px' : t.drag[0].style.height = t.dragSize + 'px', t.divider >= 1 ? t.track[0].style.display = 'none' : t.track[0].style.display = '', g.params.scrollbarHide && (t.track[0].style.opacity = 0) } }, setTranslate: function () { if (g.params.scrollbar) { let t; const e = g.scrollbar; let n = (g.translate, e.dragSize); t = (e.trackSize - e.dragSize) * g.progress, g.rtl && r() ? (t = -t, t > 0 ? (n = e.dragSize - t, t = 0) : -t + e.dragSize > e.trackSize && (n = e.trackSize + t)) : t < 0 ? (n = e.dragSize + t, t = 0) : t + e.dragSize > e.trackSize && (n = e.trackSize - t), r() ? (g.support.transforms3d ? e.drag.transform('translate3d(' + t + 'px, 0, 0)') : e.drag.transform('translateX(' + t + 'px)'), e.drag[0].style.width = n + 'px') : (g.support.transforms3d ? e.drag.transform('translate3d(0px, ' + t + 'px, 0)') : e.drag.transform('translateY(' + t + 'px)'), e.drag[0].style.height = n + 'px'), g.params.scrollbarHide && (clearTimeout(e.timeout), e.track[0].style.opacity = 1, e.timeout = setTimeout(function () { e.track[0].style.opacity = 0, e.track.transition(400) }, 1e3)) } }, setTransition: function (t) { g.params.scrollbar && g.scrollbar.drag.transition(t) } }, g.controller = { setTranslate: function (e, n) { function i (t) { e = t.rtl && t.params.direction === 'horizontal' ? -g.translate : g.translate, r = (t.maxTranslate() - t.minTranslate()) / (g.maxTranslate() - g.minTranslate()), a = (e - g.minTranslate()) * r + t.minTranslate(), g.params.controlInverse && (a = t.maxTranslate() - a), t.updateProgress(a), t.setWrapperTranslate(a, !1, g), t.updateActiveIndex() } let r; let a; const o = g.params.control; if (g.isArray(o)) for (let s = 0; s < o.length; s++)o[s] !== n && o[s] instanceof t && i(o[s]); else o instanceof t && n !== o && i(o) }, setTransition: function (e, n) { function i (t) { t.setWrapperTransition(e, g), e !== 0 && (t.onTransitionStart(), t.wrapper.transitionEnd(function () { a && t.onTransitionEnd() })) } let r; var a = g.params.control; if (g.isArray(a)) for (r = 0; r < a.length; r++)a[r] !== n && a[r] instanceof t && i(a[r]); else a instanceof t && n !== a && i(a) } }, g.hashnav = { init: function () { if (g.params.hashnav) { g.hashnav.initialized = !0; const t = document.location.hash.replace('#', ''); if (t) for (let e = 0, n = g.slides.length; e < n; e++) { const i = g.slides.eq(e); const r = i.attr('data-hash'); if (r === t && !i.hasClass(g.params.slideDuplicateClass)) { const a = i.index(); g.slideTo(a, 0, g.params.runCallbacksOnInit, !0) } } } }, setHash: function () { g.hashnav.initialized && g.params.hashnav && (document.location.hash = g.slides.eq(g.activeIndex).attr('data-hash') || '') } }, g.disableKeyboardControl = function () { v(document).off('keydown', l) }, g.enableKeyboardControl = function () { v(document).on('keydown', l) }, g.mousewheel = { event: !1, lastScrollTime: (new window.Date()).getTime() }, g.params.mousewheelControl) { if (void 0 !== document.onmousewheel && (g.mousewheel.event = 'mousewheel'), !g.mousewheel.event) try { new window.WheelEvent('wheel'), g.mousewheel.event = 'wheel' } catch (t) {}g.mousewheel.event || (g.mousewheel.event = 'DOMMouseScroll') }g.disableMousewheelControl = function () { return !!g.mousewheel.event && (g.container.off(g.mousewheel.event, c), !0) }, g.enableMousewheelControl = function () { return !!g.mousewheel.event && (g.container.on(g.mousewheel.event, c), !0) }, g.parallax = { setTranslate: function () { g.container.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]').each(function () { u(this, g.progress) }), g.slides.each(function () { const t = v(this); t.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]').each(function () { u(this, Math.min(Math.max(t[0].progress, -1), 1)) }) }) }, setTransition: function (t) { void 0 === t && (t = g.params.speed), g.container.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]').each(function () { const e = v(this); let n = parseInt(e.attr('data-swiper-parallax-duration'), 10) || t; t === 0 && (n = 0), e.transition(n) }) } }, g._plugins = []; for (const O in g.plugins) { const L = g.plugins[O](g, g.params[O]); L && g._plugins.push(L) } return g.callPlugins = function (t) { for (let e = 0; e < g._plugins.length; e++)t in g._plugins[e] && g._plugins[e][t](arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]) }, g.emitterEventListeners = {}, g.emit = function (t) { g.params[t] && g.params[t](arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]); let e; if (g.emitterEventListeners[t]) for (e = 0; e < g.emitterEventListeners[t].length; e++)g.emitterEventListeners[t][e](arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]); g.callPlugins && g.callPlugins(t, arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]) }, g.on = function (t, e) { return t = h(t), g.emitterEventListeners[t] || (g.emitterEventListeners[t] = []), g.emitterEventListeners[t].push(e), g }, g.off = function (t, e) { let n; if (t = h(t), void 0 === e) return g.emitterEventListeners[t] = [], g; if (g.emitterEventListeners[t] && g.emitterEventListeners[t].length !== 0) { for (n = 0; n < g.emitterEventListeners[t].length; n++)g.emitterEventListeners[t][n] === e && g.emitterEventListeners[t].splice(n, 1); return g } }, g.once = function (t, e) { t = h(t); const n = function () { e(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4]), g.off(t, n) }; return g.on(t, n), g }, g.a11y = { makeFocusable: function (t) { return t[0].tabIndex = '0', t }, addRole: function (t, e) { return t.attr('role', e), t }, addLabel: function (t, e) { return t.attr('aria-label', e), t }, disable: function (t) { return t.attr('aria-disabled', !0), t }, enable: function (t) { return t.attr('aria-disabled', !1), t }, onEnterKey: function (t) { t.keyCode === 13 && (v(t.target).is(g.params.nextButton) ? (g.onClickNext(t), g.isEnd ? g.a11y.notify(g.params.lastSlideMsg) : g.a11y.notify(g.params.nextSlideMsg)) : v(t.target).is(g.params.prevButton) && (g.onClickPrev(t), g.isBeginning ? g.a11y.notify(g.params.firstSlideMsg) : g.a11y.notify(g.params.prevSlideMsg))) }, liveRegion: v('<span class="swiper-notification" aria-live="assertive" aria-atomic="true"></span>'), notify: function (t) { const e = g.a11y.liveRegion; e.length !== 0 && (e.html(''), e.html(t)) }, init: function () { if (g.params.nextButton) { const t = v(g.params.nextButton); g.a11y.makeFocusable(t), g.a11y.addRole(t, 'button'), g.a11y.addLabel(t, g.params.nextSlideMsg) } if (g.params.prevButton) { const e = v(g.params.prevButton); g.a11y.makeFocusable(e), g.a11y.addRole(e, 'button'), g.a11y.addLabel(e, g.params.prevSlideMsg) }v(g.container).append(g.a11y.liveRegion) }, destroy: function () { g.a11y.liveRegion && g.a11y.liveRegion.length > 0 && g.a11y.liveRegion.remove() } }, g.init = function () { g.params.loop && g.createLoop(), g.updateContainerSize(), g.updateSlidesSize(), g.updatePagination(), g.params.scrollbar && g.scrollbar && g.scrollbar.set(), g.params.effect !== 'slide' && g.effects[g.params.effect] && (g.params.loop || g.updateProgress(), g.effects[g.params.effect].setTranslate()), g.params.loop ? g.slideTo(g.params.initialSlide + g.loopedSlides, 0, g.params.runCallbacksOnInit) : (g.slideTo(g.params.initialSlide, 0, g.params.runCallbacksOnInit), g.params.initialSlide === 0 && (g.parallax && g.params.parallax && g.parallax.setTranslate(), g.lazy && g.params.lazyLoading && (g.lazy.load(), g.lazy.initialImageLoaded = !0))), g.attachEvents(), g.params.observer && g.support.observer && g.initObservers(), g.params.preloadImages && !g.params.lazyLoading && g.preloadImages(), g.params.autoplay && g.startAutoplay(), g.params.keyboardControl && g.enableKeyboardControl && g.enableKeyboardControl(), g.params.mousewheelControl && g.enableMousewheelControl && g.enableMousewheelControl(), g.params.hashnav && g.hashnav && g.hashnav.init(), g.params.a11y && g.a11y && g.a11y.init(), g.emit('onInit', g) }, g.cleanupStyles = function () { g.container.removeClass(g.classNames.join(' ')).removeAttr('style'), g.wrapper.removeAttr('style'), g.slides && g.slides.length && g.slides.removeClass([g.params.slideVisibleClass, g.params.slideActiveClass, g.params.slideNextClass, g.params.slidePrevClass].join(' ')).removeAttr('style').removeAttr('data-swiper-column').removeAttr('data-swiper-row'), g.paginationContainer && g.paginationContainer.length && g.paginationContainer.removeClass(g.params.paginationHiddenClass), g.bullets && g.bullets.length && g.bullets.removeClass(g.params.bulletActiveClass), g.params.prevButton && v(g.params.prevButton).removeClass(g.params.buttonDisabledClass), g.params.nextButton && v(g.params.nextButton).removeClass(g.params.buttonDisabledClass), g.params.scrollbar && g.scrollbar && (g.scrollbar.track && g.scrollbar.track.length && g.scrollbar.track.removeAttr('style'), g.scrollbar.drag && g.scrollbar.drag.length && g.scrollbar.drag.removeAttr('style')) }, g.destroy = function (t, e) { g.detachEvents(), g.stopAutoplay(), g.params.loop && g.destroyLoop(), e && g.cleanupStyles(), g.disconnectObservers(), g.params.keyboardControl && g.disableKeyboardControl && g.disableKeyboardControl(), g.params.mousewheelControl && g.disableMousewheelControl && g.disableMousewheelControl(), g.params.a11y && g.a11y && g.a11y.destroy(), g.emit('onDestroy'), !1 !== t && (g = null) }, g.init(), g
    }
  }; t.prototype = { isSafari: (function () { const t = navigator.userAgent.toLowerCase(); return t.indexOf('safari') >= 0 && t.indexOf('chrome') < 0 && t.indexOf('android') < 0 }()), isUiWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(navigator.userAgent), isArray: function (t) { return Object.prototype.toString.apply(t) === '[object Array]' }, browser: { ie: window.navigator.pointerEnabled || window.navigator.msPointerEnabled, ieTouch: window.navigator.msPointerEnabled && window.navigator.msMaxTouchPoints > 1 || window.navigator.pointerEnabled && window.navigator.maxTouchPoints > 1 }, device: (function () { const t = navigator.userAgent; const e = t.match(/(Android);?[\s\/]+([\d.]+)?/); const n = t.match(/(iPad).*OS\s([\d_]+)/); const i = (t.match(/(iPod)(.*OS\s([\d_]+))?/), !n && t.match(/(iPhone\sOS)\s([\d_]+)/)); return { ios: n || i || n, android: e } }()), support: { touch: window.Modernizr && !0 === Modernizr.touch || (function () { return !!('ontouchstart' in window || window.DocumentTouch && document instanceof DocumentTouch) }()), transforms3d: window.Modernizr && !0 === Modernizr.csstransforms3d || (function () { const t = document.createElement('div').style; return 'webkitPerspective' in t || 'MozPerspective' in t || 'OPerspective' in t || 'MsPerspective' in t || 'perspective' in t }()), flexbox: (function () { for (let t = document.createElement('div').style, e = 'alignItems webkitAlignItems webkitBoxAlign msFlexAlign mozBoxAlign webkitFlexDirection msFlexDirection mozBoxDirection mozBoxOrient webkitBoxDirection webkitBoxOrient'.split(' '), n = 0; n < e.length; n++) if (e[n] in t) return !0 }()), observer: (function () { return 'MutationObserver' in window || 'WebkitMutationObserver' in window }()) }, plugins: {} }; for (var e = (function () {
      const t = function (t) { const e = this; let n = 0; for (n = 0; n < t.length; n++)e[n] = t[n]; return e.length = t.length, this }; const e = function (e, n) { const i = []; let r = 0; if (e && !n && e instanceof t) return e; if (e) if (typeof e === 'string') { let a; let o; const s = e.trim(); if (s.indexOf('<') >= 0 && s.indexOf('>') >= 0) { let l = 'div'; for (s.indexOf('<li') === 0 && (l = 'ul'), s.indexOf('<tr') === 0 && (l = 'tbody'), s.indexOf('<td') !== 0 && s.indexOf('<th') !== 0 || (l = 'tr'), s.indexOf('<tbody') === 0 && (l = 'table'), s.indexOf('<option') === 0 && (l = 'select'), o = document.createElement(l), o.innerHTML = e, r = 0; r < o.childNodes.length; r++)i.push(o.childNodes[r]) } else for (a = n || e[0] !== '#' || e.match(/[ .<>:~]/) ? (n || document).querySelectorAll(e) : [document.getElementById(e.split('#')[1])], r = 0; r < a.length; r++)a[r] && i.push(a[r]) } else if (e.nodeType || e === window || e === document)i.push(e); else if (e.length > 0 && e[0].nodeType) for (r = 0; r < e.length; r++)i.push(e[r]); return new t(i) }; return t.prototype = {
        addClass: function (t) { if (void 0 === t) return this; for (let e = t.split(' '), n = 0; n < e.length; n++) for (let i = 0; i < this.length; i++) this[i].classList.add(e[n]); return this },
        removeClass: function (t) { for (let e = t.split(' '), n = 0; n < e.length; n++) for (let i = 0; i < this.length; i++) this[i].classList.remove(e[n]); return this },
        hasClass: function (t) { return !!this[0] && this[0].classList.contains(t) },
        toggleClass: function (t) { for (let e = t.split(' '), n = 0; n < e.length; n++) for (let i = 0; i < this.length; i++) this[i].classList.toggle(e[n]); return this },
        attr: function (t, e) { if (arguments.length === 1 && typeof t === 'string') return this[0] ? this[0].getAttribute(t) : void 0; for (let n = 0; n < this.length; n++) if (arguments.length === 2) this[n].setAttribute(t, e); else for (const i in t) this[n][i] = t[i], this[n].setAttribute(i, t[i]); return this },
        removeAttr: function (t) { for (let e = 0; e < this.length; e++) this[e].removeAttribute(t); return this },
        data: function (t, e) { if (void 0 !== e) { for (let n = 0; n < this.length; n++) { const i = this[n]; i.dom7ElementDataStorage || (i.dom7ElementDataStorage = {}), i.dom7ElementDataStorage[t] = e } return this } if (this[0]) { const r = this[0].getAttribute('data-' + t); return r || (this[0].dom7ElementDataStorage && t in this[0].dom7ElementDataStorage ? this[0].dom7ElementDataStorage[t] : void 0) } },
        transform: function (t) { for (let e = 0; e < this.length; e++) { const n = this[e].style; n.webkitTransform = n.MsTransform = n.msTransform = n.MozTransform = n.OTransform = n.transform = t } return this },
        transition: function (t) { typeof t !== 'string' && (t += 'ms'); for (let e = 0; e < this.length; e++) { const n = this[e].style; n.webkitTransitionDuration = n.MsTransitionDuration = n.msTransitionDuration = n.MozTransitionDuration = n.OTransitionDuration = n.transitionDuration = t } return this },
        on: function (t, n, i, r) { function a (t) { const r = t.target; if (e(r).is(n))i.call(r, t); else for (let a = e(r).parents(), o = 0; o < a.length; o++)e(a[o]).is(n) && i.call(a[o], t) } let o; let s; const l = t.split(' '); for (o = 0; o < this.length; o++) if (typeof n === 'function' || !1 === n) for (typeof n === 'function' && (i = arguments[1], r = arguments[2] || !1), s = 0; s < l.length; s++) this[o].addEventListener(l[s], i, r); else for (s = 0; s < l.length; s++) this[o].dom7LiveListeners || (this[o].dom7LiveListeners = []), this[o].dom7LiveListeners.push({ listener: i, liveListener: a }), this[o].addEventListener(l[s], a, r); return this },
        off: function (t, e, n, i) { for (let r = t.split(' '), a = 0; a < r.length; a++) for (let o = 0; o < this.length; o++) if (typeof e === 'function' || !1 === e) typeof e === 'function' && (n = arguments[1], i = arguments[2] || !1), this[o].removeEventListener(r[a], n, i); else if (this[o].dom7LiveListeners) for (let s = 0; s < this[o].dom7LiveListeners.length; s++) this[o].dom7LiveListeners[s].listener === n && this[o].removeEventListener(r[a], this[o].dom7LiveListeners[s].liveListener, i); return this },
        once: function (t, e, n, i) { function r (o) { n(o), a.off(t, e, r, i) } var a = this; typeof e === 'function' && (e = !1, n = arguments[1], i = arguments[2]), a.on(t, e, r, i) },
        trigger: function (t, e) { for (let n = 0; n < this.length; n++) { var i; try { i = new window.CustomEvent(t, { detail: e, bubbles: !0, cancelable: !0 }) } catch (n) { i = document.createEvent('Event'), i.initEvent(t, !0, !0), i.detail = e } this[n].dispatchEvent(i) } return this },
        transitionEnd: function (t) { function e (a) { if (a.target === this) for (t.call(this, a), n = 0; n < i.length; n++)r.off(i[n], e) } let n; var i = ['webkitTransitionEnd', 'transitionend', 'oTransitionEnd', 'MSTransitionEnd', 'msTransitionEnd']; var r = this; if (t) for (n = 0; n < i.length; n++)r.on(i[n], e); return this },
        width: function () { return this[0] === window ? window.innerWidth : this.length > 0 ? parseFloat(this.css('width')) : null },
        outerWidth: function (t) { return this.length > 0 ? t ? this[0].offsetWidth + parseFloat(this.css('margin-right')) + parseFloat(this.css('margin-left')) : this[0].offsetWidth : null },
        height: function () { return this[0] === window ? window.innerHeight : this.length > 0 ? parseFloat(this.css('height')) : null },
        outerHeight: function (t) { return this.length > 0 ? t ? this[0].offsetHeight + parseFloat(this.css('margin-top')) + parseFloat(this.css('margin-bottom')) : this[0].offsetHeight : null },
        offset: function () { if (this.length > 0) { const t = this[0]; const e = t.getBoundingClientRect(); const n = document.body; const i = t.clientTop || n.clientTop || 0; const r = t.clientLeft || n.clientLeft || 0; const a = window.pageYOffset || t.scrollTop; const o = window.pageXOffset || t.scrollLeft; return { top: e.top + a - i, left: e.left + o - r } } return null },
        css: function (t, e) { let n; if (arguments.length === 1) { if (typeof t !== 'string') { for (n = 0; n < this.length; n++) for (const i in t) this[n].style[i] = t[i]; return this } if (this[0]) return window.getComputedStyle(this[0], null).getPropertyValue(t) } if (arguments.length === 2 && typeof t === 'string') { for (n = 0; n < this.length; n++) this[n].style[t] = e; return this } return this },
        each: function (t) { for (let e = 0; e < this.length; e++)t.call(this[e], e, this[e]); return this },
        html: function (t) { if (void 0 === t) return this[0] ? this[0].innerHTML : void 0; for (let e = 0; e < this.length; e++) this[e].innerHTML = t; return this },
        is: function (n) { if (!this[0]) return !1; let i, r; if (typeof n === 'string') { const a = this[0]; if (a === document) return n === document; if (a === window) return n === window; if (a.matches) return a.matches(n); if (a.webkitMatchesSelector) return a.webkitMatchesSelector(n); if (a.mozMatchesSelector) return a.mozMatchesSelector(n); if (a.msMatchesSelector) return a.msMatchesSelector(n); for (i = e(n), r = 0; r < i.length; r++) if (i[r] === this[0]) return !0; return !1 } if (n === document) return this[0] === document; if (n === window) return this[0] === window; if (n.nodeType || n instanceof t) { for (i = n.nodeType ? [n] : n, r = 0; r < i.length; r++) if (i[r] === this[0]) return !0; return !1 } return !1 },
        index: function () { if (this[0]) { for (var t = this[0], e = 0; (t = t.previousSibling) !== null;)t.nodeType === 1 && e++; return e } },
        eq: function (e) { if (void 0 === e) return this; let n; const i = this.length; return e > i - 1 ? new t([]) : e < 0 ? (n = i + e, new t(n < 0 ? [] : [this[n]])) : new t([this[e]]) },
        append: function (e) { let n, i; for (n = 0; n < this.length; n++) if (typeof e === 'string') { const r = document.createElement('div'); for (r.innerHTML = e; r.firstChild;) this[n].appendChild(r.firstChild) } else if (e instanceof t) for (i = 0; i < e.length; i++) this[n].appendChild(e[i]); else this[n].appendChild(e); return this },
        prepend: function (e) { let n, i; for (n = 0; n < this.length; n++) if (typeof e === 'string') { const r = document.createElement('div'); for (r.innerHTML = e, i = r.childNodes.length - 1; i >= 0; i--) this[n].insertBefore(r.childNodes[i], this[n].childNodes[0]) } else if (e instanceof t) for (i = 0; i < e.length; i++) this[n].insertBefore(e[i], this[n].childNodes[0]); else this[n].insertBefore(e, this[n].childNodes[0]); return this },
        insertBefore: function (t) { for (let n = e(t), i = 0; i < this.length; i++) if (n.length === 1)n[0].parentNode.insertBefore(this[i], n[0]); else if (n.length > 1) for (let r = 0; r < n.length; r++)n[r].parentNode.insertBefore(this[i].cloneNode(!0), n[r]) },
        insertAfter: function (t) { for (let n = e(t), i = 0; i < this.length; i++) if (n.length === 1)n[0].parentNode.insertBefore(this[i], n[0].nextSibling); else if (n.length > 1) for (let r = 0; r < n.length; r++)n[r].parentNode.insertBefore(this[i].cloneNode(!0), n[r].nextSibling) },
        next: function (n) { return new t(this.length > 0 ? n ? this[0].nextElementSibling && e(this[0].nextElementSibling).is(n) ? [this[0].nextElementSibling] : [] : this[0].nextElementSibling ? [this[0].nextElementSibling] : [] : []) },
        nextAll: function (n) { const i = []; let r = this[0]; if (!r) return new t([]); for (;r.nextElementSibling;) { const a = r.nextElementSibling; n ? e(a).is(n) && i.push(a) : i.push(a), r = a } return new t(i) },
        prev: function (n) {
          return new t(this.length > 0 ? n ? this[0].previousElementSibling && e(this[0].previousElementSibling).is(n) ? [this[0].previousElementSibling] : [] : this[0].previousElementSibling ? [this[0].previousElementSibling] : [] : [])
        },
        prevAll: function (n) { const i = []; let r = this[0]; if (!r) return new t([]); for (;r.previousElementSibling;) { const a = r.previousElementSibling; n ? e(a).is(n) && i.push(a) : i.push(a), r = a } return new t(i) },
        parent: function (t) { for (var n = [], i = 0; i < this.length; i++)t ? e(this[i].parentNode).is(t) && n.push(this[i].parentNode) : n.push(this[i].parentNode); return e(e.unique(n)) },
        parents: function (t) { for (var n = [], i = 0; i < this.length; i++) for (let r = this[i].parentNode; r;)t ? e(r).is(t) && n.push(r) : n.push(r), r = r.parentNode; return e(e.unique(n)) },
        find: function (e) { for (var n = [], i = 0; i < this.length; i++) for (let r = this[i].querySelectorAll(e), a = 0; a < r.length; a++)n.push(r[a]); return new t(n) },
        children: function (n) { for (var i = [], r = 0; r < this.length; r++) for (let a = this[r].childNodes, o = 0; o < a.length; o++)n ? a[o].nodeType === 1 && e(a[o]).is(n) && i.push(a[o]) : a[o].nodeType === 1 && i.push(a[o]); return new t(e.unique(i)) },
        remove: function () { for (let t = 0; t < this.length; t++) this[t].parentNode && this[t].parentNode.removeChild(this[t]); return this },
        add: function () { let t; let n; const i = this; for (t = 0; t < arguments.length; t++) { const r = e(arguments[t]); for (n = 0; n < r.length; n++)i[i.length] = r[n], i.length++ } return i }
      }, e.fn = t.prototype, e.unique = function (t) { for (var e = [], n = 0; n < t.length; n++)e.indexOf(t[n]) === -1 && e.push(t[n]); return e }, e
    }()), n = ['jQuery', 'Zepto', 'Dom7'], i = 0; i < n.length; i++)window[n[i]] && (function (e) { e.fn.swiper = function (n) { let i; return e(this).each(function () { const e = new t(this, n); i || (i = e) }), i } }(window[n[i]])); let r; r = void 0 === e ? window.Dom7 || window.Zepto || window.jQuery : e, r && ('transitionEnd' in r.fn || (r.fn.transitionEnd = function (t) { function e (a) { if (a.target === this) for (t.call(this, a), n = 0; n < i.length; n++)r.off(i[n], e) } let n; var i = ['webkitTransitionEnd', 'transitionend', 'oTransitionEnd', 'MSTransitionEnd', 'msTransitionEnd']; var r = this; if (t) for (n = 0; n < i.length; n++)r.on(i[n], e); return this }), 'transform' in r.fn || (r.fn.transform = function (t) { for (let e = 0; e < this.length; e++) { const n = this[e].style; n.webkitTransform = n.MsTransform = n.msTransform = n.MozTransform = n.OTransform = n.transform = t } return this }), 'transition' in r.fn || (r.fn.transition = function (t) { typeof t !== 'string' && (t += 'ms'); for (let e = 0; e < this.length; e++) { const n = this[e].style; n.webkitTransitionDuration = n.MsTransitionDuration = n.msTransitionDuration = n.MozTransitionDuration = n.OTransitionDuration = n.transitionDuration = t } return this })), window.Swiper = t
}()), typeof module !== 'undefined' ? module.exports = window.Swiper : typeof define === 'function' && define.amd && define([], function () { 'use strict'; return window.Swiper }), (function (t, e, n) { 'use strict'; function i () { for (var t = [], e = '0123456789abcdef', n = 0; n < 36; n++)t[n] = e.substr(Math.floor(16 * Math.random()), 1); return t[14] = '4', t[19] = e.substr(3 & t[19] | 8, 1), t[8] = t[13] = t[18] = t[23] = '-', t.join('') } function r () { return { restrict: 'E', transclude: !0, scope: { onReady: '&', slidesPerView: '=', slidesPerColumn: '=', spaceBetween: '=', parallax: '=', parallaxTransition: '@', paginationIsActive: '=', paginationClickable: '=', showNavButtons: '=', showScrollBar: '=', loop: '=', autoplay: '=', initialSlide: '=', containerCls: '@', wrapperCls: '@', paginationCls: '@', slideCls: '@', direction: '@', swiper: '=', overrideParameters: '=' }, controller: ['$scope', '$element', '$timeout', function (t, n, r) { const a = i(); t.swiper_uuid = a; let o = { slidesPerView: t.slidesPerView || 1, slidesPerColumn: t.slidesPerColumn || 1, spaceBetween: t.spaceBetween || 0, direction: t.direction || 'horizontal', loop: t.loop || !1, initialSlide: t.initialSlide || 0, showNavButtons: !1 }; e.isUndefined(t.autoplay) || typeof t.autoplay !== 'number' || (o = e.extend({}, o, { autoplay: t.autoplay })), !0 === t.paginationIsActive && (o = e.extend({}, o, { paginationClickable: t.paginationClickable || !0, pagination: '#paginator-' + t.swiper_uuid })), !0 === t.showNavButtons && (o.nextButton = '#nextButton-' + t.swiper_uuid, o.prevButton = '#prevButton-' + t.swiper_uuid), !0 === t.showScrollBar && (o.scrollbar = '#scrollBar-' + t.swiper_uuid), t.overrideParameters && (o = e.extend({}, o, t.overrideParameters)), r(function () { let i = null; e.isObject(t.swiper) ? (t.swiper = new Swiper(n[0].firstChild, o), i = t.swiper) : i = new Swiper(n[0].firstChild, o), e.isUndefined(t.onReady) || t.onReady({ swiper: i }) }) }], link: function (t, n) { const i = t.swiper_uuid; const r = 'paginator-' + i; const a = 'prevButton-' + i; const o = 'nextButton-' + i; const s = 'scrollBar-' + i; const l = n[0]; e.element(l.querySelector('.swiper-pagination')).attr('id', r), e.element(l.querySelector('.swiper-button-next')).attr('id', o), e.element(l.querySelector('.swiper-button-prev')).attr('id', a), e.element(n[0].querySelector('.swiper-scrollbar')).attr('id', s) }, template: '<div class="swiper-container {{containerCls}}"><div class="parallax-bg" data-swiper-parallax="{{parallaxTransition}}" ng-show="parallax"></div><div class="swiper-wrapper {{wrapperCls}}" ng-transclude></div><div class="swiper-pagination {{paginationCls}}"></div><div class="swiper-button-next" ng-show="showNavButtons"></div><div class="swiper-button-prev" ng-show="showNavButtons"></div><div class="swiper-scrollbar" ng-show="showScrollBar"></div></div>' } } function a () { return { restrict: 'E', require: '^ksSwiperContainer', transclude: !0, scope: { sliderCls: '@' }, template: '<div class="swiper-slide {{sliderCls}}" ng-transclude></div>', replace: !0 } }e.module('ksSwiper', []).directive('ksSwiperContainer', r).directive('ksSwiperSlide', a) }(window, angular)), angular.module('ui.bootstrap', ['ui.bootstrap.tpls', 'ui.bootstrap.collapse', 'ui.bootstrap.tabindex', 'ui.bootstrap.accordion', 'ui.bootstrap.alert', 'ui.bootstrap.buttons', 'ui.bootstrap.carousel', 'ui.bootstrap.dateparser', 'ui.bootstrap.isClass', 'ui.bootstrap.datepicker', 'ui.bootstrap.position', 'ui.bootstrap.datepickerPopup', 'ui.bootstrap.debounce', 'ui.bootstrap.multiMap', 'ui.bootstrap.dropdown', 'ui.bootstrap.stackedMap', 'ui.bootstrap.modal', 'ui.bootstrap.paging', 'ui.bootstrap.pager', 'ui.bootstrap.pagination', 'ui.bootstrap.tooltip', 'ui.bootstrap.popover', 'ui.bootstrap.progressbar', 'ui.bootstrap.rating', 'ui.bootstrap.tabs', 'ui.bootstrap.timepicker', 'ui.bootstrap.typeahead']), angular.module('ui.bootstrap.tpls', ['uib/template/accordion/accordion-group.html', 'uib/template/accordion/accordion.html', 'uib/template/alert/alert.html', 'uib/template/carousel/carousel.html', 'uib/template/carousel/slide.html', 'uib/template/datepicker/datepicker.html', 'uib/template/datepicker/day.html', 'uib/template/datepicker/month.html', 'uib/template/datepicker/year.html', 'uib/template/datepickerPopup/popup.html', 'uib/template/modal/window.html', 'uib/template/pager/pager.html', 'uib/template/pagination/pagination.html', 'uib/template/tooltip/tooltip-html-popup.html', 'uib/template/tooltip/tooltip-popup.html', 'uib/template/tooltip/tooltip-template-popup.html', 'uib/template/popover/popover-html.html', 'uib/template/popover/popover-template.html', 'uib/template/popover/popover.html', 'uib/template/progressbar/bar.html', 'uib/template/progressbar/progress.html', 'uib/template/progressbar/progressbar.html', 'uib/template/rating/rating.html', 'uib/template/tabs/tab.html', 'uib/template/tabs/tabset.html', 'uib/template/timepicker/timepicker.html', 'uib/template/typeahead/typeahead-match.html', 'uib/template/typeahead/typeahead-popup.html']), angular.module('ui.bootstrap.collapse', []).directive('uibCollapse', ['$animate', '$q', '$parse', '$injector', function (t, e, n, i) { const r = i.has('$animateCss') ? i.get('$animateCss') : null; return { link: function (i, a, o) { function s (t) { return g ? { width: t.scrollWidth + 'px' } : { height: t.scrollHeight + 'px' } } function l () { a.hasClass('collapse') && a.hasClass('in') || e.resolve(p(i)).then(function () { a.removeClass('collapse').addClass('collapsing').attr('aria-expanded', !0).attr('aria-hidden', !1), r ? r(a, { addClass: 'in', easing: 'ease', css: { overflow: 'hidden' }, to: s(a[0]) }).start().finally(c) : t.addClass(a, 'in', { css: { overflow: 'hidden' }, to: s(a[0]) }).then(c) }, angular.noop) } function c () { a.removeClass('collapsing').addClass('collapse').css(v), d(i) } function u () { if (!a.hasClass('collapse') && !a.hasClass('in')) return h(); e.resolve(f(i)).then(function () { a.css(s(a[0])).removeClass('collapse').addClass('collapsing').attr('aria-expanded', !1).attr('aria-hidden', !0), r ? r(a, { removeClass: 'in', to: y }).start().finally(h) : t.removeClass(a, 'in', { to: y }).then(h) }, angular.noop) } function h () { a.css(y), a.removeClass('collapsing').addClass('collapse'), m(i) } var p = n(o.expanding); var d = n(o.expanded); var f = n(o.collapsing); var m = n(o.collapsed); var g = !1; var v = {}; var y = {}; !(function () { g = !!('horizontal' in o), g ? (v = { width: '' }, y = { width: '0' }) : (v = { height: '' }, y = { height: '0' }), i.$eval(o.uibCollapse) || a.addClass('in').addClass('collapse').attr('aria-expanded', !0).attr('aria-hidden', !1).css(v) }()), i.$watch(o.uibCollapse, function (t) { t ? u() : l() }) } } }]), angular.module('ui.bootstrap.tabindex', []).directive('uibTabindexToggle', function () { return { restrict: 'A', link: function (t, e, n) { n.$observe('disabled', function (t) { n.$set('tabindex', t ? -1 : null) }) } } }), angular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse', 'ui.bootstrap.tabindex']).constant('uibAccordionConfig', { closeOthers: !0 }).controller('UibAccordionController', ['$scope', '$attrs', 'uibAccordionConfig', function (t, e, n) { this.groups = [], this.closeOthers = function (i) { (angular.isDefined(e.closeOthers) ? t.$eval(e.closeOthers) : n.closeOthers) && angular.forEach(this.groups, function (t) { t !== i && (t.isOpen = !1) }) }, this.addGroup = function (t) { const e = this; this.groups.push(t), t.$on('$destroy', function (n) { e.removeGroup(t) }) }, this.removeGroup = function (t) { const e = this.groups.indexOf(t); e !== -1 && this.groups.splice(e, 1) } }]).directive('uibAccordion', function () { return { controller: 'UibAccordionController', controllerAs: 'accordion', transclude: !0, templateUrl: function (t, e) { return e.templateUrl || 'uib/template/accordion/accordion.html' } } }).directive('uibAccordionGroup', function () { return { require: '^uibAccordion', transclude: !0, restrict: 'A', templateUrl: function (t, e) { return e.templateUrl || 'uib/template/accordion/accordion-group.html' }, scope: { heading: '@', panelClass: '@?', isOpen: '=?', isDisabled: '=?' }, controller: function () { this.setHeading = function (t) { this.heading = t } }, link: function (t, e, n, i) { e.addClass('panel'), i.addGroup(t), t.openClass = n.openClass || 'panel-open', t.panelClass = n.panelClass || 'panel-default', t.$watch('isOpen', function (n) { e.toggleClass(t.openClass, !!n), n && i.closeOthers(t) }), t.toggleOpen = function (e) { t.isDisabled || e && e.which !== 32 || (t.isOpen = !t.isOpen) }; const r = 'accordiongroup-' + t.$id + '-' + Math.floor(1e4 * Math.random()); t.headingId = r + '-tab', t.panelId = r + '-panel' } } }).directive('uibAccordionHeading', function () { return { transclude: !0, template: '', replace: !0, require: '^uibAccordionGroup', link: function (t, e, n, i, r) { i.setHeading(r(t, angular.noop)) } } }).directive('uibAccordionTransclude', function () { return { require: '^uibAccordionGroup', link: function (t, e, n, i) { t.$watch(function () { return i[n.uibAccordionTransclude] }, function (t) { if (t) { const n = angular.element(e[0].querySelector('uib-accordion-header,data-uib-accordion-header,x-uib-accordion-header,uib\\:accordion-header,[uib-accordion-header],[data-uib-accordion-header],[x-uib-accordion-header]')); n.html(''), n.append(t) } }) } } }), angular.module('ui.bootstrap.alert', []).controller('UibAlertController', ['$scope', '$element', '$attrs', '$interpolate', '$timeout', function (t, e, n, i, r) { t.closeable = !!n.close, e.addClass('alert'), n.$set('role', 'alert'), t.closeable && e.addClass('alert-dismissible'); const a = angular.isDefined(n.dismissOnTimeout) ? i(n.dismissOnTimeout)(t.$parent) : null; a && r(function () { t.close() }, parseInt(a, 10)) }]).directive('uibAlert', function () { return { controller: 'UibAlertController', controllerAs: 'alert', restrict: 'A', templateUrl: function (t, e) { return e.templateUrl || 'uib/template/alert/alert.html' }, transclude: !0, scope: { close: '&' } } }), angular.module('ui.bootstrap.buttons', []).constant('uibButtonConfig', { activeClass: 'active', toggleEvent: 'click' }).controller('UibButtonsController', ['uibButtonConfig', function (t) { this.activeClass = t.activeClass || 'active', this.toggleEvent = t.toggleEvent || 'click' }]).directive('uibBtnRadio', ['$parse', function (t) { return { require: ['uibBtnRadio', 'ngModel'], controller: 'UibButtonsController', controllerAs: 'buttons', link: function (e, n, i, r) { const a = r[0]; const o = r[1]; const s = t(i.uibUncheckable); n.find('input').css({ display: 'none' }), o.$render = function () { n.toggleClass(a.activeClass, angular.equals(o.$modelValue, e.$eval(i.uibBtnRadio))) }, n.on(a.toggleEvent, function () { if (!i.disabled) { const t = n.hasClass(a.activeClass); t && !angular.isDefined(i.uncheckable) || e.$apply(function () { o.$setViewValue(t ? null : e.$eval(i.uibBtnRadio)), o.$render() }) } }), i.uibUncheckable && e.$watch(s, function (t) { i.$set('uncheckable', t ? '' : void 0) }) } } }]).directive('uibBtnCheckbox', function () { return { require: ['uibBtnCheckbox', 'ngModel'], controller: 'UibButtonsController', controllerAs: 'button', link: function (t, e, n, i) { function r () { return o(n.btnCheckboxTrue, !0) } function a () { return o(n.btnCheckboxFalse, !1) } function o (e, n) { return angular.isDefined(e) ? t.$eval(e) : n } const s = i[0]; const l = i[1]; e.find('input').css({ display: 'none' }), l.$render = function () { e.toggleClass(s.activeClass, angular.equals(l.$modelValue, r())) }, e.on(s.toggleEvent, function () { n.disabled || t.$apply(function () { l.$setViewValue(e.hasClass(s.activeClass) ? a() : r()), l.$render() }) }) } } }), angular.module('ui.bootstrap.carousel', []).controller('UibCarouselController', ['$scope', '$element', '$interval', '$timeout', '$animate', function (t, e, n, i, r) { function a (t) { for (let e = 0; e < m.length; e++)m[e].slide.active = e === t } function o (n, i, o) { if (!y) { if (angular.extend(n, { direction: o }), angular.extend(m[v].slide || {}, { direction: o }), r.enabled(e) && !t.$currentTransition && m[i].element && f.slides.length > 1) { m[i].element.data(g, n.direction); const s = f.getCurrentIndex(); angular.isNumber(s) && m[s].element && m[s].element.data(g, n.direction), t.$currentTransition = !0, r.on('addClass', m[i].element, function (e, n) { n === 'close' && (t.$currentTransition = null, r.off('addClass', e)) }) }t.active = n.index, v = n.index, a(i), u() } } function s (t) { for (let e = 0; e < m.length; e++) if (m[e].slide === t) return e } function l () { p && (n.cancel(p), p = null) } function c (e) { e.length || (t.$currentTransition = null) } function u () { l(); const e = +t.interval; !isNaN(e) && e > 0 && (p = n(h, e)) } function h () { const e = +t.interval; d && !isNaN(e) && e > 0 && m.length ? t.next() : t.pause() } let p; let d; var f = this; var m = f.slides = t.slides = []; var g = 'uib-slideDirection'; var v = t.active; var y = !1; e.addClass('carousel'), f.addSlide = function (e, n) { m.push({ slide: e, element: n }), m.sort(function (t, e) { return +t.slide.index - +e.slide.index }), (e.index === t.active || m.length === 1 && !angular.isNumber(t.active)) && (t.$currentTransition && (t.$currentTransition = null), v = e.index, t.active = e.index, a(v), f.select(m[s(e)]), m.length === 1 && t.play()) }, f.getCurrentIndex = function () { for (let t = 0; t < m.length; t++) if (m[t].slide.index === v) return t }, f.next = t.next = function () { const e = (f.getCurrentIndex() + 1) % m.length; return e === 0 && t.noWrap() ? void t.pause() : f.select(m[e], 'next') }, f.prev = t.prev = function () { const e = f.getCurrentIndex() - 1 < 0 ? m.length - 1 : f.getCurrentIndex() - 1; return t.noWrap() && e === m.length - 1 ? void t.pause() : f.select(m[e], 'prev') }, f.removeSlide = function (e) { const n = s(e); m.splice(n, 1), m.length > 0 && v === n ? n >= m.length ? (v = m.length - 1, t.active = v, a(v), f.select(m[m.length - 1])) : (v = n, t.active = v, a(v), f.select(m[n])) : v > n && (v--, t.active = v), m.length === 0 && (v = null, t.active = null) }, f.select = t.select = function (e, n) { const i = s(e.slide); void 0 === n && (n = i > f.getCurrentIndex() ? 'next' : 'prev'), e.slide.index === v || t.$currentTransition || o(e.slide, i, n) }, t.indexOfSlide = function (t) { return +t.slide.index }, t.isActive = function (e) { return t.active === e.slide.index }, t.isPrevDisabled = function () { return t.active === 0 && t.noWrap() }, t.isNextDisabled = function () { return t.active === m.length - 1 && t.noWrap() }, t.pause = function () { t.noPause || (d = !1, l()) }, t.play = function () { d || (d = !0, u()) }, e.on('mouseenter', t.pause), e.on('mouseleave', t.play), t.$on('$destroy', function () { y = !0, l() }), t.$watch('noTransition', function (t) { r.enabled(e, !t) }), t.$watch('interval', u), t.$watchCollection('slides', c), t.$watch('active', function (t) { if (angular.isNumber(t) && v !== t) { for (let e = 0; e < m.length; e++) if (m[e].slide.index === t) { t = e; break }m[t] && (a(t), f.select(m[t]), v = t) } }) }]).directive('uibCarousel', function () { return { transclude: !0, controller: 'UibCarouselController', controllerAs: 'carousel', restrict: 'A', templateUrl: function (t, e) { return e.templateUrl || 'uib/template/carousel/carousel.html' }, scope: { active: '=', interval: '=', noTransition: '=', noPause: '=', noWrap: '&' } } }).directive('uibSlide', ['$animate', function (t) { return { require: '^uibCarousel', restrict: 'A', transclude: !0, templateUrl: function (t, e) { return e.templateUrl || 'uib/template/carousel/slide.html' }, scope: { actual: '=?', index: '=?' }, link: function (e, n, i, r) { n.addClass('item'), r.addSlide(e, n), e.$on('$destroy', function () { r.removeSlide(e) }), e.$watch('active', function (e) { t[e ? 'addClass' : 'removeClass'](n, 'active') }) } } }]).animation('.item', ['$animateCss', function (t) { function e (t, e, n) { t.removeClass(e), n && n() } return { beforeAddClass: function (n, i, r) { if (i === 'active') { let a = !1; const o = n.data('uib-slideDirection'); const s = o === 'next' ? 'left' : 'right'; const l = e.bind(this, n, s + ' ' + o, r); return n.addClass(o), t(n, { addClass: s }).start().done(l), function () { a = !0 } }r() }, beforeRemoveClass: function (n, i, r) { if (i === 'active') { let a = !1; const o = n.data('uib-slideDirection'); const s = o === 'next' ? 'left' : 'right'; const l = e.bind(this, n, s, r); return t(n, { addClass: s }).start().done(l), function () { a = !0 } }r() } } }]), angular.module('ui.bootstrap.dateparser', []).service('uibDateParser', ['$log', '$locale', 'dateFilter', 'orderByFilter', 'filterFilter', function (t, e, n, i, r) { function a (t) { return r(y, { key: t }, !0)[0] } function o (t) { const e = []; const n = t.split(''); const r = t.indexOf("'"); if (r > -1) { let a = !1; t = t.split(''); for (let o = r; o < t.length; o++)a ? (t[o] === "'" && (o + 1 < t.length && t[o + 1] === "'" ? (t[o + 1] = '$', n[o + 1] = '') : (n[o] = '', a = !1)), t[o] = '$') : t[o] === "'" && (t[o] = '$', n[o] = '', a = !0); t = t.join('') } return angular.forEach(y, function (i) { const r = t.indexOf(i.key); if (r > -1) { t = t.split(''), n[r] = '(' + i.regex + ')', t[r] = '$'; for (let a = r + 1, o = r + i.key.length; a < o; a++)n[a] = '', t[a] = '$'; t = t.join(''), e.push({ index: r, key: i.key, apply: i.apply, matcher: i.regex }) } }), { regex: new RegExp('^' + n.join('') + '$'), map: i(e, 'index') } } function s (t) { for (var e, n, i = [], r = 0; r < t.length;) if (angular.isNumber(n)) { if (t.charAt(r) === "'")(r + 1 >= t.length || t.charAt(r + 1) !== "'") && (i.push(l(t, n, r)), n = null); else if (r === t.length) for (;n < t.length;)e = c(t, n), i.push(e), n = e.endIdx; r++ } else t.charAt(r) !== "'" ? (e = c(t, r), i.push(e.parser), r = e.endIdx) : (n = r, r++); return i } function l (t, e, n) { return function () { return t.substr(e + 1, n - e - 1) } } function c (t, e) { for (var n = t.substr(e), i = 0; i < y.length; i++) if (new RegExp('^' + y[i].key).test(n)) { const r = y[i]; return { endIdx: e + r.key.length, parser: r.formatter } } return { endIdx: e + 1, parser: function () { return n.charAt(0) } } } function u (t, e, n) { return !(n < 1) && (e === 1 && n > 28 ? n === 29 && (t % 4 == 0 && t % 100 != 0 || t % 400 == 0) : e !== 3 && e !== 5 && e !== 8 && e !== 10 || n < 31) } function h (t) { return parseInt(t, 10) } function p (t, e) { return t && e ? g(t, e) : t } function d (t, e) { return t && e ? g(t, e, !0) : t } function f (t, e) { t = t.replace(/:/g, ''); const n = Date.parse('Jan 01, 1970 00:00:00 ' + t) / 6e4; return isNaN(n) ? e : n } function m (t, e) { return t = new Date(t.getTime()), t.setMinutes(t.getMinutes() + e), t } function g (t, e, n) { n = n ? -1 : 1; const i = t.getTimezoneOffset(); return m(t, n * (f(e, i) - i)) } let v, y; this.init = function () { v = e.id, this.parsers = {}, this.formatters = {}, y = [{ key: 'yyyy', regex: '\\d{4}', apply: function (t) { this.year = +t }, formatter: function (t) { const e = new Date(); return e.setFullYear(Math.abs(t.getFullYear())), n(e, 'yyyy') } }, { key: 'yy', regex: '\\d{2}', apply: function (t) { t = +t, this.year = t < 69 ? t + 2e3 : t + 1900 }, formatter: function (t) { const e = new Date(); return e.setFullYear(Math.abs(t.getFullYear())), n(e, 'yy') } }, { key: 'y', regex: '\\d{1,4}', apply: function (t) { this.year = +t }, formatter: function (t) { const e = new Date(); return e.setFullYear(Math.abs(t.getFullYear())), n(e, 'y') } }, { key: 'M!', regex: '0?[1-9]|1[0-2]', apply: function (t) { this.month = t - 1 }, formatter: function (t) { return /^[0-9]$/.test(t.getMonth()) ? n(t, 'MM') : n(t, 'M') } }, { key: 'MMMM', regex: e.DATETIME_FORMATS.MONTH.join('|'), apply: function (t) { this.month = e.DATETIME_FORMATS.MONTH.indexOf(t) }, formatter: function (t) { return n(t, 'MMMM') } }, { key: 'MMM', regex: e.DATETIME_FORMATS.SHORTMONTH.join('|'), apply: function (t) { this.month = e.DATETIME_FORMATS.SHORTMONTH.indexOf(t) }, formatter: function (t) { return n(t, 'MMM') } }, { key: 'MM', regex: '0[1-9]|1[0-2]', apply: function (t) { this.month = t - 1 }, formatter: function (t) { return n(t, 'MM') } }, { key: 'M', regex: '[1-9]|1[0-2]', apply: function (t) { this.month = t - 1 }, formatter: function (t) { return n(t, 'M') } }, { key: 'd!', regex: '[0-2]?[0-9]{1}|3[0-1]{1}', apply: function (t) { this.date = +t }, formatter: function (t) { return /^[1-9]$/.test(t.getDate()) ? n(t, 'dd') : n(t, 'd') } }, { key: 'dd', regex: '[0-2][0-9]{1}|3[0-1]{1}', apply: function (t) { this.date = +t }, formatter: function (t) { return n(t, 'dd') } }, { key: 'd', regex: '[1-2]?[0-9]{1}|3[0-1]{1}', apply: function (t) { this.date = +t }, formatter: function (t) { return n(t, 'd') } }, { key: 'EEEE', regex: e.DATETIME_FORMATS.DAY.join('|'), formatter: function (t) { return n(t, 'EEEE') } }, { key: 'EEE', regex: e.DATETIME_FORMATS.SHORTDAY.join('|'), formatter: function (t) { return n(t, 'EEE') } }, { key: 'HH', regex: '(?:0|1)[0-9]|2[0-3]', apply: function (t) { this.hours = +t }, formatter: function (t) { return n(t, 'HH') } }, { key: 'hh', regex: '0[0-9]|1[0-2]', apply: function (t) { this.hours = +t }, formatter: function (t) { return n(t, 'hh') } }, { key: 'H', regex: '1?[0-9]|2[0-3]', apply: function (t) { this.hours = +t }, formatter: function (t) { return n(t, 'H') } }, { key: 'h', regex: '[0-9]|1[0-2]', apply: function (t) { this.hours = +t }, formatter: function (t) { return n(t, 'h') } }, { key: 'mm', regex: '[0-5][0-9]', apply: function (t) { this.minutes = +t }, formatter: function (t) { return n(t, 'mm') } }, { key: 'm', regex: '[0-9]|[1-5][0-9]', apply: function (t) { this.minutes = +t }, formatter: function (t) { return n(t, 'm') } }, { key: 'sss', regex: '[0-9][0-9][0-9]', apply: function (t) { this.milliseconds = +t }, formatter: function (t) { return n(t, 'sss') } }, { key: 'ss', regex: '[0-5][0-9]', apply: function (t) { this.seconds = +t }, formatter: function (t) { return n(t, 'ss') } }, { key: 's', regex: '[0-9]|[1-5][0-9]', apply: function (t) { this.seconds = +t }, formatter: function (t) { return n(t, 's') } }, { key: 'a', regex: e.DATETIME_FORMATS.AMPMS.join('|'), apply: function (t) { this.hours === 12 && (this.hours = 0), t === 'PM' && (this.hours += 12) }, formatter: function (t) { return n(t, 'a') } }, { key: 'Z', regex: '[+-]\\d{4}', apply: function (t) { const e = t.match(/([+-])(\d{2})(\d{2})/); const n = e[1]; const i = e[2]; const r = e[3]; this.hours += h(n + i), this.minutes += h(n + r) }, formatter: function (t) { return n(t, 'Z') } }, { key: 'ww', regex: '[0-4][0-9]|5[0-3]', formatter: function (t) { return n(t, 'ww') } }, { key: 'w', regex: '[0-9]|[1-4][0-9]|5[0-3]', formatter: function (t) { return n(t, 'w') } }, { key: 'GGGG', regex: e.DATETIME_FORMATS.ERANAMES.join('|').replace(/\s/g, '\\s'), formatter: function (t) { return n(t, 'GGGG') } }, { key: 'GGG', regex: e.DATETIME_FORMATS.ERAS.join('|'), formatter: function (t) { return n(t, 'GGG') } }, { key: 'GG', regex: e.DATETIME_FORMATS.ERAS.join('|'), formatter: function (t) { return n(t, 'GG') } }, { key: 'G', regex: e.DATETIME_FORMATS.ERAS.join('|'), formatter: function (t) { return n(t, 'G') } }], angular.version.major >= 1 && angular.version.minor > 4 && y.push({ key: 'LLLL', regex: e.DATETIME_FORMATS.STANDALONEMONTH.join('|'), apply: function (t) { this.month = e.DATETIME_FORMATS.STANDALONEMONTH.indexOf(t) }, formatter: function (t) { return n(t, 'LLLL') } }) }, this.init(), this.getParser = function (t) { const e = a(t); return e && e.apply || null }, this.overrideParser = function (t, e) { const n = a(t); n && angular.isFunction(e) && (this.parsers = {}, n.apply = e) }.bind(this), this.filter = function (t, n) { return angular.isDate(t) && !isNaN(t) && n ? (n = e.DATETIME_FORMATS[n] || n, e.id !== v && this.init(), this.formatters[n] || (this.formatters[n] = s(n)), this.formatters[n].reduce(function (e, n) { return e + n(t) }, '')) : '' }, this.parse = function (n, i, r) { if (!angular.isString(n) || !i) return n; i = e.DATETIME_FORMATS[i] || i, i = i.replace(/[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g, '\\$&'), e.id !== v && this.init(), this.parsers[i] || (this.parsers[i] = o(i)); const a = this.parsers[i]; const s = a.regex; const l = a.map; const c = n.match(s); let h = !1; if (c && c.length) { let p, d; angular.isDate(r) && !isNaN(r.getTime()) ? p = { year: r.getFullYear(), month: r.getMonth(), date: r.getDate(), hours: r.getHours(), minutes: r.getMinutes(), seconds: r.getSeconds(), milliseconds: r.getMilliseconds() } : (r && t.warn('dateparser:', 'baseDate is not a valid date'), p = { year: 1900, month: 0, date: 1, hours: 0, minutes: 0, seconds: 0, milliseconds: 0 }); for (let f = 1, m = c.length; f < m; f++) { const g = l[f - 1]; g.matcher === 'Z' && (h = !0), g.apply && g.apply.call(p, c[f]) } const y = h ? Date.prototype.setUTCFullYear : Date.prototype.setFullYear; const b = h ? Date.prototype.setUTCHours : Date.prototype.setHours; return u(p.year, p.month, p.date) && (!angular.isDate(r) || isNaN(r.getTime()) || h ? (d = new Date(0), y.call(d, p.year, p.month, p.date), b.call(d, p.hours || 0, p.minutes || 0, p.seconds || 0, p.milliseconds || 0)) : (d = new Date(r), y.call(d, p.year, p.month, p.date), b.call(d, p.hours, p.minutes, p.seconds, p.milliseconds))), d } }, this.toTimezone = p, this.fromTimezone = d, this.timezoneToOffset = f, this.addDateMinutes = m, this.convertTimezoneToLocal = g }]), angular.module('ui.bootstrap.isClass', []).directive('uibIsClass', ['$animate', function (t) { const e = /^\s*([\s\S]+?)\s+for\s+([\s\S]+?)\s*$/; return { restrict: 'A', compile: function (n, i) { function r (t, e, n) { s.push(t), l.push({ scope: t, element: e }), d.forEach(function (e, n) { a(e, t) }), t.$on('$destroy', o) } function a (n, i) { const r = n.match(e); const a = i.$eval(r[1]); const o = r[2]; let s = c[n]; if (!s) { const u = function (e) { let n = null; l.some(function (t) { if (t.scope.$eval(h) === e) return n = t, !0 }), s.lastActivated !== n && (s.lastActivated && t.removeClass(s.lastActivated.element, a), n && t.addClass(n.element, a), s.lastActivated = n) }; c[n] = s = { lastActivated: null, scope: i, watchFn: u, compareWithExp: o, watcher: i.$watch(o, u) } }s.watchFn(i.$eval(o)) } function o (t) { const e = t.targetScope; const n = s.indexOf(e); if (s.splice(n, 1), l.splice(n, 1), s.length) { const i = s[0]; angular.forEach(c, function (t) { t.scope === e && (t.watcher = i.$watch(t.compareWithExp, t.watchFn), t.scope = i) }) } else c = {} } var s = []; var l = []; var c = {}; const u = i.uibIsClass.match(/^\s*([\s\S]+?)\s+on\s+([\s\S]+?)\s*$/); var h = u[2]; const p = u[1]; var d = p.split(','); return r } } }]), angular.module('ui.bootstrap.datepicker', ['ui.bootstrap.dateparser', 'ui.bootstrap.isClass']).value('$datepickerSuppressError', !1).value('$datepickerLiteralWarning', !0).constant('uibDatepickerConfig', { datepickerMode: 'day', formatDay: 'dd', formatMonth: 'MMMM', formatYear: 'yyyy', formatDayHeader: 'EEE', formatDayTitle: 'MMMM yyyy', formatMonthTitle: 'yyyy', maxDate: null, maxMode: 'year', minDate: null, minMode: 'day', monthColumns: 3, ngModelOptions: {}, shortcutPropagation: !1, showWeeks: !0, yearColumns: 5, yearRows: 4 }).controller('UibDatepickerController', ['$scope', '$element', '$attrs', '$parse', '$interpolate', '$locale', '$log', 'dateFilter', 'uibDatepickerConfig', '$datepickerLiteralWarning', '$datepickerSuppressError', 'uibDateParser', function (t, e, n, i, r, a, o, s, l, c, u, h) {
  function p (e) { t.datepickerMode = e, t.datepickerOptions.datepickerMode = e } function d (e) { let n; if (angular.version.minor < 6)n = e.$options || t.datepickerOptions.ngModelOptions || l.ngModelOptions || {}, n.getOption = function (t) { return n[t] }; else { const i = e.$options.getOption('timezone') || (t.datepickerOptions.ngModelOptions ? t.datepickerOptions.ngModelOptions.timezone : null) || (l.ngModelOptions ? l.ngModelOptions.timezone : null); n = e.$options.createChild(l.ngModelOptions).createChild(t.datepickerOptions.ngModelOptions).createChild(e.$options).createChild({ timezone: i }) } return n } const f = this; let m = { $setViewValue: angular.noop }; let g = {}; const v = []; e.addClass('uib-datepicker'), n.$set('role', 'application'), t.datepickerOptions || (t.datepickerOptions = {}), this.modes = ['day', 'month', 'year'], ['customClass', 'dateDisabled', 'datepickerMode', 'formatDay', 'formatDayHeader', 'formatDayTitle', 'formatMonth', 'formatMonthTitle', 'formatYear', 'maxDate', 'maxMode', 'minDate', 'minMode', 'monthColumns', 'showWeeks', 'shortcutPropagation', 'startingDay', 'yearColumns', 'yearRows'].forEach(function (e) { switch (e) { case 'customClass':case 'dateDisabled':t[e] = t.datepickerOptions[e] || angular.noop; break; case 'datepickerMode':t.datepickerMode = angular.isDefined(t.datepickerOptions.datepickerMode) ? t.datepickerOptions.datepickerMode : l.datepickerMode; break; case 'formatDay':case 'formatDayHeader':case 'formatDayTitle':case 'formatMonth':case 'formatMonthTitle':case 'formatYear':f[e] = angular.isDefined(t.datepickerOptions[e]) ? r(t.datepickerOptions[e])(t.$parent) : l[e]; break; case 'monthColumns':case 'showWeeks':case 'shortcutPropagation':case 'yearColumns':case 'yearRows':f[e] = angular.isDefined(t.datepickerOptions[e]) ? t.datepickerOptions[e] : l[e]; break; case 'startingDay':angular.isDefined(t.datepickerOptions.startingDay) ? f.startingDay = t.datepickerOptions.startingDay : angular.isNumber(l.startingDay) ? f.startingDay = l.startingDay : f.startingDay = (a.DATETIME_FORMATS.FIRSTDAYOFWEEK + 8) % 7; break; case 'maxDate':case 'minDate':t.$watch('datepickerOptions.' + e, function (t) { t ? angular.isDate(t) ? f[e] = h.fromTimezone(new Date(t), g.getOption('timezone')) : (c && o.warn('Literal date support has been deprecated, please switch to date object usage'), f[e] = new Date(s(t, 'medium'))) : f[e] = l[e] ? h.fromTimezone(new Date(l[e]), g.getOption('timezone')) : null, f.refreshView() }); break; case 'maxMode':case 'minMode':t.datepickerOptions[e] ? t.$watch(function () { return t.datepickerOptions[e] }, function (n) { f[e] = t[e] = angular.isDefined(n) ? n : t.datepickerOptions[e], (e === 'minMode' && f.modes.indexOf(t.datepickerOptions.datepickerMode) < f.modes.indexOf(f[e]) || e === 'maxMode' && f.modes.indexOf(t.datepickerOptions.datepickerMode) > f.modes.indexOf(f[e])) && (t.datepickerMode = f[e], t.datepickerOptions.datepickerMode = f[e]) }) : f[e] = t[e] = l[e] || null } }), t.uniqueId = 'datepicker-' + t.$id + '-' + Math.floor(1e4 * Math.random()), t.disabled = angular.isDefined(n.disabled) || !1, angular.isDefined(n.ngDisabled) && v.push(t.$parent.$watch(n.ngDisabled, function (e) { t.disabled = e, f.refreshView() })), t.isActive = function (e) { return f.compare(e.date, f.activeDate) === 0 && (t.activeDateId = e.uid, !0) }, this.init = function (e) { m = e, g = d(m), t.datepickerOptions.initDate ? (f.activeDate = h.fromTimezone(t.datepickerOptions.initDate, g.getOption('timezone')) || new Date(), t.$watch('datepickerOptions.initDate', function (t) { t && (m.$isEmpty(m.$modelValue) || m.$invalid) && (f.activeDate = h.fromTimezone(t, g.getOption('timezone')), f.refreshView()) })) : f.activeDate = new Date(); const n = m.$modelValue ? new Date(m.$modelValue) : new Date(); this.activeDate = isNaN(n) ? h.fromTimezone(new Date(), g.getOption('timezone')) : h.fromTimezone(n, g.getOption('timezone')), m.$render = function () { f.render() } }, this.render = function () { if (m.$viewValue) { const t = new Date(m.$viewValue); !isNaN(t) ? this.activeDate = h.fromTimezone(t, g.getOption('timezone')) : u || o.error('Datepicker directive: "ng-model" value must be a Date object') } this.refreshView() }, this.refreshView = function () { if (this.element) { t.selectedDt = null, this._refreshView(), t.activeDt && (t.activeDateId = t.activeDt.uid); let e = m.$viewValue ? new Date(m.$viewValue) : null; e = h.fromTimezone(e, g.getOption('timezone')), m.$setValidity('dateDisabled', !e || this.element && !this.isDisabled(e)) } }, this.createDateObject = function (e, n) { let i = m.$viewValue ? new Date(m.$viewValue) : null; i = h.fromTimezone(i, g.getOption('timezone')); let r = new Date(); r = h.fromTimezone(r, g.getOption('timezone')); const a = this.compare(e, r); const o = { date: e, label: h.filter(e, n), selected: i && this.compare(e, i) === 0, disabled: this.isDisabled(e), past: a < 0, current: a === 0, future: a > 0, customClass: this.customClass(e) || null }; return i && this.compare(e, i) === 0 && (t.selectedDt = o), f.activeDate && this.compare(o.date, f.activeDate) === 0 && (t.activeDt = o), o }, this.isDisabled = function (e) { return t.disabled || this.minDate && this.compare(e, this.minDate) < 0 || this.maxDate && this.compare(e, this.maxDate) > 0 || t.dateDisabled && t.dateDisabled({ date: e, mode: t.datepickerMode }) }, this.customClass = function (e) { return t.customClass({ date: e, mode: t.datepickerMode }) }, this.split = function (t, e) { for (var n = []; t.length > 0;)n.push(t.splice(0, e)); return n }, t.select = function (e) { if (t.datepickerMode === f.minMode) { let n = m.$viewValue ? h.fromTimezone(new Date(m.$viewValue), g.getOption('timezone')) : new Date(0, 0, 0, 0, 0, 0, 0); n.setFullYear(e.getFullYear(), e.getMonth(), e.getDate()), n = h.toTimezone(n, g.getOption('timezone')), m.$setViewValue(n), m.$render() } else f.activeDate = e, p(f.modes[f.modes.indexOf(t.datepickerMode) - 1]), t.$emit('uib:datepicker.mode'); t.$broadcast('uib:datepicker.focus') }, t.move = function (t) { const e = f.activeDate.getFullYear() + t * (f.step.years || 0); const n = f.activeDate.getMonth() + t * (f.step.months || 0); f.activeDate.setFullYear(e, n, 1), f.refreshView() }, t.toggleMode = function (e) {
    e = e || 1, t.datepickerMode === f.maxMode && e === 1 || t.datepickerMode === f.minMode && e === -1 || (p(f.modes[f.modes.indexOf(t.datepickerMode) + e]),
    t.$emit('uib:datepicker.mode'))
  }, t.keys = { 13: 'enter', 32: 'space', 33: 'pageup', 34: 'pagedown', 35: 'end', 36: 'home', 37: 'left', 38: 'up', 39: 'right', 40: 'down' }; const y = function () { f.element[0].focus() }; t.$on('uib:datepicker.focus', y), t.keydown = function (e) { const n = t.keys[e.which]; if (n && !e.shiftKey && !e.altKey && !t.disabled) if (e.preventDefault(), f.shortcutPropagation || e.stopPropagation(), n === 'enter' || n === 'space') { if (f.isDisabled(f.activeDate)) return; t.select(f.activeDate) } else !e.ctrlKey || n !== 'up' && n !== 'down' ? (f.handleKeyDown(n, e), f.refreshView()) : t.toggleMode(n === 'up' ? 1 : -1) }, e.on('keydown', function (e) { t.$apply(function () { t.keydown(e) }) }), t.$on('$destroy', function () { for (;v.length;)v.shift()() })
}]).controller('UibDaypickerController', ['$scope', '$element', 'dateFilter', function (t, e, n) { function i (t, e) { return e !== 1 || t % 4 != 0 || t % 100 == 0 && t % 400 != 0 ? a[e] : 29 } function r (t) { const e = new Date(t); e.setDate(e.getDate() + 4 - (e.getDay() || 7)); const n = e.getTime(); return e.setMonth(0), e.setDate(1), Math.floor(Math.round((n - e) / 864e5) / 7) + 1 } var a = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; this.step = { months: 1 }, this.element = e, this.init = function (e) { angular.extend(e, this), t.showWeeks = e.showWeeks, e.refreshView() }, this.getDates = function (t, e) { for (var n, i = new Array(e), r = new Date(t), a = 0; a < e;)n = new Date(r), i[a++] = n, r.setDate(r.getDate() + 1); return i }, this._refreshView = function () { const e = this.activeDate.getFullYear(); const i = this.activeDate.getMonth(); const a = new Date(this.activeDate); a.setFullYear(e, i, 1); const o = this.startingDay - a.getDay(); const s = o > 0 ? 7 - o : -o; const l = new Date(a); s > 0 && l.setDate(1 - s); for (var c = this.getDates(l, 42), u = 0; u < 42; u++)c[u] = angular.extend(this.createDateObject(c[u], this.formatDay), { secondary: c[u].getMonth() !== i, uid: t.uniqueId + '-' + u }); t.labels = new Array(7); for (let h = 0; h < 7; h++)t.labels[h] = { abbr: n(c[h].date, this.formatDayHeader), full: n(c[h].date, 'EEEE') }; if (t.title = n(this.activeDate, this.formatDayTitle), t.rows = this.split(c, 7), t.showWeeks) { t.weekNumbers = []; for (let p = (11 - this.startingDay) % 7, d = t.rows.length, f = 0; f < d; f++)t.weekNumbers.push(r(t.rows[f][p].date)) } }, this.compare = function (t, e) { const n = new Date(t.getFullYear(), t.getMonth(), t.getDate()); const i = new Date(e.getFullYear(), e.getMonth(), e.getDate()); return n.setFullYear(t.getFullYear()), i.setFullYear(e.getFullYear()), n - i }, this.handleKeyDown = function (t, e) { let n = this.activeDate.getDate(); if (t === 'left')n -= 1; else if (t === 'up')n -= 7; else if (t === 'right')n += 1; else if (t === 'down')n += 7; else if (t === 'pageup' || t === 'pagedown') { const r = this.activeDate.getMonth() + (t === 'pageup' ? -1 : 1); this.activeDate.setMonth(r, 1), n = Math.min(i(this.activeDate.getFullYear(), this.activeDate.getMonth()), n) } else t === 'home' ? n = 1 : t === 'end' && (n = i(this.activeDate.getFullYear(), this.activeDate.getMonth())); this.activeDate.setDate(n) } }]).controller('UibMonthpickerController', ['$scope', '$element', 'dateFilter', function (t, e, n) { this.step = { years: 1 }, this.element = e, this.init = function (t) { angular.extend(t, this), t.refreshView() }, this._refreshView = function () { for (var e, i = new Array(12), r = this.activeDate.getFullYear(), a = 0; a < 12; a++)e = new Date(this.activeDate), e.setFullYear(r, a, 1), i[a] = angular.extend(this.createDateObject(e, this.formatMonth), { uid: t.uniqueId + '-' + a }); t.title = n(this.activeDate, this.formatMonthTitle), t.rows = this.split(i, this.monthColumns), t.yearHeaderColspan = this.monthColumns > 3 ? this.monthColumns - 2 : 1 }, this.compare = function (t, e) { const n = new Date(t.getFullYear(), t.getMonth()); const i = new Date(e.getFullYear(), e.getMonth()); return n.setFullYear(t.getFullYear()), i.setFullYear(e.getFullYear()), n - i }, this.handleKeyDown = function (t, e) { let n = this.activeDate.getMonth(); if (t === 'left')n -= 1; else if (t === 'up')n -= this.monthColumns; else if (t === 'right')n += 1; else if (t === 'down')n += this.monthColumns; else if (t === 'pageup' || t === 'pagedown') { const i = this.activeDate.getFullYear() + (t === 'pageup' ? -1 : 1); this.activeDate.setFullYear(i) } else t === 'home' ? n = 0 : t === 'end' && (n = 11); this.activeDate.setMonth(n) } }]).controller('UibYearpickerController', ['$scope', '$element', 'dateFilter', function (t, e, n) { function i (t) { return parseInt((t - 1) / a, 10) * a + 1 } let r, a; this.element = e, this.yearpickerInit = function () { r = this.yearColumns, a = this.yearRows * r, this.step = { years: a } }, this._refreshView = function () { for (var e, n = new Array(a), o = 0, s = i(this.activeDate.getFullYear()); o < a; o++)e = new Date(this.activeDate), e.setFullYear(s + o, 0, 1), n[o] = angular.extend(this.createDateObject(e, this.formatYear), { uid: t.uniqueId + '-' + o }); t.title = [n[0].label, n[a - 1].label].join(' - '), t.rows = this.split(n, r), t.columns = r }, this.compare = function (t, e) { return t.getFullYear() - e.getFullYear() }, this.handleKeyDown = function (t, e) { let n = this.activeDate.getFullYear(); t === 'left' ? n -= 1 : t === 'up' ? n -= r : t === 'right' ? n += 1 : t === 'down' ? n += r : t === 'pageup' || t === 'pagedown' ? n += (t === 'pageup' ? -1 : 1) * a : t === 'home' ? n = i(this.activeDate.getFullYear()) : t === 'end' && (n = i(this.activeDate.getFullYear()) + a - 1), this.activeDate.setFullYear(n) } }]).directive('uibDatepicker', function () { return { templateUrl: function (t, e) { return e.templateUrl || 'uib/template/datepicker/datepicker.html' }, scope: { datepickerOptions: '=?' }, require: ['uibDatepicker', '^ngModel'], restrict: 'A', controller: 'UibDatepickerController', controllerAs: 'datepicker', link: function (t, e, n, i) { const r = i[0]; const a = i[1]; r.init(a) } } }).directive('uibDaypicker', function () { return { templateUrl: function (t, e) { return e.templateUrl || 'uib/template/datepicker/day.html' }, require: ['^uibDatepicker', 'uibDaypicker'], restrict: 'A', controller: 'UibDaypickerController', link: function (t, e, n, i) { const r = i[0]; i[1].init(r) } } }).directive('uibMonthpicker', function () { return { templateUrl: function (t, e) { return e.templateUrl || 'uib/template/datepicker/month.html' }, require: ['^uibDatepicker', 'uibMonthpicker'], restrict: 'A', controller: 'UibMonthpickerController', link: function (t, e, n, i) { const r = i[0]; i[1].init(r) } } }).directive('uibYearpicker', function () { return { templateUrl: function (t, e) { return e.templateUrl || 'uib/template/datepicker/year.html' }, require: ['^uibDatepicker', 'uibYearpicker'], restrict: 'A', controller: 'UibYearpickerController', link: function (t, e, n, i) { const r = i[0]; angular.extend(r, i[1]), r.yearpickerInit(), r.refreshView() } } }), angular.module('ui.bootstrap.position', []).factory('$uibPosition', ['$document', '$window', function (t, e) { let n; let i; const r = { normal: /(auto|scroll)/, hidden: /(auto|scroll|hidden)/ }; const a = { auto: /\s?auto?\s?/i, primary: /^(top|bottom|left|right)$/, secondary: /^(top|bottom|left|right|center)$/, vertical: /^(top|bottom)$/ }; const o = /(HTML|BODY)/; return { getRawNode: function (t) { return t.nodeName ? t : t[0] || t }, parseStyle: function (t) { return t = parseFloat(t), isFinite(t) ? t : 0 }, offsetParent: function (n) { n = this.getRawNode(n); for (var i = n.offsetParent || t[0].documentElement; i && i !== t[0].documentElement && (function (t) { return (e.getComputedStyle(t).position || 'static') === 'static' }(i));)i = i.offsetParent; return i || t[0].documentElement }, scrollbarWidth: function (r) { if (r) { if (angular.isUndefined(i)) { const a = t.find('body'); a.addClass('uib-position-body-scrollbar-measure'), i = e.innerWidth - a[0].clientWidth, i = isFinite(i) ? i : 0, a.removeClass('uib-position-body-scrollbar-measure') } return i } if (angular.isUndefined(n)) { const o = angular.element('<div class="uib-position-scrollbar-measure"></div>'); t.find('body').append(o), n = o[0].offsetWidth - o[0].clientWidth, n = isFinite(n) ? n : 0, o.remove() } return n }, scrollbarPadding: function (t) { t = this.getRawNode(t); const n = e.getComputedStyle(t); const i = this.parseStyle(n.paddingRight); const r = this.parseStyle(n.paddingBottom); const a = this.scrollParent(t, !1, !0); const s = this.scrollbarWidth(o.test(a.tagName)); return { scrollbarWidth: s, widthOverflow: a.scrollWidth > a.clientWidth, right: i + s, originalRight: i, heightOverflow: a.scrollHeight > a.clientHeight, bottom: r + s, originalBottom: r } }, isScrollable: function (t, n) { t = this.getRawNode(t); const i = n ? r.hidden : r.normal; const a = e.getComputedStyle(t); return i.test(a.overflow + a.overflowY + a.overflowX) }, scrollParent: function (n, i, a) { n = this.getRawNode(n); const o = i ? r.hidden : r.normal; const s = t[0].documentElement; const l = e.getComputedStyle(n); if (a && o.test(l.overflow + l.overflowY + l.overflowX)) return n; let c = l.position === 'absolute'; let u = n.parentElement || s; if (u === s || l.position === 'fixed') return s; for (;u.parentElement && u !== s;) { const h = e.getComputedStyle(u); if (c && h.position !== 'static' && (c = !1), !c && o.test(h.overflow + h.overflowY + h.overflowX)) break; u = u.parentElement } return u }, position: function (n, i) { n = this.getRawNode(n); const r = this.offset(n); if (i) { const a = e.getComputedStyle(n); r.top -= this.parseStyle(a.marginTop), r.left -= this.parseStyle(a.marginLeft) } const o = this.offsetParent(n); let s = { top: 0, left: 0 }; return o !== t[0].documentElement && (s = this.offset(o), s.top += o.clientTop - o.scrollTop, s.left += o.clientLeft - o.scrollLeft), { width: Math.round(angular.isNumber(r.width) ? r.width : n.offsetWidth), height: Math.round(angular.isNumber(r.height) ? r.height : n.offsetHeight), top: Math.round(r.top - s.top), left: Math.round(r.left - s.left) } }, offset: function (n) { n = this.getRawNode(n); const i = n.getBoundingClientRect(); return { width: Math.round(angular.isNumber(i.width) ? i.width : n.offsetWidth), height: Math.round(angular.isNumber(i.height) ? i.height : n.offsetHeight), top: Math.round(i.top + (e.pageYOffset || t[0].documentElement.scrollTop)), left: Math.round(i.left + (e.pageXOffset || t[0].documentElement.scrollLeft)) } }, viewportOffset: function (n, i, r) { n = this.getRawNode(n), r = !1 !== r; const a = n.getBoundingClientRect(); const o = { top: 0, left: 0, bottom: 0, right: 0 }; const s = i ? t[0].documentElement : this.scrollParent(n); const l = s.getBoundingClientRect(); if (o.top = l.top + s.clientTop, o.left = l.left + s.clientLeft, s === t[0].documentElement && (o.top += e.pageYOffset, o.left += e.pageXOffset), o.bottom = o.top + s.clientHeight, o.right = o.left + s.clientWidth, r) { const c = e.getComputedStyle(s); o.top += this.parseStyle(c.paddingTop), o.bottom -= this.parseStyle(c.paddingBottom), o.left += this.parseStyle(c.paddingLeft), o.right -= this.parseStyle(c.paddingRight) } return { top: Math.round(a.top - o.top), bottom: Math.round(o.bottom - a.bottom), left: Math.round(a.left - o.left), right: Math.round(o.right - a.right) } }, parsePlacement: function (t) { const e = a.auto.test(t); return e && (t = t.replace(a.auto, '')), t = t.split('-'), t[0] = t[0] || 'top', a.primary.test(t[0]) || (t[0] = 'top'), t[1] = t[1] || 'center', a.secondary.test(t[1]) || (t[1] = 'center'), t[2] = !!e, t }, positionElements: function (t, n, i, r) { t = this.getRawNode(t), n = this.getRawNode(n); const o = angular.isDefined(n.offsetWidth) ? n.offsetWidth : n.prop('offsetWidth'); const s = angular.isDefined(n.offsetHeight) ? n.offsetHeight : n.prop('offsetHeight'); i = this.parsePlacement(i); const l = r ? this.offset(t) : this.position(t); const c = { top: 0, left: 0, placement: '' }; if (i[2]) { const u = this.viewportOffset(t, r); const h = e.getComputedStyle(n); const p = { width: o + Math.round(Math.abs(this.parseStyle(h.marginLeft) + this.parseStyle(h.marginRight))), height: s + Math.round(Math.abs(this.parseStyle(h.marginTop) + this.parseStyle(h.marginBottom))) }; if (i[0] = i[0] === 'top' && p.height > u.top && p.height <= u.bottom ? 'bottom' : i[0] === 'bottom' && p.height > u.bottom && p.height <= u.top ? 'top' : i[0] === 'left' && p.width > u.left && p.width <= u.right ? 'right' : i[0] === 'right' && p.width > u.right && p.width <= u.left ? 'left' : i[0], i[1] = i[1] === 'top' && p.height - l.height > u.bottom && p.height - l.height <= u.top ? 'bottom' : i[1] === 'bottom' && p.height - l.height > u.top && p.height - l.height <= u.bottom ? 'top' : i[1] === 'left' && p.width - l.width > u.right && p.width - l.width <= u.left ? 'right' : i[1] === 'right' && p.width - l.width > u.left && p.width - l.width <= u.right ? 'left' : i[1], i[1] === 'center') if (a.vertical.test(i[0])) { const d = l.width / 2 - o / 2; u.left + d < 0 && p.width - l.width <= u.right ? i[1] = 'left' : u.right + d < 0 && p.width - l.width <= u.left && (i[1] = 'right') } else { const f = l.height / 2 - p.height / 2; u.top + f < 0 && p.height - l.height <= u.bottom ? i[1] = 'top' : u.bottom + f < 0 && p.height - l.height <= u.top && (i[1] = 'bottom') } } switch (i[0]) { case 'top':c.top = l.top - s; break; case 'bottom':c.top = l.top + l.height; break; case 'left':c.left = l.left - o; break; case 'right':c.left = l.left + l.width } switch (i[1]) { case 'top':c.top = l.top; break; case 'bottom':c.top = l.top + l.height - s; break; case 'left':c.left = l.left; break; case 'right':c.left = l.left + l.width - o; break; case 'center':a.vertical.test(i[0]) ? c.left = l.left + l.width / 2 - o / 2 : c.top = l.top + l.height / 2 - s / 2 } return c.top = Math.round(c.top), c.left = Math.round(c.left), c.placement = i[1] === 'center' ? i[0] : i[0] + '-' + i[1], c }, adjustTop: function (t, e, n, i) { if (t.indexOf('top') !== -1 && n !== i) return { top: e.top - i + 'px' } }, positionArrow: function (t, n) { t = this.getRawNode(t); const i = t.querySelector('.tooltip-inner, .popover-inner'); if (i) { const r = angular.element(i).hasClass('tooltip-inner'); const o = r ? t.querySelector('.tooltip-arrow') : t.querySelector('.arrow'); if (o) { const s = { top: '', bottom: '', left: '', right: '' }; if (n = this.parsePlacement(n), n[1] === 'center') return void angular.element(o).css(s); const l = 'border-' + n[0] + '-width'; const c = e.getComputedStyle(o)[l]; let u = 'border-'; a.vertical.test(n[0]) ? u += n[0] + '-' + n[1] : u += n[1] + '-' + n[0], u += '-radius'; const h = e.getComputedStyle(r ? i : t)[u]; switch (n[0]) { case 'top':s.bottom = r ? '0' : '-' + c; break; case 'bottom':s.top = r ? '0' : '-' + c; break; case 'left':s.right = r ? '0' : '-' + c; break; case 'right':s.left = r ? '0' : '-' + c }s[n[1]] = h, angular.element(o).css(s) } } } } }]), angular.module('ui.bootstrap.datepickerPopup', ['ui.bootstrap.datepicker', 'ui.bootstrap.position']).value('$datepickerPopupLiteralWarning', !0).constant('uibDatepickerPopupConfig', { altInputFormats: [], appendToBody: !1, clearText: 'Clear', closeOnDateSelection: !0, closeText: 'Done', currentText: 'Today', datepickerPopup: 'yyyy-MM-dd', datepickerPopupTemplateUrl: 'uib/template/datepickerPopup/popup.html', datepickerTemplateUrl: 'uib/template/datepicker/datepicker.html', html5Types: { date: 'yyyy-MM-dd', 'datetime-local': 'yyyy-MM-ddTHH:mm:ss.sss', month: 'yyyy-MM' }, onOpenFocus: !0, showButtonBar: !0, placement: 'auto bottom-left' }).controller('UibDatepickerPopupController', ['$scope', '$element', '$attrs', '$compile', '$log', '$parse', '$window', '$document', '$rootScope', '$uibPosition', 'dateFilter', 'uibDateParser', 'uibDatepickerPopupConfig', '$timeout', 'uibDatepickerConfig', '$datepickerPopupLiteralWarning', function (t, e, n, i, r, a, o, s, l, c, u, h, p, d, f, m) { function g (e) { let n = h.parse(e, $, t.date); if (isNaN(n)) for (let i = 0; i < I.length; i++) if (n = h.parse(e, I[i], t.date), !isNaN(n)) return n; return n } function v (t) { if (angular.isNumber(t) && (t = new Date(t)), !t) return null; if (angular.isDate(t) && !isNaN(t)) return t; if (angular.isString(t)) { const e = g(t); if (!isNaN(e)) return h.toTimezone(e, O.getOption('timezone')) } return O.getOption('allowInvalid') ? t : void 0 } function y (t, e) { let i = t || e; return !n.ngRequired && !i || (angular.isNumber(i) && (i = new Date(i)), !i || (!(!angular.isDate(i) || isNaN(i)) || !!angular.isString(i) && !isNaN(g(i)))) } function b (n) { if (t.isOpen || !t.disabled) { const i = L[0]; const r = e[0].contains(n.target); const a = void 0 !== i.contains && i.contains(n.target); !t.isOpen || r || a || t.$apply(function () { t.isOpen = !1 }) } } function x (n) { n.which === 27 && t.isOpen ? (n.preventDefault(), n.stopPropagation(), t.$apply(function () { t.isOpen = !1 }), e[0].focus()) : n.which !== 40 || t.isOpen || (n.preventDefault(), n.stopPropagation(), t.$apply(function () { t.isOpen = !0 })) } function w () { if (t.isOpen) { const i = angular.element(L[0].querySelector('.uib-datepicker-popup')); const r = n.popupPlacement ? n.popupPlacement : p.placement; const a = c.positionElements(e, i, r, S); i.css({ top: a.top + 'px', left: a.left + 'px' }), i.hasClass('uib-position-measure') && i.removeClass('uib-position-measure') } } function _ (t) { let e; return angular.version.minor < 6 ? (e = angular.isObject(t.$options) ? t.$options : { timezone: null }, e.getOption = function (t) { return e[t] }) : e = t.$options, e } let $; let T; let S; let M; let C; let E; let A; let P; let k; let D; let O; let L; let I; let R = !1; const N = []; this.init = function (r) { if (D = r, O = _(D), T = angular.isDefined(n.closeOnDateSelection) ? t.$parent.$eval(n.closeOnDateSelection) : p.closeOnDateSelection, S = angular.isDefined(n.datepickerAppendToBody) ? t.$parent.$eval(n.datepickerAppendToBody) : p.appendToBody, M = angular.isDefined(n.onOpenFocus) ? t.$parent.$eval(n.onOpenFocus) : p.onOpenFocus, C = angular.isDefined(n.datepickerPopupTemplateUrl) ? n.datepickerPopupTemplateUrl : p.datepickerPopupTemplateUrl, E = angular.isDefined(n.datepickerTemplateUrl) ? n.datepickerTemplateUrl : p.datepickerTemplateUrl, I = angular.isDefined(n.altInputFormats) ? t.$parent.$eval(n.altInputFormats) : p.altInputFormats, t.showButtonBar = angular.isDefined(n.showButtonBar) ? t.$parent.$eval(n.showButtonBar) : p.showButtonBar, p.html5Types[n.type] ? ($ = p.html5Types[n.type], R = !0) : ($ = n.uibDatepickerPopup || p.datepickerPopup, n.$observe('uibDatepickerPopup', function (t, e) { const n = t || p.datepickerPopup; if (n !== $ && ($ = n, D.$modelValue = null, !$)) throw new Error('uibDatepickerPopup must have a date format specified.') })), !$) throw new Error('uibDatepickerPopup must have a date format specified.'); if (R && n.uibDatepickerPopup) throw new Error('HTML5 date input types do not support custom formats.'); A = angular.element('<div uib-datepicker-popup-wrap><div uib-datepicker></div></div>'), A.attr({ 'ng-model': 'date', 'ng-change': 'dateSelection(date)', 'template-url': C }), P = angular.element(A.children()[0]), P.attr('template-url', E), t.datepickerOptions || (t.datepickerOptions = {}), R && n.type === 'month' && (t.datepickerOptions.datepickerMode = 'month', t.datepickerOptions.minMode = 'month'), P.attr('datepicker-options', 'datepickerOptions'), R ? D.$formatters.push(function (e) { return t.date = h.fromTimezone(e, O.getOption('timezone')), e }) : (D.$$parserName = 'date', D.$validators.date = y, D.$parsers.unshift(v), D.$formatters.push(function (e) { return D.$isEmpty(e) ? (t.date = e, e) : (angular.isNumber(e) && (e = new Date(e)), t.date = h.fromTimezone(e, O.getOption('timezone')), h.filter(t.date, $)) })), D.$viewChangeListeners.push(function () { t.date = g(D.$viewValue) }), e.on('keydown', x), L = i(A)(t), A.remove(), S ? s.find('body').append(L) : e.after(L), t.$on('$destroy', function () { for (!0 === t.isOpen && (l.$$phase || t.$apply(function () { t.isOpen = !1 })), L.remove(), e.off('keydown', x), s.off('click', b), k && k.off('scroll', w), angular.element(o).off('resize', w); N.length;)N.shift()() }) }, t.getText = function (e) { return t[e + 'Text'] || p[e + 'Text'] }, t.isDisabled = function (e) { e === 'today' && (e = h.fromTimezone(new Date(), O.getOption('timezone'))); const n = {}; return angular.forEach(['minDate', 'maxDate'], function (e) { t.datepickerOptions[e] ? angular.isDate(t.datepickerOptions[e]) ? n[e] = new Date(t.datepickerOptions[e]) : (m && r.warn('Literal date support has been deprecated, please switch to date object usage'), n[e] = new Date(u(t.datepickerOptions[e], 'medium'))) : n[e] = null }), t.datepickerOptions && n.minDate && t.compare(e, n.minDate) < 0 || n.maxDate && t.compare(e, n.maxDate) > 0 }, t.compare = function (t, e) { return new Date(t.getFullYear(), t.getMonth(), t.getDate()) - new Date(e.getFullYear(), e.getMonth(), e.getDate()) }, t.dateSelection = function (n) { t.date = n; const i = t.date ? h.filter(t.date, $) : null; e.val(i), D.$setViewValue(i), T && (t.isOpen = !1, e[0].focus()) }, t.keydown = function (n) { n.which === 27 && (n.stopPropagation(), t.isOpen = !1, e[0].focus()) }, t.select = function (e, n) { if (n.stopPropagation(), e === 'today') { const i = new Date(); angular.isDate(t.date) ? (e = new Date(t.date), e.setFullYear(i.getFullYear(), i.getMonth(), i.getDate())) : (e = h.fromTimezone(i, O.getOption('timezone')), e.setHours(0, 0, 0, 0)) }t.dateSelection(e) }, t.close = function (n) { n.stopPropagation(), t.isOpen = !1, e[0].focus() }, t.disabled = angular.isDefined(n.disabled) || !1, n.ngDisabled && N.push(t.$parent.$watch(a(n.ngDisabled), function (e) { t.disabled = e })), t.$watch('isOpen', function (i) { i ? t.disabled ? t.isOpen = !1 : d(function () { w(), M && t.$broadcast('uib:datepicker.focus'), s.on('click', b); const i = n.popupPlacement ? n.popupPlacement : p.placement; S || c.parsePlacement(i)[2] ? (k = k || angular.element(c.scrollParent(e))) && k.on('scroll', w) : k = null, angular.element(o).on('resize', w) }, 0, !1) : (s.off('click', b), k && k.off('scroll', w), angular.element(o).off('resize', w)) }), t.$on('uib:datepicker.mode', function () { d(w, 0, !1) }) }]).directive('uibDatepickerPopup', function () { return { require: ['ngModel', 'uibDatepickerPopup'], controller: 'UibDatepickerPopupController', scope: { datepickerOptions: '=?', isOpen: '=?', currentText: '@', clearText: '@', closeText: '@' }, link: function (t, e, n, i) { const r = i[0]; i[1].init(r) } } }).directive('uibDatepickerPopupWrap', function () { return { restrict: 'A', transclude: !0, templateUrl: function (t, e) { return e.templateUrl || 'uib/template/datepickerPopup/popup.html' } } }), angular.module('ui.bootstrap.debounce', []).factory('$$debounce', ['$timeout', function (t) { return function (e, n) { let i; return function () { const r = this; const a = Array.prototype.slice.call(arguments); i && t.cancel(i), i = t(function () { e.apply(r, a) }, n) } } }]), angular.module('ui.bootstrap.multiMap', []).factory('$$multiMap', function () { return { createNew: function () { const t = {}; return { entries: function () { return Object.keys(t).map(function (e) { return { key: e, value: t[e] } }) }, get: function (e) { return t[e] }, hasKey: function (e) { return !!t[e] }, keys: function () { return Object.keys(t) }, put: function (e, n) { t[e] || (t[e] = []), t[e].push(n) }, remove: function (e, n) { const i = t[e]; if (i) { const r = i.indexOf(n); r !== -1 && i.splice(r, 1), i.length || delete t[e] } } } } } }), angular.module('ui.bootstrap.dropdown', ['ui.bootstrap.multiMap', 'ui.bootstrap.position']).constant('uibDropdownConfig', { appendToOpenClass: 'uib-dropdown-open', openClass: 'open' }).service('uibDropdownService', ['$document', '$rootScope', '$$multiMap', function (t, e, n) { let i = null; const r = n.createNew(); this.isOnlyOpen = function (t, e) { const n = r.get(e); if (n) { if (n.reduce(function (e, n) { return n.scope === t ? n : e }, {})) return n.length === 1 } return !1 }, this.open = function (e, n, o) { if (i || t.on('click', a), i && i !== e && (i.isOpen = !1), i = e, o) { const s = r.get(o); if (s) { s.map(function (t) { return t.scope }).indexOf(e) === -1 && r.put(o, { scope: e }) } else r.put(o, { scope: e }) } }, this.close = function (e, n, o) { if (i === e && (t.off('click', a), t.off('keydown', this.keybindFilter), i = null), o) { const s = r.get(o); if (s) { const l = s.reduce(function (t, n) { return n.scope === e ? n : t }, {}); l && r.remove(o, l) } } }; var a = function (t) { if (i && i.isOpen && !(t && i.getAutoClose() === 'disabled' || t && t.which === 3)) { const n = i.getToggleElement(); if (!(t && n && n[0].contains(t.target))) { const r = i.getDropdownElement(); t && i.getAutoClose() === 'outsideClick' && r && r[0].contains(t.target) || (i.focusToggleElement(), i.isOpen = !1, e.$$phase || i.$apply()) } } }; this.keybindFilter = function (t) { if (i) { const e = i.getDropdownElement(); const n = i.getToggleElement(); const r = e && e[0].contains(t.target); const o = n && n[0].contains(t.target); t.which === 27 ? (t.stopPropagation(), i.focusToggleElement(), a()) : i.isKeynavEnabled() && [38, 40].indexOf(t.which) !== -1 && i.isOpen && (r || o) && (t.preventDefault(), t.stopPropagation(), i.focusDropdownEntry(t.which)) } } }]).controller('UibDropdownController', ['$scope', '$element', '$attrs', '$parse', 'uibDropdownConfig', 'uibDropdownService', '$animate', '$uibPosition', '$document', '$compile', '$templateRequest', function (t, e, n, i, r, a, o, s, l, c, u) { function h () { e.append(f.dropdownMenu) } let p; let d; var f = this; const m = t.$new(); const g = r.appendToOpenClass; const v = r.openClass; let y = angular.noop; const b = n.onToggle ? i(n.onToggle) : angular.noop; let x = !1; const w = l.find('body'); e.addClass('dropdown'), this.init = function () { n.isOpen && (d = i(n.isOpen), y = d.assign, t.$watch(d, function (t) { m.isOpen = !!t })), x = angular.isDefined(n.keyboardNav) }, this.toggle = function (t) { return m.isOpen = arguments.length ? !!t : !m.isOpen, angular.isFunction(y) && y(m, m.isOpen), m.isOpen }, this.isOpen = function () { return m.isOpen }, m.getToggleElement = function () { return f.toggleElement }, m.getAutoClose = function () { return n.autoClose || 'always' }, m.getElement = function () { return e }, m.isKeynavEnabled = function () { return x }, m.focusDropdownEntry = function (t) { const n = f.dropdownMenu ? angular.element(f.dropdownMenu).find('a') : e.find('ul').eq(0).find('a'); switch (t) { case 40:angular.isNumber(f.selectedOption) ? f.selectedOption = f.selectedOption === n.length - 1 ? f.selectedOption : f.selectedOption + 1 : f.selectedOption = 0; break; case 38:angular.isNumber(f.selectedOption) ? f.selectedOption = f.selectedOption === 0 ? 0 : f.selectedOption - 1 : f.selectedOption = n.length - 1 }n[f.selectedOption].focus() }, m.getDropdownElement = function () { return f.dropdownMenu }, m.focusToggleElement = function () { f.toggleElement && f.toggleElement[0].focus() }, m.$watch('isOpen', function (r, d) { let x = null; let _ = !1; if (angular.isDefined(n.dropdownAppendTo)) { const $ = i(n.dropdownAppendTo)(m); $ && (x = angular.element($)) } if (angular.isDefined(n.dropdownAppendToBody)) { !1 !== i(n.dropdownAppendToBody)(m) && (_ = !0) } if (_ && !x && (x = w), x && f.dropdownMenu && (r ? (x.append(f.dropdownMenu), e.on('$destroy', h)) : (e.off('$destroy', h), h())), x && f.dropdownMenu) { let T; let S; let M; const C = s.positionElements(e, f.dropdownMenu, 'bottom-left', !0); let E = 0; if (T = { top: C.top + 'px', display: r ? 'block' : 'none' }, S = f.dropdownMenu.hasClass('dropdown-menu-right'), S ? (T.left = 'auto', M = s.scrollbarPadding(x), M.heightOverflow && M.scrollbarWidth && (E = M.scrollbarWidth), T.right = window.innerWidth - E - (C.left + e.prop('offsetWidth')) + 'px') : (T.left = C.left + 'px', T.right = 'auto'), !_) { const A = s.offset(x); T.top = C.top - A.top + 'px', S ? T.right = window.innerWidth - (C.left - A.left + e.prop('offsetWidth')) + 'px' : T.left = C.left - A.left + 'px' }f.dropdownMenu.css(T) } const P = x || e; const k = x ? g : v; const D = P.hasClass(k); const O = a.isOnlyOpen(t, x); if (D === !r) { let L; L = x ? O ? 'removeClass' : 'addClass' : r ? 'addClass' : 'removeClass', o[L](P, k).then(function () { angular.isDefined(r) && r !== d && b(t, { open: !!r }) }) } if (r)f.dropdownMenuTemplateUrl ? u(f.dropdownMenuTemplateUrl).then(function (t) { p = m.$new(), c(t.trim())(p, function (t) { const e = t; f.dropdownMenu.replaceWith(e), f.dropdownMenu = e, l.on('keydown', a.keybindFilter) }) }) : l.on('keydown', a.keybindFilter), m.focusToggleElement(), a.open(m, e, x); else { if (a.close(m, e, x), f.dropdownMenuTemplateUrl) { p && p.$destroy(); const I = angular.element('<ul class="dropdown-menu"></ul>'); f.dropdownMenu.replaceWith(I), f.dropdownMenu = I }f.selectedOption = null }angular.isFunction(y) && y(t, r) }) }]).directive('uibDropdown', function () { return { controller: 'UibDropdownController', link: function (t, e, n, i) { i.init() } } }).directive('uibDropdownMenu', function () { return { restrict: 'A', require: '?^uibDropdown', link: function (t, e, n, i) { if (i && !angular.isDefined(n.dropdownNested)) { e.addClass('dropdown-menu'); const r = n.templateUrl; r && (i.dropdownMenuTemplateUrl = r), i.dropdownMenu || (i.dropdownMenu = e) } } } }).directive('uibDropdownToggle', function () { return { require: '?^uibDropdown', link: function (t, e, n, i) { if (i) { e.addClass('dropdown-toggle'), i.toggleElement = e; const r = function (r) { r.preventDefault(), e.hasClass('disabled') || n.disabled || t.$apply(function () { i.toggle() }) }; e.on('click', r), e.attr({ 'aria-haspopup': !0, 'aria-expanded': !1 }), t.$watch(i.isOpen, function (t) { e.attr('aria-expanded', !!t) }), t.$on('$destroy', function () { e.off('click', r) }) } } } }), angular.module('ui.bootstrap.stackedMap', []).factory('$$stackedMap', function () { return { createNew: function () { const t = []; return { add: function (e, n) { t.push({ key: e, value: n }) }, get: function (e) { for (let n = 0; n < t.length; n++) if (e === t[n].key) return t[n] }, keys: function () { for (var e = [], n = 0; n < t.length; n++)e.push(t[n].key); return e }, top: function () { return t[t.length - 1] }, remove: function (e) { for (var n = -1, i = 0; i < t.length; i++) if (e === t[i].key) { n = i; break } return t.splice(n, 1)[0] }, removeTop: function () { return t.pop() }, length: function () { return t.length } } } } }), angular.module('ui.bootstrap.modal', ['ui.bootstrap.multiMap', 'ui.bootstrap.stackedMap', 'ui.bootstrap.position']).provider('$uibResolve', function () { const t = this; this.resolver = null, this.setResolver = function (t) { this.resolver = t }, this.$get = ['$injector', '$q', function (e, n) { const i = t.resolver ? e.get(t.resolver) : null; return { resolve: function (t, r, a, o) { if (i) return i.resolve(t, r, a, o); const s = []; return angular.forEach(t, function (t) { angular.isFunction(t) || angular.isArray(t) ? s.push(n.resolve(e.invoke(t))) : angular.isString(t) ? s.push(n.resolve(e.get(t))) : s.push(n.resolve(t)) }), n.all(s).then(function (e) { const n = {}; let i = 0; return angular.forEach(t, function (t, r) { n[r] = e[i++] }), n }) } } }] }).directive('uibModalBackdrop', ['$animate', '$injector', '$uibModalStack', function (t, e, n) { function i (e, i, r) { r.modalInClass && (t.addClass(i, r.modalInClass), e.$on(n.NOW_CLOSING_EVENT, function (n, a) { const o = a(); e.modalOptions.animation ? t.removeClass(i, r.modalInClass).then(o) : o() })) } return { restrict: 'A', compile: function (t, e) { return t.addClass(e.backdropClass), i } } }]).directive('uibModalWindow', ['$uibModalStack', '$q', '$animateCss', '$document', function (t, e, n, i) { return { scope: { index: '@' }, restrict: 'A', transclude: !0, templateUrl: function (t, e) { return e.templateUrl || 'uib/template/modal/window.html' }, link: function (r, a, o) { a.addClass(o.windowTopClass || ''), r.size = o.size, r.close = function (e) { const n = t.getTop(); n && n.value.backdrop && n.value.backdrop !== 'static' && e.target === e.currentTarget && (e.preventDefault(), e.stopPropagation(), t.dismiss(n.key, 'backdrop click')) }, a.on('click', r.close), r.$isRendered = !0; const s = e.defer(); r.$$postDigest(function () { s.resolve() }), s.promise.then(function () { let s = null; o.modalInClass && (s = n(a, { addClass: o.modalInClass }).start(), r.$on(t.NOW_CLOSING_EVENT, function (t, e) { const i = e(); n(a, { removeClass: o.modalInClass }).start().then(i) })), e.when(s).then(function () { const e = t.getTop(); if (e && t.modalRendered(e.key), !i[0].activeElement || !a[0].contains(i[0].activeElement)) { const n = a[0].querySelector('[autofocus]'); n ? n.focus() : a[0].focus() } }) }) } } }]).directive('uibModalAnimationClass', function () { return { compile: function (t, e) { e.modalAnimation && t.addClass(e.uibModalAnimationClass) } } }).directive('uibModalTransclude', ['$animate', function (t) { return { link: function (e, n, i, r, a) { a(e.$parent, function (e) { n.empty(), t.enter(e, n) }) } } }]).factory('$uibModalStack', ['$animate', '$animateCss', '$document', '$compile', '$rootScope', '$q', '$$multiMap', '$$stackedMap', '$uibPosition', function (t, e, n, i, r, a, o, s, l) {
  function c (t) { return t.replace(A, function (t, e) { return (e ? '-' : '') + t.toLowerCase() }) } function u (t) { return !!(t.offsetWidth || t.offsetHeight || t.getClientRects().length) } function h () { for (var t = -1, e = $.keys(), n = 0; n < e.length; n++)$.get(e[n]).value.backdrop && (t = n); return t > -1 && t < M && (t = M), t } function p (t, e) { const n = $.get(t).value; const i = n.appendTo; $.remove(t), C = $.top(), C && (M = parseInt(C.value.modalDomEl.attr('index'), 10)), m(n.modalDomEl, n.modalScope, function () { const e = n.openedClass || _; T.remove(e, t); const r = T.hasKey(e); i.toggleClass(e, r), !r && w && w.heightOverflow && w.scrollbarWidth && (w.originalRight ? i.css({ paddingRight: w.originalRight + 'px' }) : i.css({ paddingRight: '' }), w = null), d(!0) }, n.closedDeferred), f(), e && e.focus ? e.focus() : i.focus && i.focus() } function d (t) { let e; $.length() > 0 && (e = $.top().value, e.modalDomEl.toggleClass(e.windowTopClass || '', t)) } function f () { if (b && h() === -1) { let t = x; m(b, x, function () { t = null }), b = void 0, x = void 0 } } function m (e, n, i, r) { function o () { o.done || (o.done = !0, t.leave(e).then(function () { i && i(), e.remove(), r && r.resolve() }), n.$destroy()) } let s; let l = null; const c = function () { return s || (s = a.defer(), l = s.promise), function () { s.resolve() } }; return n.$broadcast(S.NOW_CLOSING_EVENT, c), a.when(l).then(o) } function g (t) { if (t.isDefaultPrevented()) return t; const e = $.top(); if (e) switch (t.which) { case 27:e.value.keyboard && (t.preventDefault(), r.$apply(function () { S.dismiss(e.key, 'escape key press') })); break; case 9:var n = S.loadFocusElementList(e); var i = !1; t.shiftKey ? (S.isFocusInFirstItem(t, n) || S.isModalFocused(t, e)) && (i = S.focusLastFocusableElement(n)) : S.isFocusInLastItem(t, n) && (i = S.focusFirstFocusableElement(n)), i && (t.preventDefault(), t.stopPropagation()) } } function v (t, e, n) { return !t.value.modalScope.$broadcast('modal.closing', e, n).defaultPrevented } function y () { Array.prototype.forEach.call(document.querySelectorAll('[' + E + ']'), function (t) { const e = parseInt(t.getAttribute(E), 10); const n = e - 1; t.setAttribute(E, n), n || (t.removeAttribute(E), t.removeAttribute('aria-hidden')) }) } let b; let x; let w; var _ = 'modal-open'; var $ = s.createNew(); var T = o.createNew(); var S = { NOW_CLOSING_EVENT: 'modal.stack.now-closing' }; var M = 0; var C = null; var E = 'data-bootstrap-modal-aria-hidden-count'; var A = /[A-Z]/g; return r.$watch(h, function (t) { x && (x.index = t) }), n.on('keydown', g), r.$on('$destroy', function () { n.off('keydown', g) }), S.open = function (e, a) {
    function o (t) { if (t && t[0].tagName !== 'BODY') return (function (t) { const e = t.parent() ? t.parent().children() : []; return Array.prototype.filter.call(e, function (e) { return e !== t[0] }) }(t)).forEach(function (t) { const e = t.getAttribute('aria-hidden') === 'true'; let n = parseInt(t.getAttribute(E), 10); n || (n = e ? 1 : 0), t.setAttribute(E, n + 1), t.setAttribute('aria-hidden', 'true') }), o(t.parent()) } const s = n[0].activeElement; const u = a.openedClass || _; d(!1), C = $.top(), $.add(e, { deferred: a.deferred, renderDeferred: a.renderDeferred, closedDeferred: a.closedDeferred, modalScope: a.scope, backdrop: a.backdrop, keyboard: a.keyboard, openedClass: a.openedClass, windowTopClass: a.windowTopClass, animation: a.animation, appendTo: a.appendTo }), T.put(u, e); const p = a.appendTo; const f = h(); f >= 0 && !b && (x = r.$new(!0), x.modalOptions = a, x.index = f, b = angular.element('<div uib-modal-backdrop="modal-backdrop"></div>'), b.attr({ class: 'modal-backdrop', 'ng-style': "{'z-index': 1040 + (index && 1 || 0) + index*10}", 'uib-modal-animation-class': 'fade', 'modal-in-class': 'in' }), a.backdropClass && b.addClass(a.backdropClass), a.animation && b.attr('modal-animation', 'true'), i(b)(x), t.enter(b, p), l.isScrollable(p) && (w = l.scrollbarPadding(p),
    w.heightOverflow && w.scrollbarWidth && p.css({ paddingRight: w.right + 'px' }))); let m; a.component ? (m = document.createElement(c(a.component.name)), m = angular.element(m), m.attr({ resolve: '$resolve', 'modal-instance': '$uibModalInstance', close: '$close($value)', dismiss: '$dismiss($value)' })) : m = a.content, M = C ? parseInt(C.value.modalDomEl.attr('index'), 10) + 1 : 0; const g = angular.element('<div uib-modal-window="modal-window"></div>'); g.attr({ class: 'modal', 'template-url': a.windowTemplateUrl, 'window-top-class': a.windowTopClass, role: 'dialog', 'aria-labelledby': a.ariaLabelledBy, 'aria-describedby': a.ariaDescribedBy, size: a.size, index: M, animate: 'animate', 'ng-style': "{'z-index': 1050 + $$topModalIndex*10, display: 'block'}", tabindex: -1, 'uib-modal-animation-class': 'fade', 'modal-in-class': 'in' }).append(m), a.windowClass && g.addClass(a.windowClass), a.animation && g.attr('modal-animation', 'true'), p.addClass(u), a.scope && (a.scope.$$topModalIndex = M), t.enter(i(g)(a.scope), p), $.top().value.modalDomEl = g, $.top().value.modalOpener = s, o(g)
  }, S.close = function (t, e) { const n = $.get(t); return y(), n && v(n, e, !0) ? (n.value.modalScope.$$uibDestructionScheduled = !0, n.value.deferred.resolve(e), p(t, n.value.modalOpener), !0) : !n }, S.dismiss = function (t, e) { const n = $.get(t); return y(), n && v(n, e, !1) ? (n.value.modalScope.$$uibDestructionScheduled = !0, n.value.deferred.reject(e), p(t, n.value.modalOpener), !0) : !n }, S.dismissAll = function (t) { for (let e = this.getTop(); e && this.dismiss(e.key, t);)e = this.getTop() }, S.getTop = function () { return $.top() }, S.modalRendered = function (t) { const e = $.get(t); e && e.value.renderDeferred.resolve() }, S.focusFirstFocusableElement = function (t) { return t.length > 0 && (t[0].focus(), !0) }, S.focusLastFocusableElement = function (t) { return t.length > 0 && (t[t.length - 1].focus(), !0) }, S.isModalFocused = function (t, e) { if (t && e) { const n = e.value.modalDomEl; if (n && n.length) return (t.target || t.srcElement) === n[0] } return !1 }, S.isFocusInFirstItem = function (t, e) { return e.length > 0 && (t.target || t.srcElement) === e[0] }, S.isFocusInLastItem = function (t, e) { return e.length > 0 && (t.target || t.srcElement) === e[e.length - 1] }, S.loadFocusElementList = function (t) { if (t) { const e = t.value.modalDomEl; if (e && e.length) { const n = e[0].querySelectorAll("a[href], area[href], input:not([disabled]):not([tabindex='-1']), button:not([disabled]):not([tabindex='-1']),select:not([disabled]):not([tabindex='-1']), textarea:not([disabled]):not([tabindex='-1']), iframe, object, embed, *[tabindex]:not([tabindex='-1']), *[contenteditable=true]"); return n ? Array.prototype.filter.call(n, function (t) { return u(t) }) : n } } }, S
}]).provider('$uibModal', function () { var t = { options: { animation: !0, backdrop: !0, keyboard: !0 }, $get: ['$rootScope', '$q', '$document', '$templateRequest', '$controller', '$uibResolve', '$uibModalStack', function (e, n, i, r, a, o, s) { function l (t) { return t.template ? n.when(t.template) : r(angular.isFunction(t.templateUrl) ? t.templateUrl() : t.templateUrl) } const c = {}; let u = null; return c.getPromiseChain = function () { return u }, c.open = function (r) { function c () { return g } const h = n.defer(); const p = n.defer(); const d = n.defer(); const f = n.defer(); var m = { result: h.promise, opened: p.promise, closed: d.promise, rendered: f.promise, close: function (t) { return s.close(m, t) }, dismiss: function (t) { return s.dismiss(m, t) } }; if (r = angular.extend({}, t.options, r), r.resolve = r.resolve || {}, r.appendTo = r.appendTo || i.find('body').eq(0), !r.appendTo.length) throw new Error('appendTo element not found. Make sure that the element passed is in DOM.'); if (!r.component && !r.template && !r.templateUrl) throw new Error('One of component or template or templateUrl options is required.'); let g; g = r.component ? n.when(o.resolve(r.resolve, {}, null, null)) : n.all([l(r), o.resolve(r.resolve, {}, null, null)]); let v; return v = u = n.all([u]).then(c, c).then(function (t) { function n (e, n, i, r) { e.$scope = o, e.$scope.$resolve = {}, i ? e.$scope.$uibModalInstance = m : e.$uibModalInstance = m; const a = n ? t[1] : t; angular.forEach(a, function (t, n) { r && (e[n] = t), e.$scope.$resolve[n] = t }) } const i = r.scope || e; var o = i.$new(); o.$close = m.close, o.$dismiss = m.dismiss, o.$on('$destroy', function () { o.$$uibDestructionScheduled || o.$dismiss('$uibUnscheduledDestruction') }); let l; let c; const u = { scope: o, deferred: h, renderDeferred: f, closedDeferred: d, animation: r.animation, backdrop: r.backdrop, keyboard: r.keyboard, backdropClass: r.backdropClass, windowTopClass: r.windowTopClass, windowClass: r.windowClass, windowTemplateUrl: r.windowTemplateUrl, ariaLabelledBy: r.ariaLabelledBy, ariaDescribedBy: r.ariaDescribedBy, size: r.size, openedClass: r.openedClass, appendTo: r.appendTo }; const g = {}; const v = {}; r.component ? (n(g, !1, !0, !1), g.name = r.component, u.component = g) : r.controller && (n(v, !0, !1, !0), c = a(r.controller, v, !0, r.controllerAs), r.controllerAs && r.bindToController && (l = c.instance, l.$close = o.$close, l.$dismiss = o.$dismiss, angular.extend(l, { $resolve: v.$scope.$resolve }, i)), l = c(), angular.isFunction(l.$onInit) && l.$onInit()), r.component || (u.content = t[0]), s.open(m, u), p.resolve(!0) }, function (t) { p.reject(t), h.reject(t) }).finally(function () { u === v && (u = null) }), m }, c }] }; return t }), angular.module('ui.bootstrap.paging', []).factory('uibPaging', ['$parse', function (t) { return { create: function (e, n, i) { e.setNumPages = i.numPages ? t(i.numPages).assign : angular.noop, e.ngModelCtrl = { $setViewValue: angular.noop }, e._watchers = [], e.init = function (t, r) { e.ngModelCtrl = t, e.config = r, t.$render = function () { e.render() }, i.itemsPerPage ? e._watchers.push(n.$parent.$watch(i.itemsPerPage, function (t) { e.itemsPerPage = parseInt(t, 10), n.totalPages = e.calculateTotalPages(), e.updatePage() })) : e.itemsPerPage = r.itemsPerPage, n.$watch('totalItems', function (t, i) { (angular.isDefined(t) || t !== i) && (n.totalPages = e.calculateTotalPages(), e.updatePage()) }) }, e.calculateTotalPages = function () { const t = e.itemsPerPage < 1 ? 1 : Math.ceil(n.totalItems / e.itemsPerPage); return Math.max(t || 0, 1) }, e.render = function () { n.page = parseInt(e.ngModelCtrl.$viewValue, 10) || 1 }, n.selectPage = function (t, i) { i && i.preventDefault(), (!n.ngDisabled || !i) && n.page !== t && t > 0 && t <= n.totalPages && (i && i.target && i.target.blur(), e.ngModelCtrl.$setViewValue(t), e.ngModelCtrl.$render()) }, n.getText = function (t) { return n[t + 'Text'] || e.config[t + 'Text'] }, n.noPrevious = function () { return n.page === 1 }, n.noNext = function () { return n.page === n.totalPages }, e.updatePage = function () { e.setNumPages(n.$parent, n.totalPages), n.page > n.totalPages ? n.selectPage(n.totalPages) : e.ngModelCtrl.$render() }, n.$on('$destroy', function () { for (;e._watchers.length;)e._watchers.shift()() }) } } }]), angular.module('ui.bootstrap.pager', ['ui.bootstrap.paging', 'ui.bootstrap.tabindex']).controller('UibPagerController', ['$scope', '$attrs', 'uibPaging', 'uibPagerConfig', function (t, e, n, i) { t.align = angular.isDefined(e.align) ? t.$parent.$eval(e.align) : i.align, n.create(this, t, e) }]).constant('uibPagerConfig', { itemsPerPage: 10, previousText: ' Previous', nextText: 'Next ', align: !0 }).directive('uibPager', ['uibPagerConfig', function (t) { return { scope: { totalItems: '=', previousText: '@', nextText: '@', ngDisabled: '=' }, require: ['uibPager', '?ngModel'], restrict: 'A', controller: 'UibPagerController', controllerAs: 'pager', templateUrl: function (t, e) { return e.templateUrl || 'uib/template/pager/pager.html' }, link: function (e, n, i, r) { n.addClass('pager'); const a = r[0]; const o = r[1]; o && a.init(o, t) } } }]), angular.module('ui.bootstrap.pagination', ['ui.bootstrap.paging', 'ui.bootstrap.tabindex']).controller('UibPaginationController', ['$scope', '$attrs', '$parse', 'uibPaging', 'uibPaginationConfig', function (t, e, n, i, r) { function a (t, e, n) { return { number: t, text: e, active: n } } function o (t, e) { const n = []; let i = 1; let r = e; const o = angular.isDefined(l) && l < e; o && (c ? (i = Math.max(t - Math.floor(l / 2), 1), (r = i + l - 1) > e && (r = e, i = r - l + 1)) : (i = (Math.ceil(t / l) - 1) * l + 1, r = Math.min(i + l - 1, e))); for (let s = i; s <= r; s++) { const d = a(s, p(s), s === t); n.push(d) } if (o && l > 0 && (!c || u || h)) { if (i > 1) { if (!h || i > 3) { const f = a(i - 1, '...', !1); n.unshift(f) } if (h) { if (i === 3) { const m = a(2, '2', !1); n.unshift(m) } const g = a(1, '1', !1); n.unshift(g) } } if (r < e) { if (!h || r < e - 2) { const v = a(r + 1, '...', !1); n.push(v) } if (h) { if (r === e - 2) { const y = a(e - 1, e - 1, !1); n.push(y) } const b = a(e, e, !1); n.push(b) } } } return n } const s = this; var l = angular.isDefined(e.maxSize) ? t.$parent.$eval(e.maxSize) : r.maxSize; var c = angular.isDefined(e.rotate) ? t.$parent.$eval(e.rotate) : r.rotate; var u = angular.isDefined(e.forceEllipses) ? t.$parent.$eval(e.forceEllipses) : r.forceEllipses; var h = angular.isDefined(e.boundaryLinkNumbers) ? t.$parent.$eval(e.boundaryLinkNumbers) : r.boundaryLinkNumbers; var p = angular.isDefined(e.pageLabel) ? function (n) { return t.$parent.$eval(e.pageLabel, { $page: n }) } : angular.identity; t.boundaryLinks = angular.isDefined(e.boundaryLinks) ? t.$parent.$eval(e.boundaryLinks) : r.boundaryLinks, t.directionLinks = angular.isDefined(e.directionLinks) ? t.$parent.$eval(e.directionLinks) : r.directionLinks, e.$set('role', 'menu'), i.create(this, t, e), e.maxSize && s._watchers.push(t.$parent.$watch(n(e.maxSize), function (t) { l = parseInt(t, 10), s.render() })); const d = this.render; this.render = function () { d(), t.page > 0 && t.page <= t.totalPages && (t.pages = o(t.page, t.totalPages)) } }]).constant('uibPaginationConfig', { itemsPerPage: 10, boundaryLinks: !1, boundaryLinkNumbers: !1, directionLinks: !0, firstText: 'First', previousText: 'Previous', nextText: 'Next', lastText: 'Last', rotate: !0, forceEllipses: !1 }).directive('uibPagination', ['$parse', 'uibPaginationConfig', function (t, e) { return { scope: { totalItems: '=', firstText: '@', previousText: '@', nextText: '@', lastText: '@', ngDisabled: '=' }, require: ['uibPagination', '?ngModel'], restrict: 'A', controller: 'UibPaginationController', controllerAs: 'pagination', templateUrl: function (t, e) { return e.templateUrl || 'uib/template/pagination/pagination.html' }, link: function (t, n, i, r) { n.addClass('pagination'); const a = r[0]; const o = r[1]; o && a.init(o, e) } } }]), angular.module('ui.bootstrap.tooltip', ['ui.bootstrap.position', 'ui.bootstrap.stackedMap']).provider('$uibTooltip', function () { function t (t) { return t.replace(/[A-Z]/g, function (t, e) { return (e ? '-' : '') + t.toLowerCase() }) } const e = { placement: 'top', placementClassPrefix: '', animation: !0, popupDelay: 0, popupCloseDelay: 0, useContentExp: !1 }; const n = { mouseenter: 'mouseleave', click: 'click', outsideClick: 'outsideClick', focus: 'blur', none: '' }; const i = {}; this.options = function (t) { angular.extend(i, t) }, this.setTriggers = function (t) { angular.extend(n, t) }, this.$get = ['$window', '$compile', '$timeout', '$document', '$uibPosition', '$interpolate', '$rootScope', '$parse', '$$stackedMap', function (r, a, o, s, l, c, u, h, p) { function d (t) { if (t.which === 27) { let e = f.top(); e && (e.value.close(), e = null) } } var f = p.createNew(); return s.on('keyup', d), u.$on('$destroy', function () { s.off('keyup', d) }), function (r, u, p, d) { function m (t) { const e = (t || d.trigger || p).split(' '); return { show: e, hide: e.map(function (t) { return n[t] || t }) } }d = angular.extend({}, e, i, d); const g = t(r); const v = c.startSymbol(); const y = c.endSymbol(); const b = '<div ' + g + '-popup uib-title="' + v + 'title' + y + '" ' + (d.useContentExp ? 'content-exp="contentExp()" ' : 'content="' + v + 'content' + y + '" ') + 'origin-scope="origScope" class="uib-position-measure ' + u + '" tooltip-animation-class="fade"uib-tooltip-classes ng-class="{ in: isOpen }" ></div>'; return { compile: function (t, e) { const n = a(b); return function (t, e, i, a) { function c () { z.isOpen ? g() : p() } function p () { U && !t.$eval(i[u + 'Enable']) || (x(), $(), z.popupDelay ? D || (D = o(v, z.popupDelay, !1)) : v()) } function g () { y(), z.popupCloseDelay ? O || (O = o(b, z.popupCloseDelay, !1)) : b() } function v () { if (y(), x(), !z.content) return angular.noop; w(), z.$evalAsync(function () { z.isOpen = !0, T(!0), H() }) } function y () { D && (o.cancel(D), D = null), L && (o.cancel(L), L = null) } function b () { z && z.$evalAsync(function () { z && (z.isOpen = !1, T(!1), z.animation ? k || (k = o(_, 150, !1)) : _()) }) } function x () { O && (o.cancel(O), O = null), k && (o.cancel(k), k = null) } function w () { A || (P = z.$new(), A = n(P, function (t) { N ? s.find('body').append(t) : e.after(t) }), f.add(z, { close: b }), S()) } function _ () { y(), x(), M(), A && (A.remove(), A = null, I && o.cancel(I)), f.remove(z), P && (P.$destroy(), P = null) } function $ () { z.title = i[u + 'Title'], z.content = V ? V(t) : i[r], z.popupClass = i[u + 'Class'], z.placement = angular.isDefined(i[u + 'Placement']) ? i[u + 'Placement'] : d.placement; const e = l.parsePlacement(z.placement); R = e[1] ? e[0] + '-' + e[1] : e[0]; const n = parseInt(i[u + 'PopupDelay'], 10); const a = parseInt(i[u + 'PopupCloseDelay'], 10); z.popupDelay = isNaN(n) ? d.popupDelay : n, z.popupCloseDelay = isNaN(a) ? d.popupCloseDelay : a } function T (e) { j && angular.isFunction(j.assign) && j.assign(t, e) } function S () { G.length = 0, V ? (G.push(t.$watch(V, function (t) { z.content = t, !t && z.isOpen && b() })), G.push(P.$watch(function () { B || (B = !0, P.$$postDigest(function () { B = !1, z && z.isOpen && H() })) }))) : G.push(i.$observe(r, function (t) { z.content = t, !t && z.isOpen ? b() : H() })), G.push(i.$observe(u + 'Title', function (t) { z.title = t, z.isOpen && H() })), G.push(i.$observe(u + 'Placement', function (t) { z.placement = t || d.placement, z.isOpen && H() })) } function M () { G.length && (angular.forEach(G, function (t) { t() }), G.length = 0) } function C (t) { z && z.isOpen && A && (e[0].contains(t.target) || A[0].contains(t.target) || g()) } function E (t) { t.which === 27 && g() } let A; let P; let k; let D; let O; let L; let I; let R; var N = !!angular.isDefined(d.appendToBody) && d.appendToBody; let F = m(void 0); var U = angular.isDefined(i[u + 'Enable']); var z = t.$new(!0); var B = !1; var j = !!angular.isDefined(i[u + 'IsOpen']) && h(i[u + 'IsOpen']); var V = !!d.useContentExp && h(i[r]); var G = []; var H = function () { A && A.html() && (L || (L = o(function () { const t = l.positionElements(e, A, z.placement, N); const n = angular.isDefined(A.offsetHeight) ? A.offsetHeight : A.prop('offsetHeight'); const i = N ? l.offset(e) : l.position(e); A.css({ top: t.top + 'px', left: t.left + 'px' }); const r = t.placement.split('-'); A.hasClass(r[0]) || (A.removeClass(R.split('-')[0]), A.addClass(r[0])), A.hasClass(d.placementClassPrefix + t.placement) || (A.removeClass(d.placementClassPrefix + R), A.addClass(d.placementClassPrefix + t.placement)), I = o(function () { const t = angular.isDefined(A.offsetHeight) ? A.offsetHeight : A.prop('offsetHeight'); const e = l.adjustTop(r, i, n, t); e && A.css(e), I = null }, 0, !1), A.hasClass('uib-position-measure') ? (l.positionArrow(A, t.placement), A.removeClass('uib-position-measure')) : R !== t.placement && l.positionArrow(A, t.placement), R = t.placement, L = null }, 0, !1))) }; z.origScope = t, z.isOpen = !1, z.contentExp = function () { return z.content }, i.$observe('disabled', function (t) { t && y(), t && z.isOpen && b() }), j && t.$watch(j, function (t) { z && !t === z.isOpen && c() }); const W = function () { F.show.forEach(function (t) { t === 'outsideClick' ? e.off('click', c) : (e.off(t, p), e.off(t, c)), e.off('keypress', E) }), F.hide.forEach(function (t) { t === 'outsideClick' ? s.off('click', C) : e.off(t, g) }) }; !(function () { const n = []; const r = []; const a = t.$eval(i[u + 'Trigger']); W(), angular.isObject(a) ? (Object.keys(a).forEach(function (t) { n.push(t), r.push(a[t]) }), F = { show: n, hide: r }) : F = m(a), F.show !== 'none' && F.show.forEach(function (t, n) { t === 'outsideClick' ? (e.on('click', c), s.on('click', C)) : t === F.hide[n] ? e.on(t, c) : t && (e.on(t, p), e.on(F.hide[n], g)), e.on('keypress', E) }) }()); const q = t.$eval(i[u + 'Animation']); z.animation = angular.isDefined(q) ? !!q : d.animation; let X; const Y = u + 'AppendToBody'; X = Y in i && void 0 === i[Y] || t.$eval(i[Y]), N = angular.isDefined(X) ? X : N, t.$on('$destroy', function () { W(), _(), z = null }) } } } } }] }).directive('uibTooltipTemplateTransclude', ['$animate', '$sce', '$compile', '$templateRequest', function (t, e, n, i) { return { link: function (r, a, o) { let s; let l; let c; const u = r.$eval(o.tooltipTemplateTranscludeScope); let h = 0; const p = function () { l && (l.remove(), l = null), s && (s.$destroy(), s = null), c && (t.leave(c).then(function () { l = null }), l = c, c = null) }; r.$watch(e.parseAsResourceUrl(o.uibTooltipTemplateTransclude), function (e) { const o = ++h; e ? (i(e, !0).then(function (i) { if (o === h) { const r = u.$new(); const l = i; const d = n(l)(r, function (e) { p(), t.enter(e, a) }); s = r, c = d, s.$emit('$includeContentLoaded', e) } }, function () { o === h && (p(), r.$emit('$includeContentError', e)) }), r.$emit('$includeContentRequested', e)) : p() }), r.$on('$destroy', p) } } }]).directive('uibTooltipClasses', ['$uibPosition', function (t) { return { restrict: 'A', link: function (e, n, i) { if (e.placement) { const r = t.parsePlacement(e.placement); n.addClass(r[0]) }e.popupClass && n.addClass(e.popupClass), e.animation && n.addClass(i.tooltipAnimationClass) } } }]).directive('uibTooltipPopup', function () { return { restrict: 'A', scope: { content: '@' }, templateUrl: 'uib/template/tooltip/tooltip-popup.html' } }).directive('uibTooltip', ['$uibTooltip', function (t) { return t('uibTooltip', 'tooltip', 'mouseenter') }]).directive('uibTooltipTemplatePopup', function () { return { restrict: 'A', scope: { contentExp: '&', originScope: '&' }, templateUrl: 'uib/template/tooltip/tooltip-template-popup.html' } }).directive('uibTooltipTemplate', ['$uibTooltip', function (t) { return t('uibTooltipTemplate', 'tooltip', 'mouseenter', { useContentExp: !0 }) }]).directive('uibTooltipHtmlPopup', function () { return { restrict: 'A', scope: { contentExp: '&' }, templateUrl: 'uib/template/tooltip/tooltip-html-popup.html' } }).directive('uibTooltipHtml', ['$uibTooltip', function (t) { return t('uibTooltipHtml', 'tooltip', 'mouseenter', { useContentExp: !0 }) }]), angular.module('ui.bootstrap.popover', ['ui.bootstrap.tooltip']).directive('uibPopoverTemplatePopup', function () { return { restrict: 'A', scope: { uibTitle: '@', contentExp: '&', originScope: '&' }, templateUrl: 'uib/template/popover/popover-template.html' } }).directive('uibPopoverTemplate', ['$uibTooltip', function (t) { return t('uibPopoverTemplate', 'popover', 'click', { useContentExp: !0 }) }]).directive('uibPopoverHtmlPopup', function () { return { restrict: 'A', scope: { contentExp: '&', uibTitle: '@' }, templateUrl: 'uib/template/popover/popover-html.html' } }).directive('uibPopoverHtml', ['$uibTooltip', function (t) { return t('uibPopoverHtml', 'popover', 'click', { useContentExp: !0 }) }]).directive('uibPopoverPopup', function () { return { restrict: 'A', scope: { uibTitle: '@', content: '@' }, templateUrl: 'uib/template/popover/popover.html' } }).directive('uibPopover', ['$uibTooltip', function (t) { return t('uibPopover', 'popover', 'click') }]), angular.module('ui.bootstrap.progressbar', []).constant('uibProgressConfig', { animate: !0, max: 100 }).controller('UibProgressController', ['$scope', '$attrs', 'uibProgressConfig', function (t, e, n) { function i () { return angular.isDefined(t.maxParam) ? t.maxParam : n.max } const r = this; const a = angular.isDefined(e.animate) ? t.$parent.$eval(e.animate) : n.animate; this.bars = [], t.max = i(), this.addBar = function (t, e, n) { a || e.css({ transition: 'none' }), this.bars.push(t), t.max = i(), t.title = n && angular.isDefined(n.title) ? n.title : 'progressbar', t.$watch('value', function (e) { t.recalculatePercentage() }), t.recalculatePercentage = function () { const e = r.bars.reduce(function (t, e) { return e.percent = +(100 * e.value / e.max).toFixed(2), t + e.percent }, 0); e > 100 && (t.percent -= e - 100) }, t.$on('$destroy', function () { e = null, r.removeBar(t) }) }, this.removeBar = function (t) { this.bars.splice(this.bars.indexOf(t), 1), this.bars.forEach(function (t) { t.recalculatePercentage() }) }, t.$watch('maxParam', function (t) { r.bars.forEach(function (t) { t.max = i(), t.recalculatePercentage() }) }) }]).directive('uibProgress', function () { return { replace: !0, transclude: !0, controller: 'UibProgressController', require: 'uibProgress', scope: { maxParam: '=?max' }, templateUrl: 'uib/template/progressbar/progress.html' } }).directive('uibBar', function () { return { replace: !0, transclude: !0, require: '^uibProgress', scope: { value: '=', type: '@' }, templateUrl: 'uib/template/progressbar/bar.html', link: function (t, e, n, i) { i.addBar(t, e, n) } } }).directive('uibProgressbar', function () { return { replace: !0, transclude: !0, controller: 'UibProgressController', scope: { value: '=', maxParam: '=?max', type: '@' }, templateUrl: 'uib/template/progressbar/progressbar.html', link: function (t, e, n, i) { i.addBar(t, angular.element(e.children()[0]), { title: n.title }) } } }), angular.module('ui.bootstrap.rating', []).constant('uibRatingConfig', { max: 5, stateOn: null, stateOff: null, enableReset: !0, titles: ['one', 'two', 'three', 'four', 'five'] }).controller('UibRatingController', ['$scope', '$attrs', 'uibRatingConfig', function (t, e, n) { let i = { $setViewValue: angular.noop }; const r = this; this.init = function (r) { i = r, i.$render = this.render, i.$formatters.push(function (t) { return angular.isNumber(t) && t << 0 !== t && (t = Math.round(t)), t }), this.stateOn = angular.isDefined(e.stateOn) ? t.$parent.$eval(e.stateOn) : n.stateOn, this.stateOff = angular.isDefined(e.stateOff) ? t.$parent.$eval(e.stateOff) : n.stateOff, this.enableReset = angular.isDefined(e.enableReset) ? t.$parent.$eval(e.enableReset) : n.enableReset; const a = angular.isDefined(e.titles) ? t.$parent.$eval(e.titles) : n.titles; this.titles = angular.isArray(a) && a.length > 0 ? a : n.titles; const o = angular.isDefined(e.ratingStates) ? t.$parent.$eval(e.ratingStates) : new Array(angular.isDefined(e.max) ? t.$parent.$eval(e.max) : n.max); t.range = this.buildTemplateObjects(o) }, this.buildTemplateObjects = function (t) { for (let e = 0, n = t.length; e < n; e++)t[e] = angular.extend({ index: e }, { stateOn: this.stateOn, stateOff: this.stateOff, title: this.getTitle(e) }, t[e]); return t }, this.getTitle = function (t) { return t >= this.titles.length ? t + 1 : this.titles[t] }, t.rate = function (e) { if (!t.readonly && e >= 0 && e <= t.range.length) { const n = r.enableReset && i.$viewValue === e ? 0 : e; i.$setViewValue(n), i.$render() } }, t.enter = function (e) { t.readonly || (t.value = e), t.onHover({ value: e }) }, t.reset = function () { t.value = i.$viewValue, t.onLeave() }, t.onKeydown = function (e) { /(37|38|39|40)/.test(e.which) && (e.preventDefault(), e.stopPropagation(), t.rate(t.value + (e.which === 38 || e.which === 39 ? 1 : -1))) }, this.render = function () { t.value = i.$viewValue, t.title = r.getTitle(t.value - 1) } }]).directive('uibRating', function () { return { require: ['uibRating', 'ngModel'], restrict: 'A', scope: { readonly: '=?readOnly', onHover: '&', onLeave: '&' }, controller: 'UibRatingController', templateUrl: 'uib/template/rating/rating.html', link: function (t, e, n, i) { const r = i[0]; const a = i[1]; r.init(a) } } }), angular.module('ui.bootstrap.tabs', []).controller('UibTabsetController', ['$scope', function (t) { function e (t) { for (let e = 0; e < i.tabs.length; e++) if (i.tabs[e].index === t) return e } let n; var i = this; i.tabs = [], i.select = function (t, a) { if (!r) { const o = e(n); const s = i.tabs[o]; if (s) { if (s.tab.onDeselect({ $event: a, $selectedIndex: t }), a && a.isDefaultPrevented()) return; s.tab.active = !1 } const l = i.tabs[t]; l ? (l.tab.onSelect({ $event: a }), l.tab.active = !0, i.active = l.index, n = l.index) : !l && angular.isDefined(n) && (i.active = null, n = null) } }, i.addTab = function (t) { if (i.tabs.push({ tab: t, index: t.index }), i.tabs.sort(function (t, e) { return t.index > e.index ? 1 : t.index < e.index ? -1 : 0 }), t.index === i.active || !angular.isDefined(i.active) && i.tabs.length === 1) { const n = e(t.index); i.select(n) } }, i.removeTab = function (t) { for (var e, n = 0; n < i.tabs.length; n++) if (i.tabs[n].tab === t) { e = n; break } if (i.tabs[e].index === i.active) { const r = e === i.tabs.length - 1 ? e - 1 : e + 1 % i.tabs.length; i.select(r) }i.tabs.splice(e, 1) }, t.$watch('tabset.active', function (t) { angular.isDefined(t) && t !== n && i.select(e(t)) }); let r; t.$on('$destroy', function () { r = !0 }) }]).directive('uibTabset', function () { return { transclude: !0, replace: !0, scope: {}, bindToController: { active: '=?', type: '@' }, controller: 'UibTabsetController', controllerAs: 'tabset', templateUrl: function (t, e) { return e.templateUrl || 'uib/template/tabs/tabset.html' }, link: function (t, e, n) { t.vertical = !!angular.isDefined(n.vertical) && t.$parent.$eval(n.vertical), t.justified = !!angular.isDefined(n.justified) && t.$parent.$eval(n.justified) } } }).directive('uibTab', ['$parse', function (t) { return { require: '^uibTabset', replace: !0, templateUrl: function (t, e) { return e.templateUrl || 'uib/template/tabs/tab.html' }, transclude: !0, scope: { heading: '@', index: '=?', classes: '@?', onSelect: '&select', onDeselect: '&deselect' }, controller: function () {}, controllerAs: 'tab', link: function (e, n, i, r, a) { e.disabled = !1, i.disable && e.$parent.$watch(t(i.disable), function (t) { e.disabled = !!t }), angular.isUndefined(i.index) && (r.tabs && r.tabs.length ? e.index = Math.max.apply(null, r.tabs.map(function (t) { return t.index })) + 1 : e.index = 0), angular.isUndefined(i.classes) && (e.classes = ''), e.select = function (t) { if (!e.disabled) { for (var n, i = 0; i < r.tabs.length; i++) if (r.tabs[i].tab === e) { n = i; break }r.select(n, t) } }, r.addTab(e), e.$on('$destroy', function () { r.removeTab(e) }), e.$transcludeFn = a } } }]).directive('uibTabHeadingTransclude', function () { return { restrict: 'A', require: '^uibTab', link: function (t, e) { t.$watch('headingElement', function (t) { t && (e.html(''), e.append(t)) }) } } }).directive('uibTabContentTransclude', function () { function t (t) { return t.tagName && (t.hasAttribute('uib-tab-heading') || t.hasAttribute('data-uib-tab-heading') || t.hasAttribute('x-uib-tab-heading') || t.tagName.toLowerCase() === 'uib-tab-heading' || t.tagName.toLowerCase() === 'data-uib-tab-heading' || t.tagName.toLowerCase() === 'x-uib-tab-heading' || t.tagName.toLowerCase() === 'uib:tab-heading') } return { restrict: 'A', require: '^uibTabset', link: function (e, n, i) { const r = e.$eval(i.uibTabContentTransclude).tab; r.$transcludeFn(r.$parent, function (e) { angular.forEach(e, function (e) { t(e) ? r.headingElement = e : n.append(e) }) }) } } }), angular.module('ui.bootstrap.timepicker', []).constant('uibTimepickerConfig', { hourStep: 1, minuteStep: 1, secondStep: 1, showMeridian: !0, showSeconds: !1, meridians: null, readonlyInput: !1, mousewheel: !0, arrowkeys: !0, showSpinners: !0, templateUrl: 'uib/template/timepicker/timepicker.html' }).controller('UibTimepickerController', ['$scope', '$element', '$attrs', '$parse', '$log', '$locale', 'uibTimepickerConfig', function (t, e, n, i, r, a, o) { function s () { let e = +t.hours; if ((t.showMeridian ? e > 0 && e < 13 : e >= 0 && e < 24) && t.hours !== '') return t.showMeridian && (e === 12 && (e = 0), t.meridian === T[1] && (e += 12)), e } function l () { const e = +t.minutes; if (e >= 0 && e < 60 && t.minutes !== '') return e } function c () { const e = +t.seconds; return e >= 0 && e < 60 ? e : void 0 } function u (t, e) { return t === null ? '' : angular.isDefined(t) && t.toString().length < 2 && !e ? '0' + t : t.toString() } function h (t) { p(), $.$setViewValue(new Date(w)), d(t) } function p () { y && y.$setValidity('hours', !0), b && b.$setValidity('minutes', !0), x && x.$setValidity('seconds', !0), $.$setValidity('time', !0), t.invalidHours = !1, t.invalidMinutes = !1, t.invalidSeconds = !1 } function d (e) { if ($.$modelValue) { let n = w.getHours(); const i = w.getMinutes(); const r = w.getSeconds(); t.showMeridian && (n = n === 0 || n === 12 ? 12 : n % 12), t.hours = e === 'h' ? n : u(n, !S), e !== 'm' && (t.minutes = u(i)), t.meridian = w.getHours() < 12 ? T[0] : T[1], e !== 's' && (t.seconds = u(r)), t.meridian = w.getHours() < 12 ? T[0] : T[1] } else t.hours = null, t.minutes = null, t.seconds = null, t.meridian = T[0] } function f (t) { w = g(w, t), h() } function m (t, e) { return g(t, 60 * e) } function g (t, e) { const n = new Date(t.getTime() + 1e3 * e); const i = new Date(t); return i.setHours(n.getHours(), n.getMinutes(), n.getSeconds()), i } function v () { return (t.hours === null || t.hours === '') && (t.minutes === null || t.minutes === '') && (!t.showSeconds || t.showSeconds && (t.seconds === null || t.seconds === '')) } let y; let b; let x; var w = new Date(); const _ = []; var $ = { $setViewValue: angular.noop }; var T = angular.isDefined(n.meridians) ? t.$parent.$eval(n.meridians) : o.meridians || a.DATETIME_FORMATS.AMPMS; var S = !angular.isDefined(n.padHours) || t.$parent.$eval(n.padHours); t.tabindex = angular.isDefined(n.tabindex) ? n.tabindex : 0, e.removeAttr('tabindex'), this.init = function (e, i) { $ = e, $.$render = this.render, $.$formatters.unshift(function (t) { return t ? new Date(t) : null }); const r = i.eq(0); const a = i.eq(1); const s = i.eq(2); y = r.controller('ngModel'), b = a.controller('ngModel'), x = s.controller('ngModel'), (angular.isDefined(n.mousewheel) ? t.$parent.$eval(n.mousewheel) : o.mousewheel) && this.setupMousewheelEvents(r, a, s), (angular.isDefined(n.arrowkeys) ? t.$parent.$eval(n.arrowkeys) : o.arrowkeys) && this.setupArrowkeyEvents(r, a, s), t.readonlyInput = angular.isDefined(n.readonlyInput) ? t.$parent.$eval(n.readonlyInput) : o.readonlyInput, this.setupInputEvents(r, a, s) }; let M = o.hourStep; n.hourStep && _.push(t.$parent.$watch(i(n.hourStep), function (t) { M = +t })); let C = o.minuteStep; n.minuteStep && _.push(t.$parent.$watch(i(n.minuteStep), function (t) { C = +t })); let E; _.push(t.$parent.$watch(i(n.min), function (t) { const e = new Date(t); E = isNaN(e) ? void 0 : e })); let A; _.push(t.$parent.$watch(i(n.max), function (t) { const e = new Date(t); A = isNaN(e) ? void 0 : e })); let P = !1; n.ngDisabled && _.push(t.$parent.$watch(i(n.ngDisabled), function (t) { P = t })), t.noIncrementHours = function () { const t = m(w, 60 * M); return P || t > A || t < w && t < E }, t.noDecrementHours = function () { const t = m(w, 60 * -M); return P || t < E || t > w && t > A }, t.noIncrementMinutes = function () { const t = m(w, C); return P || t > A || t < w && t < E }, t.noDecrementMinutes = function () { const t = m(w, -C); return P || t < E || t > w && t > A }, t.noIncrementSeconds = function () { const t = g(w, k); return P || t > A || t < w && t < E }, t.noDecrementSeconds = function () { const t = g(w, -k); return P || t < E || t > w && t > A }, t.noToggleMeridian = function () { return w.getHours() < 12 ? P || m(w, 720) > A : P || m(w, -720) < E }; var k = o.secondStep; n.secondStep && _.push(t.$parent.$watch(i(n.secondStep), function (t) { k = +t })), t.showSeconds = o.showSeconds, n.showSeconds && _.push(t.$parent.$watch(i(n.showSeconds), function (e) { t.showSeconds = !!e })), t.showMeridian = o.showMeridian, n.showMeridian && _.push(t.$parent.$watch(i(n.showMeridian), function (e) { if (t.showMeridian = !!e, $.$error.time) { const n = s(); const i = l(); angular.isDefined(n) && angular.isDefined(i) && (w.setHours(n), h()) } else d() })), this.setupMousewheelEvents = function (e, n, i) { const r = function (t) { t.originalEvent && (t = t.originalEvent); const e = t.wheelDelta ? t.wheelDelta : -t.deltaY; return t.detail || e > 0 }; e.on('mousewheel wheel', function (e) { P || t.$apply(r(e) ? t.incrementHours() : t.decrementHours()), e.preventDefault() }), n.on('mousewheel wheel', function (e) { P || t.$apply(r(e) ? t.incrementMinutes() : t.decrementMinutes()), e.preventDefault() }), i.on('mousewheel wheel', function (e) { P || t.$apply(r(e) ? t.incrementSeconds() : t.decrementSeconds()), e.preventDefault() }) }, this.setupArrowkeyEvents = function (e, n, i) { e.on('keydown', function (e) { P || (e.which === 38 ? (e.preventDefault(), t.incrementHours(), t.$apply()) : e.which === 40 && (e.preventDefault(), t.decrementHours(), t.$apply())) }), n.on('keydown', function (e) { P || (e.which === 38 ? (e.preventDefault(), t.incrementMinutes(), t.$apply()) : e.which === 40 && (e.preventDefault(), t.decrementMinutes(), t.$apply())) }), i.on('keydown', function (e) { P || (e.which === 38 ? (e.preventDefault(), t.incrementSeconds(), t.$apply()) : e.which === 40 && (e.preventDefault(), t.decrementSeconds(), t.$apply())) }) }, this.setupInputEvents = function (e, n, i) { if (t.readonlyInput) return t.updateHours = angular.noop, t.updateMinutes = angular.noop, void (t.updateSeconds = angular.noop); const r = function (e, n, i) { $.$setViewValue(null), $.$setValidity('time', !1), angular.isDefined(e) && (t.invalidHours = e, y && y.$setValidity('hours', !1)), angular.isDefined(n) && (t.invalidMinutes = n, b && b.$setValidity('minutes', !1)), angular.isDefined(i) && (t.invalidSeconds = i, x && x.$setValidity('seconds', !1)) }; t.updateHours = function () { const t = s(); const e = l(); $.$setDirty(), angular.isDefined(t) && angular.isDefined(e) ? (w.setHours(t), w.setMinutes(e), w < E || w > A ? r(!0) : h('h')) : r(!0) }, e.on('blur', function (e) { $.$setTouched(), v() ? p() : t.hours === null || t.hours === '' ? r(!0) : !t.invalidHours && t.hours < 10 && t.$apply(function () { t.hours = u(t.hours, !S) }) }), t.updateMinutes = function () { const t = l(); const e = s(); $.$setDirty(), angular.isDefined(t) && angular.isDefined(e) ? (w.setHours(e), w.setMinutes(t), w < E || w > A ? r(void 0, !0) : h('m')) : r(void 0, !0) }, n.on('blur', function (e) { $.$setTouched(), v() ? p() : t.minutes === null ? r(void 0, !0) : !t.invalidMinutes && t.minutes < 10 && t.$apply(function () { t.minutes = u(t.minutes) }) }), t.updateSeconds = function () { const t = c(); $.$setDirty(), angular.isDefined(t) ? (w.setSeconds(t), h('s')) : r(void 0, void 0, !0) }, i.on('blur', function (e) { v() ? p() : !t.invalidSeconds && t.seconds < 10 && t.$apply(function () { t.seconds = u(t.seconds) }) }) }, this.render = function () { const e = $.$viewValue; isNaN(e) ? ($.$setValidity('time', !1), r.error('Timepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.')) : (e && (w = e), w < E || w > A ? ($.$setValidity('time', !1), t.invalidHours = !0, t.invalidMinutes = !0) : p(), d()) }, t.showSpinners = angular.isDefined(n.showSpinners) ? t.$parent.$eval(n.showSpinners) : o.showSpinners, t.incrementHours = function () { t.noIncrementHours() || f(60 * M * 60) }, t.decrementHours = function () { t.noDecrementHours() || f(60 * -M * 60) }, t.incrementMinutes = function () { t.noIncrementMinutes() || f(60 * C) }, t.decrementMinutes = function () { t.noDecrementMinutes() || f(60 * -C) }, t.incrementSeconds = function () { t.noIncrementSeconds() || f(k) }, t.decrementSeconds = function () { t.noDecrementSeconds() || f(-k) }, t.toggleMeridian = function () { const e = l(); const n = s(); t.noToggleMeridian() || (angular.isDefined(e) && angular.isDefined(n) ? f(720 * (w.getHours() < 12 ? 60 : -60)) : t.meridian = t.meridian === T[0] ? T[1] : T[0]) }, t.blur = function () { $.$setTouched() }, t.$on('$destroy', function () { for (;_.length;)_.shift()() }) }]).directive('uibTimepicker', ['uibTimepickerConfig', function (t) { return { require: ['uibTimepicker', '?^ngModel'], restrict: 'A', controller: 'UibTimepickerController', controllerAs: 'timepicker', scope: {}, templateUrl: function (e, n) { return n.templateUrl || t.templateUrl }, link: function (t, e, n, i) { const r = i[0]; const a = i[1]; a && r.init(a, e.find('input')) } } }]), angular.module('ui.bootstrap.typeahead', ['ui.bootstrap.debounce', 'ui.bootstrap.position']).factory('uibTypeaheadParser', ['$parse', function (t) {
  return {
    parse: function (e) {
      const n = e.match(/^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+([\s\S]+?)$/)
      if (!n) throw new Error('Expected typeahead specification in form of "_modelValue_ (as _label_)? for _item_ in _collection_" but got "' + e + '".'); return { itemName: n[3], source: t(n[4]), viewMapper: t(n[2] || n[1]), modelMapper: t(n[1]) }
    }
  }
}]).controller('UibTypeaheadController', ['$scope', '$element', '$attrs', '$compile', '$parse', '$q', '$timeout', '$document', '$window', '$rootScope', '$$debounce', '$uibPosition', 'uibTypeaheadParser', function (t, e, n, i, r, a, o, s, l, c, u, h, p) { function d () { z.moveInProgress || (z.moveInProgress = !0, z.$digest()), K() } function f () { z.position = P ? h.offset(e) : h.position(e), z.position.top += e.prop('offsetHeight') } function m (t) { let e; return angular.version.minor < 6 ? (e = t.$options || {}, e.getOption = function (t) { return e[t] }) : e = t.$options, e } let g; let v; const y = [9, 13, 27, 38, 40]; let b = t.$eval(n.typeaheadMinLength); b || b === 0 || (b = 1), t.$watch(n.typeaheadMinLength, function (t) { b = t || t === 0 ? t : 1 }); const x = t.$eval(n.typeaheadWaitMs) || 0; let w = !1 !== t.$eval(n.typeaheadEditable); t.$watch(n.typeaheadEditable, function (t) { w = !1 !== t }); let _; let $; const T = r(n.typeaheadLoading).assign || angular.noop; const S = n.typeaheadShouldSelect ? r(n.typeaheadShouldSelect) : function (t, e) { const n = e.$event; return n.which === 13 || n.which === 9 }; const M = r(n.typeaheadOnSelect); const C = !!angular.isDefined(n.typeaheadSelectOnBlur) && t.$eval(n.typeaheadSelectOnBlur); const E = r(n.typeaheadNoResults).assign || angular.noop; const A = n.typeaheadInputFormatter ? r(n.typeaheadInputFormatter) : void 0; var P = !!n.typeaheadAppendToBody && t.$eval(n.typeaheadAppendToBody); const k = n.typeaheadAppendTo ? t.$eval(n.typeaheadAppendTo) : null; const D = !1 !== t.$eval(n.typeaheadFocusFirst); const O = !!n.typeaheadSelectOnExact && t.$eval(n.typeaheadSelectOnExact); const L = r(n.typeaheadIsOpen).assign || angular.noop; const I = t.$eval(n.typeaheadShowHint) || !1; const R = r(n.ngModel); const N = r(n.ngModel + '($$$p)'); const F = function (e, n) { return angular.isFunction(R(t)) && v.getOption('getterSetter') ? N(e, { $$$p: n }) : R.assign(e, n) }; const U = p.parse(n.uibTypeahead); var z = t.$new(); const B = t.$on('$destroy', function () { z.$destroy() }); z.$on('$destroy', B); const j = 'typeahead-' + z.$id + '-' + Math.floor(1e4 * Math.random()); e.attr({ 'aria-autocomplete': 'list', 'aria-expanded': !1, 'aria-owns': j }); let V, G; I && (V = angular.element('<div></div>'), V.css('position', 'relative'), e.after(V), G = e.clone(), G.attr('placeholder', ''), G.attr('tabindex', '-1'), G.val(''), G.css({ position: 'absolute', top: '0px', left: '0px', 'border-color': 'transparent', 'box-shadow': 'none', opacity: 1, background: 'none 0% 0% / auto repeat scroll padding-box border-box rgb(255, 255, 255)', color: '#999' }), e.css({ position: 'relative', 'vertical-align': 'top', 'background-color': 'transparent' }), G.attr('id') && G.removeAttr('id'), V.append(G), G.after(e)); const H = angular.element('<div uib-typeahead-popup></div>'); H.attr({ id: j, matches: 'matches', active: 'activeIdx', select: 'select(activeIdx, evt)', 'move-in-progress': 'moveInProgress', query: 'query', position: 'position', 'assign-is-open': 'assignIsOpen(isOpen)', debounce: 'debounceUpdate' }), angular.isDefined(n.typeaheadTemplateUrl) && H.attr('template-url', n.typeaheadTemplateUrl), angular.isDefined(n.typeaheadPopupTemplateUrl) && H.attr('popup-template-url', n.typeaheadPopupTemplateUrl); const W = function () { I && G.val('') }; const q = function () { z.matches = [], z.activeIdx = -1, e.attr('aria-expanded', !1), W() }; const X = function (t) { return j + '-option-' + t }; z.$watch('activeIdx', function (t) { t < 0 ? e.removeAttr('aria-activedescendant') : e.attr('aria-activedescendant', X(t)) }); const Y = function (t, e) { return !!(z.matches.length > e && t) && t.toUpperCase() === z.matches[e].label.toUpperCase() }; const Z = function (n, i) { const r = { $viewValue: n }; T(t, !0), E(t, !1), a.when(U.source(t, r)).then(function (a) { const o = n === g.$viewValue; if (o && _) if (a && a.length > 0) { z.activeIdx = D ? 0 : -1, E(t, !1), z.matches.length = 0; for (let s = 0; s < a.length; s++)r[U.itemName] = a[s], z.matches.push({ id: X(s), label: U.viewMapper(z, r), model: a[s] }); if (z.query = n, f(), e.attr('aria-expanded', !0), O && z.matches.length === 1 && Y(n, 0) && (angular.isNumber(z.debounceUpdate) || angular.isObject(z.debounceUpdate) ? u(function () { z.select(0, i) }, angular.isNumber(z.debounceUpdate) ? z.debounceUpdate : z.debounceUpdate.default) : z.select(0, i)), I) { const l = z.matches[0].label; angular.isString(n) && n.length > 0 && l.slice(0, n.length).toUpperCase() === n.toUpperCase() ? G.val(n + l.slice(n.length)) : G.val('') } } else q(), E(t, !0); o && T(t, !1) }, function () { q(), T(t, !1), E(t, !0) }) }; P && (angular.element(l).on('resize', d), s.find('body').on('scroll', d)); var K = u(function () { z.matches.length && f(), z.moveInProgress = !1 }, 200); z.moveInProgress = !1, z.query = void 0; let J; const Q = function (t) { J = o(function () { Z(t) }, x) }; const tt = function () { J && o.cancel(J) }; q(), z.assignIsOpen = function (e) { L(t, e) }, z.select = function (i, r) { let a; let s; const l = {}; $ = !0, l[U.itemName] = s = z.matches[i].model, a = U.modelMapper(t, l), F(t, a), g.$setValidity('editable', !0), g.$setValidity('parse', !0), M(t, { $item: s, $model: a, $label: U.viewMapper(t, l), $event: r }), q(), !1 !== z.$eval(n.typeaheadFocusOnSelect) && o(function () { e[0].focus() }, 0, !1) }, e.on('keydown', function (e) { if (z.matches.length !== 0 && y.indexOf(e.which) !== -1) { const n = S(t, { $event: e }); if (z.activeIdx === -1 && n || e.which === 9 && e.shiftKey) return q(), void z.$digest(); e.preventDefault(); let i; switch (e.which) { case 27:e.stopPropagation(), q(), t.$digest(); break; case 38:z.activeIdx = (z.activeIdx > 0 ? z.activeIdx : z.matches.length) - 1, z.$digest(), i = H[0].querySelectorAll('.uib-typeahead-match')[z.activeIdx], i.parentNode.scrollTop = i.offsetTop; break; case 40:z.activeIdx = (z.activeIdx + 1) % z.matches.length, z.$digest(), i = H[0].querySelectorAll('.uib-typeahead-match')[z.activeIdx], i.parentNode.scrollTop = i.offsetTop; break; default:n && z.$apply(function () { angular.isNumber(z.debounceUpdate) || angular.isObject(z.debounceUpdate) ? u(function () { z.select(z.activeIdx, e) }, angular.isNumber(z.debounceUpdate) ? z.debounceUpdate : z.debounceUpdate.default) : z.select(z.activeIdx, e) }) } } }), e.on('focus', function (t) { _ = !0, b !== 0 || g.$viewValue || o(function () { Z(g.$viewValue, t) }, 0) }), e.on('blur', function (t) { C && z.matches.length && z.activeIdx !== -1 && !$ && ($ = !0, z.$apply(function () { angular.isObject(z.debounceUpdate) && angular.isNumber(z.debounceUpdate.blur) ? u(function () { z.select(z.activeIdx, t) }, z.debounceUpdate.blur) : z.select(z.activeIdx, t) })), !w && g.$error.editable && (g.$setViewValue(), z.$apply(function () { g.$setValidity('editable', !0), g.$setValidity('parse', !0) }), e.val('')), _ = !1, $ = !1 }); const et = function (n) { e[0] !== n.target && n.which !== 3 && z.matches.length !== 0 && (q(), c.$$phase || t.$digest()) }; s.on('click', et), t.$on('$destroy', function () { s.off('click', et), (P || k) && nt.remove(), P && (angular.element(l).off('resize', d), s.find('body').off('scroll', d)), H.remove(), I && V.remove() }); var nt = i(H)(z); P ? s.find('body').append(nt) : k ? angular.element(k).eq(0).append(nt) : e.after(nt), this.init = function (e) { g = e, v = m(g), z.debounceUpdate = r(v.getOption('debounce'))(t), g.$parsers.unshift(function (e) { return _ = !0, b === 0 || e && e.length >= b ? x > 0 ? (tt(), Q(e)) : Z(e) : (T(t, !1), tt(), q()), w ? e : e ? void g.$setValidity('editable', !1) : (g.$setValidity('editable', !0), null) }), g.$formatters.push(function (e) { let n; let i; const r = {}; return w || g.$setValidity('editable', !0), A ? (r.$model = e, A(t, r)) : (r[U.itemName] = e, n = U.viewMapper(t, r), r[U.itemName] = void 0, i = U.viewMapper(t, r), n !== i ? n : e) }) } }]).directive('uibTypeahead', function () { return { controller: 'UibTypeaheadController', require: ['ngModel', 'uibTypeahead'], link: function (t, e, n, i) { i[1].init(i[0]) } } }).directive('uibTypeaheadPopup', ['$$debounce', function (t) { return { scope: { matches: '=', query: '=', active: '=', position: '&', moveInProgress: '=', select: '&', assignIsOpen: '&', debounce: '&' }, replace: !0, templateUrl: function (t, e) { return e.popupTemplateUrl || 'uib/template/typeahead/typeahead-popup.html' }, link: function (e, n, i) { e.templateUrl = i.templateUrl, e.isOpen = function () { const t = e.matches.length > 0; return e.assignIsOpen({ isOpen: t }), t }, e.isActive = function (t) { return e.active === t }, e.selectActive = function (t) { e.active = t }, e.selectMatch = function (n, i) { const r = e.debounce(); angular.isNumber(r) || angular.isObject(r) ? t(function () { e.select({ activeIdx: n, evt: i }) }, angular.isNumber(r) ? r : r.default) : e.select({ activeIdx: n, evt: i }) } } } }]).directive('uibTypeaheadMatch', ['$templateRequest', '$compile', '$parse', function (t, e, n) { return { scope: { index: '=', match: '=', query: '=' }, link: function (i, r, a) { const o = n(a.templateUrl)(i.$parent) || 'uib/template/typeahead/typeahead-match.html'; t(o).then(function (t) { const n = angular.element(t.trim()); r.replaceWith(n), e(n)(i) }) } } }]).filter('uibTypeaheadHighlight', ['$sce', '$injector', '$log', function (t, e, n) { function i (t) { return t.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1') } function r (t) { return /<.*>/g.test(t) } let a; return a = e.has('$sanitize'), function (e, o) { return !a && r(e) && n.warn('Unsafe use of typeahead please use ngSanitize'), e = o ? ('' + e).replace(new RegExp(i(o), 'gi'), '<strong>$&</strong>') : e, a || (e = t.trustAsHtml(e)), e } }]), angular.module('uib/template/accordion/accordion-group.html', []).run(['$templateCache', function (t) { t.put('uib/template/accordion/accordion-group.html', '<div role="tab" id="{{::headingId}}" aria-selected="{{isOpen}}" class="panel-heading" ng-keypress="toggleOpen($event)">\n  <h4 class="panel-title">\n    <a role="button" data-toggle="collapse" href aria-expanded="{{isOpen}}" aria-controls="{{::panelId}}" tabindex="0" class="accordion-toggle" ng-click="toggleOpen()" uib-accordion-transclude="heading" ng-disabled="isDisabled" uib-tabindex-toggle><span uib-accordion-header ng-class="{\'text-muted\': isDisabled}">{{heading}}</span></a>\n  </h4>\n</div>\n<div id="{{::panelId}}" aria-labelledby="{{::headingId}}" aria-hidden="{{!isOpen}}" role="tabpanel" class="panel-collapse collapse" uib-collapse="!isOpen">\n  <div class="panel-body" ng-transclude></div>\n</div>\n') }]), angular.module('uib/template/accordion/accordion.html', []).run(['$templateCache', function (t) { t.put('uib/template/accordion/accordion.html', '<div role="tablist" class="panel-group" ng-transclude></div>') }]), angular.module('uib/template/alert/alert.html', []).run(['$templateCache', function (t) { t.put('uib/template/alert/alert.html', '<button ng-show="closeable" type="button" class="close" ng-click="close({$event: $event})">\n  <span aria-hidden="true">&times;</span>\n  <span class="sr-only">Close</span>\n</button>\n<div ng-transclude></div>\n') }]), angular.module('uib/template/carousel/carousel.html', []).run(['$templateCache', function (t) { t.put('uib/template/carousel/carousel.html', '<div class="carousel-inner" ng-transclude></div>\n<a role="button" href class="left carousel-control" ng-click="prev()" ng-class="{ disabled: isPrevDisabled() }" ng-show="slides.length > 1">\n  <span aria-hidden="true" class="glyphicon glyphicon-chevron-left"></span>\n  <span class="sr-only">previous</span>\n</a>\n<a role="button" href class="right carousel-control" ng-click="next()" ng-class="{ disabled: isNextDisabled() }" ng-show="slides.length > 1">\n  <span aria-hidden="true" class="glyphicon glyphicon-chevron-right"></span>\n  <span class="sr-only">next</span>\n</a>\n<ol class="carousel-indicators" ng-show="slides.length > 1">\n  <li ng-repeat="slide in slides | orderBy:indexOfSlide track by $index" ng-class="{ active: isActive(slide) }" ng-click="select(slide)">\n    <span class="sr-only">slide {{ $index + 1 }} of {{ slides.length }}<span ng-if="isActive(slide)">, currently active</span></span>\n  </li>\n</ol>\n') }]), angular.module('uib/template/carousel/slide.html', []).run(['$templateCache', function (t) { t.put('uib/template/carousel/slide.html', '<div class="text-center" ng-transclude></div>\n') }]), angular.module('uib/template/datepicker/datepicker.html', []).run(['$templateCache', function (t) { t.put('uib/template/datepicker/datepicker.html', '<div ng-switch="datepickerMode">\n  <div uib-daypicker ng-switch-when="day" tabindex="0" class="uib-daypicker"></div>\n  <div uib-monthpicker ng-switch-when="month" tabindex="0" class="uib-monthpicker"></div>\n  <div uib-yearpicker ng-switch-when="year" tabindex="0" class="uib-yearpicker"></div>\n</div>\n') }]), angular.module('uib/template/datepicker/day.html', []).run(['$templateCache', function (t) { t.put('uib/template/datepicker/day.html', '<table role="grid" aria-labelledby="{{::uniqueId}}-title" aria-activedescendant="{{activeDateId}}">\n  <thead>\n    <tr>\n      <th><button type="button" class="btn btn-default btn-sm pull-left uib-left" ng-click="move(-1)" tabindex="-1"><i aria-hidden="true" class="glyphicon glyphicon-chevron-left"></i><span class="sr-only">previous</span></button></th>\n      <th colspan="{{::5 + showWeeks}}"><button id="{{::uniqueId}}-title" role="heading" aria-live="assertive" aria-atomic="true" type="button" class="btn btn-default btn-sm uib-title" ng-click="toggleMode()" ng-disabled="datepickerMode === maxMode" tabindex="-1"><strong>{{title}}</strong></button></th>\n      <th><button type="button" class="btn btn-default btn-sm pull-right uib-right" ng-click="move(1)" tabindex="-1"><i aria-hidden="true" class="glyphicon glyphicon-chevron-right"></i><span class="sr-only">next</span></button></th>\n    </tr>\n    <tr>\n      <th ng-if="showWeeks" class="text-center"></th>\n      <th ng-repeat="label in ::labels track by $index" class="text-center"><small aria-label="{{::label.full}}">{{::label.abbr}}</small></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr class="uib-weeks" ng-repeat="row in rows track by $index" role="row">\n      <td ng-if="showWeeks" class="text-center h6"><em>{{ weekNumbers[$index] }}</em></td>\n      <td ng-repeat="dt in row" class="uib-day text-center" role="gridcell"\n        id="{{::dt.uid}}"\n        ng-class="::dt.customClass">\n        <button type="button" class="btn btn-default btn-sm"\n          uib-is-class="\n            \'btn-info\' for selectedDt,\n            \'active\' for activeDt\n            on dt"\n          ng-click="select(dt.date)"\n          ng-disabled="::dt.disabled"\n          tabindex="-1"><span ng-class="::{\'text-muted\': dt.secondary, \'text-info\': dt.current}">{{::dt.label}}</span></button>\n      </td>\n    </tr>\n  </tbody>\n</table>\n') }]), angular.module('uib/template/datepicker/month.html', []).run(['$templateCache', function (t) { t.put('uib/template/datepicker/month.html', '<table role="grid" aria-labelledby="{{::uniqueId}}-title" aria-activedescendant="{{activeDateId}}">\n  <thead>\n    <tr>\n      <th><button type="button" class="btn btn-default btn-sm pull-left uib-left" ng-click="move(-1)" tabindex="-1"><i aria-hidden="true" class="glyphicon glyphicon-chevron-left"></i><span class="sr-only">previous</span></button></th>\n      <th colspan="{{::yearHeaderColspan}}"><button id="{{::uniqueId}}-title" role="heading" aria-live="assertive" aria-atomic="true" type="button" class="btn btn-default btn-sm uib-title" ng-click="toggleMode()" ng-disabled="datepickerMode === maxMode" tabindex="-1"><strong>{{title}}</strong></button></th>\n      <th><button type="button" class="btn btn-default btn-sm pull-right uib-right" ng-click="move(1)" tabindex="-1"><i aria-hidden="true" class="glyphicon glyphicon-chevron-right"></i><span class="sr-only">next</span></i></button></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr class="uib-months" ng-repeat="row in rows track by $index" role="row">\n      <td ng-repeat="dt in row" class="uib-month text-center" role="gridcell"\n        id="{{::dt.uid}}"\n        ng-class="::dt.customClass">\n        <button type="button" class="btn btn-default"\n          uib-is-class="\n            \'btn-info\' for selectedDt,\n            \'active\' for activeDt\n            on dt"\n          ng-click="select(dt.date)"\n          ng-disabled="::dt.disabled"\n          tabindex="-1"><span ng-class="::{\'text-info\': dt.current}">{{::dt.label}}</span></button>\n      </td>\n    </tr>\n  </tbody>\n</table>\n') }]), angular.module('uib/template/datepicker/year.html', []).run(['$templateCache', function (t) { t.put('uib/template/datepicker/year.html', '<table role="grid" aria-labelledby="{{::uniqueId}}-title" aria-activedescendant="{{activeDateId}}">\n  <thead>\n    <tr>\n      <th><button type="button" class="btn btn-default btn-sm pull-left uib-left" ng-click="move(-1)" tabindex="-1"><i aria-hidden="true" class="glyphicon glyphicon-chevron-left"></i><span class="sr-only">previous</span></button></th>\n      <th colspan="{{::columns - 2}}"><button id="{{::uniqueId}}-title" role="heading" aria-live="assertive" aria-atomic="true" type="button" class="btn btn-default btn-sm uib-title" ng-click="toggleMode()" ng-disabled="datepickerMode === maxMode" tabindex="-1"><strong>{{title}}</strong></button></th>\n      <th><button type="button" class="btn btn-default btn-sm pull-right uib-right" ng-click="move(1)" tabindex="-1"><i aria-hidden="true" class="glyphicon glyphicon-chevron-right"></i><span class="sr-only">next</span></button></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr class="uib-years" ng-repeat="row in rows track by $index" role="row">\n      <td ng-repeat="dt in row" class="uib-year text-center" role="gridcell"\n        id="{{::dt.uid}}"\n        ng-class="::dt.customClass">\n        <button type="button" class="btn btn-default"\n          uib-is-class="\n            \'btn-info\' for selectedDt,\n            \'active\' for activeDt\n            on dt"\n          ng-click="select(dt.date)"\n          ng-disabled="::dt.disabled"\n          tabindex="-1"><span ng-class="::{\'text-info\': dt.current}">{{::dt.label}}</span></button>\n      </td>\n    </tr>\n  </tbody>\n</table>\n') }]), angular.module('uib/template/datepickerPopup/popup.html', []).run(['$templateCache', function (t) { t.put('uib/template/datepickerPopup/popup.html', '<ul role="presentation" class="uib-datepicker-popup dropdown-menu uib-position-measure" dropdown-nested ng-if="isOpen" ng-keydown="keydown($event)" ng-click="$event.stopPropagation()">\n  <li ng-transclude></li>\n  <li ng-if="showButtonBar" class="uib-button-bar">\n    <span class="btn-group pull-left">\n      <button type="button" class="btn btn-sm btn-info uib-datepicker-current" ng-click="select(\'today\', $event)" ng-disabled="isDisabled(\'today\')">{{ getText(\'current\') }}</button>\n      <button type="button" class="btn btn-sm btn-danger uib-clear" ng-click="select(null, $event)">{{ getText(\'clear\') }}</button>\n    </span>\n    <button type="button" class="btn btn-sm btn-success pull-right uib-close" ng-click="close($event)">{{ getText(\'close\') }}</button>\n  </li>\n</ul>\n') }]), angular.module('uib/template/modal/window.html', []).run(['$templateCache', function (t) { t.put('uib/template/modal/window.html', "<div class=\"modal-dialog {{size ? 'modal-' + size : ''}}\"><div class=\"modal-content\" uib-modal-transclude></div></div>\n") }]), angular.module('uib/template/pager/pager.html', []).run(['$templateCache', function (t) { t.put('uib/template/pager/pager.html', '<li ng-class="{disabled: noPrevious()||ngDisabled, previous: align}"><a href ng-click="selectPage(page - 1, $event)" ng-disabled="noPrevious()||ngDisabled" uib-tabindex-toggle>{{::getText(\'previous\')}}</a></li>\n<li ng-class="{disabled: noNext()||ngDisabled, next: align}"><a href ng-click="selectPage(page + 1, $event)" ng-disabled="noNext()||ngDisabled" uib-tabindex-toggle>{{::getText(\'next\')}}</a></li>\n') }]), angular.module('uib/template/pagination/pagination.html', []).run(['$templateCache', function (t) { t.put('uib/template/pagination/pagination.html', '<li role="menuitem" ng-if="::boundaryLinks" ng-class="{disabled: noPrevious()||ngDisabled}" class="pagination-first"><a href ng-click="selectPage(1, $event)" ng-disabled="noPrevious()||ngDisabled" uib-tabindex-toggle>{{::getText(\'first\')}}</a></li>\n<li role="menuitem" ng-if="::directionLinks" ng-class="{disabled: noPrevious()||ngDisabled}" class="pagination-prev"><a href ng-click="selectPage(page - 1, $event)" ng-disabled="noPrevious()||ngDisabled" uib-tabindex-toggle>{{::getText(\'previous\')}}</a></li>\n<li role="menuitem" ng-repeat="page in pages track by $index" ng-class="{active: page.active,disabled: ngDisabled&&!page.active}" class="pagination-page"><a href ng-click="selectPage(page.number, $event)" ng-disabled="ngDisabled&&!page.active" uib-tabindex-toggle>{{page.text}}</a></li>\n<li role="menuitem" ng-if="::directionLinks" ng-class="{disabled: noNext()||ngDisabled}" class="pagination-next"><a href ng-click="selectPage(page + 1, $event)" ng-disabled="noNext()||ngDisabled" uib-tabindex-toggle>{{::getText(\'next\')}}</a></li>\n<li role="menuitem" ng-if="::boundaryLinks" ng-class="{disabled: noNext()||ngDisabled}" class="pagination-last"><a href ng-click="selectPage(totalPages, $event)" ng-disabled="noNext()||ngDisabled" uib-tabindex-toggle>{{::getText(\'last\')}}</a></li>\n') }]), angular.module('uib/template/tooltip/tooltip-html-popup.html', []).run(['$templateCache', function (t) { t.put('uib/template/tooltip/tooltip-html-popup.html', '<div class="tooltip-arrow"></div>\n<div class="tooltip-inner" ng-bind-html="contentExp()"></div>\n') }]), angular.module('uib/template/tooltip/tooltip-popup.html', []).run(['$templateCache', function (t) { t.put('uib/template/tooltip/tooltip-popup.html', '<div class="tooltip-arrow"></div>\n<div class="tooltip-inner" ng-bind="content"></div>\n') }]), angular.module('uib/template/tooltip/tooltip-template-popup.html', []).run(['$templateCache', function (t) { t.put('uib/template/tooltip/tooltip-template-popup.html', '<div class="tooltip-arrow"></div>\n<div class="tooltip-inner"\n  uib-tooltip-template-transclude="contentExp()"\n  tooltip-template-transclude-scope="originScope()"></div>\n') }]), angular.module('uib/template/popover/popover-html.html', []).run(['$templateCache', function (t) { t.put('uib/template/popover/popover-html.html', '<div class="arrow"></div>\n\n<div class="popover-inner">\n    <h3 class="popover-title" ng-bind="uibTitle" ng-if="uibTitle"></h3>\n    <div class="popover-content" ng-bind-html="contentExp()"></div>\n</div>\n') }]), angular.module('uib/template/popover/popover-template.html', []).run(['$templateCache', function (t) { t.put('uib/template/popover/popover-template.html', '<div class="arrow"></div>\n\n<div class="popover-inner">\n    <h3 class="popover-title" ng-bind="uibTitle" ng-if="uibTitle"></h3>\n    <div class="popover-content"\n      uib-tooltip-template-transclude="contentExp()"\n      tooltip-template-transclude-scope="originScope()"></div>\n</div>\n') }]), angular.module('uib/template/popover/popover.html', []).run(['$templateCache', function (t) { t.put('uib/template/popover/popover.html', '<div class="arrow"></div>\n\n<div class="popover-inner">\n    <h3 class="popover-title" ng-bind="uibTitle" ng-if="uibTitle"></h3>\n    <div class="popover-content" ng-bind="content"></div>\n</div>\n') }]), angular.module('uib/template/progressbar/bar.html', []).run(['$templateCache', function (t) { t.put('uib/template/progressbar/bar.html', '<div class="progress-bar" ng-class="type && \'progress-bar-\' + type" role="progressbar" aria-valuenow="{{value}}" aria-valuemin="0" aria-valuemax="{{max}}" ng-style="{width: (percent < 100 ? percent : 100) + \'%\'}" aria-valuetext="{{percent | number:0}}%" aria-labelledby="{{::title}}" ng-transclude></div>\n') }]), angular.module('uib/template/progressbar/progress.html', []).run(['$templateCache', function (t) { t.put('uib/template/progressbar/progress.html', '<div class="progress" ng-transclude aria-labelledby="{{::title}}"></div>') }]), angular.module('uib/template/progressbar/progressbar.html', []).run(['$templateCache', function (t) { t.put('uib/template/progressbar/progressbar.html', '<div class="progress">\n  <div class="progress-bar" ng-class="type && \'progress-bar-\' + type" role="progressbar" aria-valuenow="{{value}}" aria-valuemin="0" aria-valuemax="{{max}}" ng-style="{width: (percent < 100 ? percent : 100) + \'%\'}" aria-valuetext="{{percent | number:0}}%" aria-labelledby="{{::title}}" ng-transclude></div>\n</div>\n') }]), angular.module('uib/template/rating/rating.html', []).run(['$templateCache', function (t) { t.put('uib/template/rating/rating.html', '<span ng-mouseleave="reset()" ng-keydown="onKeydown($event)" tabindex="0" role="slider" aria-valuemin="0" aria-valuemax="{{range.length}}" aria-valuenow="{{value}}" aria-valuetext="{{title}}">\n    <span ng-repeat-start="r in range track by $index" class="sr-only">({{ $index < value ? \'*\' : \' \' }})</span>\n    <i ng-repeat-end ng-mouseenter="enter($index + 1)" ng-click="rate($index + 1)" class="glyphicon" ng-class="$index < value && (r.stateOn || \'glyphicon-star\') || (r.stateOff || \'glyphicon-star-empty\')" ng-attr-title="{{r.title}}"></i>\n</span>\n') }]), angular.module('uib/template/tabs/tab.html', []).run(['$templateCache', function (t) { t.put('uib/template/tabs/tab.html', '<li ng-class="[{active: active, disabled: disabled}, classes]" class="uib-tab nav-item">\n  <a href ng-click="select($event)" class="nav-link" uib-tab-heading-transclude>{{heading}}</a>\n</li>\n') }]), angular.module('uib/template/tabs/tabset.html', []).run(['$templateCache', function (t) { t.put('uib/template/tabs/tabset.html', '<div>\n  <ul class="nav nav-{{tabset.type || \'tabs\'}}" ng-class="{\'nav-stacked\': vertical, \'nav-justified\': justified}" ng-transclude></ul>\n  <div class="tab-content">\n    <div class="tab-pane"\n         ng-repeat="tab in tabset.tabs"\n         ng-class="{active: tabset.active === tab.index}"\n         uib-tab-content-transclude="tab">\n    </div>\n  </div>\n</div>\n') }]), angular.module('uib/template/timepicker/timepicker.html', []).run(['$templateCache', function (t) { t.put('uib/template/timepicker/timepicker.html', '<table class="uib-timepicker">\n  <tbody>\n    <tr class="text-center" ng-show="::showSpinners">\n      <td class="uib-increment hours"><a ng-click="incrementHours()" ng-class="{disabled: noIncrementHours()}" class="btn btn-link" ng-disabled="noIncrementHours()" tabindex="-1"><span class="glyphicon glyphicon-chevron-up"></span></a></td>\n      <td>&nbsp;</td>\n      <td class="uib-increment minutes"><a ng-click="incrementMinutes()" ng-class="{disabled: noIncrementMinutes()}" class="btn btn-link" ng-disabled="noIncrementMinutes()" tabindex="-1"><span class="glyphicon glyphicon-chevron-up"></span></a></td>\n      <td ng-show="showSeconds">&nbsp;</td>\n      <td ng-show="showSeconds" class="uib-increment seconds"><a ng-click="incrementSeconds()" ng-class="{disabled: noIncrementSeconds()}" class="btn btn-link" ng-disabled="noIncrementSeconds()" tabindex="-1"><span class="glyphicon glyphicon-chevron-up"></span></a></td>\n      <td ng-show="showMeridian"></td>\n    </tr>\n    <tr>\n      <td class="form-group uib-time hours" ng-class="{\'has-error\': invalidHours}">\n        <input type="text" placeholder="HH" ng-model="hours" ng-change="updateHours()" class="form-control text-center" ng-readonly="::readonlyInput" maxlength="2" tabindex="{{::tabindex}}" ng-disabled="noIncrementHours()" ng-blur="blur()">\n      </td>\n      <td class="uib-separator">:</td>\n      <td class="form-group uib-time minutes" ng-class="{\'has-error\': invalidMinutes}">\n        <input type="text" placeholder="MM" ng-model="minutes" ng-change="updateMinutes()" class="form-control text-center" ng-readonly="::readonlyInput" maxlength="2" tabindex="{{::tabindex}}" ng-disabled="noIncrementMinutes()" ng-blur="blur()">\n      </td>\n      <td ng-show="showSeconds" class="uib-separator">:</td>\n      <td class="form-group uib-time seconds" ng-class="{\'has-error\': invalidSeconds}" ng-show="showSeconds">\n        <input type="text" placeholder="SS" ng-model="seconds" ng-change="updateSeconds()" class="form-control text-center" ng-readonly="readonlyInput" maxlength="2" tabindex="{{::tabindex}}" ng-disabled="noIncrementSeconds()" ng-blur="blur()">\n      </td>\n      <td ng-show="showMeridian" class="uib-time am-pm"><button type="button" ng-class="{disabled: noToggleMeridian()}" class="btn btn-default text-center" ng-click="toggleMeridian()" ng-disabled="noToggleMeridian()" tabindex="{{::tabindex}}">{{meridian}}</button></td>\n    </tr>\n    <tr class="text-center" ng-show="::showSpinners">\n      <td class="uib-decrement hours"><a ng-click="decrementHours()" ng-class="{disabled: noDecrementHours()}" class="btn btn-link" ng-disabled="noDecrementHours()" tabindex="-1"><span class="glyphicon glyphicon-chevron-down"></span></a></td>\n      <td>&nbsp;</td>\n      <td class="uib-decrement minutes"><a ng-click="decrementMinutes()" ng-class="{disabled: noDecrementMinutes()}" class="btn btn-link" ng-disabled="noDecrementMinutes()" tabindex="-1"><span class="glyphicon glyphicon-chevron-down"></span></a></td>\n      <td ng-show="showSeconds">&nbsp;</td>\n      <td ng-show="showSeconds" class="uib-decrement seconds"><a ng-click="decrementSeconds()" ng-class="{disabled: noDecrementSeconds()}" class="btn btn-link" ng-disabled="noDecrementSeconds()" tabindex="-1"><span class="glyphicon glyphicon-chevron-down"></span></a></td>\n      <td ng-show="showMeridian"></td>\n    </tr>\n  </tbody>\n</table>\n') }]), angular.module('uib/template/typeahead/typeahead-match.html', []).run(['$templateCache', function (t) { t.put('uib/template/typeahead/typeahead-match.html', '<a href\n   tabindex="-1"\n   ng-bind-html="match.label | uibTypeaheadHighlight:query"\n   ng-attr-title="{{match.label}}"></a>\n') }]), angular.module('uib/template/typeahead/typeahead-popup.html', []).run(['$templateCache', function (t) { t.put('uib/template/typeahead/typeahead-popup.html', '<ul class="dropdown-menu" ng-show="isOpen() && !moveInProgress" ng-style="{top: position().top+\'px\', left: position().left+\'px\'}" role="listbox" aria-hidden="{{!isOpen()}}">\n    <li class="uib-typeahead-match" ng-repeat="match in matches track by $index" ng-class="{active: isActive($index) }" ng-mouseenter="selectActive($index)" ng-click="selectMatch($index, $event)" role="option" id="{{::match.id}}">\n        <div uib-typeahead-match index="$index" match="match" query="query" template-url="templateUrl"></div>\n    </li>\n</ul>\n') }]), angular.module('ui.bootstrap.carousel').run(function () { !angular.$$csp().noInlineStyle && !angular.$$uibCarouselCss && angular.element(document).find('head').prepend('<style type="text/css">.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}</style>'), angular.$$uibCarouselCss = !0 }), angular.module('ui.bootstrap.datepicker').run(function () { !angular.$$csp().noInlineStyle && !angular.$$uibDatepickerCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-datepicker .uib-title{width:100%;}.uib-day button,.uib-month button,.uib-year button{min-width:100%;}.uib-left,.uib-right{width:100%}</style>'), angular.$$uibDatepickerCss = !0 }), angular.module('ui.bootstrap.position').run(function () { !angular.$$csp().noInlineStyle && !angular.$$uibPositionCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-position-measure{display:block !important;visibility:hidden !important;position:absolute !important;top:-9999px !important;left:-9999px !important;}.uib-position-scrollbar-measure{position:absolute !important;top:-9999px !important;width:50px !important;height:50px !important;overflow:scroll !important;}.uib-position-body-scrollbar-measure{overflow:scroll !important;}</style>'), angular.$$uibPositionCss = !0 }), angular.module('ui.bootstrap.datepickerPopup').run(function () { !angular.$$csp().noInlineStyle && !angular.$$uibDatepickerpopupCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-datepicker-popup.dropdown-menu{display:block;float:none;margin:0;}.uib-button-bar{padding:10px 9px 2px;}</style>'), angular.$$uibDatepickerpopupCss = !0 }), angular.module('ui.bootstrap.tooltip').run(function () {
  !angular.$$csp().noInlineStyle && !angular.$$uibTooltipCss && angular.element(document).find('head').prepend('<style type="text/css">[uib-tooltip-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-bottom > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-bottom > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-bottom > .tooltip-arrow,[uib-popover-popup].popover.top-left > .arrow,[uib-popover-popup].popover.top-right > .arrow,[uib-popover-popup].popover.bottom-left > .arrow,[uib-popover-popup].popover.bottom-right > .arrow,[uib-popover-popup].popover.left-top > .arrow,[uib-popover-popup].popover.left-bottom > .arrow,[uib-popover-popup].popover.right-top > .arrow,[uib-popover-popup].popover.right-bottom > .arrow,[uib-popover-html-popup].popover.top-left > .arrow,[uib-popover-html-popup].popover.top-right > .arrow,[uib-popover-html-popup].popover.bottom-left > .arrow,[uib-popover-html-popup].popover.bottom-right > .arrow,[uib-popover-html-popup].popover.left-top > .arrow,[uib-popover-html-popup].popover.left-bottom > .arrow,[uib-popover-html-popup].popover.right-top > .arrow,[uib-popover-html-popup].popover.right-bottom > .arrow,[uib-popover-template-popup].popover.top-left > .arrow,[uib-popover-template-popup].popover.top-right > .arrow,[uib-popover-template-popup].popover.bottom-left > .arrow,[uib-popover-template-popup].popover.bottom-right > .arrow,[uib-popover-template-popup].popover.left-top > .arrow,[uib-popover-template-popup].popover.left-bottom > .arrow,[uib-popover-template-popup].popover.right-top > .arrow,[uib-popover-template-popup].popover.right-bottom > .arrow{top:auto;bottom:auto;left:auto;right:auto;margin:0;}[uib-popover-popup].popover,[uib-popover-html-popup].popover,[uib-popover-template-popup].popover{display:block !important;}</style>'), angular.$$uibTooltipCss = !0
}), angular.module('ui.bootstrap.timepicker').run(function () { !angular.$$csp().noInlineStyle && !angular.$$uibTimepickerCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-time input{width:50px;}</style>'), angular.$$uibTimepickerCss = !0 }), angular.module('ui.bootstrap.typeahead').run(function () { !angular.$$csp().noInlineStyle && !angular.$$uibTypeaheadCss && angular.element(document).find('head').prepend('<style type="text/css">[uib-typeahead-popup].dropdown-menu{display:block;}</style>'), angular.$$uibTypeaheadCss = !0 }), (function (t, e) { 'use strict'; typeof module === 'object' && typeof module.exports === 'object' ? module.exports = t.document ? e(t, !0) : function (t) { if (!t.document) throw new Error('jQuery requires a window with a document'); return e(t) } : e(t) }(typeof window !== 'undefined' ? window : this, function (t, e) {
  'use strict'; function n (t, e) { e = e || nt; const n = e.createElement('script'); n.text = t, e.head.appendChild(n).parentNode.removeChild(n) } function i (t) { const e = !!t && 'length' in t && t.length; const n = ft.type(t); return n !== 'function' && !ft.isWindow(t) && (n === 'array' || e === 0 || typeof e === 'number' && e > 0 && e - 1 in t) } function r (t, e) { return t.nodeName && t.nodeName.toLowerCase() === e.toLowerCase() } function a (t, e, n) { return ft.isFunction(e) ? ft.grep(t, function (t, i) { return !!e.call(t, i, t) !== n }) : e.nodeType ? ft.grep(t, function (t) { return t === e !== n }) : typeof e !== 'string' ? ft.grep(t, function (t) { return st.call(e, t) > -1 !== n }) : wt.test(e) ? ft.filter(e, t, n) : (e = ft.filter(e, t), ft.grep(t, function (t) { return st.call(e, t) > -1 !== n && t.nodeType === 1 })) } function o (t, e) { for (;(t = t[e]) && t.nodeType !== 1;);return t } function s (t) { const e = {}; return ft.each(t.match(Mt) || [], function (t, n) { e[n] = !0 }), e } function l (t) { return t } function c (t) { throw t } function u (t, e, n, i) { let r; try { t && ft.isFunction(r = t.promise) ? r.call(t).done(e).fail(n) : t && ft.isFunction(r = t.then) ? r.call(t, e, n) : e.apply(void 0, [t].slice(i)) } catch (t) { n.apply(void 0, [t]) } } function h () { nt.removeEventListener('DOMContentLoaded', h), t.removeEventListener('load', h), ft.ready() } function p () { this.expando = ft.expando + p.uid++ } function d (t) { return t === 'true' || t !== 'false' && (t === 'null' ? null : t === +t + '' ? +t : Ot.test(t) ? JSON.parse(t) : t) } function f (t, e, n) { let i; if (void 0 === n && t.nodeType === 1) if (i = 'data-' + e.replace(Lt, '-$&').toLowerCase(), typeof (n = t.getAttribute(i)) === 'string') { try { n = d(n) } catch (t) {}Dt.set(t, e, n) } else n = void 0; return n } function m (t, e, n, i) { let r; let a = 1; let o = 20; const s = i ? function () { return i.cur() } : function () { return ft.css(t, e, '') }; const l = s(); let c = n && n[3] || (ft.cssNumber[e] ? '' : 'px'); let u = (ft.cssNumber[e] || c !== 'px' && +l) && Rt.exec(ft.css(t, e)); if (u && u[3] !== c) { c = c || u[3], n = n || [], u = +l || 1; do { a = a || '.5', u /= a, ft.style(t, e, u + c) } while (a !== (a = s() / l) && a !== 1 && --o) } return n && (u = +u || +l || 0, r = n[1] ? u + (n[1] + 1) * n[2] : +n[2], i && (i.unit = c, i.start = u, i.end = r)), r } function g (t) { let e; const n = t.ownerDocument; const i = t.nodeName; let r = zt[i]; return r || (e = n.body.appendChild(n.createElement(i)), r = ft.css(e, 'display'), e.parentNode.removeChild(e), r === 'none' && (r = 'block'), zt[i] = r, r) } function v (t, e) { for (var n, i, r = [], a = 0, o = t.length; a < o; a++)i = t[a], i.style && (n = i.style.display, e ? (n === 'none' && (r[a] = kt.get(i, 'display') || null, r[a] || (i.style.display = '')), i.style.display === '' && Ft(i) && (r[a] = g(i))) : n !== 'none' && (r[a] = 'none', kt.set(i, 'display', n))); for (a = 0; a < o; a++)r[a] != null && (t[a].style.display = r[a]); return t } function y (t, e) { let n; return n = void 0 !== t.getElementsByTagName ? t.getElementsByTagName(e || '*') : void 0 !== t.querySelectorAll ? t.querySelectorAll(e || '*') : [], void 0 === e || e && r(t, e) ? ft.merge([t], n) : n } function b (t, e) { for (let n = 0, i = t.length; n < i; n++)kt.set(t[n], 'globalEval', !e || kt.get(e[n], 'globalEval')) } function x (t, e, n, i, r) { for (var a, o, s, l, c, u, h = e.createDocumentFragment(), p = [], d = 0, f = t.length; d < f; d++) if ((a = t[d]) || a === 0) if (ft.type(a) === 'object')ft.merge(p, a.nodeType ? [a] : a); else if (Ht.test(a)) { for (o = o || h.appendChild(e.createElement('div')), s = (jt.exec(a) || ['', ''])[1].toLowerCase(), l = Gt[s] || Gt._default, o.innerHTML = l[1] + ft.htmlPrefilter(a) + l[2], u = l[0]; u--;)o = o.lastChild; ft.merge(p, o.childNodes), o = h.firstChild, o.textContent = '' } else p.push(e.createTextNode(a)); for (h.textContent = '', d = 0; a = p[d++];) if (i && ft.inArray(a, i) > -1)r && r.push(a); else if (c = ft.contains(a.ownerDocument, a), o = y(h.appendChild(a), 'script'), c && b(o), n) for (u = 0; a = o[u++];)Vt.test(a.type || '') && n.push(a); return h } function w () { return !0 } function _ () { return !1 } function $ () { try { return nt.activeElement } catch (t) {} } function T (t, e, n, i, r, a) { let o, s; if (typeof e === 'object') { typeof n !== 'string' && (i = i || n, n = void 0); for (s in e)T(t, s, n, i, e[s], a); return t } if (i == null && r == null ? (r = n, i = n = void 0) : r == null && (typeof n === 'string' ? (r = i, i = void 0) : (r = i, i = n, n = void 0)), !1 === r)r = _; else if (!r) return t; return a === 1 && (o = r, r = function (t) { return ft().off(t), o.apply(this, arguments) }, r.guid = o.guid || (o.guid = ft.guid++)), t.each(function () { ft.event.add(this, e, r, i, n) }) } function S (t, e) { return r(t, 'table') && r(e.nodeType !== 11 ? e : e.firstChild, 'tr') ? ft('>tbody', t)[0] || t : t } function M (t) { return t.type = (t.getAttribute('type') !== null) + '/' + t.type, t } function C (t) { const e = Jt.exec(t.type); return e ? t.type = e[1] : t.removeAttribute('type'), t } function E (t, e) { let n, i, r, a, o, s, l, c; if (e.nodeType === 1) { if (kt.hasData(t) && (a = kt.access(t), o = kt.set(e, a), c = a.events)) { delete o.handle, o.events = {}; for (r in c) for (n = 0, i = c[r].length; n < i; n++)ft.event.add(e, r, c[r][n]) }Dt.hasData(t) && (s = Dt.access(t), l = ft.extend({}, s), Dt.set(e, l)) } } function A (t, e) { const n = e.nodeName.toLowerCase(); n === 'input' && Bt.test(t.type) ? e.checked = t.checked : n !== 'input' && n !== 'textarea' || (e.defaultValue = t.defaultValue) } function P (t, e, i, r) { e = at.apply([], e); let a; let o; let s; let l; let c; let u; let h = 0; const p = t.length; const d = p - 1; const f = e[0]; const m = ft.isFunction(f); if (m || p > 1 && typeof f === 'string' && !dt.checkClone && Kt.test(f)) return t.each(function (n) { const a = t.eq(n); m && (e[0] = f.call(this, n, a.html())), P(a, e, i, r) }); if (p && (a = x(e, t[0].ownerDocument, !1, t, r), o = a.firstChild, a.childNodes.length === 1 && (a = o), o || r)) { for (s = ft.map(y(a, 'script'), M), l = s.length; h < p; h++)c = a, h !== d && (c = ft.clone(c, !0, !0), l && ft.merge(s, y(c, 'script'))), i.call(t[h], c, h); if (l) for (u = s[s.length - 1].ownerDocument, ft.map(s, C), h = 0; h < l; h++)c = s[h], Vt.test(c.type || '') && !kt.access(c, 'globalEval') && ft.contains(u, c) && (c.src ? ft._evalUrl && ft._evalUrl(c.src) : n(c.textContent.replace(Qt, ''), u)) } return t } function k (t, e, n) { for (var i, r = e ? ft.filter(e, t) : t, a = 0; (i = r[a]) != null; a++)n || i.nodeType !== 1 || ft.cleanData(y(i)), i.parentNode && (n && ft.contains(i.ownerDocument, i) && b(y(i, 'script')), i.parentNode.removeChild(i)); return t } function D (t, e, n) { let i; let r; let a; let o; const s = t.style; return n = n || ne(t), n && (o = n.getPropertyValue(e) || n[e], o !== '' || ft.contains(t.ownerDocument, t) || (o = ft.style(t, e)), !dt.pixelMarginRight() && ee.test(o) && te.test(e) && (i = s.width, r = s.minWidth, a = s.maxWidth, s.minWidth = s.maxWidth = s.width = o, o = n.width, s.width = i, s.minWidth = r, s.maxWidth = a)), void 0 !== o ? o + '' : o } function O (t, e) { return { get: function () { return t() ? void delete this.get : (this.get = e).apply(this, arguments) } } } function L (t) { if (t in le) return t; for (let e = t[0].toUpperCase() + t.slice(1), n = se.length; n--;) if ((t = se[n] + e) in le) return t } function I (t) { let e = ft.cssProps[t]; return e || (e = ft.cssProps[t] = L(t) || t), e } function R (t, e, n) { const i = Rt.exec(e); return i ? Math.max(0, i[2] - (n || 0)) + (i[3] || 'px') : e } function N (t, e, n, i, r) { let a; let o = 0; for (a = n === (i ? 'border' : 'content') ? 4 : e === 'width' ? 1 : 0; a < 4; a += 2)n === 'margin' && (o += ft.css(t, n + Nt[a], !0, r)), i ? (n === 'content' && (o -= ft.css(t, 'padding' + Nt[a], !0, r)), n !== 'margin' && (o -= ft.css(t, 'border' + Nt[a] + 'Width', !0, r))) : (o += ft.css(t, 'padding' + Nt[a], !0, r), n !== 'padding' && (o += ft.css(t, 'border' + Nt[a] + 'Width', !0, r))); return o } function F (t, e, n) { let i; const r = ne(t); let a = D(t, e, r); const o = ft.css(t, 'boxSizing', !1, r) === 'border-box'; return ee.test(a) ? a : (i = o && (dt.boxSizingReliable() || a === t.style[e]), a === 'auto' && (a = t['offset' + e[0].toUpperCase() + e.slice(1)]), (a = parseFloat(a) || 0) + N(t, e, n || (o ? 'border' : 'content'), i, r) + 'px') } function U (t, e, n, i, r) { return new U.prototype.init(t, e, n, i, r) } function z () { ue && (!1 === nt.hidden && t.requestAnimationFrame ? t.requestAnimationFrame(z) : t.setTimeout(z, ft.fx.interval), ft.fx.tick()) } function B () { return t.setTimeout(function () { ce = void 0 }), ce = ft.now() } function j (t, e) { let n; let i = 0; const r = { height: t }; for (e = e ? 1 : 0; i < 4; i += 2 - e)n = Nt[i], r['margin' + n] = r['padding' + n] = t; return e && (r.opacity = r.width = t), r } function V (t, e, n) { for (var i, r = (W.tweeners[e] || []).concat(W.tweeners['*']), a = 0, o = r.length; a < o; a++) if (i = r[a].call(n, e, t)) return i } function G (t, e, n) { let i; let r; let a; let o; let s; let l; let c; let u; const h = 'width' in e || 'height' in e; const p = this; const d = {}; const f = t.style; let m = t.nodeType && Ft(t); let g = kt.get(t, 'fxshow'); n.queue || (o = ft._queueHooks(t, 'fx'), o.unqueued == null && (o.unqueued = 0, s = o.empty.fire, o.empty.fire = function () { o.unqueued || s() }), o.unqueued++, p.always(function () { p.always(function () { o.unqueued--, ft.queue(t, 'fx').length || o.empty.fire() }) })); for (i in e) if (r = e[i], he.test(r)) { if (delete e[i], a = a || r === 'toggle', r === (m ? 'hide' : 'show')) { if (r !== 'show' || !g || void 0 === g[i]) continue; m = !0 }d[i] = g && g[i] || ft.style(t, i) } if ((l = !ft.isEmptyObject(e)) || !ft.isEmptyObject(d)) { h && t.nodeType === 1 && (n.overflow = [f.overflow, f.overflowX, f.overflowY], c = g && g.display, c == null && (c = kt.get(t, 'display')), u = ft.css(t, 'display'), u === 'none' && (c ? u = c : (v([t], !0), c = t.style.display || c, u = ft.css(t, 'display'), v([t]))), (u === 'inline' || u === 'inline-block' && c != null) && ft.css(t, 'float') === 'none' && (l || (p.done(function () { f.display = c }), c == null && (u = f.display, c = u === 'none' ? '' : u)), f.display = 'inline-block')), n.overflow && (f.overflow = 'hidden', p.always(function () { f.overflow = n.overflow[0], f.overflowX = n.overflow[1], f.overflowY = n.overflow[2] })), l = !1; for (i in d)l || (g ? 'hidden' in g && (m = g.hidden) : g = kt.access(t, 'fxshow', { display: c }), a && (g.hidden = !m), m && v([t], !0), p.done(function () { m || v([t]), kt.remove(t, 'fxshow'); for (i in d)ft.style(t, i, d[i]) })), l = V(m ? g[i] : 0, i, p), i in g || (g[i] = l.start, m && (l.end = l.start, l.start = 0)) } } function H (t, e) { let n, i, r, a, o; for (n in t) if (i = ft.camelCase(n), r = e[i], a = t[n], Array.isArray(a) && (r = a[1], a = t[n] = a[0]), n !== i && (t[i] = a, delete t[n]), (o = ft.cssHooks[i]) && 'expand' in o) { a = o.expand(a), delete t[i]; for (n in a)n in t || (t[n] = a[n], e[n] = r) } else e[i] = r } function W (t, e, n) { let i; let r; let a = 0; const o = W.prefilters.length; const s = ft.Deferred().always(function () { delete l.elem }); var l = function () { if (r) return !1; for (var e = ce || B(), n = Math.max(0, c.startTime + c.duration - e), i = n / c.duration || 0, a = 1 - i, o = 0, l = c.tweens.length; o < l; o++)c.tweens[o].run(a); return s.notifyWith(t, [c, a, n]), a < 1 && l ? n : (l || s.notifyWith(t, [c, 1, 0]), s.resolveWith(t, [c]), !1) }; var c = s.promise({ elem: t, props: ft.extend({}, e), opts: ft.extend(!0, { specialEasing: {}, easing: ft.easing._default }, n), originalProperties: e, originalOptions: n, startTime: ce || B(), duration: n.duration, tweens: [], createTween: function (e, n) { const i = ft.Tween(t, c.opts, e, n, c.opts.specialEasing[e] || c.opts.easing); return c.tweens.push(i), i }, stop: function (e) { let n = 0; const i = e ? c.tweens.length : 0; if (r) return this; for (r = !0; n < i; n++)c.tweens[n].run(1); return e ? (s.notifyWith(t, [c, 1, 0]), s.resolveWith(t, [c, e])) : s.rejectWith(t, [c, e]), this } }); const u = c.props; for (H(u, c.opts.specialEasing); a < o; a++) if (i = W.prefilters[a].call(c, t, u, c.opts)) return ft.isFunction(i.stop) && (ft._queueHooks(c.elem, c.opts.queue).stop = ft.proxy(i.stop, i)), i; return ft.map(u, V, c), ft.isFunction(c.opts.start) && c.opts.start.call(t, c), c.progress(c.opts.progress).done(c.opts.done, c.opts.complete).fail(c.opts.fail).always(c.opts.always), ft.fx.timer(ft.extend(l, { elem: t, anim: c, queue: c.opts.queue })), c } function q (t) { return (t.match(Mt) || []).join(' ') } function X (t) { return t.getAttribute && t.getAttribute('class') || '' } function Y (t, e, n, i) { let r; if (Array.isArray(e))ft.each(e, function (e, r) { n || we.test(t) ? i(t, r) : Y(t + '[' + (typeof r === 'object' && r != null ? e : '') + ']', r, n, i) }); else if (n || ft.type(e) !== 'object')i(t, e); else for (r in e)Y(t + '[' + r + ']', e[r], n, i) } function Z (t) { return function (e, n) { typeof e !== 'string' && (n = e, e = '*'); let i; let r = 0; const a = e.toLowerCase().match(Mt) || []; if (ft.isFunction(n)) for (;i = a[r++];)i[0] === '+' ? (i = i.slice(1) || '*', (t[i] = t[i] || []).unshift(n)) : (t[i] = t[i] || []).push(n) } } function K (t, e, n, i) { function r (s) { let l; return a[s] = !0, ft.each(t[s] || [], function (t, s) { const c = s(e, n, i); return typeof c !== 'string' || o || a[c] ? o ? !(l = c) : void 0 : (e.dataTypes.unshift(c), r(c), !1) }), l } var a = {}; var o = t === Ee; return r(e.dataTypes[0]) || !a['*'] && r('*') } function J (t, e) { let n; let i; const r = ft.ajaxSettings.flatOptions || {}; for (n in e) void 0 !== e[n] && ((r[n] ? t : i || (i = {}))[n] = e[n]); return i && ft.extend(!0, t, i), t } function Q (t, e, n) { for (var i, r, a, o, s = t.contents, l = t.dataTypes; l[0] === '*';)l.shift(), void 0 === i && (i = t.mimeType || e.getResponseHeader('Content-Type')); if (i) for (r in s) if (s[r] && s[r].test(i)) { l.unshift(r); break } if (l[0] in n)a = l[0]; else { for (r in n) { if (!l[0] || t.converters[r + ' ' + l[0]]) { a = r; break }o || (o = r) }a = a || o } if (a) return a !== l[0] && l.unshift(a), n[a] } function tt (t, e, n, i) { let r; let a; let o; let s; let l; const c = {}; const u = t.dataTypes.slice(); if (u[1]) for (o in t.converters)c[o.toLowerCase()] = t.converters[o]; for (a = u.shift(); a;) if (t.responseFields[a] && (n[t.responseFields[a]] = e), !l && i && t.dataFilter && (e = t.dataFilter(e, t.dataType)), l = a, a = u.shift()) if (a === '*')a = l; else if (l !== '*' && l !== a) { if (!(o = c[l + ' ' + a] || c['* ' + a])) for (r in c) if (s = r.split(' '), s[1] === a && (o = c[l + ' ' + s[0]] || c['* ' + s[0]])) { !0 === o ? o = c[r] : !0 !== c[r] && (a = s[0], u.unshift(s[1])); break } if (!0 !== o) if (o && t.throws)e = o(e); else try { e = o(e) } catch (t) { return { state: 'parsererror', error: o ? t : 'No conversion from ' + l + ' to ' + a } } } return { state: 'success', data: e } } const et = []; var nt = t.document; const it = Object.getPrototypeOf; const rt = et.slice; var at = et.concat; const ot = et.push; var st = et.indexOf; const lt = {}; const ct = lt.toString; const ut = lt.hasOwnProperty; const ht = ut.toString; const pt = ht.call(Object); var dt = {}; var ft = function (t, e) { return new ft.fn.init(t, e) }; const mt = function (t, e) { return e.toUpperCase() }; ft.fn = ft.prototype = { jquery: '3.2.1', constructor: ft, length: 0, toArray: function () { return rt.call(this) }, get: function (t) { return t == null ? rt.call(this) : t < 0 ? this[t + this.length] : this[t] }, pushStack: function (t) { const e = ft.merge(this.constructor(), t); return e.prevObject = this, e }, each: function (t) { return ft.each(this, t) }, map: function (t) { return this.pushStack(ft.map(this, function (e, n) { return t.call(e, n, e) })) }, slice: function () { return this.pushStack(rt.apply(this, arguments)) }, first: function () { return this.eq(0) }, last: function () { return this.eq(-1) }, eq: function (t) { const e = this.length; const n = +t + (t < 0 ? e : 0); return this.pushStack(n >= 0 && n < e ? [this[n]] : []) }, end: function () { return this.prevObject || this.constructor() }, push: ot, sort: et.sort, splice: et.splice }, ft.extend = ft.fn.extend = function () { let t; let e; let n; let i; let r; let a; let o = arguments[0] || {}; let s = 1; const l = arguments.length; let c = !1; for (typeof o === 'boolean' && (c = o, o = arguments[s] || {}, s++), typeof o === 'object' || ft.isFunction(o) || (o = {}), s === l && (o = this, s--); s < l; s++) if ((t = arguments[s]) != null) for (e in t)n = o[e], i = t[e], o !== i && (c && i && (ft.isPlainObject(i) || (r = Array.isArray(i))) ? (r ? (r = !1, a = n && Array.isArray(n) ? n : []) : a = n && ft.isPlainObject(n) ? n : {}, o[e] = ft.extend(c, a, i)) : void 0 !== i && (o[e] = i)); return o }, ft.extend({ expando: 'jQuery' + ('3.2.1' + Math.random()).replace(/\D/g, ''), isReady: !0, error: function (t) { throw new Error(t) }, noop: function () {}, isFunction: function (t) { return ft.type(t) === 'function' }, isWindow: function (t) { return t != null && t === t.window }, isNumeric: function (t) { const e = ft.type(t); return (e === 'number' || e === 'string') && !isNaN(t - parseFloat(t)) }, isPlainObject: function (t) { let e, n; return !(!t || ct.call(t) !== '[object Object]') && (!(e = it(t)) || typeof (n = ut.call(e, 'constructor') && e.constructor) === 'function' && ht.call(n) === pt) }, isEmptyObject: function (t) { let e; for (e in t) return !1; return !0 }, type: function (t) { return t == null ? t + '' : typeof t === 'object' || typeof t === 'function' ? lt[ct.call(t)] || 'object' : typeof t }, globalEval: function (t) { n(t) }, camelCase: function (t) { return t.replace(/^-ms-/, 'ms-').replace(/-([a-z])/g, mt) }, each: function (t, e) { let n; let r = 0; if (i(t)) for (n = t.length; r < n && !1 !== e.call(t[r], r, t[r]); r++);else for (r in t) if (!1 === e.call(t[r], r, t[r])) break; return t }, trim: function (t) { return t == null ? '' : (t + '').replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '') }, makeArray: function (t, e) { const n = e || []; return t != null && (i(Object(t)) ? ft.merge(n, typeof t === 'string' ? [t] : t) : ot.call(n, t)), n }, inArray: function (t, e, n) { return e == null ? -1 : st.call(e, t, n) }, merge: function (t, e) { for (var n = +e.length, i = 0, r = t.length; i < n; i++)t[r++] = e[i]; return t.length = r, t }, grep: function (t, e, n) { for (var i = [], r = 0, a = t.length, o = !n; r < a; r++)!e(t[r], r) !== o && i.push(t[r]); return i }, map: function (t, e, n) { let r; let a; let o = 0; const s = []; if (i(t)) for (r = t.length; o < r; o++)(a = e(t[o], o, n)) != null && s.push(a); else for (o in t)(a = e(t[o], o, n)) != null && s.push(a); return at.apply([], s) }, guid: 1, proxy: function (t, e) { let n, i, r; if (typeof e === 'string' && (n = t[e], e = t, t = n), ft.isFunction(t)) return i = rt.call(arguments, 2), r = function () { return t.apply(e || this, i.concat(rt.call(arguments))) }, r.guid = t.guid = t.guid || ft.guid++, r }, now: Date.now, support: dt }), typeof Symbol === 'function' && (ft.fn[Symbol.iterator] = et[Symbol.iterator]), ft.each('Boolean Number String Function Array Date RegExp Object Error Symbol'.split(' '), function (t, e) { lt['[object ' + e + ']'] = e.toLowerCase() }); const gt = (function (t) {
    function e (t, e, n, i) { let r; let a; let o; let s; let l; let u; let p; let d = e && e.ownerDocument; const f = e ? e.nodeType : 9; if (n = n || [], typeof t !== 'string' || !t || f !== 1 && f !== 9 && f !== 11) return n; if (!i && ((e ? e.ownerDocument || e : U) !== k && P(e), e = e || k, O)) { if (f !== 11 && (l = mt.exec(t))) if (r = l[1]) { if (f === 9) { if (!(o = e.getElementById(r))) return n; if (o.id === r) return n.push(o), n } else if (d && (o = d.getElementById(r)) && N(e, o) && o.id === r) return n.push(o), n } else { if (l[2]) return Z.apply(n, e.getElementsByTagName(t)), n; if ((r = l[3]) && x.getElementsByClassName && e.getElementsByClassName) return Z.apply(n, e.getElementsByClassName(r)), n } if (x.qsa && !G[t + ' '] && (!L || !L.test(t))) { if (f !== 1)d = e, p = t; else if (e.nodeName.toLowerCase() !== 'object') { for ((s = e.getAttribute('id')) ? s = s.replace(bt, xt) : e.setAttribute('id', s = F), u = T(t), a = u.length; a--;)u[a] = '#' + s + ' ' + h(u[a]); p = u.join(','), d = gt.test(t) && c(e.parentNode) || e } if (p) try { return Z.apply(n, d.querySelectorAll(p)), n } catch (t) {} finally { s === F && e.removeAttribute('id') } } } return M(t.replace(at, '$1'), e, n, i) } function n () { function t (n, i) { return e.push(n + ' ') > w.cacheLength && delete t[e.shift()], t[n + ' '] = i } var e = []; return t } function i (t) { return t[F] = !0, t } function r (t) { let e = k.createElement('fieldset'); try { return !!t(e) } catch (t) { return !1 } finally { e.parentNode && e.parentNode.removeChild(e), e = null } } function a (t, e) { for (let n = t.split('|'), i = n.length; i--;)w.attrHandle[n[i]] = e } function o (t, e) { let n = e && t; const i = n && t.nodeType === 1 && e.nodeType === 1 && t.sourceIndex - e.sourceIndex; if (i) return i; if (n) for (;n = n.nextSibling;) if (n === e) return -1; return t ? 1 : -1 } function s (t) { return function (e) { return 'form' in e ? e.parentNode && !1 === e.disabled ? 'label' in e ? 'label' in e.parentNode ? e.parentNode.disabled === t : e.disabled === t : e.isDisabled === t || e.isDisabled !== !t && _t(e) === t : e.disabled === t : 'label' in e && e.disabled === t } } function l (t) { return i(function (e) { return e = +e, i(function (n, i) { for (var r, a = t([], n.length, e), o = a.length; o--;)n[r = a[o]] && (n[r] = !(i[r] = n[r])) }) }) } function c (t) { return t && void 0 !== t.getElementsByTagName && t } function u () {} function h (t) { for (var e = 0, n = t.length, i = ''; e < n; e++)i += t[e].value; return i } function p (t, e, n) { const i = e.dir; const r = e.next; const a = r || i; const o = n && a === 'parentNode'; const s = B++; return e.first ? function (e, n, r) { for (;e = e[i];) if (e.nodeType === 1 || o) return t(e, n, r); return !1 } : function (e, n, l) { let c; let u; let h; const p = [z, s]; if (l) { for (;e = e[i];) if ((e.nodeType === 1 || o) && t(e, n, l)) return !0 } else for (;e = e[i];) if (e.nodeType === 1 || o) if (h = e[F] || (e[F] = {}), u = h[e.uniqueID] || (h[e.uniqueID] = {}), r && r === e.nodeName.toLowerCase())e = e[i] || e; else { if ((c = u[a]) && c[0] === z && c[1] === s) return p[2] = c[2]; if (u[a] = p, p[2] = t(e, n, l)) return !0 } return !1 } } function d (t) { return t.length > 1 ? function (e, n, i) { for (let r = t.length; r--;) if (!t[r](e, n, i)) return !1; return !0 } : t[0] } function f (t, n, i) { for (let r = 0, a = n.length; r < a; r++)e(t, n[r], i); return i } function m (t, e, n, i, r) { for (var a, o = [], s = 0, l = t.length, c = e != null; s < l; s++)(a = t[s]) && (n && !n(a, i, r) || (o.push(a), c && e.push(s))); return o } function g (t, e, n, r, a, o) { return r && !r[F] && (r = g(r)), a && !a[F] && (a = g(a, o)), i(function (i, o, s, l) { let c; let u; let h; const p = []; const d = []; const g = o.length; const v = i || f(e || '*', s.nodeType ? [s] : s, []); const y = !t || !i && e ? v : m(v, p, t, s, l); let b = n ? a || (i ? t : g || r) ? [] : o : y; if (n && n(y, b, s, l), r) for (c = m(b, d), r(c, [], s, l), u = c.length; u--;)(h = c[u]) && (b[d[u]] = !(y[d[u]] = h)); if (i) { if (a || t) { if (a) { for (c = [], u = b.length; u--;)(h = b[u]) && c.push(y[u] = h); a(null, b = [], c, l) } for (u = b.length; u--;)(h = b[u]) && (c = a ? J(i, h) : p[u]) > -1 && (i[c] = !(o[c] = h)) } } else b = m(b === o ? b.splice(g, b.length) : b), a ? a(null, o, b, l) : Z.apply(o, b) }) } function v (t) { for (var e, n, i, r = t.length, a = w.relative[t[0].type], o = a || w.relative[' '], s = a ? 1 : 0, l = p(function (t) { return t === e }, o, !0), c = p(function (t) { return J(e, t) > -1 }, o, !0), u = [function (t, n, i) { const r = !a && (i || n !== C) || ((e = n).nodeType ? l(t, n, i) : c(t, n, i)); return e = null, r }]; s < r; s++) if (n = w.relative[t[s].type])u = [p(d(u), n)]; else { if (n = w.filter[t[s].type].apply(null, t[s].matches), n[F]) { for (i = ++s; i < r && !w.relative[t[i].type]; i++);return g(s > 1 && d(u), s > 1 && h(t.slice(0, s - 1).concat({ value: t[s - 2].type === ' ' ? '*' : '' })).replace(at, '$1'), n, s < i && v(t.slice(s, i)), i < r && v(t = t.slice(i)), i < r && h(t)) }u.push(n) } return d(u) } function y (t, n) { const r = n.length > 0; const a = t.length > 0; const o = function (i, o, s, l, c) { let u; let h; let p; let d = 0; let f = '0'; const g = i && []; let v = []; const y = C; const b = i || a && w.find.TAG('*', c); const x = z += y == null ? 1 : Math.random() || 0.1; const _ = b.length; for (c && (C = o === k || o || c); f !== _ && (u = b[f]) != null; f++) { if (a && u) { for (h = 0, o || u.ownerDocument === k || (P(u), s = !O); p = t[h++];) if (p(u, o || k, s)) { l.push(u); break }c && (z = x) }r && ((u = !p && u) && d--, i && g.push(u)) } if (d += f, r && f !== d) { for (h = 0; p = n[h++];)p(g, v, o, s); if (i) { if (d > 0) for (;f--;)g[f] || v[f] || (v[f] = X.call(l)); v = m(v) }Z.apply(l, v), c && !i && v.length > 0 && d + n.length > 1 && e.uniqueSort(l) } return c && (z = x, C = y), g }; return r ? i(o) : o } let b; let x; let w; let _; let $; let T; let S; let M; let C; let E; let A; let P; let k; let D; let O; let L; let I; let R; let N; var F = 'sizzle' + 1 * new Date(); var U = t.document; var z = 0; var B = 0; const j = n(); const V = n(); var G = n(); let H = function (t, e) { return t === e && (A = !0), 0 }; const W = {}.hasOwnProperty; let q = []; var X = q.pop; const Y = q.push; var Z = q.push; const K = q.slice; var J = function (t, e) { for (let n = 0, i = t.length; n < i; n++) if (t[n] === e) return n; return -1 }; const Q = 'checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped'; const tt = '[\\x20\\t\\r\\n\\f]'; const et = '(?:\\\\.|[\\w-]|[^\0-\\xa0])+'; const nt = '\\[' + tt + '*(' + et + ')(?:' + tt + '*([*^$|!~]?=)' + tt + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + et + '))|)' + tt + '*\\]'; const it = ':(' + et + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + nt + ')*)|.*)\\)|)'; const rt = new RegExp(tt + '+', 'g'); var at = new RegExp('^' + tt + '+|((?:^|[^\\\\])(?:\\\\.)*)' + tt + '+$', 'g'); const ot = new RegExp('^' + tt + '*,' + tt + '*'); const st = new RegExp('^' + tt + '*([>+~]|' + tt + ')' + tt + '*'); const lt = new RegExp('=' + tt + "*([^\\]'\"]*?)" + tt + '*\\]', 'g'); const ct = new RegExp(it); const ut = new RegExp('^' + et + '$'); const ht = { ID: new RegExp('^#(' + et + ')'), CLASS: new RegExp('^\\.(' + et + ')'), TAG: new RegExp('^(' + et + '|[*])'), ATTR: new RegExp('^' + nt), PSEUDO: new RegExp('^' + it), CHILD: new RegExp('^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(' + tt + '*(even|odd|(([+-]|)(\\d*)n|)' + tt + '*(?:([+-]|)' + tt + '*(\\d+)|))' + tt + '*\\)|)', 'i'), bool: new RegExp('^(?:' + Q + ')$', 'i'), needsContext: new RegExp('^' + tt + '*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(' + tt + '*((?:-\\d)?\\d*)' + tt + '*\\)|)(?=[^-]|$)', 'i') }; const pt = /^(?:input|select|textarea|button)$/i; const dt = /^h\d$/i; const ft = /^[^{]+\{\s*\[native \w/; var mt = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/; var gt = /[+~]/; const vt = new RegExp('\\\\([\\da-f]{1,6}' + tt + '?|(' + tt + ')|.)', 'ig'); const yt = function (t, e, n) { const i = '0x' + e - 65536; return i !== i || n ? e : i < 0 ? String.fromCharCode(i + 65536) : String.fromCharCode(i >> 10 | 55296, 1023 & i | 56320) }; var bt = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g; var xt = function (t, e) { return e ? t === '\0' ? '' : t.slice(0, -1) + '\\' + t.charCodeAt(t.length - 1).toString(16) + ' ' : '\\' + t }; const wt = function () { P() }; var _t = p(function (t) { return !0 === t.disabled && ('form' in t || 'label' in t) }, { dir: 'parentNode', next: 'legend' }); try { Z.apply(q = K.call(U.childNodes), U.childNodes), q[U.childNodes.length].nodeType } catch (t) { Z = { apply: q.length ? function (t, e) { Y.apply(t, K.call(e)) } : function (t, e) { for (var n = t.length, i = 0; t[n++] = e[i++];);t.length = n - 1 } } }x = e.support = {}, $ = e.isXML = function (t) { const e = t && (t.ownerDocument || t).documentElement; return !!e && e.nodeName !== 'HTML' }, P = e.setDocument = function (t) { let e; let n; const i = t ? t.ownerDocument || t : U; return i !== k && i.nodeType === 9 && i.documentElement ? (k = i, D = k.documentElement, O = !$(k), U !== k && (n = k.defaultView) && n.top !== n && (n.addEventListener ? n.addEventListener('unload', wt, !1) : n.attachEvent && n.attachEvent('onunload', wt)), x.attributes = r(function (t) { return t.className = 'i', !t.getAttribute('className') }), x.getElementsByTagName = r(function (t) { return t.appendChild(k.createComment('')), !t.getElementsByTagName('*').length }), x.getElementsByClassName = ft.test(k.getElementsByClassName), x.getById = r(function (t) { return D.appendChild(t).id = F, !k.getElementsByName || !k.getElementsByName(F).length }), x.getById ? (w.filter.ID = function (t) { const e = t.replace(vt, yt); return function (t) { return t.getAttribute('id') === e } }, w.find.ID = function (t, e) { if (void 0 !== e.getElementById && O) { const n = e.getElementById(t); return n ? [n] : [] } }) : (w.filter.ID = function (t) { const e = t.replace(vt, yt); return function (t) { const n = void 0 !== t.getAttributeNode && t.getAttributeNode('id'); return n && n.value === e } }, w.find.ID = function (t, e) { if (void 0 !== e.getElementById && O) { let n; let i; let r; let a = e.getElementById(t); if (a) { if ((n = a.getAttributeNode('id')) && n.value === t) return [a]; for (r = e.getElementsByName(t), i = 0; a = r[i++];) if ((n = a.getAttributeNode('id')) && n.value === t) return [a] } return [] } }), w.find.TAG = x.getElementsByTagName ? function (t, e) { return void 0 !== e.getElementsByTagName ? e.getElementsByTagName(t) : x.qsa ? e.querySelectorAll(t) : void 0 } : function (t, e) { let n; const i = []; let r = 0; const a = e.getElementsByTagName(t); if (t === '*') { for (;n = a[r++];)n.nodeType === 1 && i.push(n); return i } return a }, w.find.CLASS = x.getElementsByClassName && function (t, e) { if (void 0 !== e.getElementsByClassName && O) return e.getElementsByClassName(t) }, I = [], L = [], (x.qsa = ft.test(k.querySelectorAll)) && (r(function (t) { D.appendChild(t).innerHTML = "<a id='" + F + "'></a><select id='" + F + "-\r\\' msallowcapture=''><option selected=''></option></select>", t.querySelectorAll("[msallowcapture^='']").length && L.push('[*^$]=' + tt + "*(?:''|\"\")"), t.querySelectorAll('[selected]').length || L.push('\\[' + tt + '*(?:value|' + Q + ')'), t.querySelectorAll('[id~=' + F + '-]').length || L.push('~='), t.querySelectorAll(':checked').length || L.push(':checked'), t.querySelectorAll('a#' + F + '+*').length || L.push('.#.+[+~]') }), r(function (t) { t.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>"; const e = k.createElement('input'); e.setAttribute('type', 'hidden'), t.appendChild(e).setAttribute('name', 'D'), t.querySelectorAll('[name=d]').length && L.push('name' + tt + '*[*^$|!~]?='), t.querySelectorAll(':enabled').length !== 2 && L.push(':enabled', ':disabled'), D.appendChild(t).disabled = !0, t.querySelectorAll(':disabled').length !== 2 && L.push(':enabled', ':disabled'), t.querySelectorAll('*,:x'), L.push(',.*:') })), (x.matchesSelector = ft.test(R = D.matches || D.webkitMatchesSelector || D.mozMatchesSelector || D.oMatchesSelector || D.msMatchesSelector)) && r(function (t) { x.disconnectedMatch = R.call(t, '*'), R.call(t, "[s!='']:x"), I.push('!=', it) }), L = L.length && new RegExp(L.join('|')), I = I.length && new RegExp(I.join('|')), e = ft.test(D.compareDocumentPosition), N = e || ft.test(D.contains) ? function (t, e) { const n = t.nodeType === 9 ? t.documentElement : t; const i = e && e.parentNode; return t === i || !(!i || i.nodeType !== 1 || !(n.contains ? n.contains(i) : t.compareDocumentPosition && 16 & t.compareDocumentPosition(i))) } : function (t, e) { if (e) for (;e = e.parentNode;) if (e === t) return !0; return !1 }, H = e ? function (t, e) { if (t === e) return A = !0, 0; let n = !t.compareDocumentPosition - !e.compareDocumentPosition; return n || (n = (t.ownerDocument || t) === (e.ownerDocument || e) ? t.compareDocumentPosition(e) : 1, 1 & n || !x.sortDetached && e.compareDocumentPosition(t) === n ? t === k || t.ownerDocument === U && N(U, t) ? -1 : e === k || e.ownerDocument === U && N(U, e) ? 1 : E ? J(E, t) - J(E, e) : 0 : 4 & n ? -1 : 1) } : function (t, e) { if (t === e) return A = !0, 0; let n; let i = 0; const r = t.parentNode; const a = e.parentNode; const s = [t]; const l = [e]; if (!r || !a) return t === k ? -1 : e === k ? 1 : r ? -1 : a ? 1 : E ? J(E, t) - J(E, e) : 0; if (r === a) return o(t, e); for (n = t; n = n.parentNode;)s.unshift(n); for (n = e; n = n.parentNode;)l.unshift(n); for (;s[i] === l[i];)i++; return i ? o(s[i], l[i]) : s[i] === U ? -1 : l[i] === U ? 1 : 0 }, k) : k }, e.matches = function (t, n) { return e(t, null, null, n) }, e.matchesSelector = function (t, n) { if ((t.ownerDocument || t) !== k && P(t), n = n.replace(lt, "='$1']"), x.matchesSelector && O && !G[n + ' '] && (!I || !I.test(n)) && (!L || !L.test(n))) try { const i = R.call(t, n); if (i || x.disconnectedMatch || t.document && t.document.nodeType !== 11) return i } catch (t) {} return e(n, k, null, [t]).length > 0 }, e.contains = function (t, e) { return (t.ownerDocument || t) !== k && P(t), N(t, e) }, e.attr = function (t, e) { (t.ownerDocument || t) !== k && P(t); const n = w.attrHandle[e.toLowerCase()]; let i = n && W.call(w.attrHandle, e.toLowerCase()) ? n(t, e, !O) : void 0; return void 0 !== i ? i : x.attributes || !O ? t.getAttribute(e) : (i = t.getAttributeNode(e)) && i.specified ? i.value : null }, e.escape = function (t) { return (t + '').replace(bt, xt) }, e.error = function (t) { throw new Error('Syntax error, unrecognized expression: ' + t) }, e.uniqueSort = function (t) { let e; const n = []; let i = 0; let r = 0; if (A = !x.detectDuplicates, E = !x.sortStable && t.slice(0), t.sort(H), A) { for (;e = t[r++];)e === t[r] && (i = n.push(r)); for (;i--;)t.splice(n[i], 1) } return E = null, t }, _ = e.getText = function (t) { let e; let n = ''; let i = 0; const r = t.nodeType; if (r) { if (r === 1 || r === 9 || r === 11) { if (typeof t.textContent === 'string') return t.textContent; for (t = t.firstChild; t; t = t.nextSibling)n += _(t) } else if (r === 3 || r === 4) return t.nodeValue } else for (;e = t[i++];)n += _(e); return n }, w = e.selectors = {
      cacheLength: 50,
      createPseudo: i,
      match: ht,
      attrHandle: {},
      find: {},
      relative: { '>': { dir: 'parentNode', first: !0 }, ' ': { dir: 'parentNode' }, '+': { dir: 'previousSibling', first: !0 }, '~': { dir: 'previousSibling' } },
      preFilter: {
        ATTR: function (t) {
          return t[1] = t[1].replace(vt, yt), t[3] = (t[3] || t[4] || t[5] || '').replace(vt, yt), t[2] === '~=' && (t[3] = ' ' + t[3] + ' '), t.slice(0, 4)
        },
        CHILD: function (t) { return t[1] = t[1].toLowerCase(), t[1].slice(0, 3) === 'nth' ? (t[3] || e.error(t[0]), t[4] = +(t[4] ? t[5] + (t[6] || 1) : 2 * (t[3] === 'even' || t[3] === 'odd')), t[5] = +(t[7] + t[8] || t[3] === 'odd')) : t[3] && e.error(t[0]), t },
        PSEUDO: function (t) { let e; const n = !t[6] && t[2]; return ht.CHILD.test(t[0]) ? null : (t[3] ? t[2] = t[4] || t[5] || '' : n && ct.test(n) && (e = T(n, !0)) && (e = n.indexOf(')', n.length - e) - n.length) && (t[0] = t[0].slice(0, e), t[2] = n.slice(0, e)), t.slice(0, 3)) }
      },
      filter: { TAG: function (t) { const e = t.replace(vt, yt).toLowerCase(); return t === '*' ? function () { return !0 } : function (t) { return t.nodeName && t.nodeName.toLowerCase() === e } }, CLASS: function (t) { let e = j[t + ' ']; return e || (e = new RegExp('(^|' + tt + ')' + t + '(' + tt + '|$)')) && j(t, function (t) { return e.test(typeof t.className === 'string' && t.className || void 0 !== t.getAttribute && t.getAttribute('class') || '') }) }, ATTR: function (t, n, i) { return function (r) { let a = e.attr(r, t); return a == null ? n === '!=' : !n || (a += '', n === '=' ? a === i : n === '!=' ? a !== i : n === '^=' ? i && a.indexOf(i) === 0 : n === '*=' ? i && a.indexOf(i) > -1 : n === '$=' ? i && a.slice(-i.length) === i : n === '~=' ? (' ' + a.replace(rt, ' ') + ' ').indexOf(i) > -1 : n === '|=' && (a === i || a.slice(0, i.length + 1) === i + '-')) } }, CHILD: function (t, e, n, i, r) { const a = t.slice(0, 3) !== 'nth'; const o = t.slice(-4) !== 'last'; const s = e === 'of-type'; return i === 1 && r === 0 ? function (t) { return !!t.parentNode } : function (e, n, l) { let c; let u; let h; let p; let d; let f; let m = a !== o ? 'nextSibling' : 'previousSibling'; const g = e.parentNode; const v = s && e.nodeName.toLowerCase(); const y = !l && !s; let b = !1; if (g) { if (a) { for (;m;) { for (p = e; p = p[m];) if (s ? p.nodeName.toLowerCase() === v : p.nodeType === 1) return !1; f = m = t === 'only' && !f && 'nextSibling' } return !0 } if (f = [o ? g.firstChild : g.lastChild], o && y) { for (p = g, h = p[F] || (p[F] = {}), u = h[p.uniqueID] || (h[p.uniqueID] = {}), c = u[t] || [], d = c[0] === z && c[1], b = d && c[2], p = d && g.childNodes[d]; p = ++d && p && p[m] || (b = d = 0) || f.pop();) if (p.nodeType === 1 && ++b && p === e) { u[t] = [z, d, b]; break } } else if (y && (p = e, h = p[F] || (p[F] = {}), u = h[p.uniqueID] || (h[p.uniqueID] = {}), c = u[t] || [], d = c[0] === z && c[1], b = d), !1 === b) for (;(p = ++d && p && p[m] || (b = d = 0) || f.pop()) && ((s ? p.nodeName.toLowerCase() !== v : p.nodeType !== 1) || !++b || (y && (h = p[F] || (p[F] = {}), u = h[p.uniqueID] || (h[p.uniqueID] = {}), u[t] = [z, b]), p !== e)););return (b -= r) === i || b % i == 0 && b / i >= 0 } } }, PSEUDO: function (t, n) { let r; const a = w.pseudos[t] || w.setFilters[t.toLowerCase()] || e.error('unsupported pseudo: ' + t); return a[F] ? a(n) : a.length > 1 ? (r = [t, t, '', n], w.setFilters.hasOwnProperty(t.toLowerCase()) ? i(function (t, e) { for (var i, r = a(t, n), o = r.length; o--;)i = J(t, r[o]), t[i] = !(e[i] = r[o]) }) : function (t) { return a(t, 0, r) }) : a } },
      pseudos: { not: i(function (t) { const e = []; const n = []; const r = S(t.replace(at, '$1')); return r[F] ? i(function (t, e, n, i) { for (var a, o = r(t, null, i, []), s = t.length; s--;)(a = o[s]) && (t[s] = !(e[s] = a)) }) : function (t, i, a) { return e[0] = t, r(e, null, a, n), e[0] = null, !n.pop() } }), has: i(function (t) { return function (n) { return e(t, n).length > 0 } }), contains: i(function (t) { return t = t.replace(vt, yt), function (e) { return (e.textContent || e.innerText || _(e)).indexOf(t) > -1 } }), lang: i(function (t) { return ut.test(t || '') || e.error('unsupported lang: ' + t), t = t.replace(vt, yt).toLowerCase(), function (e) { let n; do { if (n = O ? e.lang : e.getAttribute('xml:lang') || e.getAttribute('lang')) return (n = n.toLowerCase()) === t || n.indexOf(t + '-') === 0 } while ((e = e.parentNode) && e.nodeType === 1); return !1 } }), target: function (e) { const n = t.location && t.location.hash; return n && n.slice(1) === e.id }, root: function (t) { return t === D }, focus: function (t) { return t === k.activeElement && (!k.hasFocus || k.hasFocus()) && !!(t.type || t.href || ~t.tabIndex) }, enabled: s(!1), disabled: s(!0), checked: function (t) { const e = t.nodeName.toLowerCase(); return e === 'input' && !!t.checked || e === 'option' && !!t.selected }, selected: function (t) { return t.parentNode && t.parentNode.selectedIndex, !0 === t.selected }, empty: function (t) { for (t = t.firstChild; t; t = t.nextSibling) if (t.nodeType < 6) return !1; return !0 }, parent: function (t) { return !w.pseudos.empty(t) }, header: function (t) { return dt.test(t.nodeName) }, input: function (t) { return pt.test(t.nodeName) }, button: function (t) { const e = t.nodeName.toLowerCase(); return e === 'input' && t.type === 'button' || e === 'button' }, text: function (t) { let e; return t.nodeName.toLowerCase() === 'input' && t.type === 'text' && ((e = t.getAttribute('type')) == null || e.toLowerCase() === 'text') }, first: l(function () { return [0] }), last: l(function (t, e) { return [e - 1] }), eq: l(function (t, e, n) { return [n < 0 ? n + e : n] }), even: l(function (t, e) { for (let n = 0; n < e; n += 2)t.push(n); return t }), odd: l(function (t, e) { for (let n = 1; n < e; n += 2)t.push(n); return t }), lt: l(function (t, e, n) { for (let i = n < 0 ? n + e : n; --i >= 0;)t.push(i); return t }), gt: l(function (t, e, n) { for (let i = n < 0 ? n + e : n; ++i < e;)t.push(i); return t }) }
    }, w.pseudos.nth = w.pseudos.eq; for (b in { radio: !0, checkbox: !0, file: !0, password: !0, image: !0 })w.pseudos[b] = (function (t) { return function (e) { return e.nodeName.toLowerCase() === 'input' && e.type === t } }(b)); for (b in { submit: !0, reset: !0 })w.pseudos[b] = (function (t) { return function (e) { const n = e.nodeName.toLowerCase(); return (n === 'input' || n === 'button') && e.type === t } }(b)); return u.prototype = w.filters = w.pseudos, w.setFilters = new u(), T = e.tokenize = function (t, n) { let i; let r; let a; let o; let s; let l; let c; const u = V[t + ' ']; if (u) return n ? 0 : u.slice(0); for (s = t, l = [], c = w.preFilter; s;) { i && !(r = ot.exec(s)) || (r && (s = s.slice(r[0].length) || s), l.push(a = [])), i = !1, (r = st.exec(s)) && (i = r.shift(), a.push({ value: i, type: r[0].replace(at, ' ') }), s = s.slice(i.length)); for (o in w.filter)!(r = ht[o].exec(s)) || c[o] && !(r = c[o](r)) || (i = r.shift(), a.push({ value: i, type: o, matches: r }), s = s.slice(i.length)); if (!i) break } return n ? s.length : s ? e.error(t) : V(t, l).slice(0) }, S = e.compile = function (t, e) { let n; const i = []; const r = []; let a = G[t + ' ']; if (!a) { for (e || (e = T(t)), n = e.length; n--;)a = v(e[n]), a[F] ? i.push(a) : r.push(a); a = G(t, y(r, i)), a.selector = t } return a }, M = e.select = function (t, e, n, i) { let r; let a; let o; let s; let l; const u = typeof t === 'function' && t; const p = !i && T(t = u.selector || t); if (n = n || [], p.length === 1) { if (a = p[0] = p[0].slice(0), a.length > 2 && (o = a[0]).type === 'ID' && e.nodeType === 9 && O && w.relative[a[1].type]) { if (!(e = (w.find.ID(o.matches[0].replace(vt, yt), e) || [])[0])) return n; u && (e = e.parentNode), t = t.slice(a.shift().value.length) } for (r = ht.needsContext.test(t) ? 0 : a.length; r-- && (o = a[r], !w.relative[s = o.type]);) if ((l = w.find[s]) && (i = l(o.matches[0].replace(vt, yt), gt.test(a[0].type) && c(e.parentNode) || e))) { if (a.splice(r, 1), !(t = i.length && h(a))) return Z.apply(n, i), n; break } } return (u || S(t, p))(i, e, !O, n, !e || gt.test(t) && c(e.parentNode) || e), n }, x.sortStable = F.split('').sort(H).join('') === F, x.detectDuplicates = !!A, P(), x.sortDetached = r(function (t) { return 1 & t.compareDocumentPosition(k.createElement('fieldset')) }), r(function (t) { return t.innerHTML = "<a href='#'></a>", t.firstChild.getAttribute('href') === '#' }) || a('type|href|height|width', function (t, e, n) { if (!n) return t.getAttribute(e, e.toLowerCase() === 'type' ? 1 : 2) }), x.attributes && r(function (t) { return t.innerHTML = '<input/>', t.firstChild.setAttribute('value', ''), t.firstChild.getAttribute('value') === '' }) || a('value', function (t, e, n) { if (!n && t.nodeName.toLowerCase() === 'input') return t.defaultValue }), r(function (t) { return t.getAttribute('disabled') == null }) || a(Q, function (t, e, n) { let i; if (!n) return !0 === t[e] ? e.toLowerCase() : (i = t.getAttributeNode(e)) && i.specified ? i.value : null }), e
  }(t)); ft.find = gt, ft.expr = gt.selectors, ft.expr[':'] = ft.expr.pseudos, ft.uniqueSort = ft.unique = gt.uniqueSort, ft.text = gt.getText, ft.isXMLDoc = gt.isXML, ft.contains = gt.contains, ft.escapeSelector = gt.escape; const vt = function (t, e, n) { for (var i = [], r = void 0 !== n; (t = t[e]) && t.nodeType !== 9;) if (t.nodeType === 1) { if (r && ft(t).is(n)) break; i.push(t) } return i }; const yt = function (t, e) { for (var n = []; t; t = t.nextSibling)t.nodeType === 1 && t !== e && n.push(t); return n }; const bt = ft.expr.match.needsContext; const xt = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i; var wt = /^.[^:#\[\.,]*$/; ft.filter = function (t, e, n) { const i = e[0]; return n && (t = ':not(' + t + ')'), e.length === 1 && i.nodeType === 1 ? ft.find.matchesSelector(i, t) ? [i] : [] : ft.find.matches(t, ft.grep(e, function (t) { return t.nodeType === 1 })) }, ft.fn.extend({ find: function (t) { let e; let n; const i = this.length; const r = this; if (typeof t !== 'string') return this.pushStack(ft(t).filter(function () { for (e = 0; e < i; e++) if (ft.contains(r[e], this)) return !0 })); for (n = this.pushStack([]), e = 0; e < i; e++)ft.find(t, r[e], n); return i > 1 ? ft.uniqueSort(n) : n }, filter: function (t) { return this.pushStack(a(this, t || [], !1)) }, not: function (t) { return this.pushStack(a(this, t || [], !0)) }, is: function (t) { return !!a(this, typeof t === 'string' && bt.test(t) ? ft(t) : t || [], !1).length } }); let _t; const $t = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/; (ft.fn.init = function (t, e, n) { let i, r; if (!t) return this; if (n = n || _t, typeof t === 'string') { if (!(i = t[0] === '<' && t[t.length - 1] === '>' && t.length >= 3 ? [null, t, null] : $t.exec(t)) || !i[1] && e) return !e || e.jquery ? (e || n).find(t) : this.constructor(e).find(t); if (i[1]) { if (e = e instanceof ft ? e[0] : e, ft.merge(this, ft.parseHTML(i[1], e && e.nodeType ? e.ownerDocument || e : nt, !0)), xt.test(i[1]) && ft.isPlainObject(e)) for (i in e)ft.isFunction(this[i]) ? this[i](e[i]) : this.attr(i, e[i]); return this } return r = nt.getElementById(i[2]), r && (this[0] = r, this.length = 1), this } return t.nodeType ? (this[0] = t, this.length = 1, this) : ft.isFunction(t) ? void 0 !== n.ready ? n.ready(t) : t(ft) : ft.makeArray(t, this) }).prototype = ft.fn, _t = ft(nt); const Tt = /^(?:parents|prev(?:Until|All))/; const St = { children: !0, contents: !0, next: !0, prev: !0 }; ft.fn.extend({ has: function (t) { const e = ft(t, this); const n = e.length; return this.filter(function () { for (let t = 0; t < n; t++) if (ft.contains(this, e[t])) return !0 }) }, closest: function (t, e) { let n; let i = 0; const r = this.length; const a = []; const o = typeof t !== 'string' && ft(t); if (!bt.test(t)) for (;i < r; i++) for (n = this[i]; n && n !== e; n = n.parentNode) if (n.nodeType < 11 && (o ? o.index(n) > -1 : n.nodeType === 1 && ft.find.matchesSelector(n, t))) { a.push(n); break } return this.pushStack(a.length > 1 ? ft.uniqueSort(a) : a) }, index: function (t) { return t ? typeof t === 'string' ? st.call(ft(t), this[0]) : st.call(this, t.jquery ? t[0] : t) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1 }, add: function (t, e) { return this.pushStack(ft.uniqueSort(ft.merge(this.get(), ft(t, e)))) }, addBack: function (t) { return this.add(t == null ? this.prevObject : this.prevObject.filter(t)) } }), ft.each({ parent: function (t) { const e = t.parentNode; return e && e.nodeType !== 11 ? e : null }, parents: function (t) { return vt(t, 'parentNode') }, parentsUntil: function (t, e, n) { return vt(t, 'parentNode', n) }, next: function (t) { return o(t, 'nextSibling') }, prev: function (t) { return o(t, 'previousSibling') }, nextAll: function (t) { return vt(t, 'nextSibling') }, prevAll: function (t) { return vt(t, 'previousSibling') }, nextUntil: function (t, e, n) { return vt(t, 'nextSibling', n) }, prevUntil: function (t, e, n) { return vt(t, 'previousSibling', n) }, siblings: function (t) { return yt((t.parentNode || {}).firstChild, t) }, children: function (t) { return yt(t.firstChild) }, contents: function (t) { return r(t, 'iframe') ? t.contentDocument : (r(t, 'template') && (t = t.content || t), ft.merge([], t.childNodes)) } }, function (t, e) { ft.fn[t] = function (n, i) { let r = ft.map(this, e, n); return t.slice(-5) !== 'Until' && (i = n), i && typeof i === 'string' && (r = ft.filter(i, r)), this.length > 1 && (St[t] || ft.uniqueSort(r), Tt.test(t) && r.reverse()), this.pushStack(r) } }); var Mt = /[^\x20\t\r\n\f]+/g; ft.Callbacks = function (t) { t = typeof t === 'string' ? s(t) : ft.extend({}, t); let e; let n; let i; let r; let a = []; let o = []; let l = -1; const c = function () { for (r = r || t.once, i = e = !0; o.length; l = -1) for (n = o.shift(); ++l < a.length;)!1 === a[l].apply(n[0], n[1]) && t.stopOnFalse && (l = a.length, n = !1); t.memory || (n = !1), e = !1, r && (a = n ? [] : '') }; var u = { add: function () { return a && (n && !e && (l = a.length - 1, o.push(n)), (function e (n) { ft.each(n, function (n, i) { ft.isFunction(i) ? t.unique && u.has(i) || a.push(i) : i && i.length && ft.type(i) !== 'string' && e(i) }) }(arguments)), n && !e && c()), this }, remove: function () { return ft.each(arguments, function (t, e) { for (var n; (n = ft.inArray(e, a, n)) > -1;)a.splice(n, 1), n <= l && l-- }), this }, has: function (t) { return t ? ft.inArray(t, a) > -1 : a.length > 0 }, empty: function () { return a && (a = []), this }, disable: function () { return r = o = [], a = n = '', this }, disabled: function () { return !a }, lock: function () { return r = o = [], n || e || (a = n = ''), this }, locked: function () { return !!r }, fireWith: function (t, n) { return r || (n = n || [], n = [t, n.slice ? n.slice() : n], o.push(n), e || c()), this }, fire: function () { return u.fireWith(this, arguments), this }, fired: function () { return !!i } }; return u }, ft.extend({ Deferred: function (e) { const n = [['notify', 'progress', ft.Callbacks('memory'), ft.Callbacks('memory'), 2], ['resolve', 'done', ft.Callbacks('once memory'), ft.Callbacks('once memory'), 0, 'resolved'], ['reject', 'fail', ft.Callbacks('once memory'), ft.Callbacks('once memory'), 1, 'rejected']]; let i = 'pending'; var r = { state: function () { return i }, always: function () { return a.done(arguments).fail(arguments), this }, catch: function (t) { return r.then(null, t) }, pipe: function () { let t = arguments; return ft.Deferred(function (e) { ft.each(n, function (n, i) { const r = ft.isFunction(t[i[4]]) && t[i[4]]; a[i[1]](function () { const t = r && r.apply(this, arguments); t && ft.isFunction(t.promise) ? t.promise().progress(e.notify).done(e.resolve).fail(e.reject) : e[i[0] + 'With'](this, r ? [t] : arguments) }) }), t = null }).promise() }, then: function (e, i, r) { function a (e, n, i, r) { return function () { let s = this; let u = arguments; const h = function () { let t, h; if (!(e < o)) { if ((t = i.apply(s, u)) === n.promise()) throw new TypeError('Thenable self-resolution'); h = t && (typeof t === 'object' || typeof t === 'function') && t.then, ft.isFunction(h) ? r ? h.call(t, a(o, n, l, r), a(o, n, c, r)) : (o++, h.call(t, a(o, n, l, r), a(o, n, c, r), a(o, n, l, n.notifyWith))) : (i !== l && (s = void 0, u = [t]), (r || n.resolveWith)(s, u)) } }; var p = r ? h : function () { try { h() } catch (t) { ft.Deferred.exceptionHook && ft.Deferred.exceptionHook(t, p.stackTrace), e + 1 >= o && (i !== c && (s = void 0, u = [t]), n.rejectWith(s, u)) } }; e ? p() : (ft.Deferred.getStackHook && (p.stackTrace = ft.Deferred.getStackHook()), t.setTimeout(p)) } } var o = 0; return ft.Deferred(function (t) { n[0][3].add(a(0, t, ft.isFunction(r) ? r : l, t.notifyWith)), n[1][3].add(a(0, t, ft.isFunction(e) ? e : l)), n[2][3].add(a(0, t, ft.isFunction(i) ? i : c)) }).promise() }, promise: function (t) { return t != null ? ft.extend(t, r) : r } }; var a = {}; return ft.each(n, function (t, e) { const o = e[2]; const s = e[5]; r[e[1]] = o.add, s && o.add(function () { i = s }, n[3 - t][2].disable, n[0][2].lock), o.add(e[3].fire), a[e[0]] = function () { return a[e[0] + 'With'](this === a ? void 0 : this, arguments), this }, a[e[0] + 'With'] = o.fireWith }), r.promise(a), e && e.call(a, a), a }, when: function (t) { let e = arguments.length; let n = e; const i = Array(n); const r = rt.call(arguments); const a = ft.Deferred(); const o = function (t) { return function (n) { i[t] = this, r[t] = arguments.length > 1 ? rt.call(arguments) : n, --e || a.resolveWith(i, r) } }; if (e <= 1 && (u(t, a.done(o(n)).resolve, a.reject, !e), a.state() === 'pending' || ft.isFunction(r[n] && r[n].then))) return a.then(); for (;n--;)u(r[n], o(n), a.reject); return a.promise() } }); const Ct = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/; ft.Deferred.exceptionHook = function (e, n) { t.console && t.console.warn && e && Ct.test(e.name) && t.console.warn('jQuery.Deferred exception: ' + e.message, e.stack, n) }, ft.readyException = function (e) { t.setTimeout(function () { throw e }) }; const Et = ft.Deferred(); ft.fn.ready = function (t) { return Et.then(t).catch(function (t) { ft.readyException(t) }), this }, ft.extend({ isReady: !1, readyWait: 1, ready: function (t) { (!0 === t ? --ft.readyWait : ft.isReady) || (ft.isReady = !0, !0 !== t && --ft.readyWait > 0 || Et.resolveWith(nt, [ft])) } }), ft.ready.then = Et.then, nt.readyState === 'complete' || nt.readyState !== 'loading' && !nt.documentElement.doScroll ? t.setTimeout(ft.ready) : (nt.addEventListener('DOMContentLoaded', h), t.addEventListener('load', h)); const At = function (t, e, n, i, r, a, o) { let s = 0; const l = t.length; let c = n == null; if (ft.type(n) === 'object') { r = !0; for (s in n)At(t, e, s, n[s], !0, a, o) } else if (void 0 !== i && (r = !0, ft.isFunction(i) || (o = !0), c && (o ? (e.call(t, i), e = null) : (c = e, e = function (t, e, n) { return c.call(ft(t), n) })), e)) for (;s < l; s++)e(t[s], n, o ? i : i.call(t[s], s, e(t[s], n))); return r ? t : c ? e.call(t) : l ? e(t[0], n) : a }; const Pt = function (t) { return t.nodeType === 1 || t.nodeType === 9 || !+t.nodeType }; p.uid = 1, p.prototype = { cache: function (t) { let e = t[this.expando]; return e || (e = {}, Pt(t) && (t.nodeType ? t[this.expando] = e : Object.defineProperty(t, this.expando, { value: e, configurable: !0 }))), e }, set: function (t, e, n) { let i; const r = this.cache(t); if (typeof e === 'string')r[ft.camelCase(e)] = n; else for (i in e)r[ft.camelCase(i)] = e[i]; return r }, get: function (t, e) { return void 0 === e ? this.cache(t) : t[this.expando] && t[this.expando][ft.camelCase(e)] }, access: function (t, e, n) { return void 0 === e || e && typeof e === 'string' && void 0 === n ? this.get(t, e) : (this.set(t, e, n), void 0 !== n ? n : e) }, remove: function (t, e) { let n; const i = t[this.expando]; if (void 0 !== i) { if (void 0 !== e) { Array.isArray(e) ? e = e.map(ft.camelCase) : (e = ft.camelCase(e), e = e in i ? [e] : e.match(Mt) || []), n = e.length; for (;n--;) delete i[e[n]] }(void 0 === e || ft.isEmptyObject(i)) && (t.nodeType ? t[this.expando] = void 0 : delete t[this.expando]) } }, hasData: function (t) { const e = t[this.expando]; return void 0 !== e && !ft.isEmptyObject(e) } }; var kt = new p(); var Dt = new p(); var Ot = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/; var Lt = /[A-Z]/g; ft.extend({ hasData: function (t) { return Dt.hasData(t) || kt.hasData(t) }, data: function (t, e, n) { return Dt.access(t, e, n) }, removeData: function (t, e) { Dt.remove(t, e) }, _data: function (t, e, n) { return kt.access(t, e, n) }, _removeData: function (t, e) { kt.remove(t, e) } }), ft.fn.extend({ data: function (t, e) { let n; let i; let r; const a = this[0]; const o = a && a.attributes; if (void 0 === t) { if (this.length && (r = Dt.get(a), a.nodeType === 1 && !kt.get(a, 'hasDataAttrs'))) { for (n = o.length; n--;)o[n] && (i = o[n].name, i.indexOf('data-') === 0 && (i = ft.camelCase(i.slice(5)), f(a, i, r[i]))); kt.set(a, 'hasDataAttrs', !0) } return r } return typeof t === 'object' ? this.each(function () { Dt.set(this, t) }) : At(this, function (e) { let n; if (a && void 0 === e) { if (void 0 !== (n = Dt.get(a, t))) return n; if (void 0 !== (n = f(a, t))) return n } else this.each(function () { Dt.set(this, t, e) }) }, null, e, arguments.length > 1, null, !0) }, removeData: function (t) { return this.each(function () { Dt.remove(this, t) }) } }), ft.extend({ queue: function (t, e, n) { let i; if (t) return e = (e || 'fx') + 'queue', i = kt.get(t, e), n && (!i || Array.isArray(n) ? i = kt.access(t, e, ft.makeArray(n)) : i.push(n)), i || [] }, dequeue: function (t, e) { e = e || 'fx'; const n = ft.queue(t, e); let i = n.length; let r = n.shift(); const a = ft._queueHooks(t, e); const o = function () { ft.dequeue(t, e) }; r === 'inprogress' && (r = n.shift(), i--), r && (e === 'fx' && n.unshift('inprogress'), delete a.stop, r.call(t, o, a)), !i && a && a.empty.fire() }, _queueHooks: function (t, e) { const n = e + 'queueHooks'; return kt.get(t, n) || kt.access(t, n, { empty: ft.Callbacks('once memory').add(function () { kt.remove(t, [e + 'queue', n]) }) }) } }), ft.fn.extend({ queue: function (t, e) { let n = 2; return typeof t !== 'string' && (e = t, t = 'fx', n--), arguments.length < n ? ft.queue(this[0], t) : void 0 === e ? this : this.each(function () { const n = ft.queue(this, t, e); ft._queueHooks(this, t), t === 'fx' && n[0] !== 'inprogress' && ft.dequeue(this, t) }) }, dequeue: function (t) { return this.each(function () { ft.dequeue(this, t) }) }, clearQueue: function (t) { return this.queue(t || 'fx', []) }, promise: function (t, e) { let n; let i = 1; const r = ft.Deferred(); const a = this; let o = this.length; const s = function () { --i || r.resolveWith(a, [a]) }; for (typeof t !== 'string' && (e = t, t = void 0), t = t || 'fx'; o--;)(n = kt.get(a[o], t + 'queueHooks')) && n.empty && (i++, n.empty.add(s)); return s(), r.promise(e) } }); const It = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source; var Rt = new RegExp('^(?:([+-])=|)(' + It + ')([a-z%]*)$', 'i'); var Nt = ['Top', 'Right', 'Bottom', 'Left']; var Ft = function (t, e) { return t = e || t, t.style.display === 'none' || t.style.display === '' && ft.contains(t.ownerDocument, t) && ft.css(t, 'display') === 'none' }; const Ut = function (t, e, n, i) { let r; let a; const o = {}; for (a in e)o[a] = t.style[a], t.style[a] = e[a]; r = n.apply(t, i || []); for (a in e)t.style[a] = o[a]; return r }; var zt = {}; ft.fn.extend({ show: function () { return v(this, !0) }, hide: function () { return v(this) }, toggle: function (t) { return typeof t === 'boolean' ? t ? this.show() : this.hide() : this.each(function () { Ft(this) ? ft(this).show() : ft(this).hide() }) } }); var Bt = /^(?:checkbox|radio)$/i; var jt = /<([a-z][^\/\0>\x20\t\r\n\f]+)/i; var Vt = /^$|\/(?:java|ecma)script/i; var Gt = { option: [1, "<select multiple='multiple'>", '</select>'], thead: [1, '<table>', '</table>'], col: [2, '<table><colgroup>', '</colgroup></table>'], tr: [2, '<table><tbody>', '</tbody></table>'], td: [3, '<table><tbody><tr>', '</tr></tbody></table>'], _default: [0, '', ''] }; Gt.optgroup = Gt.option, Gt.tbody = Gt.tfoot = Gt.colgroup = Gt.caption = Gt.thead, Gt.th = Gt.td; var Ht = /<|&#?\w+;/; !(function () { const t = nt.createDocumentFragment(); const e = t.appendChild(nt.createElement('div')); const n = nt.createElement('input'); n.setAttribute('type', 'radio'), n.setAttribute('checked', 'checked'), n.setAttribute('name', 't'), e.appendChild(n), dt.checkClone = e.cloneNode(!0).cloneNode(!0).lastChild.checked, e.innerHTML = '<textarea>x</textarea>', dt.noCloneChecked = !!e.cloneNode(!0).lastChild.defaultValue }()); const Wt = nt.documentElement; const qt = /^key/; const Xt = /^(?:mouse|pointer|contextmenu|drag|drop)|click/; const Yt = /^([^.]*)(?:\.(.+)|)/; ft.event = { global: {}, add: function (t, e, n, i, r) { let a; let o; let s; let l; let c; let u; let h; let p; let d; let f; let m; const g = kt.get(t); if (g) for (n.handler && (a = n, n = a.handler, r = a.selector), r && ft.find.matchesSelector(Wt, r), n.guid || (n.guid = ft.guid++), (l = g.events) || (l = g.events = {}), (o = g.handle) || (o = g.handle = function (e) { return void 0 !== ft && ft.event.triggered !== e.type ? ft.event.dispatch.apply(t, arguments) : void 0 }), e = (e || '').match(Mt) || [''], c = e.length; c--;)s = Yt.exec(e[c]) || [], d = m = s[1], f = (s[2] || '').split('.').sort(), d && (h = ft.event.special[d] || {}, d = (r ? h.delegateType : h.bindType) || d, h = ft.event.special[d] || {}, u = ft.extend({ type: d, origType: m, data: i, handler: n, guid: n.guid, selector: r, needsContext: r && ft.expr.match.needsContext.test(r), namespace: f.join('.') }, a), (p = l[d]) || (p = l[d] = [], p.delegateCount = 0, h.setup && !1 !== h.setup.call(t, i, f, o) || t.addEventListener && t.addEventListener(d, o)), h.add && (h.add.call(t, u), u.handler.guid || (u.handler.guid = n.guid)), r ? p.splice(p.delegateCount++, 0, u) : p.push(u), ft.event.global[d] = !0) }, remove: function (t, e, n, i, r) { let a; let o; let s; let l; let c; let u; let h; let p; let d; let f; let m; const g = kt.hasData(t) && kt.get(t); if (g && (l = g.events)) { for (e = (e || '').match(Mt) || [''], c = e.length; c--;) if (s = Yt.exec(e[c]) || [], d = m = s[1], f = (s[2] || '').split('.').sort(), d) { for (h = ft.event.special[d] || {}, d = (i ? h.delegateType : h.bindType) || d, p = l[d] || [], s = s[2] && new RegExp('(^|\\.)' + f.join('\\.(?:.*\\.|)') + '(\\.|$)'), o = a = p.length; a--;)u = p[a], !r && m !== u.origType || n && n.guid !== u.guid || s && !s.test(u.namespace) || i && i !== u.selector && (i !== '**' || !u.selector) || (p.splice(a, 1), u.selector && p.delegateCount--, h.remove && h.remove.call(t, u)); o && !p.length && (h.teardown && !1 !== h.teardown.call(t, f, g.handle) || ft.removeEvent(t, d, g.handle), delete l[d]) } else for (d in l)ft.event.remove(t, d + e[c], n, i, !0); ft.isEmptyObject(l) && kt.remove(t, 'handle events') } }, dispatch: function (t) { let e; let n; let i; let r; let a; let o; const s = ft.event.fix(t); const l = new Array(arguments.length); const c = (kt.get(this, 'events') || {})[s.type] || []; const u = ft.event.special[s.type] || {}; for (l[0] = s, e = 1; e < arguments.length; e++)l[e] = arguments[e]; if (s.delegateTarget = this, !u.preDispatch || !1 !== u.preDispatch.call(this, s)) { for (o = ft.event.handlers.call(this, s, c), e = 0; (r = o[e++]) && !s.isPropagationStopped();) for (s.currentTarget = r.elem, n = 0; (a = r.handlers[n++]) && !s.isImmediatePropagationStopped();)s.rnamespace && !s.rnamespace.test(a.namespace) || (s.handleObj = a, s.data = a.data, void 0 !== (i = ((ft.event.special[a.origType] || {}).handle || a.handler).apply(r.elem, l)) && !1 === (s.result = i) && (s.preventDefault(), s.stopPropagation())); return u.postDispatch && u.postDispatch.call(this, s), s.result } }, handlers: function (t, e) { let n; let i; let r; let a; let o; const s = []; const l = e.delegateCount; let c = t.target; if (l && c.nodeType && !(t.type === 'click' && t.button >= 1)) for (;c !== this; c = c.parentNode || this) if (c.nodeType === 1 && (t.type !== 'click' || !0 !== c.disabled)) { for (a = [], o = {}, n = 0; n < l; n++)i = e[n], r = i.selector + ' ', void 0 === o[r] && (o[r] = i.needsContext ? ft(r, this).index(c) > -1 : ft.find(r, this, null, [c]).length), o[r] && a.push(i); a.length && s.push({ elem: c, handlers: a }) } return c = this, l < e.length && s.push({ elem: c, handlers: e.slice(l) }), s }, addProp: function (t, e) { Object.defineProperty(ft.Event.prototype, t, { enumerable: !0, configurable: !0, get: ft.isFunction(e) ? function () { if (this.originalEvent) return e(this.originalEvent) } : function () { if (this.originalEvent) return this.originalEvent[t] }, set: function (e) { Object.defineProperty(this, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) } }) }, fix: function (t) { return t[ft.expando] ? t : new ft.Event(t) }, special: { load: { noBubble: !0 }, focus: { trigger: function () { if (this !== $() && this.focus) return this.focus(), !1 }, delegateType: 'focusin' }, blur: { trigger: function () { if (this === $() && this.blur) return this.blur(), !1 }, delegateType: 'focusout' }, click: { trigger: function () { if (this.type === 'checkbox' && this.click && r(this, 'input')) return this.click(), !1 }, _default: function (t) { return r(t.target, 'a') } }, beforeunload: { postDispatch: function (t) { void 0 !== t.result && t.originalEvent && (t.originalEvent.returnValue = t.result) } } } }, ft.removeEvent = function (t, e, n) { t.removeEventListener && t.removeEventListener(e, n) }, ft.Event = function (t, e) { if (!(this instanceof ft.Event)) return new ft.Event(t, e); t && t.type ? (this.originalEvent = t, this.type = t.type, this.isDefaultPrevented = t.defaultPrevented || void 0 === t.defaultPrevented && !1 === t.returnValue ? w : _, this.target = t.target && t.target.nodeType === 3 ? t.target.parentNode : t.target, this.currentTarget = t.currentTarget, this.relatedTarget = t.relatedTarget) : this.type = t, e && ft.extend(this, e), this.timeStamp = t && t.timeStamp || ft.now(), this[ft.expando] = !0 }, ft.Event.prototype = { constructor: ft.Event, isDefaultPrevented: _, isPropagationStopped: _, isImmediatePropagationStopped: _, isSimulated: !1, preventDefault: function () { const t = this.originalEvent; this.isDefaultPrevented = w, t && !this.isSimulated && t.preventDefault() }, stopPropagation: function () { const t = this.originalEvent; this.isPropagationStopped = w, t && !this.isSimulated && t.stopPropagation() }, stopImmediatePropagation: function () { const t = this.originalEvent; this.isImmediatePropagationStopped = w, t && !this.isSimulated && t.stopImmediatePropagation(), this.stopPropagation() } }, ft.each({ altKey: !0, bubbles: !0, cancelable: !0, changedTouches: !0, ctrlKey: !0, detail: !0, eventPhase: !0, metaKey: !0, pageX: !0, pageY: !0, shiftKey: !0, view: !0, char: !0, charCode: !0, key: !0, keyCode: !0, button: !0, buttons: !0, clientX: !0, clientY: !0, offsetX: !0, offsetY: !0, pointerId: !0, pointerType: !0, screenX: !0, screenY: !0, targetTouches: !0, toElement: !0, touches: !0, which: function (t) { const e = t.button; return t.which == null && qt.test(t.type) ? t.charCode != null ? t.charCode : t.keyCode : !t.which && void 0 !== e && Xt.test(t.type) ? 1 & e ? 1 : 2 & e ? 3 : 4 & e ? 2 : 0 : t.which } }, ft.event.addProp), ft.each({ mouseenter: 'mouseover', mouseleave: 'mouseout', pointerenter: 'pointerover', pointerleave: 'pointerout' }, function (t, e) { ft.event.special[t] = { delegateType: e, bindType: e, handle: function (t) { let n; const i = this; const r = t.relatedTarget; const a = t.handleObj; return r && (r === i || ft.contains(i, r)) || (t.type = a.origType, n = a.handler.apply(this, arguments), t.type = e), n } } }), ft.fn.extend({ on: function (t, e, n, i) { return T(this, t, e, n, i) }, one: function (t, e, n, i) { return T(this, t, e, n, i, 1) }, off: function (t, e, n) { let i, r; if (t && t.preventDefault && t.handleObj) return i = t.handleObj, ft(t.delegateTarget).off(i.namespace ? i.origType + '.' + i.namespace : i.origType, i.selector, i.handler), this; if (typeof t === 'object') { for (r in t) this.off(r, e, t[r]); return this } return !1 !== e && typeof e !== 'function' || (n = e, e = void 0), !1 === n && (n = _), this.each(function () { ft.event.remove(this, t, n, e) }) } }); const Zt = /<script|<style|<link/i; var Kt = /checked\s*(?:[^=]|=\s*.checked.)/i; var Jt = /^true\/(.*)/; var Qt = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g; ft.extend({ htmlPrefilter: function (t) { return t.replace(/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi, '<$1></$2>') }, clone: function (t, e, n) { let i; let r; let a; let o; const s = t.cloneNode(!0); const l = ft.contains(t.ownerDocument, t); if (!(dt.noCloneChecked || t.nodeType !== 1 && t.nodeType !== 11 || ft.isXMLDoc(t))) for (o = y(s), a = y(t), i = 0, r = a.length; i < r; i++)A(a[i], o[i]); if (e) if (n) for (a = a || y(t), o = o || y(s), i = 0, r = a.length; i < r; i++)E(a[i], o[i]); else E(t, s); return o = y(s, 'script'), o.length > 0 && b(o, !l && y(t, 'script')), s }, cleanData: function (t) { for (var e, n, i, r = ft.event.special, a = 0; void 0 !== (n = t[a]); a++) if (Pt(n)) { if (e = n[kt.expando]) { if (e.events) for (i in e.events)r[i] ? ft.event.remove(n, i) : ft.removeEvent(n, i, e.handle); n[kt.expando] = void 0 }n[Dt.expando] && (n[Dt.expando] = void 0) } } }), ft.fn.extend({ detach: function (t) { return k(this, t, !0) }, remove: function (t) { return k(this, t) }, text: function (t) { return At(this, function (t) { return void 0 === t ? ft.text(this) : this.empty().each(function () { this.nodeType !== 1 && this.nodeType !== 11 && this.nodeType !== 9 || (this.textContent = t) }) }, null, t, arguments.length) }, append: function () { return P(this, arguments, function (t) { if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) { S(this, t).appendChild(t) } }) }, prepend: function () { return P(this, arguments, function (t) { if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) { const e = S(this, t); e.insertBefore(t, e.firstChild) } }) }, before: function () { return P(this, arguments, function (t) { this.parentNode && this.parentNode.insertBefore(t, this) }) }, after: function () { return P(this, arguments, function (t) { this.parentNode && this.parentNode.insertBefore(t, this.nextSibling) }) }, empty: function () { for (var t, e = 0; (t = this[e]) != null; e++)t.nodeType === 1 && (ft.cleanData(y(t, !1)), t.textContent = ''); return this }, clone: function (t, e) { return t = t != null && t, e = e == null ? t : e, this.map(function () { return ft.clone(this, t, e) }) }, html: function (t) { return At(this, function (t) { let e = this[0] || {}; let n = 0; const i = this.length; if (void 0 === t && e.nodeType === 1) return e.innerHTML; if (typeof t === 'string' && !Zt.test(t) && !Gt[(jt.exec(t) || ['', ''])[1].toLowerCase()]) { t = ft.htmlPrefilter(t); try { for (;n < i; n++)e = this[n] || {}, e.nodeType === 1 && (ft.cleanData(y(e, !1)), e.innerHTML = t); e = 0 } catch (t) {} }e && this.empty().append(t) }, null, t, arguments.length) }, replaceWith: function () { const t = []; return P(this, arguments, function (e) { const n = this.parentNode; ft.inArray(this, t) < 0 && (ft.cleanData(y(this)), n && n.replaceChild(e, this)) }, t) } }), ft.each({ appendTo: 'append', prependTo: 'prepend', insertBefore: 'before', insertAfter: 'after', replaceAll: 'replaceWith' }, function (t, e) { ft.fn[t] = function (t) { for (var n, i = [], r = ft(t), a = r.length - 1, o = 0; o <= a; o++)n = o === a ? this : this.clone(!0), ft(r[o])[e](n), ot.apply(i, n.get()); return this.pushStack(i) } }); var te = /^margin/; var ee = new RegExp('^(' + It + ')(?!px)[a-z%]+$', 'i'); var ne = function (e) { let n = e.ownerDocument.defaultView; return n && n.opener || (n = t), n.getComputedStyle(e) }; !(function () { function e () { if (s) { s.style.cssText = 'box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%', s.innerHTML = '', Wt.appendChild(o); const e = t.getComputedStyle(s); n = e.top !== '1%', a = e.marginLeft === '2px', i = e.width === '4px', s.style.marginRight = '50%', r = e.marginRight === '4px', Wt.removeChild(o), s = null } } let n; let i; let r; let a; var o = nt.createElement('div'); var s = nt.createElement('div'); s.style && (s.style.backgroundClip = 'content-box', s.cloneNode(!0).style.backgroundClip = '', dt.clearCloneStyle = s.style.backgroundClip === 'content-box', o.style.cssText = 'border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute', o.appendChild(s), ft.extend(dt, { pixelPosition: function () { return e(), n }, boxSizingReliable: function () { return e(), i }, pixelMarginRight: function () { return e(), r }, reliableMarginLeft: function () { return e(), a } })) }()); const ie = /^(none|table(?!-c[ea]).+)/; const re = /^--/; const ae = { position: 'absolute', visibility: 'hidden', display: 'block' }; const oe = { letterSpacing: '0', fontWeight: '400' }; var se = ['Webkit', 'Moz', 'ms']; var le = nt.createElement('div').style; ft.extend({ cssHooks: { opacity: { get: function (t, e) { if (e) { const n = D(t, 'opacity'); return n === '' ? '1' : n } } } }, cssNumber: { animationIterationCount: !0, columnCount: !0, fillOpacity: !0, flexGrow: !0, flexShrink: !0, fontWeight: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, widows: !0, zIndex: !0, zoom: !0 }, cssProps: { float: 'cssFloat' }, style: function (t, e, n, i) { if (t && t.nodeType !== 3 && t.nodeType !== 8 && t.style) { let r; let a; let o; const s = ft.camelCase(e); const l = re.test(e); const c = t.style; if (l || (e = I(s)), o = ft.cssHooks[e] || ft.cssHooks[s], void 0 === n) return o && 'get' in o && void 0 !== (r = o.get(t, !1, i)) ? r : c[e]; a = typeof n, a === 'string' && (r = Rt.exec(n)) && r[1] && (n = m(t, e, r), a = 'number'), n != null && n === n && (a === 'number' && (n += r && r[3] || (ft.cssNumber[s] ? '' : 'px')), dt.clearCloneStyle || n !== '' || e.indexOf('background') !== 0 || (c[e] = 'inherit'), o && 'set' in o && void 0 === (n = o.set(t, n, i)) || (l ? c.setProperty(e, n) : c[e] = n)) } }, css: function (t, e, n, i) { let r; let a; let o; const s = ft.camelCase(e); return re.test(e) || (e = I(s)), o = ft.cssHooks[e] || ft.cssHooks[s], o && 'get' in o && (r = o.get(t, !0, n)), void 0 === r && (r = D(t, e, i)), r === 'normal' && e in oe && (r = oe[e]), n === '' || n ? (a = parseFloat(r), !0 === n || isFinite(a) ? a || 0 : r) : r } }), ft.each(['height', 'width'], function (t, e) { ft.cssHooks[e] = { get: function (t, n, i) { if (n) return !ie.test(ft.css(t, 'display')) || t.getClientRects().length && t.getBoundingClientRect().width ? F(t, e, i) : Ut(t, ae, function () { return F(t, e, i) }) }, set: function (t, n, i) { let r; const a = i && ne(t); const o = i && N(t, e, i, ft.css(t, 'boxSizing', !1, a) === 'border-box', a); return o && (r = Rt.exec(n)) && (r[3] || 'px') !== 'px' && (t.style[e] = n, n = ft.css(t, e)), R(t, n, o) } } }), ft.cssHooks.marginLeft = O(dt.reliableMarginLeft, function (t, e) { if (e) return (parseFloat(D(t, 'marginLeft')) || t.getBoundingClientRect().left - Ut(t, { marginLeft: 0 }, function () { return t.getBoundingClientRect().left })) + 'px' }), ft.each({ margin: '', padding: '', border: 'Width' }, function (t, e) { ft.cssHooks[t + e] = { expand: function (n) { for (var i = 0, r = {}, a = typeof n === 'string' ? n.split(' ') : [n]; i < 4; i++)r[t + Nt[i] + e] = a[i] || a[i - 2] || a[0]; return r } }, te.test(t) || (ft.cssHooks[t + e].set = R) }), ft.fn.extend({ css: function (t, e) { return At(this, function (t, e, n) { let i; let r; const a = {}; let o = 0; if (Array.isArray(e)) { for (i = ne(t), r = e.length; o < r; o++)a[e[o]] = ft.css(t, e[o], !1, i); return a } return void 0 !== n ? ft.style(t, e, n) : ft.css(t, e) }, t, e, arguments.length > 1) } }), ft.Tween = U, U.prototype = { constructor: U, init: function (t, e, n, i, r, a) { this.elem = t, this.prop = n, this.easing = r || ft.easing._default, this.options = e, this.start = this.now = this.cur(), this.end = i, this.unit = a || (ft.cssNumber[n] ? '' : 'px') }, cur: function () { const t = U.propHooks[this.prop]; return t && t.get ? t.get(this) : U.propHooks._default.get(this) }, run: function (t) { let e; const n = U.propHooks[this.prop]; return this.options.duration ? this.pos = e = ft.easing[this.easing](t, this.options.duration * t, 0, 1, this.options.duration) : this.pos = e = t, this.now = (this.end - this.start) * e + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), n && n.set ? n.set(this) : U.propHooks._default.set(this), this } }, U.prototype.init.prototype = U.prototype, U.propHooks = { _default: { get: function (t) { let e; return t.elem.nodeType !== 1 || t.elem[t.prop] != null && t.elem.style[t.prop] == null ? t.elem[t.prop] : (e = ft.css(t.elem, t.prop, ''), e && e !== 'auto' ? e : 0) }, set: function (t) { ft.fx.step[t.prop] ? ft.fx.step[t.prop](t) : t.elem.nodeType !== 1 || t.elem.style[ft.cssProps[t.prop]] == null && !ft.cssHooks[t.prop] ? t.elem[t.prop] = t.now : ft.style(t.elem, t.prop, t.now + t.unit) } } }, U.propHooks.scrollTop = U.propHooks.scrollLeft = { set: function (t) { t.elem.nodeType && t.elem.parentNode && (t.elem[t.prop] = t.now) } }, ft.easing = { linear: function (t) { return t }, swing: function (t) { return 0.5 - Math.cos(t * Math.PI) / 2 }, _default: 'swing' }, ft.fx = U.prototype.init, ft.fx.step = {}; let ce; let ue; var he = /^(?:toggle|show|hide)$/; const pe = /queueHooks$/; ft.Animation = ft.extend(W, { tweeners: { '*': [function (t, e) { const n = this.createTween(t, e); return m(n.elem, t, Rt.exec(e), n), n }] }, tweener: function (t, e) { ft.isFunction(t) ? (e = t, t = ['*']) : t = t.match(Mt); for (var n, i = 0, r = t.length; i < r; i++)n = t[i], W.tweeners[n] = W.tweeners[n] || [], W.tweeners[n].unshift(e) }, prefilters: [G], prefilter: function (t, e) { e ? W.prefilters.unshift(t) : W.prefilters.push(t) } }), ft.speed = function (t, e, n) { const i = t && typeof t === 'object' ? ft.extend({}, t) : { complete: n || !n && e || ft.isFunction(t) && t, duration: t, easing: n && e || e && !ft.isFunction(e) && e }; return ft.fx.off ? i.duration = 0 : typeof i.duration !== 'number' && (i.duration in ft.fx.speeds ? i.duration = ft.fx.speeds[i.duration] : i.duration = ft.fx.speeds._default), i.queue != null && !0 !== i.queue || (i.queue = 'fx'), i.old = i.complete, i.complete = function () { ft.isFunction(i.old) && i.old.call(this), i.queue && ft.dequeue(this, i.queue) }, i }, ft.fn.extend({ fadeTo: function (t, e, n, i) { return this.filter(Ft).css('opacity', 0).show().end().animate({ opacity: e }, t, n, i) }, animate: function (t, e, n, i) { const r = ft.isEmptyObject(t); const a = ft.speed(e, n, i); const o = function () { const e = W(this, ft.extend({}, t), a); (r || kt.get(this, 'finish')) && e.stop(!0) }; return o.finish = o, r || !1 === a.queue ? this.each(o) : this.queue(a.queue, o) }, stop: function (t, e, n) { const i = function (t) { const e = t.stop; delete t.stop, e(n) }; return typeof t !== 'string' && (n = e, e = t, t = void 0), e && !1 !== t && this.queue(t || 'fx', []), this.each(function () { let e = !0; let r = t != null && t + 'queueHooks'; const a = ft.timers; const o = kt.get(this); if (r)o[r] && o[r].stop && i(o[r]); else for (r in o)o[r] && o[r].stop && pe.test(r) && i(o[r]); for (r = a.length; r--;)a[r].elem !== this || t != null && a[r].queue !== t || (a[r].anim.stop(n), e = !1, a.splice(r, 1)); !e && n || ft.dequeue(this, t) }) }, finish: function (t) { return !1 !== t && (t = t || 'fx'), this.each(function () { let e; const n = kt.get(this); const i = n[t + 'queue']; const r = n[t + 'queueHooks']; const a = ft.timers; const o = i ? i.length : 0; for (n.finish = !0, ft.queue(this, t, []), r && r.stop && r.stop.call(this, !0), e = a.length; e--;)a[e].elem === this && a[e].queue === t && (a[e].anim.stop(!0), a.splice(e, 1)); for (e = 0; e < o; e++)i[e] && i[e].finish && i[e].finish.call(this); delete n.finish }) } }), ft.each(['toggle', 'show', 'hide'], function (t, e) { const n = ft.fn[e]; ft.fn[e] = function (t, i, r) { return t == null || typeof t === 'boolean' ? n.apply(this, arguments) : this.animate(j(e, !0), t, i, r) } }), ft.each({ slideDown: j('show'), slideUp: j('hide'), slideToggle: j('toggle'), fadeIn: { opacity: 'show' }, fadeOut: { opacity: 'hide' }, fadeToggle: { opacity: 'toggle' } }, function (t, e) { ft.fn[t] = function (t, n, i) { return this.animate(e, t, n, i) } }), ft.timers = [], ft.fx.tick = function () { let t; let e = 0; const n = ft.timers; for (ce = ft.now(); e < n.length; e++)(t = n[e])() || n[e] !== t || n.splice(e--, 1); n.length || ft.fx.stop(), ce = void 0 }, ft.fx.timer = function (t) { ft.timers.push(t), ft.fx.start() }, ft.fx.interval = 13, ft.fx.start = function () { ue || (ue = !0, z()) }, ft.fx.stop = function () { ue = null }, ft.fx.speeds = { slow: 600, fast: 200, _default: 400 }, ft.fn.delay = function (e, n) { return e = ft.fx ? ft.fx.speeds[e] || e : e, n = n || 'fx', this.queue(n, function (n, i) { const r = t.setTimeout(n, e); i.stop = function () { t.clearTimeout(r) } }) }, (function () { let t = nt.createElement('input'); const e = nt.createElement('select'); const n = e.appendChild(nt.createElement('option')); t.type = 'checkbox', dt.checkOn = t.value !== '', dt.optSelected = n.selected, t = nt.createElement('input'), t.value = 't', t.type = 'radio', dt.radioValue = t.value === 't' }()); let de; const fe = ft.expr.attrHandle; ft.fn.extend({ attr: function (t, e) { return At(this, ft.attr, t, e, arguments.length > 1) }, removeAttr: function (t) { return this.each(function () { ft.removeAttr(this, t) }) } }), ft.extend({ attr: function (t, e, n) { let i; let r; const a = t.nodeType; if (a !== 3 && a !== 8 && a !== 2) return void 0 === t.getAttribute ? ft.prop(t, e, n) : (a === 1 && ft.isXMLDoc(t) || (r = ft.attrHooks[e.toLowerCase()] || (ft.expr.match.bool.test(e) ? de : void 0)), void 0 !== n ? n === null ? void ft.removeAttr(t, e) : r && 'set' in r && void 0 !== (i = r.set(t, n, e)) ? i : (t.setAttribute(e, n + ''), n) : r && 'get' in r && (i = r.get(t, e)) !== null ? i : (i = ft.find.attr(t, e), i == null ? void 0 : i)) }, attrHooks: { type: { set: function (t, e) { if (!dt.radioValue && e === 'radio' && r(t, 'input')) { const n = t.value; return t.setAttribute('type', e), n && (t.value = n), e } } } }, removeAttr: function (t, e) { let n; let i = 0; const r = e && e.match(Mt); if (r && t.nodeType === 1) for (;n = r[i++];)t.removeAttribute(n) } }), de = { set: function (t, e, n) { return !1 === e ? ft.removeAttr(t, n) : t.setAttribute(n, n), n } }, ft.each(ft.expr.match.bool.source.match(/\w+/g), function (t, e) { const n = fe[e] || ft.find.attr; fe[e] = function (t, e, i) { let r; let a; const o = e.toLowerCase(); return i || (a = fe[o], fe[o] = r, r = n(t, e, i) != null ? o : null, fe[o] = a), r } }); const me = /^(?:input|select|textarea|button)$/i; const ge = /^(?:a|area)$/i; ft.fn.extend({ prop: function (t, e) { return At(this, ft.prop, t, e, arguments.length > 1) }, removeProp: function (t) { return this.each(function () { delete this[ft.propFix[t] || t] }) } }), ft.extend({ prop: function (t, e, n) { let i; let r; const a = t.nodeType; if (a !== 3 && a !== 8 && a !== 2) return a === 1 && ft.isXMLDoc(t) || (e = ft.propFix[e] || e, r = ft.propHooks[e]), void 0 !== n ? r && 'set' in r && void 0 !== (i = r.set(t, n, e)) ? i : t[e] = n : r && 'get' in r && (i = r.get(t, e)) !== null ? i : t[e] }, propHooks: { tabIndex: { get: function (t) { const e = ft.find.attr(t, 'tabindex'); return e ? parseInt(e, 10) : me.test(t.nodeName) || ge.test(t.nodeName) && t.href ? 0 : -1 } } }, propFix: { for: 'htmlFor', class: 'className' } }), dt.optSelected || (ft.propHooks.selected = { get: function (t) { const e = t.parentNode; return e && e.parentNode && e.parentNode.selectedIndex, null }, set: function (t) { const e = t.parentNode; e && (e.selectedIndex, e.parentNode && e.parentNode.selectedIndex) } }), ft.each(['tabIndex', 'readOnly', 'maxLength', 'cellSpacing', 'cellPadding', 'rowSpan', 'colSpan', 'useMap', 'frameBorder', 'contentEditable'], function () { ft.propFix[this.toLowerCase()] = this }), ft.fn.extend({ addClass: function (t) { let e; let n; let i; let r; let a; let o; let s; let l = 0; if (ft.isFunction(t)) return this.each(function (e) { ft(this).addClass(t.call(this, e, X(this))) }); if (typeof t === 'string' && t) for (e = t.match(Mt) || []; n = this[l++];) if (r = X(n), i = n.nodeType === 1 && ' ' + q(r) + ' ') { for (o = 0; a = e[o++];)i.indexOf(' ' + a + ' ') < 0 && (i += a + ' '); s = q(i), r !== s && n.setAttribute('class', s) } return this }, removeClass: function (t) { let e; let n; let i; let r; let a; let o; let s; let l = 0; if (ft.isFunction(t)) return this.each(function (e) { ft(this).removeClass(t.call(this, e, X(this))) }); if (!arguments.length) return this.attr('class', ''); if (typeof t === 'string' && t) for (e = t.match(Mt) || []; n = this[l++];) if (r = X(n), i = n.nodeType === 1 && ' ' + q(r) + ' ') { for (o = 0; a = e[o++];) for (;i.indexOf(' ' + a + ' ') > -1;)i = i.replace(' ' + a + ' ', ' '); s = q(i), r !== s && n.setAttribute('class', s) } return this }, toggleClass: function (t, e) { const n = typeof t; return typeof e === 'boolean' && n === 'string' ? e ? this.addClass(t) : this.removeClass(t) : ft.isFunction(t) ? this.each(function (n) { ft(this).toggleClass(t.call(this, n, X(this), e), e) }) : this.each(function () { let e, i, r, a; if (n === 'string') for (i = 0, r = ft(this), a = t.match(Mt) || []; e = a[i++];)r.hasClass(e) ? r.removeClass(e) : r.addClass(e); else void 0 !== t && n !== 'boolean' || (e = X(this), e && kt.set(this, '__className__', e), this.setAttribute && this.setAttribute('class', e || !1 === t ? '' : kt.get(this, '__className__') || '')) }) }, hasClass: function (t) { let e; let n; let i = 0; for (e = ' ' + t + ' '; n = this[i++];) if (n.nodeType === 1 && (' ' + q(X(n)) + ' ').indexOf(e) > -1) return !0; return !1 } }); ft.fn.extend({ val: function (t) { let e; let n; let i; const r = this[0]; { if (arguments.length) return i = ft.isFunction(t), this.each(function (n) { let r; this.nodeType === 1 && (r = i ? t.call(this, n, ft(this).val()) : t, r == null ? r = '' : typeof r === 'number' ? r += '' : Array.isArray(r) && (r = ft.map(r, function (t) { return t == null ? '' : t + '' })), (e = ft.valHooks[this.type] || ft.valHooks[this.nodeName.toLowerCase()]) && 'set' in e && void 0 !== e.set(this, r, 'value') || (this.value = r)) }); if (r) return (e = ft.valHooks[r.type] || ft.valHooks[r.nodeName.toLowerCase()]) && 'get' in e && void 0 !== (n = e.get(r, 'value')) ? n : (n = r.value, typeof n === 'string' ? n.replace(/\r/g, '') : n == null ? '' : n) } } }), ft.extend({ valHooks: { option: { get: function (t) { const e = ft.find.attr(t, 'value'); return e != null ? e : q(ft.text(t)) } }, select: { get: function (t) { let e; let n; let i; const a = t.options; const o = t.selectedIndex; const s = t.type === 'select-one'; const l = s ? null : []; const c = s ? o + 1 : a.length; for (i = o < 0 ? c : s ? o : 0; i < c; i++) if (n = a[i], (n.selected || i === o) && !n.disabled && (!n.parentNode.disabled || !r(n.parentNode, 'optgroup'))) { if (e = ft(n).val(), s) return e; l.push(e) } return l }, set: function (t, e) { for (var n, i, r = t.options, a = ft.makeArray(e), o = r.length; o--;)i = r[o], (i.selected = ft.inArray(ft.valHooks.option.get(i), a) > -1) && (n = !0); return n || (t.selectedIndex = -1), a } } } }), ft.each(['radio', 'checkbox'], function () { ft.valHooks[this] = { set: function (t, e) { if (Array.isArray(e)) return t.checked = ft.inArray(ft(t).val(), e) > -1 } }, dt.checkOn || (ft.valHooks[this].get = function (t) { return t.getAttribute('value') === null ? 'on' : t.value }) }); const ve = /^(?:focusinfocus|focusoutblur)$/; ft.extend(ft.event, { trigger: function (e, n, i, r) { let a; let o; let s; let l; let c; let u; let h; const p = [i || nt]; let d = ut.call(e, 'type') ? e.type : e; let f = ut.call(e, 'namespace') ? e.namespace.split('.') : []; if (o = s = i = i || nt, i.nodeType !== 3 && i.nodeType !== 8 && !ve.test(d + ft.event.triggered) && (d.indexOf('.') > -1 && (f = d.split('.'), d = f.shift(), f.sort()), c = d.indexOf(':') < 0 && 'on' + d, e = e[ft.expando] ? e : new ft.Event(d, typeof e === 'object' && e), e.isTrigger = r ? 2 : 3, e.namespace = f.join('.'), e.rnamespace = e.namespace ? new RegExp('(^|\\.)' + f.join('\\.(?:.*\\.|)') + '(\\.|$)') : null, e.result = void 0, e.target || (e.target = i), n = n == null ? [e] : ft.makeArray(n, [e]), h = ft.event.special[d] || {}, r || !h.trigger || !1 !== h.trigger.apply(i, n))) { if (!r && !h.noBubble && !ft.isWindow(i)) { for (l = h.delegateType || d, ve.test(l + d) || (o = o.parentNode); o; o = o.parentNode)p.push(o), s = o; s === (i.ownerDocument || nt) && p.push(s.defaultView || s.parentWindow || t) } for (a = 0; (o = p[a++]) && !e.isPropagationStopped();)e.type = a > 1 ? l : h.bindType || d, u = (kt.get(o, 'events') || {})[e.type] && kt.get(o, 'handle'), u && u.apply(o, n), (u = c && o[c]) && u.apply && Pt(o) && (e.result = u.apply(o, n), !1 === e.result && e.preventDefault()); return e.type = d, r || e.isDefaultPrevented() || h._default && !1 !== h._default.apply(p.pop(), n) || !Pt(i) || c && ft.isFunction(i[d]) && !ft.isWindow(i) && (s = i[c], s && (i[c] = null), ft.event.triggered = d, i[d](), ft.event.triggered = void 0, s && (i[c] = s)), e.result } }, simulate: function (t, e, n) { const i = ft.extend(new ft.Event(), n, { type: t, isSimulated: !0 }); ft.event.trigger(i, null, e) } }), ft.fn.extend({ trigger: function (t, e) { return this.each(function () { ft.event.trigger(t, e, this) }) }, triggerHandler: function (t, e) { const n = this[0]; if (n) return ft.event.trigger(t, e, n, !0) } }), ft.each('blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu'.split(' '), function (t, e) { ft.fn[e] = function (t, n) { return arguments.length > 0 ? this.on(e, null, t, n) : this.trigger(e) } }), ft.fn.extend({ hover: function (t, e) { return this.mouseenter(t).mouseleave(e || t) } }), dt.focusin = 'onfocusin' in t, dt.focusin || ft.each({ focus: 'focusin', blur: 'focusout' }, function (t, e) { const n = function (t) { ft.event.simulate(e, t.target, ft.event.fix(t)) }; ft.event.special[e] = { setup: function () { const i = this.ownerDocument || this; const r = kt.access(i, e); r || i.addEventListener(t, n, !0), kt.access(i, e, (r || 0) + 1) }, teardown: function () { const i = this.ownerDocument || this; const r = kt.access(i, e) - 1; r ? kt.access(i, e, r) : (i.removeEventListener(t, n, !0), kt.remove(i, e)) } } }); const ye = t.location; let be = ft.now(); const xe = /\?/; ft.parseXML = function (e) { let n; if (!e || typeof e !== 'string') return null; try { n = (new t.DOMParser()).parseFromString(e, 'text/xml') } catch (t) { n = void 0 } return n && !n.getElementsByTagName('parsererror').length || ft.error('Invalid XML: ' + e), n }; var we = /\[\]$/; const _e = /^(?:submit|button|image|reset|file)$/i; const $e = /^(?:input|select|textarea|keygen)/i; ft.param = function (t, e) { let n; const i = []; const r = function (t, e) { const n = ft.isFunction(e) ? e() : e; i[i.length] = encodeURIComponent(t) + '=' + encodeURIComponent(n == null ? '' : n) }; if (Array.isArray(t) || t.jquery && !ft.isPlainObject(t))ft.each(t, function () { r(this.name, this.value) }); else for (n in t)Y(n, t[n], e, r); return i.join('&') }, ft.fn.extend({ serialize: function () { return ft.param(this.serializeArray()) }, serializeArray: function () { return this.map(function () { const t = ft.prop(this, 'elements'); return t ? ft.makeArray(t) : this }).filter(function () { const t = this.type; return this.name && !ft(this).is(':disabled') && $e.test(this.nodeName) && !_e.test(t) && (this.checked || !Bt.test(t)) }).map(function (t, e) { const n = ft(this).val(); return n == null ? null : Array.isArray(n) ? ft.map(n, function (t) { return { name: e.name, value: t.replace(/\r?\n/g, '\r\n') } }) : { name: e.name, value: n.replace(/\r?\n/g, '\r\n') } }).get() } }); const Te = /^(.*?):[ \t]*([^\r\n]*)$/gm; const Se = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/; const Me = /^(?:GET|HEAD)$/; const Ce = {}; var Ee = {}; const Ae = '*/'.concat('*'); const Pe = nt.createElement('a'); Pe.href = ye.href, ft.extend({ active: 0, lastModified: {}, etag: {}, ajaxSettings: { url: ye.href, type: 'GET', isLocal: Se.test(ye.protocol), global: !0, processData: !0, async: !0, contentType: 'application/x-www-form-urlencoded; charset=UTF-8', accepts: { '*': Ae, text: 'text/plain', html: 'text/html', xml: 'application/xml, text/xml', json: 'application/json, text/javascript' }, contents: { xml: /\bxml\b/, html: /\bhtml/, json: /\bjson\b/ }, responseFields: { xml: 'responseXML', text: 'responseText', json: 'responseJSON' }, converters: { '* text': String, 'text html': !0, 'text json': JSON.parse, 'text xml': ft.parseXML }, flatOptions: { url: !0, context: !0 } }, ajaxSetup: function (t, e) { return e ? J(J(t, ft.ajaxSettings), e) : J(ft.ajaxSettings, t) }, ajaxPrefilter: Z(Ce), ajaxTransport: Z(Ee), ajax: function (e, n) { function i (e, n, i, s) { let c; let p; let d; let x; let w; let _ = n; u || (u = !0, l && t.clearTimeout(l), r = void 0, o = s || '', $.readyState = e > 0 ? 4 : 0, c = e >= 200 && e < 300 || e === 304, i && (x = Q(f, $, i)), x = tt(f, x, $, c), c ? (f.ifModified && (w = $.getResponseHeader('Last-Modified'), w && (ft.lastModified[a] = w), (w = $.getResponseHeader('etag')) && (ft.etag[a] = w)), e === 204 || f.type === 'HEAD' ? _ = 'nocontent' : e === 304 ? _ = 'notmodified' : (_ = x.state, p = x.data, d = x.error, c = !d)) : (d = _, !e && _ || (_ = 'error', e < 0 && (e = 0))), $.status = e, $.statusText = (n || _) + '', c ? v.resolveWith(m, [p, _, $]) : v.rejectWith(m, [$, _, d]), $.statusCode(b), b = void 0, h && g.trigger(c ? 'ajaxSuccess' : 'ajaxError', [$, f, c ? p : d]), y.fireWith(m, [$, _]), h && (g.trigger('ajaxComplete', [$, f]), --ft.active || ft.event.trigger('ajaxStop'))) } typeof e === 'object' && (n = e, e = void 0), n = n || {}; let r; let a; let o; let s; let l; let c; let u; let h; let p; let d; var f = ft.ajaxSetup({}, n); var m = f.context || f; var g = f.context && (m.nodeType || m.jquery) ? ft(m) : ft.event; var v = ft.Deferred(); var y = ft.Callbacks('once memory'); var b = f.statusCode || {}; const x = {}; const w = {}; let _ = 'canceled'; var $ = { readyState: 0, getResponseHeader: function (t) { let e; if (u) { if (!s) for (s = {}; e = Te.exec(o);)s[e[1].toLowerCase()] = e[2]; e = s[t.toLowerCase()] } return e == null ? null : e }, getAllResponseHeaders: function () { return u ? o : null }, setRequestHeader: function (t, e) { return u == null && (t = w[t.toLowerCase()] = w[t.toLowerCase()] || t, x[t] = e), this }, overrideMimeType: function (t) { return u == null && (f.mimeType = t), this }, statusCode: function (t) { let e; if (t) if (u)$.always(t[$.status]); else for (e in t)b[e] = [b[e], t[e]]; return this }, abort: function (t) { const e = t || _; return r && r.abort(e), i(0, e), this } }; if (v.promise($), f.url = ((e || f.url || ye.href) + '').replace(/^\/\//, ye.protocol + '//'), f.type = n.method || n.type || f.method || f.type, f.dataTypes = (f.dataType || '*').toLowerCase().match(Mt) || [''], f.crossDomain == null) { c = nt.createElement('a'); try { c.href = f.url, c.href = c.href, f.crossDomain = Pe.protocol + '//' + Pe.host != c.protocol + '//' + c.host } catch (t) { f.crossDomain = !0 } } if (f.data && f.processData && typeof f.data !== 'string' && (f.data = ft.param(f.data, f.traditional)), K(Ce, f, n, $), u) return $; h = ft.event && f.global, h && ft.active++ == 0 && ft.event.trigger('ajaxStart'), f.type = f.type.toUpperCase(), f.hasContent = !Me.test(f.type), a = f.url.replace(/#.*$/, ''), f.hasContent ? f.data && f.processData && (f.contentType || '').indexOf('application/x-www-form-urlencoded') === 0 && (f.data = f.data.replace(/%20/g, '+')) : (d = f.url.slice(a.length), f.data && (a += (xe.test(a) ? '&' : '?') + f.data, delete f.data), !1 === f.cache && (a = a.replace(/([?&])_=[^&]*/, '$1'), d = (xe.test(a) ? '&' : '?') + '_=' + be++ + d), f.url = a + d), f.ifModified && (ft.lastModified[a] && $.setRequestHeader('If-Modified-Since', ft.lastModified[a]), ft.etag[a] && $.setRequestHeader('If-None-Match', ft.etag[a])), (f.data && f.hasContent && !1 !== f.contentType || n.contentType) && $.setRequestHeader('Content-Type', f.contentType), $.setRequestHeader('Accept', f.dataTypes[0] && f.accepts[f.dataTypes[0]] ? f.accepts[f.dataTypes[0]] + (f.dataTypes[0] !== '*' ? ', ' + Ae + '; q=0.01' : '') : f.accepts['*']); for (p in f.headers)$.setRequestHeader(p, f.headers[p]); if (f.beforeSend && (!1 === f.beforeSend.call(m, $, f) || u)) return $.abort(); if (_ = 'abort', y.add(f.complete), $.done(f.success), $.fail(f.error), r = K(Ee, f, n, $)) { if ($.readyState = 1, h && g.trigger('ajaxSend', [$, f]), u) return $; f.async && f.timeout > 0 && (l = t.setTimeout(function () { $.abort('timeout') }, f.timeout)); try { u = !1, r.send(x, i) } catch (t) { if (u) throw t; i(-1, t) } } else i(-1, 'No Transport'); return $ }, getJSON: function (t, e, n) { return ft.get(t, e, n, 'json') }, getScript: function (t, e) { return ft.get(t, void 0, e, 'script') } }), ft.each(['get', 'post'], function (t, e) { ft[e] = function (t, n, i, r) { return ft.isFunction(n) && (r = r || i, i = n, n = void 0), ft.ajax(ft.extend({ url: t, type: e, dataType: r, data: n, success: i }, ft.isPlainObject(t) && t)) } }), ft._evalUrl = function (t) { return ft.ajax({ url: t, type: 'GET', dataType: 'script', cache: !0, async: !1, global: !1, throws: !0 }) }, ft.fn.extend({ wrapAll: function (t) { let e; return this[0] && (ft.isFunction(t) && (t = t.call(this[0])), e = ft(t, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && e.insertBefore(this[0]), e.map(function () { for (var t = this; t.firstElementChild;)t = t.firstElementChild; return t }).append(this)), this }, wrapInner: function (t) { return ft.isFunction(t) ? this.each(function (e) { ft(this).wrapInner(t.call(this, e)) }) : this.each(function () { const e = ft(this); const n = e.contents(); n.length ? n.wrapAll(t) : e.append(t) }) }, wrap: function (t) { const e = ft.isFunction(t); return this.each(function (n) { ft(this).wrapAll(e ? t.call(this, n) : t) }) }, unwrap: function (t) { return this.parent(t).not('body').each(function () { ft(this).replaceWith(this.childNodes) }), this } }), ft.expr.pseudos.hidden = function (t) { return !ft.expr.pseudos.visible(t) }, ft.expr.pseudos.visible = function (t) { return !!(t.offsetWidth || t.offsetHeight || t.getClientRects().length) }, ft.ajaxSettings.xhr = function () { try { return new t.XMLHttpRequest() } catch (t) {} }; const ke = { 0: 200, 1223: 204 }; let De = ft.ajaxSettings.xhr(); dt.cors = !!De && 'withCredentials' in De, dt.ajax = De = !!De, ft.ajaxTransport(function (e) { let n, i; if (dt.cors || De && !e.crossDomain) return { send: function (r, a) { let o; const s = e.xhr(); if (s.open(e.type, e.url, e.async, e.username, e.password), e.xhrFields) for (o in e.xhrFields)s[o] = e.xhrFields[o]; e.mimeType && s.overrideMimeType && s.overrideMimeType(e.mimeType), e.crossDomain || r['X-Requested-With'] || (r['X-Requested-With'] = 'XMLHttpRequest'); for (o in r)s.setRequestHeader(o, r[o]); n = function (t) { return function () { n && (n = i = s.onload = s.onerror = s.onabort = s.onreadystatechange = null, t === 'abort' ? s.abort() : t === 'error' ? typeof s.status !== 'number' ? a(0, 'error') : a(s.status, s.statusText) : a(ke[s.status] || s.status, s.statusText, (s.responseType || 'text') !== 'text' || typeof s.responseText !== 'string' ? { binary: s.response } : { text: s.responseText }, s.getAllResponseHeaders())) } }, s.onload = n(), i = s.onerror = n('error'), void 0 !== s.onabort ? s.onabort = i : s.onreadystatechange = function () { s.readyState === 4 && t.setTimeout(function () { n && i() }) }, n = n('abort'); try { s.send(e.hasContent && e.data || null) } catch (t) { if (n) throw t } }, abort: function () { n && n() } } }), ft.ajaxPrefilter(function (t) { t.crossDomain && (t.contents.script = !1) }), ft.ajaxSetup({ accepts: { script: 'text/javascript, application/javascript, application/ecmascript, application/x-ecmascript' }, contents: { script: /\b(?:java|ecma)script\b/ }, converters: { 'text script': function (t) { return ft.globalEval(t), t } } }), ft.ajaxPrefilter('script', function (t) { void 0 === t.cache && (t.cache = !1), t.crossDomain && (t.type = 'GET') }), ft.ajaxTransport('script', function (t) { if (t.crossDomain) { let e, n; return { send: function (i, r) { e = ft('<script>').prop({ charset: t.scriptCharset, src: t.url }).on('load error', n = function (t) { e.remove(), n = null, t && r(t.type === 'error' ? 404 : 200, t.type) }), nt.head.appendChild(e[0]) }, abort: function () { n && n() } } } }); const Oe = []; const Le = /(=)\?(?=&|$)|\?\?/; ft.ajaxSetup({ jsonp: 'callback', jsonpCallback: function () { const t = Oe.pop() || ft.expando + '_' + be++; return this[t] = !0, t } }), ft.ajaxPrefilter('json jsonp', function (e, n, i) { let r; let a; let o; const s = !1 !== e.jsonp && (Le.test(e.url) ? 'url' : typeof e.data === 'string' && (e.contentType || '').indexOf('application/x-www-form-urlencoded') === 0 && Le.test(e.data) && 'data'); if (s || e.dataTypes[0] === 'jsonp') return r = e.jsonpCallback = ft.isFunction(e.jsonpCallback) ? e.jsonpCallback() : e.jsonpCallback, s ? e[s] = e[s].replace(Le, '$1' + r) : !1 !== e.jsonp && (e.url += (xe.test(e.url) ? '&' : '?') + e.jsonp + '=' + r), e.converters['script json'] = function () { return o || ft.error(r + ' was not called'), o[0] }, e.dataTypes[0] = 'json', a = t[r], t[r] = function () { o = arguments }, i.always(function () { void 0 === a ? ft(t).removeProp(r) : t[r] = a, e[r] && (e.jsonpCallback = n.jsonpCallback, Oe.push(r)), o && ft.isFunction(a) && a(o[0]), o = a = void 0 }), 'script' }), dt.createHTMLDocument = (function () { const t = nt.implementation.createHTMLDocument('').body; return t.innerHTML = '<form></form><form></form>', t.childNodes.length === 2 }()), ft.parseHTML = function (t, e, n) { if (typeof t !== 'string') return []; typeof e === 'boolean' && (n = e, e = !1); let i, r, a; return e || (dt.createHTMLDocument ? (e = nt.implementation.createHTMLDocument(''), i = e.createElement('base'), i.href = nt.location.href, e.head.appendChild(i)) : e = nt), r = xt.exec(t), a = !n && [], r ? [e.createElement(r[1])] : (r = x([t], e, a), a && a.length && ft(a).remove(), ft.merge([], r.childNodes)) }, ft.fn.load = function (t, e, n) { let i; let r; let a; const o = this; const s = t.indexOf(' '); return s > -1 && (i = q(t.slice(s)), t = t.slice(0, s)), ft.isFunction(e) ? (n = e, e = void 0) : e && typeof e === 'object' && (r = 'POST'), o.length > 0 && ft.ajax({ url: t, type: r || 'GET', dataType: 'html', data: e }).done(function (t) { a = arguments, o.html(i ? ft('<div>').append(ft.parseHTML(t)).find(i) : t) }).always(n && function (t, e) { o.each(function () { n.apply(this, a || [t.responseText, e, t]) }) }), this }, ft.each(['ajaxStart', 'ajaxStop', 'ajaxComplete', 'ajaxError', 'ajaxSuccess', 'ajaxSend'], function (t, e) { ft.fn[e] = function (t) { return this.on(e, t) } }), ft.expr.pseudos.animated = function (t) { return ft.grep(ft.timers, function (e) { return t === e.elem }).length }, ft.offset = { setOffset: function (t, e, n) { let i; let r; let a; let o; let s; let l; let c; const u = ft.css(t, 'position'); const h = ft(t); const p = {}; u === 'static' && (t.style.position = 'relative'), s = h.offset(), a = ft.css(t, 'top'), l = ft.css(t, 'left'), c = (u === 'absolute' || u === 'fixed') && (a + l).indexOf('auto') > -1, c ? (i = h.position(), o = i.top, r = i.left) : (o = parseFloat(a) || 0, r = parseFloat(l) || 0), ft.isFunction(e) && (e = e.call(t, n, ft.extend({}, s))), e.top != null && (p.top = e.top - s.top + o), e.left != null && (p.left = e.left - s.left + r), 'using' in e ? e.using.call(t, p) : h.css(p) } }, ft.fn.extend({ offset: function (t) { if (arguments.length) return void 0 === t ? this : this.each(function (e) { ft.offset.setOffset(this, t, e) }); let e; let n; let i; let r; const a = this[0]; if (a) return a.getClientRects().length ? (i = a.getBoundingClientRect(), e = a.ownerDocument, n = e.documentElement, r = e.defaultView, { top: i.top + r.pageYOffset - n.clientTop, left: i.left + r.pageXOffset - n.clientLeft }) : { top: 0, left: 0 } }, position: function () { if (this[0]) { let t; let e; const n = this[0]; let i = { top: 0, left: 0 }; return ft.css(n, 'position') === 'fixed' ? e = n.getBoundingClientRect() : (t = this.offsetParent(), e = this.offset(), r(t[0], 'html') || (i = t.offset()), i = { top: i.top + ft.css(t[0], 'borderTopWidth', !0), left: i.left + ft.css(t[0], 'borderLeftWidth', !0) }), { top: e.top - i.top - ft.css(n, 'marginTop', !0), left: e.left - i.left - ft.css(n, 'marginLeft', !0) } } }, offsetParent: function () { return this.map(function () { for (var t = this.offsetParent; t && ft.css(t, 'position') === 'static';)t = t.offsetParent; return t || Wt }) } }), ft.each({ scrollLeft: 'pageXOffset', scrollTop: 'pageYOffset' }, function (t, e) { const n = e === 'pageYOffset'; ft.fn[t] = function (i) { return At(this, function (t, i, r) { let a; if (ft.isWindow(t) ? a = t : t.nodeType === 9 && (a = t.defaultView), void 0 === r) return a ? a[e] : t[i]; a ? a.scrollTo(n ? a.pageXOffset : r, n ? r : a.pageYOffset) : t[i] = r }, t, i, arguments.length) } }), ft.each(['top', 'left'], function (t, e) { ft.cssHooks[e] = O(dt.pixelPosition, function (t, n) { if (n) return n = D(t, e), ee.test(n) ? ft(t).position()[e] + 'px' : n }) }), ft.each({ Height: 'height', Width: 'width' }, function (t, e) { ft.each({ padding: 'inner' + t, content: e, '': 'outer' + t }, function (n, i) { ft.fn[i] = function (r, a) { const o = arguments.length && (n || typeof r !== 'boolean'); const s = n || (!0 === r || !0 === a ? 'margin' : 'border'); return At(this, function (e, n, r) { let a; return ft.isWindow(e) ? i.indexOf('outer') === 0 ? e['inner' + t] : e.document.documentElement['client' + t] : e.nodeType === 9 ? (a = e.documentElement, Math.max(e.body['scroll' + t], a['scroll' + t], e.body['offset' + t], a['offset' + t], a['client' + t])) : void 0 === r ? ft.css(e, n, s) : ft.style(e, n, r, s) }, e, o ? r : void 0, o) } }) }), ft.fn.extend({ bind: function (t, e, n) { return this.on(t, null, e, n) }, unbind: function (t, e) { return this.off(t, null, e) }, delegate: function (t, e, n, i) { return this.on(e, t, n, i) }, undelegate: function (t, e, n) { return arguments.length === 1 ? this.off(t, '**') : this.off(e, t || '**', n) } }), ft.holdReady = function (t) { t ? ft.readyWait++ : ft.ready(!0) }, ft.isArray = Array.isArray, ft.parseJSON = JSON.parse, ft.nodeName = r, typeof define === 'function' && define.amd && define('jquery', [], function () { return ft }); const Ie = t.jQuery; const Re = t.$; return ft.noConflict = function (e) { return t.$ === ft && (t.$ = Re), e && t.jQuery === ft && (t.jQuery = Ie), ft }, e || (t.jQuery = t.$ = ft), ft
})), typeof jQuery === 'undefined') throw new Error("Bootstrap's JavaScript requires jQuery"); +(function (t) { 'use strict'; const e = t.fn.jquery.split(' ')[0].split('.'); if (e[0] < 2 && e[1] < 9 || e[0] == 1 && e[1] == 9 && e[2] < 1 || e[0] > 3) throw new Error("Bootstrap's JavaScript requires jQuery version 1.9.1 or higher, but lower than version 4") }(jQuery)), (function (t) { 'use strict'; function e () { const t = document.createElement('bootstrap'); const e = { WebkitTransition: 'webkitTransitionEnd', MozTransition: 'transitionend', OTransition: 'oTransitionEnd otransitionend', transition: 'transitionend' }; for (const n in e) if (void 0 !== t.style[n]) return { end: e[n] }; return !1 }t.fn.emulateTransitionEnd = function (e) { let n = !1; const i = this; t(this).one('bsTransitionEnd', function () { n = !0 }); const r = function () { n || t(i).trigger(t.support.transition.end) }; return setTimeout(r, e), this }, t(function () { t.support.transition = e(), t.support.transition && (t.event.special.bsTransitionEnd = { bindType: t.support.transition.end, delegateType: t.support.transition.end, handle: function (e) { if (t(e.target).is(this)) return e.handleObj.handler.apply(this, arguments) } }) }) }(jQuery)), (function (t) { 'use strict'; function e (e) { return this.each(function () { const n = t(this); let r = n.data('bs.alert'); r || n.data('bs.alert', r = new i(this)), typeof e === 'string' && r[e].call(n) }) } const n = '[data-dismiss="alert"]'; var i = function (e) { t(e).on('click', n, this.close) }; i.VERSION = '3.3.7', i.TRANSITION_DURATION = 150, i.prototype.close = function (e) { function n () { o.detach().trigger('closed.bs.alert').remove() } const r = t(this); let a = r.attr('data-target'); a || (a = r.attr('href'), a = a && a.replace(/.*(?=#[^\s]*$)/, '')); var o = t(a === '#' ? [] : a); e && e.preventDefault(), o.length || (o = r.closest('.alert')), o.trigger(e = t.Event('close.bs.alert')), e.isDefaultPrevented() || (o.removeClass('in'), t.support.transition && o.hasClass('fade') ? o.one('bsTransitionEnd', n).emulateTransitionEnd(i.TRANSITION_DURATION) : n()) }; const r = t.fn.alert; t.fn.alert = e, t.fn.alert.Constructor = i, t.fn.alert.noConflict = function () { return t.fn.alert = r, this }, t(document).on('click.bs.alert.data-api', n, i.prototype.close) }(jQuery)), (function (t) { 'use strict'; function e (e) { return this.each(function () { const i = t(this); let r = i.data('bs.button'); const a = typeof e === 'object' && e; r || i.data('bs.button', r = new n(this, a)), e == 'toggle' ? r.toggle() : e && r.setState(e) }) } var n = function (e, i) { this.$element = t(e), this.options = t.extend({}, n.DEFAULTS, i), this.isLoading = !1 }; n.VERSION = '3.3.7', n.DEFAULTS = { loadingText: 'loading...' }, n.prototype.setState = function (e) { const n = 'disabled'; const i = this.$element; const r = i.is('input') ? 'val' : 'html'; const a = i.data(); e += 'Text', a.resetText == null && i.data('resetText', i[r]()), setTimeout(t.proxy(function () { i[r](a[e] == null ? this.options[e] : a[e]), e == 'loadingText' ? (this.isLoading = !0, i.addClass(n).attr(n, n).prop(n, !0)) : this.isLoading && (this.isLoading = !1, i.removeClass(n).removeAttr(n).prop(n, !1)) }, this), 0) }, n.prototype.toggle = function () { let t = !0; const e = this.$element.closest('[data-toggle="buttons"]'); if (e.length) { const n = this.$element.find('input'); n.prop('type') == 'radio' ? (n.prop('checked') && (t = !1), e.find('.active').removeClass('active'), this.$element.addClass('active')) : n.prop('type') == 'checkbox' && (n.prop('checked') !== this.$element.hasClass('active') && (t = !1), this.$element.toggleClass('active')), n.prop('checked', this.$element.hasClass('active')), t && n.trigger('change') } else this.$element.attr('aria-pressed', !this.$element.hasClass('active')), this.$element.toggleClass('active') }; const i = t.fn.button; t.fn.button = e, t.fn.button.Constructor = n, t.fn.button.noConflict = function () { return t.fn.button = i, this }, t(document).on('click.bs.button.data-api', '[data-toggle^="button"]', function (n) { const i = t(n.target).closest('.btn'); e.call(i, 'toggle'), t(n.target).is('input[type="radio"], input[type="checkbox"]') || (n.preventDefault(), i.is('input,button') ? i.trigger('focus') : i.find('input:visible,button:visible').first().trigger('focus')) }).on('focus.bs.button.data-api blur.bs.button.data-api', '[data-toggle^="button"]', function (e) { t(e.target).closest('.btn').toggleClass('focus', /^focus(in)?$/.test(e.type)) }) }(jQuery)), (function (t) {
  'use strict'; function e (e) { return this.each(function () { const i = t(this); let r = i.data('bs.carousel'); const a = t.extend({}, n.DEFAULTS, i.data(), typeof e === 'object' && e); const o = typeof e === 'string' ? e : a.slide; r || i.data('bs.carousel', r = new n(this, a)), typeof e === 'number' ? r.to(e) : o ? r[o]() : a.interval && r.pause().cycle() }) } var n = function (e, n) { this.$element = t(e), this.$indicators = this.$element.find('.carousel-indicators'), this.options = n, this.paused = null, this.sliding = null, this.interval = null, this.$active = null, this.$items = null, this.options.keyboard && this.$element.on('keydown.bs.carousel', t.proxy(this.keydown, this)), this.options.pause == 'hover' && !('ontouchstart' in document.documentElement) && this.$element.on('mouseenter.bs.carousel', t.proxy(this.pause, this)).on('mouseleave.bs.carousel', t.proxy(this.cycle, this)) }; n.VERSION = '3.3.7', n.TRANSITION_DURATION = 600, n.DEFAULTS = { interval: 5e3, pause: 'hover', wrap: !0, keyboard: !0 }, n.prototype.keydown = function (t) { if (!/input|textarea/i.test(t.target.tagName)) { switch (t.which) { case 37:this.prev(); break; case 39:this.next(); break; default:return }t.preventDefault() } }, n.prototype.cycle = function (e) { return e || (this.paused = !1), this.interval && clearInterval(this.interval), this.options.interval && !this.paused && (this.interval = setInterval(t.proxy(this.next, this), this.options.interval)), this }, n.prototype.getItemIndex = function (t) { return this.$items = t.parent().children('.item'), this.$items.index(t || this.$active) }, n.prototype.getItemForDirection = function (t, e) {
    const n = this.getItemIndex(e); if ((t == 'prev' && n === 0 || t == 'next' && n == this.$items.length - 1) && !this.options.wrap) return e
    const i = t == 'prev' ? -1 : 1; const r = (n + i) % this.$items.length; return this.$items.eq(r)
  }, n.prototype.to = function (t) { const e = this; const n = this.getItemIndex(this.$active = this.$element.find('.item.active')); if (!(t > this.$items.length - 1 || t < 0)) return this.sliding ? this.$element.one('slid.bs.carousel', function () { e.to(t) }) : n == t ? this.pause().cycle() : this.slide(t > n ? 'next' : 'prev', this.$items.eq(t)) }, n.prototype.pause = function (e) { return e || (this.paused = !0), this.$element.find('.next, .prev').length && t.support.transition && (this.$element.trigger(t.support.transition.end), this.cycle(!0)), this.interval = clearInterval(this.interval), this }, n.prototype.next = function () { if (!this.sliding) return this.slide('next') }, n.prototype.prev = function () { if (!this.sliding) return this.slide('prev') }, n.prototype.slide = function (e, i) { const r = this.$element.find('.item.active'); const a = i || this.getItemForDirection(e, r); const o = this.interval; const s = e == 'next' ? 'left' : 'right'; const l = this; if (a.hasClass('active')) return this.sliding = !1; const c = a[0]; const u = t.Event('slide.bs.carousel', { relatedTarget: c, direction: s }); if (this.$element.trigger(u), !u.isDefaultPrevented()) { if (this.sliding = !0, o && this.pause(), this.$indicators.length) { this.$indicators.find('.active').removeClass('active'); const h = t(this.$indicators.children()[this.getItemIndex(a)]); h && h.addClass('active') } const p = t.Event('slid.bs.carousel', { relatedTarget: c, direction: s }); return t.support.transition && this.$element.hasClass('slide') ? (a.addClass(e), a[0].offsetWidth, r.addClass(s), a.addClass(s), r.one('bsTransitionEnd', function () { a.removeClass([e, s].join(' ')).addClass('active'), r.removeClass(['active', s].join(' ')), l.sliding = !1, setTimeout(function () { l.$element.trigger(p) }, 0) }).emulateTransitionEnd(n.TRANSITION_DURATION)) : (r.removeClass('active'), a.addClass('active'), this.sliding = !1, this.$element.trigger(p)), o && this.cycle(), this } }; const i = t.fn.carousel; t.fn.carousel = e, t.fn.carousel.Constructor = n, t.fn.carousel.noConflict = function () { return t.fn.carousel = i, this }; const r = function (n) { let i; const r = t(this); const a = t(r.attr('data-target') || (i = r.attr('href')) && i.replace(/.*(?=#[^\s]+$)/, '')); if (a.hasClass('carousel')) { const o = t.extend({}, a.data(), r.data()); const s = r.attr('data-slide-to'); s && (o.interval = !1), e.call(a, o), s && a.data('bs.carousel').to(s), n.preventDefault() } }; t(document).on('click.bs.carousel.data-api', '[data-slide]', r).on('click.bs.carousel.data-api', '[data-slide-to]', r), t(window).on('load', function () { t('[data-ride="carousel"]').each(function () { const n = t(this); e.call(n, n.data()) }) })
}(jQuery)), (function (t) { 'use strict'; function e (e) { let n; const i = e.attr('data-target') || (n = e.attr('href')) && n.replace(/.*(?=#[^\s]+$)/, ''); return t(i) } function n (e) { return this.each(function () { const n = t(this); let r = n.data('bs.collapse'); const a = t.extend({}, i.DEFAULTS, n.data(), typeof e === 'object' && e); !r && a.toggle && /show|hide/.test(e) && (a.toggle = !1), r || n.data('bs.collapse', r = new i(this, a)), typeof e === 'string' && r[e]() }) } var i = function (e, n) { this.$element = t(e), this.options = t.extend({}, i.DEFAULTS, n), this.$trigger = t('[data-toggle="collapse"][href="#' + e.id + '"],[data-toggle="collapse"][data-target="#' + e.id + '"]'), this.transitioning = null, this.options.parent ? this.$parent = this.getParent() : this.addAriaAndCollapsedClass(this.$element, this.$trigger), this.options.toggle && this.toggle() }; i.VERSION = '3.3.7', i.TRANSITION_DURATION = 350, i.DEFAULTS = { toggle: !0 }, i.prototype.dimension = function () { return this.$element.hasClass('width') ? 'width' : 'height' }, i.prototype.show = function () { if (!this.transitioning && !this.$element.hasClass('in')) { let e; const r = this.$parent && this.$parent.children('.panel').children('.in, .collapsing'); if (!(r && r.length && (e = r.data('bs.collapse')) && e.transitioning)) { const a = t.Event('show.bs.collapse'); if (this.$element.trigger(a), !a.isDefaultPrevented()) { r && r.length && (n.call(r, 'hide'), e || r.data('bs.collapse', null)); const o = this.dimension(); this.$element.removeClass('collapse').addClass('collapsing')[o](0).attr('aria-expanded', !0), this.$trigger.removeClass('collapsed').attr('aria-expanded', !0), this.transitioning = 1; const s = function () { this.$element.removeClass('collapsing').addClass('collapse in')[o](''), this.transitioning = 0, this.$element.trigger('shown.bs.collapse') }; if (!t.support.transition) return s.call(this); const l = t.camelCase(['scroll', o].join('-')); this.$element.one('bsTransitionEnd', t.proxy(s, this)).emulateTransitionEnd(i.TRANSITION_DURATION)[o](this.$element[0][l]) } } } }, i.prototype.hide = function () { if (!this.transitioning && this.$element.hasClass('in')) { const e = t.Event('hide.bs.collapse'); if (this.$element.trigger(e), !e.isDefaultPrevented()) { const n = this.dimension(); this.$element[n](this.$element[n]())[0].offsetHeight, this.$element.addClass('collapsing').removeClass('collapse in').attr('aria-expanded', !1), this.$trigger.addClass('collapsed').attr('aria-expanded', !1), this.transitioning = 1; const r = function () { this.transitioning = 0, this.$element.removeClass('collapsing').addClass('collapse').trigger('hidden.bs.collapse') }; if (!t.support.transition) return r.call(this); this.$element[n](0).one('bsTransitionEnd', t.proxy(r, this)).emulateTransitionEnd(i.TRANSITION_DURATION) } } }, i.prototype.toggle = function () { this[this.$element.hasClass('in') ? 'hide' : 'show']() }, i.prototype.getParent = function () { return t(this.options.parent).find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]').each(t.proxy(function (n, i) { const r = t(i); this.addAriaAndCollapsedClass(e(r), r) }, this)).end() }, i.prototype.addAriaAndCollapsedClass = function (t, e) { const n = t.hasClass('in'); t.attr('aria-expanded', n), e.toggleClass('collapsed', !n).attr('aria-expanded', n) }; const r = t.fn.collapse; t.fn.collapse = n, t.fn.collapse.Constructor = i, t.fn.collapse.noConflict = function () { return t.fn.collapse = r, this }, t(document).on('click.bs.collapse.data-api', '[data-toggle="collapse"]', function (i) { const r = t(this); r.attr('data-target') || i.preventDefault(); const a = e(r); const o = a.data('bs.collapse'); const s = o ? 'toggle' : r.data(); n.call(a, s) }) }(jQuery)), (function (t) { 'use strict'; function e (e) { let n = e.attr('data-target'); n || (n = e.attr('href'), n = n && /#[A-Za-z]/.test(n) && n.replace(/.*(?=#[^\s]*$)/, '')); const i = n && t(n); return i && i.length ? i : e.parent() } function n (n) { n && n.which === 3 || (t(r).remove(), t(a).each(function () { const i = t(this); const r = e(i); const a = { relatedTarget: this }; r.hasClass('open') && (n && n.type == 'click' && /input|textarea/i.test(n.target.tagName) && t.contains(r[0], n.target) || (r.trigger(n = t.Event('hide.bs.dropdown', a)), n.isDefaultPrevented() || (i.attr('aria-expanded', 'false'), r.removeClass('open').trigger(t.Event('hidden.bs.dropdown', a))))) })) } function i (e) { return this.each(function () { const n = t(this); let i = n.data('bs.dropdown'); i || n.data('bs.dropdown', i = new o(this)), typeof e === 'string' && i[e].call(n) }) } var r = '.dropdown-backdrop'; var a = '[data-toggle="dropdown"]'; var o = function (e) { t(e).on('click.bs.dropdown', this.toggle) }; o.VERSION = '3.3.7', o.prototype.toggle = function (i) { const r = t(this); if (!r.is('.disabled, :disabled')) { const a = e(r); const o = a.hasClass('open'); if (n(), !o) { 'ontouchstart' in document.documentElement && !a.closest('.navbar-nav').length && t(document.createElement('div')).addClass('dropdown-backdrop').insertAfter(t(this)).on('click', n); const s = { relatedTarget: this }; if (a.trigger(i = t.Event('show.bs.dropdown', s)), i.isDefaultPrevented()) return; r.trigger('focus').attr('aria-expanded', 'true'), a.toggleClass('open').trigger(t.Event('shown.bs.dropdown', s)) } return !1 } }, o.prototype.keydown = function (n) { if (/(38|40|27|32)/.test(n.which) && !/input|textarea/i.test(n.target.tagName)) { const i = t(this); if (n.preventDefault(), n.stopPropagation(), !i.is('.disabled, :disabled')) { const r = e(i); const o = r.hasClass('open'); if (!o && n.which != 27 || o && n.which == 27) return n.which == 27 && r.find(a).trigger('focus'), i.trigger('click'); const s = r.find('.dropdown-menu li:not(.disabled):visible a'); if (s.length) { let l = s.index(n.target); n.which == 38 && l > 0 && l--, n.which == 40 && l < s.length - 1 && l++, ~l || (l = 0), s.eq(l).trigger('focus') } } } }; const s = t.fn.dropdown; t.fn.dropdown = i, t.fn.dropdown.Constructor = o, t.fn.dropdown.noConflict = function () { return t.fn.dropdown = s, this }, t(document).on('click.bs.dropdown.data-api', n).on('click.bs.dropdown.data-api', '.dropdown form', function (t) { t.stopPropagation() }).on('click.bs.dropdown.data-api', a, o.prototype.toggle).on('keydown.bs.dropdown.data-api', a, o.prototype.keydown).on('keydown.bs.dropdown.data-api', '.dropdown-menu', o.prototype.keydown) }(jQuery)), (function (t) { 'use strict'; function e (e, i) { return this.each(function () { const r = t(this); let a = r.data('bs.modal'); const o = t.extend({}, n.DEFAULTS, r.data(), typeof e === 'object' && e); a || r.data('bs.modal', a = new n(this, o)), typeof e === 'string' ? a[e](i) : o.show && a.show(i) }) } var n = function (e, n) { this.options = n, this.$body = t(document.body), this.$element = t(e), this.$dialog = this.$element.find('.modal-dialog'), this.$backdrop = null, this.isShown = null, this.originalBodyPad = null, this.scrollbarWidth = 0, this.ignoreBackdropClick = !1, this.options.remote && this.$element.find('.modal-content').load(this.options.remote, t.proxy(function () { this.$element.trigger('loaded.bs.modal') }, this)) }; n.VERSION = '3.3.7', n.TRANSITION_DURATION = 300, n.BACKDROP_TRANSITION_DURATION = 150, n.DEFAULTS = { backdrop: !0, keyboard: !0, show: !0 }, n.prototype.toggle = function (t) { return this.isShown ? this.hide() : this.show(t) }, n.prototype.show = function (e) { const i = this; const r = t.Event('show.bs.modal', { relatedTarget: e }); this.$element.trigger(r), this.isShown || r.isDefaultPrevented() || (this.isShown = !0, this.checkScrollbar(), this.setScrollbar(), this.$body.addClass('modal-open'), this.escape(), this.resize(), this.$element.on('click.dismiss.bs.modal', '[data-dismiss="modal"]', t.proxy(this.hide, this)), this.$dialog.on('mousedown.dismiss.bs.modal', function () { i.$element.one('mouseup.dismiss.bs.modal', function (e) { t(e.target).is(i.$element) && (i.ignoreBackdropClick = !0) }) }), this.backdrop(function () { const r = t.support.transition && i.$element.hasClass('fade'); i.$element.parent().length || i.$element.appendTo(i.$body), i.$element.show().scrollTop(0), i.adjustDialog(), r && i.$element[0].offsetWidth, i.$element.addClass('in'), i.enforceFocus(); const a = t.Event('shown.bs.modal', { relatedTarget: e }); r ? i.$dialog.one('bsTransitionEnd', function () { i.$element.trigger('focus').trigger(a) }).emulateTransitionEnd(n.TRANSITION_DURATION) : i.$element.trigger('focus').trigger(a) })) }, n.prototype.hide = function (e) { e && e.preventDefault(), e = t.Event('hide.bs.modal'), this.$element.trigger(e), this.isShown && !e.isDefaultPrevented() && (this.isShown = !1, this.escape(), this.resize(), t(document).off('focusin.bs.modal'), this.$element.removeClass('in').off('click.dismiss.bs.modal').off('mouseup.dismiss.bs.modal'), this.$dialog.off('mousedown.dismiss.bs.modal'), t.support.transition && this.$element.hasClass('fade') ? this.$element.one('bsTransitionEnd', t.proxy(this.hideModal, this)).emulateTransitionEnd(n.TRANSITION_DURATION) : this.hideModal()) }, n.prototype.enforceFocus = function () { t(document).off('focusin.bs.modal').on('focusin.bs.modal', t.proxy(function (t) { document === t.target || this.$element[0] === t.target || this.$element.has(t.target).length || this.$element.trigger('focus') }, this)) }, n.prototype.escape = function () { this.isShown && this.options.keyboard ? this.$element.on('keydown.dismiss.bs.modal', t.proxy(function (t) { t.which == 27 && this.hide() }, this)) : this.isShown || this.$element.off('keydown.dismiss.bs.modal') }, n.prototype.resize = function () { this.isShown ? t(window).on('resize.bs.modal', t.proxy(this.handleUpdate, this)) : t(window).off('resize.bs.modal') }, n.prototype.hideModal = function () { const t = this; this.$element.hide(), this.backdrop(function () { t.$body.removeClass('modal-open'), t.resetAdjustments(), t.resetScrollbar(), t.$element.trigger('hidden.bs.modal') }) }, n.prototype.removeBackdrop = function () { this.$backdrop && this.$backdrop.remove(), this.$backdrop = null }, n.prototype.backdrop = function (e) { const i = this; const r = this.$element.hasClass('fade') ? 'fade' : ''; if (this.isShown && this.options.backdrop) { const a = t.support.transition && r; if (this.$backdrop = t(document.createElement('div')).addClass('modal-backdrop ' + r).appendTo(this.$body), this.$element.on('click.dismiss.bs.modal', t.proxy(function (t) { if (this.ignoreBackdropClick) return void (this.ignoreBackdropClick = !1); t.target === t.currentTarget && (this.options.backdrop == 'static' ? this.$element[0].focus() : this.hide()) }, this)), a && this.$backdrop[0].offsetWidth, this.$backdrop.addClass('in'), !e) return; a ? this.$backdrop.one('bsTransitionEnd', e).emulateTransitionEnd(n.BACKDROP_TRANSITION_DURATION) : e() } else if (!this.isShown && this.$backdrop) { this.$backdrop.removeClass('in'); const o = function () { i.removeBackdrop(), e && e() }; t.support.transition && this.$element.hasClass('fade') ? this.$backdrop.one('bsTransitionEnd', o).emulateTransitionEnd(n.BACKDROP_TRANSITION_DURATION) : o() } else e && e() }, n.prototype.handleUpdate = function () { this.adjustDialog() }, n.prototype.adjustDialog = function () { const t = this.$element[0].scrollHeight > document.documentElement.clientHeight; this.$element.css({ paddingLeft: !this.bodyIsOverflowing && t ? this.scrollbarWidth : '', paddingRight: this.bodyIsOverflowing && !t ? this.scrollbarWidth : '' }) }, n.prototype.resetAdjustments = function () { this.$element.css({ paddingLeft: '', paddingRight: '' }) }, n.prototype.checkScrollbar = function () { let t = window.innerWidth; if (!t) { const e = document.documentElement.getBoundingClientRect(); t = e.right - Math.abs(e.left) } this.bodyIsOverflowing = document.body.clientWidth < t, this.scrollbarWidth = this.measureScrollbar() }, n.prototype.setScrollbar = function () { const t = parseInt(this.$body.css('padding-right') || 0, 10); this.originalBodyPad = document.body.style.paddingRight || '', this.bodyIsOverflowing && this.$body.css('padding-right', t + this.scrollbarWidth) }, n.prototype.resetScrollbar = function () { this.$body.css('padding-right', this.originalBodyPad) }, n.prototype.measureScrollbar = function () { const t = document.createElement('div'); t.className = 'modal-scrollbar-measure', this.$body.append(t); const e = t.offsetWidth - t.clientWidth; return this.$body[0].removeChild(t), e }; const i = t.fn.modal; t.fn.modal = e, t.fn.modal.Constructor = n, t.fn.modal.noConflict = function () { return t.fn.modal = i, this }, t(document).on('click.bs.modal.data-api', '[data-toggle="modal"]', function (n) { const i = t(this); const r = i.attr('href'); const a = t(i.attr('data-target') || r && r.replace(/.*(?=#[^\s]+$)/, '')); const o = a.data('bs.modal') ? 'toggle' : t.extend({ remote: !/#/.test(r) && r }, a.data(), i.data()); i.is('a') && n.preventDefault(), a.one('show.bs.modal', function (t) { t.isDefaultPrevented() || a.one('hidden.bs.modal', function () { i.is(':visible') && i.trigger('focus') }) }), e.call(a, o, this) }) }(jQuery)), (function (t) { 'use strict'; function e (e) { return this.each(function () { const i = t(this); let r = i.data('bs.tooltip'); const a = typeof e === 'object' && e; !r && /destroy|hide/.test(e) || (r || i.data('bs.tooltip', r = new n(this, a)), typeof e === 'string' && r[e]()) }) } var n = function (t, e) { this.type = null, this.options = null, this.enabled = null, this.timeout = null, this.hoverState = null, this.$element = null, this.inState = null, this.init('tooltip', t, e) }; n.VERSION = '3.3.7', n.TRANSITION_DURATION = 150, n.DEFAULTS = { animation: !0, placement: 'top', selector: !1, template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>', trigger: 'hover focus', title: '', delay: 0, html: !1, container: !1, viewport: { selector: 'body', padding: 0 } }, n.prototype.init = function (e, n, i) { if (this.enabled = !0, this.type = e, this.$element = t(n), this.options = this.getOptions(i), this.$viewport = this.options.viewport && t(t.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : this.options.viewport.selector || this.options.viewport), this.inState = { click: !1, hover: !1, focus: !1 }, this.$element[0] instanceof document.constructor && !this.options.selector) throw new Error('`selector` option must be specified when initializing ' + this.type + ' on the window.document object!'); for (let r = this.options.trigger.split(' '), a = r.length; a--;) { const o = r[a]; if (o == 'click') this.$element.on('click.' + this.type, this.options.selector, t.proxy(this.toggle, this)); else if (o != 'manual') { const s = o == 'hover' ? 'mouseenter' : 'focusin'; const l = o == 'hover' ? 'mouseleave' : 'focusout'; this.$element.on(s + '.' + this.type, this.options.selector, t.proxy(this.enter, this)), this.$element.on(l + '.' + this.type, this.options.selector, t.proxy(this.leave, this)) } } this.options.selector ? this._options = t.extend({}, this.options, { trigger: 'manual', selector: '' }) : this.fixTitle() }, n.prototype.getDefaults = function () { return n.DEFAULTS }, n.prototype.getOptions = function (e) { return e = t.extend({}, this.getDefaults(), this.$element.data(), e), e.delay && typeof e.delay === 'number' && (e.delay = { show: e.delay, hide: e.delay }), e }, n.prototype.getDelegateOptions = function () { const e = {}; const n = this.getDefaults(); return this._options && t.each(this._options, function (t, i) { n[t] != i && (e[t] = i) }), e }, n.prototype.enter = function (e) { let n = e instanceof this.constructor ? e : t(e.currentTarget).data('bs.' + this.type); return n || (n = new this.constructor(e.currentTarget, this.getDelegateOptions()), t(e.currentTarget).data('bs.' + this.type, n)), e instanceof t.Event && (n.inState[e.type == 'focusin' ? 'focus' : 'hover'] = !0), n.tip().hasClass('in') || n.hoverState == 'in' ? void (n.hoverState = 'in') : (clearTimeout(n.timeout), n.hoverState = 'in', n.options.delay && n.options.delay.show ? void (n.timeout = setTimeout(function () { n.hoverState == 'in' && n.show() }, n.options.delay.show)) : n.show()) }, n.prototype.isInStateTrue = function () { for (const t in this.inState) if (this.inState[t]) return !0; return !1 }, n.prototype.leave = function (e) { let n = e instanceof this.constructor ? e : t(e.currentTarget).data('bs.' + this.type); if (n || (n = new this.constructor(e.currentTarget, this.getDelegateOptions()), t(e.currentTarget).data('bs.' + this.type, n)), e instanceof t.Event && (n.inState[e.type == 'focusout' ? 'focus' : 'hover'] = !1), !n.isInStateTrue()) { if (clearTimeout(n.timeout), n.hoverState = 'out', !n.options.delay || !n.options.delay.hide) return n.hide(); n.timeout = setTimeout(function () { n.hoverState == 'out' && n.hide() }, n.options.delay.hide) } }, n.prototype.show = function () { const e = t.Event('show.bs.' + this.type); if (this.hasContent() && this.enabled) { this.$element.trigger(e); const i = t.contains(this.$element[0].ownerDocument.documentElement, this.$element[0]); if (e.isDefaultPrevented() || !i) return; const r = this; const a = this.tip(); const o = this.getUID(this.type); this.setContent(), a.attr('id', o), this.$element.attr('aria-describedby', o), this.options.animation && a.addClass('fade'); let s = typeof this.options.placement === 'function' ? this.options.placement.call(this, a[0], this.$element[0]) : this.options.placement; const l = /\s?auto?\s?/i; const c = l.test(s); c && (s = s.replace(l, '') || 'top'), a.detach().css({ top: 0, left: 0, display: 'block' }).addClass(s).data('bs.' + this.type, this), this.options.container ? a.appendTo(this.options.container) : a.insertAfter(this.$element), this.$element.trigger('inserted.bs.' + this.type); const u = this.getPosition(); const h = a[0].offsetWidth; const p = a[0].offsetHeight; if (c) { const d = s; const f = this.getPosition(this.$viewport); s = s == 'bottom' && u.bottom + p > f.bottom ? 'top' : s == 'top' && u.top - p < f.top ? 'bottom' : s == 'right' && u.right + h > f.width ? 'left' : s == 'left' && u.left - h < f.left ? 'right' : s, a.removeClass(d).addClass(s) } const m = this.getCalculatedOffset(s, u, h, p); this.applyPlacement(m, s); const g = function () { const t = r.hoverState; r.$element.trigger('shown.bs.' + r.type), r.hoverState = null, t == 'out' && r.leave(r) }; t.support.transition && this.$tip.hasClass('fade') ? a.one('bsTransitionEnd', g).emulateTransitionEnd(n.TRANSITION_DURATION) : g() } }, n.prototype.applyPlacement = function (e, n) { const i = this.tip(); const r = i[0].offsetWidth; const a = i[0].offsetHeight; let o = parseInt(i.css('margin-top'), 10); let s = parseInt(i.css('margin-left'), 10); isNaN(o) && (o = 0), isNaN(s) && (s = 0), e.top += o, e.left += s, t.offset.setOffset(i[0], t.extend({ using: function (t) { i.css({ top: Math.round(t.top), left: Math.round(t.left) }) } }, e), 0), i.addClass('in'); const l = i[0].offsetWidth; const c = i[0].offsetHeight; n == 'top' && c != a && (e.top = e.top + a - c); const u = this.getViewportAdjustedDelta(n, e, l, c); u.left ? e.left += u.left : e.top += u.top; const h = /top|bottom/.test(n); const p = h ? 2 * u.left - r + l : 2 * u.top - a + c; const d = h ? 'offsetWidth' : 'offsetHeight'; i.offset(e), this.replaceArrow(p, i[0][d], h) }, n.prototype.replaceArrow = function (t, e, n) { this.arrow().css(n ? 'left' : 'top', 50 * (1 - t / e) + '%').css(n ? 'top' : 'left', '') }, n.prototype.setContent = function () { const t = this.tip(); const e = this.getTitle(); t.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](e), t.removeClass('fade in top bottom left right') }, n.prototype.hide = function (e) { function i () { r.hoverState != 'in' && a.detach(), r.$element && r.$element.removeAttr('aria-describedby').trigger('hidden.bs.' + r.type), e && e() } var r = this; var a = t(this.$tip); const o = t.Event('hide.bs.' + this.type); if (this.$element.trigger(o), !o.isDefaultPrevented()) return a.removeClass('in'), t.support.transition && a.hasClass('fade') ? a.one('bsTransitionEnd', i).emulateTransitionEnd(n.TRANSITION_DURATION) : i(), this.hoverState = null, this }, n.prototype.fixTitle = function () { const t = this.$element; (t.attr('title') || typeof t.attr('data-original-title') !== 'string') && t.attr('data-original-title', t.attr('title') || '').attr('title', '') }, n.prototype.hasContent = function () { return this.getTitle() }, n.prototype.getPosition = function (e) { e = e || this.$element; const n = e[0]; const i = n.tagName == 'BODY'; let r = n.getBoundingClientRect(); r.width == null && (r = t.extend({}, r, { width: r.right - r.left, height: r.bottom - r.top })); const a = window.SVGElement && n instanceof window.SVGElement; const o = i ? { top: 0, left: 0 } : a ? null : e.offset(); const s = { scroll: i ? document.documentElement.scrollTop || document.body.scrollTop : e.scrollTop() }; const l = i ? { width: t(window).width(), height: t(window).height() } : null; return t.extend({}, r, s, l, o) }, n.prototype.getCalculatedOffset = function (t, e, n, i) { return t == 'bottom' ? { top: e.top + e.height, left: e.left + e.width / 2 - n / 2 } : t == 'top' ? { top: e.top - i, left: e.left + e.width / 2 - n / 2 } : t == 'left' ? { top: e.top + e.height / 2 - i / 2, left: e.left - n } : { top: e.top + e.height / 2 - i / 2, left: e.left + e.width } }, n.prototype.getViewportAdjustedDelta = function (t, e, n, i) { const r = { top: 0, left: 0 }; if (!this.$viewport) return r; const a = this.options.viewport && this.options.viewport.padding || 0; const o = this.getPosition(this.$viewport); if (/right|left/.test(t)) { const s = e.top - a - o.scroll; const l = e.top + a - o.scroll + i; s < o.top ? r.top = o.top - s : l > o.top + o.height && (r.top = o.top + o.height - l) } else { const c = e.left - a; const u = e.left + a + n; c < o.left ? r.left = o.left - c : u > o.right && (r.left = o.left + o.width - u) } return r }, n.prototype.getTitle = function () { const t = this.$element; const e = this.options; return t.attr('data-original-title') || (typeof e.title === 'function' ? e.title.call(t[0]) : e.title) }, n.prototype.getUID = function (t) { do { t += ~~(1e6 * Math.random()) } while (document.getElementById(t)); return t }, n.prototype.tip = function () { if (!this.$tip && (this.$tip = t(this.options.template), this.$tip.length != 1)) throw new Error(this.type + ' `template` option must consist of exactly 1 top-level element!'); return this.$tip }, n.prototype.arrow = function () { return this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow') }, n.prototype.enable = function () { this.enabled = !0 }, n.prototype.disable = function () { this.enabled = !1 }, n.prototype.toggleEnabled = function () { this.enabled = !this.enabled }, n.prototype.toggle = function (e) { let n = this; e && ((n = t(e.currentTarget).data('bs.' + this.type)) || (n = new this.constructor(e.currentTarget, this.getDelegateOptions()), t(e.currentTarget).data('bs.' + this.type, n))), e ? (n.inState.click = !n.inState.click, n.isInStateTrue() ? n.enter(n) : n.leave(n)) : n.tip().hasClass('in') ? n.leave(n) : n.enter(n) }, n.prototype.destroy = function () { const t = this; clearTimeout(this.timeout), this.hide(function () { t.$element.off('.' + t.type).removeData('bs.' + t.type), t.$tip && t.$tip.detach(), t.$tip = null, t.$arrow = null, t.$viewport = null, t.$element = null }) }; const i = t.fn.tooltip; t.fn.tooltip = e, t.fn.tooltip.Constructor = n, t.fn.tooltip.noConflict = function () { return t.fn.tooltip = i, this } }(jQuery)), (function (t) { 'use strict'; function e (e) { return this.each(function () { const i = t(this); let r = i.data('bs.popover'); const a = typeof e === 'object' && e; !r && /destroy|hide/.test(e) || (r || i.data('bs.popover', r = new n(this, a)), typeof e === 'string' && r[e]()) }) } var n = function (t, e) { this.init('popover', t, e) }; if (!t.fn.tooltip) throw new Error('Popover requires tooltip.js'); n.VERSION = '3.3.7', n.DEFAULTS = t.extend({}, t.fn.tooltip.Constructor.DEFAULTS, { placement: 'right', trigger: 'click', content: '', template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>' }), n.prototype = t.extend({}, t.fn.tooltip.Constructor.prototype), n.prototype.constructor = n, n.prototype.getDefaults = function () { return n.DEFAULTS }, n.prototype.setContent = function () { const t = this.tip(); const e = this.getTitle(); const n = this.getContent(); t.find('.popover-title')[this.options.html ? 'html' : 'text'](e), t.find('.popover-content').children().detach().end()[this.options.html ? typeof n === 'string' ? 'html' : 'append' : 'text'](n), t.removeClass('fade top bottom left right in'), t.find('.popover-title').html() || t.find('.popover-title').hide() }, n.prototype.hasContent = function () { return this.getTitle() || this.getContent() }, n.prototype.getContent = function () { const t = this.$element; const e = this.options; return t.attr('data-content') || (typeof e.content === 'function' ? e.content.call(t[0]) : e.content) }, n.prototype.arrow = function () { return this.$arrow = this.$arrow || this.tip().find('.arrow') }; const i = t.fn.popover; t.fn.popover = e, t.fn.popover.Constructor = n, t.fn.popover.noConflict = function () { return t.fn.popover = i, this } }(jQuery)), (function (t) { 'use strict'; function e (n, i) { this.$body = t(document.body), this.$scrollElement = t(t(n).is(document.body) ? window : n), this.options = t.extend({}, e.DEFAULTS, i), this.selector = (this.options.target || '') + ' .nav li > a', this.offsets = [], this.targets = [], this.activeTarget = null, this.scrollHeight = 0, this.$scrollElement.on('scroll.bs.scrollspy', t.proxy(this.process, this)), this.refresh(), this.process() } function n (n) { return this.each(function () { const i = t(this); let r = i.data('bs.scrollspy'); const a = typeof n === 'object' && n; r || i.data('bs.scrollspy', r = new e(this, a)), typeof n === 'string' && r[n]() }) }e.VERSION = '3.3.7', e.DEFAULTS = { offset: 10 }, e.prototype.getScrollHeight = function () { return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight) }, e.prototype.refresh = function () { const e = this; let n = 'offset'; let i = 0; this.offsets = [], this.targets = [], this.scrollHeight = this.getScrollHeight(), t.isWindow(this.$scrollElement[0]) || (n = 'position', i = this.$scrollElement.scrollTop()), this.$body.find(this.selector).map(function () { const e = t(this); const r = e.data('target') || e.attr('href'); const a = /^#./.test(r) && t(r); return a && a.length && a.is(':visible') && [[a[n]().top + i, r]] || null }).sort(function (t, e) { return t[0] - e[0] }).each(function () { e.offsets.push(this[0]), e.targets.push(this[1]) }) }, e.prototype.process = function () { let t; const e = this.$scrollElement.scrollTop() + this.options.offset; const n = this.getScrollHeight(); const i = this.options.offset + n - this.$scrollElement.height(); const r = this.offsets; const a = this.targets; const o = this.activeTarget; if (this.scrollHeight != n && this.refresh(), e >= i) return o != (t = a[a.length - 1]) && this.activate(t); if (o && e < r[0]) return this.activeTarget = null, this.clear(); for (t = r.length; t--;)o != a[t] && e >= r[t] && (void 0 === r[t + 1] || e < r[t + 1]) && this.activate(a[t]) }, e.prototype.activate = function (e) { this.activeTarget = e, this.clear(); const n = this.selector + '[data-target="' + e + '"],' + this.selector + '[href="' + e + '"]'; let i = t(n).parents('li').addClass('active'); i.parent('.dropdown-menu').length && (i = i.closest('li.dropdown').addClass('active')), i.trigger('activate.bs.scrollspy') }, e.prototype.clear = function () { t(this.selector).parentsUntil(this.options.target, '.active').removeClass('active') }; const i = t.fn.scrollspy; t.fn.scrollspy = n, t.fn.scrollspy.Constructor = e, t.fn.scrollspy.noConflict = function () { return t.fn.scrollspy = i, this }, t(window).on('load.bs.scrollspy.data-api', function () { t('[data-spy="scroll"]').each(function () { const e = t(this); n.call(e, e.data()) }) }) }(jQuery)), (function (t) { 'use strict'; function e (e) { return this.each(function () { const i = t(this); let r = i.data('bs.tab'); r || i.data('bs.tab', r = new n(this)), typeof e === 'string' && r[e]() }) } var n = function (e) { this.element = t(e) }; n.VERSION = '3.3.7', n.TRANSITION_DURATION = 150, n.prototype.show = function () { const e = this.element; const n = e.closest('ul:not(.dropdown-menu)'); let i = e.data('target'); if (i || (i = e.attr('href'), i = i && i.replace(/.*(?=#[^\s]*$)/, '')), !e.parent('li').hasClass('active')) { const r = n.find('.active:last a'); const a = t.Event('hide.bs.tab', { relatedTarget: e[0] }); const o = t.Event('show.bs.tab', { relatedTarget: r[0] }); if (r.trigger(a), e.trigger(o), !o.isDefaultPrevented() && !a.isDefaultPrevented()) { const s = t(i); this.activate(e.closest('li'), n), this.activate(s, s.parent(), function () { r.trigger({ type: 'hidden.bs.tab', relatedTarget: e[0] }), e.trigger({ type: 'shown.bs.tab', relatedTarget: r[0] }) }) } } }, n.prototype.activate = function (e, i, r) { function a () { o.removeClass('active').find('> .dropdown-menu > .active').removeClass('active').end().find('[data-toggle="tab"]').attr('aria-expanded', !1), e.addClass('active').find('[data-toggle="tab"]').attr('aria-expanded', !0), s ? (e[0].offsetWidth, e.addClass('in')) : e.removeClass('fade'), e.parent('.dropdown-menu').length && e.closest('li.dropdown').addClass('active').end().find('[data-toggle="tab"]').attr('aria-expanded', !0), r && r() } var o = i.find('> .active'); var s = r && t.support.transition && (o.length && o.hasClass('fade') || !!i.find('> .fade').length); o.length && s ? o.one('bsTransitionEnd', a).emulateTransitionEnd(n.TRANSITION_DURATION) : a(), o.removeClass('in') }; const i = t.fn.tab; t.fn.tab = e, t.fn.tab.Constructor = n, t.fn.tab.noConflict = function () { return t.fn.tab = i, this }; const r = function (n) { n.preventDefault(), e.call(t(this), 'show') }; t(document).on('click.bs.tab.data-api', '[data-toggle="tab"]', r).on('click.bs.tab.data-api', '[data-toggle="pill"]', r) }(jQuery)), (function (t) { 'use strict'; function e (e) { return this.each(function () { const i = t(this); let r = i.data('bs.affix'); const a = typeof e === 'object' && e; r || i.data('bs.affix', r = new n(this, a)), typeof e === 'string' && r[e]() }) } var n = function (e, i) { this.options = t.extend({}, n.DEFAULTS, i), this.$target = t(this.options.target).on('scroll.bs.affix.data-api', t.proxy(this.checkPosition, this)).on('click.bs.affix.data-api', t.proxy(this.checkPositionWithEventLoop, this)), this.$element = t(e), this.affixed = null, this.unpin = null, this.pinnedOffset = null, this.checkPosition() }; n.VERSION = '3.3.7', n.RESET = 'affix affix-top affix-bottom', n.DEFAULTS = { offset: 0, target: window }, n.prototype.getState = function (t, e, n, i) { const r = this.$target.scrollTop(); const a = this.$element.offset(); const o = this.$target.height(); if (n != null && this.affixed == 'top') return r < n && 'top'; if (this.affixed == 'bottom') return n != null ? !(r + this.unpin <= a.top) && 'bottom' : !(r + o <= t - i) && 'bottom'; const s = this.affixed == null; const l = s ? r : a.top; const c = s ? o : e; return n != null && r <= n ? 'top' : i != null && l + c >= t - i && 'bottom' }, n.prototype.getPinnedOffset = function () { if (this.pinnedOffset) return this.pinnedOffset; this.$element.removeClass(n.RESET).addClass('affix'); const t = this.$target.scrollTop(); const e = this.$element.offset(); return this.pinnedOffset = e.top - t }, n.prototype.checkPositionWithEventLoop = function () { setTimeout(t.proxy(this.checkPosition, this), 1) }, n.prototype.checkPosition = function () { if (this.$element.is(':visible')) { const e = this.$element.height(); const i = this.options.offset; let r = i.top; let a = i.bottom; const o = Math.max(t(document).height(), t(document.body).height()); typeof i !== 'object' && (a = r = i), typeof r === 'function' && (r = i.top(this.$element)), typeof a === 'function' && (a = i.bottom(this.$element)); const s = this.getState(o, e, r, a); if (this.affixed != s) { this.unpin != null && this.$element.css('top', ''); const l = 'affix' + (s ? '-' + s : ''); const c = t.Event(l + '.bs.affix'); if (this.$element.trigger(c), c.isDefaultPrevented()) return; this.affixed = s, this.unpin = s == 'bottom' ? this.getPinnedOffset() : null, this.$element.removeClass(n.RESET).addClass(l).trigger(l.replace('affix', 'affixed') + '.bs.affix') }s == 'bottom' && this.$element.offset({ top: o - e - a }) } }; const i = t.fn.affix; t.fn.affix = e, t.fn.affix.Constructor = n, t.fn.affix.noConflict = function () { return t.fn.affix = i, this }, t(window).on('load', function () { t('[data-spy="affix"]').each(function () { const n = t(this); const i = n.data(); i.offset = i.offset || {}, i.offsetBottom != null && (i.offset.bottom = i.offsetBottom), i.offsetTop != null && (i.offset.top = i.offsetTop), e.call(n, i) }) }) }(jQuery)), (function () {
  'use strict'; function t (t) { return angular.isUndefined(t) || t === null } var e = {
    TAB: 9,
    ENTER: 13,
    ESC: 27,
    SPACE: 32,
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
    SHIFT: 16,
    CTRL: 17,
    ALT: 18,
    PAGE_UP: 33,
    PAGE_DOWN: 34,
    HOME: 36,
    END: 35,
    BACKSPACE: 8,
    DELETE: 46,
    COMMAND: 91,
    MAP: {
      91: 'COMMAND',
      8: 'BACKSPACE',
      9: 'TAB',
      13: 'ENTER',
      16: 'SHIFT',
      17: 'CTRL',
      18: 'ALT',
      19: 'PAUSEBREAK',
      20: 'CAPSLOCK',
      27: 'ESC',
      32: 'SPACE',
      33: 'PAGE_UP',
      34: 'PAGE_DOWN',
      35: 'END',
      36: 'HOME',
      37: 'LEFT',
      38: 'UP',
      39: 'RIGHT',
      40: 'DOWN',
      43: '+',
      44: 'PRINTSCREEN',
      45: 'INSERT',
      46: 'DELETE',
      48: '0',
      49: '1',
      50: '2',
      51: '3',
      52: '4',
      53: '5',
      54: '6',
      55: '7',
      56: '8',
      57: '9',
      59: ';',
      61: '=',
      65: 'A',
      66: 'B',
      67: 'C',
      68: 'D',
      69: 'E',
      70: 'F',
      71: 'G',
      72: 'H',
      73: 'I',
      74: 'J',
      75: 'K',
      76: 'L',
      77: 'M',
      78: 'N',
      79: 'O',
      80: 'P',
      81: 'Q',
      82: 'R',
      83: 'S',
      84: 'T',
      85: 'U',
      86: 'V',
      87: 'W',
      88: 'X',
      89: 'Y',
      90: 'Z',
      96: '0',
      97: '1',
      98: '2',
      99: '3',
      100: '4',
      101: '5',
      102: '6',
      103: '7',
      104: '8',
      105: '9',
      106: '*',
      107: '+',
      109: '-',
      110: '.',
      111: '/',
      112: 'F1',
      113: 'F2',
      114: 'F3',
      115: 'F4',
      116: 'F5',
      117: 'F6',
      118: 'F7',
      119: 'F8',
      120: 'F9',
      121: 'F10',
      122: 'F11',
      123: 'F12',
      144: 'NUMLOCK',
      145: 'SCROLLLOCK',
      186: ';',
      187: '=',
      188: ',',
      189: '-',
      190: '.',
      191: '/',
      192: '`',
      219: '[',
      220: '\\',
      221: ']',
      222: "'"
    },
    isControl: function (t) { switch (t.which) { case e.COMMAND:case e.SHIFT:case e.CTRL:case e.ALT:return !0 } return !!(t.metaKey || t.ctrlKey || t.altKey) },
    isFunctionKey: function (t) { return (t = t.which ? t.which : t) >= 112 && t <= 123 },
    isVerticalMovement: function (t) { return ~[e.UP, e.DOWN].indexOf(t) },
    isHorizontalMovement: function (t) { return ~[e.LEFT, e.RIGHT, e.BACKSPACE, e.DELETE].indexOf(t) },
    toSeparator: function (t) { const n = { ENTER: '\n', TAB: '\t', SPACE: ' ' }[t]; return n || (e[t] ? void 0 : t) }
  }; void 0 === angular.element.prototype.querySelectorAll && (angular.element.prototype.querySelectorAll = function (t) { return angular.element(this[0].querySelectorAll(t)) }), void 0 === angular.element.prototype.closest && (angular.element.prototype.closest = function (t) { for (let e = this[0], n = e.matches || e.webkitMatchesSelector || e.mozMatchesSelector || e.msMatchesSelector; e;) { if (n.bind(e)(t)) return e; e = e.parentElement } return !1 }); let n = 0; const i = angular.module('ui.select', []).constant('uiSelectConfig', { theme: 'bootstrap', searchEnabled: !0, sortable: !1, placeholder: '', refreshDelay: 1e3, closeOnSelect: !0, skipFocusser: !1, dropdownPosition: 'auto', removeSelected: !0, resetSearchInput: !0, generateId: function () { return n++ }, appendToBody: !1, spinnerEnabled: !1, spinnerClass: 'glyphicon glyphicon-refresh ui-select-spin', backspaceReset: !0 }).service('uiSelectMinErr', function () { const t = angular.$$minErr('ui.select'); return function () { const e = t.apply(this, arguments); const n = e.message.replace(new RegExp('\nhttp://errors.angularjs.org/.*'), ''); return new Error(n) } }).directive('uisTranscludeAppend', function () { return { link: function (t, e, n, i, r) { r(t, function (t) { e.append(t) }) } } }).filter('highlight', function () { function t (t) { return ('' + t).replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1') } return function (e, n) { return n && e ? ('' + e).replace(new RegExp(t(n), 'gi'), '<span class="ui-select-highlight">$&</span>') : e } }).factory('uisOffset', ['$document', '$window', function (t, e) { return function (n) { const i = n[0].getBoundingClientRect(); return { width: i.width || n.prop('offsetWidth'), height: i.height || n.prop('offsetHeight'), top: i.top + (e.pageYOffset || t[0].documentElement.scrollTop), left: i.left + (e.pageXOffset || t[0].documentElement.scrollLeft) } } }]); i.factory('$$uisDebounce', ['$timeout', function (t) { return function (e, n) { let i; return function () { const r = this; const a = Array.prototype.slice.call(arguments); i && t.cancel(i), i = t(function () { e.apply(r, a) }, n) } } }]), i.directive('uiSelectChoices', ['uiSelectConfig', 'uisRepeatParser', 'uiSelectMinErr', '$compile', '$window', function (t, e, n, i, r) { return { restrict: 'EA', require: '^uiSelect', replace: !0, transclude: !0, templateUrl: function (e) { return e.addClass('ui-select-choices'), (e.parent().attr('theme') || t.theme) + '/choices.tpl.html' }, compile: function (i, a) { if (!a.repeat) throw n('repeat', "Expected 'repeat' expression."); const o = a.groupBy; const s = a.groupFilter; if (o) { const l = i.querySelectorAll('.ui-select-choices-group'); if (l.length !== 1) throw n('rows', "Expected 1 .ui-select-choices-group but got '{0}'.", l.length); l.attr('ng-repeat', e.getGroupNgRepeatExpression()) } const c = e.parse(a.repeat); const u = i.querySelectorAll('.ui-select-choices-row'); if (u.length !== 1) throw n('rows', "Expected 1 .ui-select-choices-row but got '{0}'.", u.length); u.attr('ng-repeat', c.repeatExpression(o)).attr('ng-if', '$select.open'); const h = i.querySelectorAll('.ui-select-choices-row-inner'); if (h.length !== 1) throw n('rows', "Expected 1 .ui-select-choices-row-inner but got '{0}'.", h.length); return h.attr('uis-transclude-append', ''), (r.document.addEventListener ? u : h).attr('ng-click', '$select.select(' + c.itemName + ',$select.skipFocusser,$event)'), function (e, n, r, a) { a.parseRepeatAttr(r.repeat, o, s), a.disableChoiceExpression = r.uiDisableChoice, a.onHighlightCallback = r.onHighlight, a.minimumInputLength = parseInt(r.minimumInputLength) || 0, a.dropdownPosition = r.position ? r.position.toLowerCase() : t.dropdownPosition, e.$watch('$select.search', function (t) { t && !a.open && a.multiple && a.activate(!1, !0), a.activeIndex = a.tagging.isActivated ? -1 : 0, !r.minimumInputLength || a.search.length >= r.minimumInputLength ? a.refresh(r.refresh) : a.items = [] }), r.$observe('refreshDelay', function () { const n = e.$eval(r.refreshDelay); a.refreshDelay = void 0 !== n ? n : t.refreshDelay }), e.$watch('$select.open', function (t) { t ? (i.attr('role', 'listbox'), a.refresh(r.refresh)) : n.removeAttr('role') }) } } } }]), i.controller('uiSelectCtrl', ['$scope', '$element', '$timeout', '$filter', '$$uisDebounce', 'uisRepeatParser', 'uiSelectMinErr', 'uiSelectConfig', '$parse', '$injector', '$window', function (n, i, r, a, o, s, l, c, u, h, p) { function d (t, e, n) { if (t.findIndex) return t.findIndex(e, n); for (var i, r = Object(t), a = r.length >>> 0, o = 0; o < a; o++) if (i = r[o], e.call(n, i, o, r)) return o; return -1 } function f () { w.resetSearchInput && (w.search = _, w.selected && w.items.length && !w.multiple && (w.activeIndex = d(w.items, function (t) { return angular.equals(this, t) }, w.selected))) } function m (t, e) { let n; let i; const r = []; for (n = 0; n < e.length; n++) for (i = 0; i < t.length; i++)t[i].name == [e[n]] && r.push(t[i]); return r } function g (t, e) { const n = S.indexOf(t); e && n === -1 && S.push(t), !e && n > -1 && S.splice(n, 1) } function v (t) { return S.indexOf(t) > -1 } function y (t) { function e (t, e) { const n = i.indexOf(t); e && n === -1 && i.push(t), !e && n > -1 && i.splice(n, 1) } function n (t) { return i.indexOf(t) > -1 } if (t) { var i = []; w.isLocked = function (t, i) { let r = !1; const a = w.selected[i]; return a && (t ? (r = !!t.$eval(w.lockChoiceExpression), e(a, r)) : r = n(a)), r } } } function b (t) { let n = !0; switch (t) { case e.DOWN:if (!w.open && w.multiple)w.activate(!1, !0); else if (w.activeIndex < w.items.length - 1) for (let i = ++w.activeIndex; v(w.items[i]) && i < w.items.length;)w.activeIndex = ++i; break; case e.UP:var r = w.search.length === 0 && w.tagging.isActivated ? -1 : 0; if (!w.open && w.multiple)w.activate(!1, !0); else if (w.activeIndex > r) for (let a = --w.activeIndex; v(w.items[a]) && a > r;)w.activeIndex = --a; break; case e.TAB:w.multiple && !w.open || w.select(w.items[w.activeIndex], !0); break; case e.ENTER:w.open && (w.tagging.isActivated || w.activeIndex >= 0) ? w.select(w.items[w.activeIndex], w.skipFocusser) : w.activate(!1, !0); break; case e.ESC:w.close(); break; default:n = !1 } return n } function x () { const t = i.querySelectorAll('.ui-select-choices-content'); const e = t.querySelectorAll('.ui-select-choices-row'); if (e.length < 1) throw l('choices', "Expected multiple .ui-select-choices-row but got '{0}'.", e.length); if (!(w.activeIndex < 0)) { const n = e[w.activeIndex]; const r = n.offsetTop + n.clientHeight - t[0].scrollTop; const a = t[0].offsetHeight; r > a ? t[0].scrollTop += r - a : r < n.clientHeight && (w.isGrouped && w.activeIndex === 0 ? t[0].scrollTop = 0 : t[0].scrollTop -= n.clientHeight - r) } } var w = this; var _ = ''; if (w.placeholder = c.placeholder, w.searchEnabled = c.searchEnabled, w.sortable = c.sortable, w.refreshDelay = c.refreshDelay, w.paste = c.paste, w.resetSearchInput = c.resetSearchInput, w.refreshing = !1, w.spinnerEnabled = c.spinnerEnabled, w.spinnerClass = c.spinnerClass, w.removeSelected = c.removeSelected, w.closeOnSelect = !0, w.skipFocusser = !1, w.search = _, w.activeIndex = 0, w.items = [], w.open = !1, w.focus = !1, w.disabled = !1, w.selected = void 0, w.dropdownPosition = 'auto', w.focusser = void 0, w.multiple = void 0, w.disableChoiceExpression = void 0, w.tagging = { isActivated: !1, fct: void 0 }, w.taggingTokens = { isActivated: !1, tokens: void 0 }, w.lockChoiceExpression = void 0, w.clickTriggeredSelect = !1, w.$filter = a, w.$element = i, w.$animate = (function () { try { return h.get('$animate') } catch (t) { return null } }()), w.searchInput = i.querySelectorAll('input.ui-select-search'), w.searchInput.length !== 1) throw l('searchInput', "Expected 1 input.ui-select-search but got '{0}'.", w.searchInput.length); w.isEmpty = function () { return t(w.selected) || w.selected === '' || w.multiple && w.selected.length === 0 }, w.activate = function (t, e) { if (w.disabled || w.open)w.open && !w.searchEnabled && w.close(); else { e || f(), n.$broadcast('uis:activate'), w.open = !0, w.activeIndex = w.activeIndex >= w.items.length ? 0 : w.activeIndex, w.activeIndex === -1 && !1 !== w.taggingLabel && (w.activeIndex = 0); const a = i.querySelectorAll('.ui-select-choices-content'); const o = i.querySelectorAll('.ui-select-search'); if (w.$animate && w.$animate.on && w.$animate.enabled(a[0])) { const s = function (e, n) { n === 'start' && w.items.length === 0 ? (w.$animate.off('removeClass', o[0], s), r(function () { w.focusSearchInput(t) })) : n === 'close' && (w.$animate.off('enter', a[0], s), r(function () { w.focusSearchInput(t) })) }; w.items.length > 0 ? w.$animate.on('enter', a[0], s) : w.$animate.on('removeClass', o[0], s) } else r(function () { w.focusSearchInput(t), !w.tagging.isActivated && w.items.length > 1 && x() }) } }, w.focusSearchInput = function (t) { w.search = t || w.search, w.searchInput[0].focus() }, w.findGroupByName = function (t) { return w.groups && w.groups.filter(function (e) { return e.name === t })[0] }, w.parseRepeatAttr = function (t, e, i) { function r (t) { const r = n.$eval(e); if (w.groups = [], angular.forEach(t, function (t) { const e = angular.isFunction(r) ? r(t) : t[r]; const n = w.findGroupByName(e); n ? n.items.push(t) : w.groups.push({ name: e, items: [t] }) }), i) { const a = n.$eval(i); angular.isFunction(a) ? w.groups = a(w.groups) : angular.isArray(a) && (w.groups = m(w.groups, a)) }w.items = [], w.groups.forEach(function (t) { w.items = w.items.concat(t.items) }) } function a (t) { w.items = t || [] }w.setItemsFn = e ? r : a, w.parserResult = s.parse(t), w.isGrouped = !!e, w.itemProperty = w.parserResult.itemName; const o = w.parserResult.source; const c = function () { const t = o(n); n.$uisSource = Object.keys(t).map(function (e) { const n = {}; return n[w.parserResult.keyName] = e, n.value = t[e], n }) }; w.parserResult.keyName && (c(), w.parserResult.source = u('$uisSource' + w.parserResult.filters), n.$watch(o, function (t, e) { t !== e && c() }, !0)), w.refreshItems = function (t) { t = t || w.parserResult.source(n); const e = w.selected; if (w.isEmpty() || angular.isArray(e) && !e.length || !w.multiple || !w.removeSelected)w.setItemsFn(t); else if (void 0 !== t && t !== null) { const i = t.filter(function (t) { return angular.isArray(e) ? e.every(function (e) { return !angular.equals(t, e) }) : !angular.equals(t, e) }); w.setItemsFn(i) }w.dropdownPosition !== 'auto' && w.dropdownPosition !== 'up' || n.calculateDropdownPos(), n.$broadcast('uis:refresh') }, n.$watchCollection(w.parserResult.source, function (t) { if (void 0 === t || t === null)w.items = []; else { if (!angular.isArray(t)) throw l('items', "Expected an array but got '{0}'.", t); w.refreshItems(t), angular.isDefined(w.ngModel.$modelValue) && (w.ngModel.$modelValue = null) } }) }; let $; w.refresh = function (t) { void 0 !== t && ($ && r.cancel($), $ = r(function () { if (n.$select.search.length >= n.$select.minimumInputLength) { const e = n.$eval(t); e && angular.isFunction(e.then) && !w.refreshing && (w.refreshing = !0, e.finally(function () { w.refreshing = !1 })) } }, w.refreshDelay)) }, w.isActive = function (t) { if (!w.open) return !1; const e = w.items.indexOf(t[w.itemProperty]); const n = e == w.activeIndex; return !(!n || e < 0) && (n && !angular.isUndefined(w.onHighlightCallback) && t.$eval(w.onHighlightCallback), n) }; const T = function (t) { return w.selected && angular.isArray(w.selected) && w.selected.filter(function (e) { return angular.equals(e, t) }).length > 0 }; var S = []; w.isDisabled = function (t) { if (w.open) { const e = t[w.itemProperty]; const n = w.items.indexOf(e); let i = !1; if (n >= 0 && (angular.isDefined(w.disableChoiceExpression) || w.multiple)) { if (e.isTag) return !1; w.multiple && (i = T(e)), !i && angular.isDefined(w.disableChoiceExpression) && (i = !!t.$eval(w.disableChoiceExpression)), g(e, i) } return i } }, w.select = function (e, i, r) { if (t(e) || !v(e)) { if (!w.items && !w.search && !w.tagging.isActivated) return; if (!e || !v(e)) { if (w.clickTriggeredSelect = !1, r && (r.type === 'click' || r.type === 'touchend') && e && (w.clickTriggeredSelect = !0), w.tagging.isActivated && !1 === w.clickTriggeredSelect) { if (!1 === w.taggingLabel) if (w.activeIndex < 0) { if (void 0 === e && (e = void 0 !== w.tagging.fct ? w.tagging.fct(w.search) : w.search), !e || angular.equals(w.items[0], e)) return } else e = w.items[w.activeIndex]; else if (w.activeIndex === 0) { if (void 0 === e) return; if (void 0 !== w.tagging.fct && typeof e === 'string') { if (!(e = w.tagging.fct(e))) return } else typeof e === 'string' && (e = e.replace(w.taggingLabel, '').trim()) } if (T(e)) return void w.close(i) }f(), n.$broadcast('uis:select', e), w.closeOnSelect && w.close(i) } } }, w.close = function (t) { w.open && (w.ngModel && w.ngModel.$setTouched && w.ngModel.$setTouched(), w.open = !1, f(), n.$broadcast('uis:close', t)) }, w.setFocus = function () { w.focus || w.focusInput[0].focus() }, w.clear = function (t) { w.select(null), t.stopPropagation(), r(function () { w.focusser[0].focus() }, 0, !1) }, w.toggle = function (t) { w.open ? (w.close(), t.preventDefault(), t.stopPropagation()) : w.activate() }, w.isLocked = function () { return !1 }, n.$watch(function () { return angular.isDefined(w.lockChoiceExpression) && w.lockChoiceExpression !== '' }, y); let M = null; let C = !1; w.sizeSearchInput = function () { const t = w.searchInput[0]; const e = w.$element[0]; const i = function () { return e.clientWidth * !!t.offsetParent }; const a = function (e) { if (e === 0) return !1; let n = e - t.offsetLeft; return n < 50 && (n = e), w.searchInput.css('width', n + 'px'), !0 }; w.searchInput.css('width', '10px'), r(function () { M !== null || a(i()) || (M = n.$watch(function () { C || (C = !0, n.$$postDigest(function () { C = !1, a(i()) && (M(), M = null) })) }, angular.noop)) }) }, w.searchInput.on('keydown', function (t) { const i = t.which; ~[e.ENTER, e.ESC].indexOf(i) && (t.preventDefault(), t.stopPropagation()), n.$apply(function () { let n = !1; if ((w.items.length > 0 || w.tagging.isActivated) && (b(i) || w.searchEnabled || (t.preventDefault(), t.stopPropagation()), w.taggingTokens.isActivated)) { for (let a = 0; a < w.taggingTokens.tokens.length; a++)w.taggingTokens.tokens[a] === e.MAP[t.keyCode] && w.search.length > 0 && (n = !0); n && r(function () { w.searchInput.triggerHandler('tagged'); let n = w.search.replace(e.MAP[t.keyCode], '').trim(); w.tagging.fct && (n = w.tagging.fct(n)), n && w.select(n, !0) }) } }), e.isVerticalMovement(i) && w.items.length > 0 && x(), i !== e.ENTER && i !== e.ESC || (t.preventDefault(), t.stopPropagation()) }), w.searchInput.on('paste', function (t) { let n; if (n = window.clipboardData && window.clipboardData.getData ? window.clipboardData.getData('Text') : (t.originalEvent || t).clipboardData.getData('text/plain'), (n = w.search + n) && n.length > 0) if (w.taggingTokens.isActivated) { for (var i = [], r = 0; r < w.taggingTokens.tokens.length; r++) { const a = e.toSeparator(w.taggingTokens.tokens[r]) || w.taggingTokens.tokens[r]; if (n.indexOf(a) > -1) { i = n.split(a); break } }i.length === 0 && (i = [n]); const o = w.search; angular.forEach(i, function (t) { const e = w.tagging.fct ? w.tagging.fct(t) : t; e && w.select(e, !0) }), w.search = o || _, t.preventDefault(), t.stopPropagation() } else w.paste && (w.paste(n), w.search = _, t.preventDefault(), t.stopPropagation()) }), w.searchInput.on('tagged', function () { r(function () { f() }) }); const E = o(function () { w.sizeSearchInput() }, 50); angular.element(p).bind('resize', E), n.$on('$destroy', function () { w.searchInput.off('keyup keydown tagged blur paste'), angular.element(p).off('resize', E) }), n.$watch('$select.activeIndex', function (t) { t && i.find('input').attr('aria-activedescendant', 'ui-select-choices-row-' + w.generatedId + '-' + t) }), n.$watch('$select.open', function (t) { t || i.find('input').removeAttr('aria-activedescendant') }) }]), i.directive('uiSelect', ['$document', 'uiSelectConfig', 'uiSelectMinErr', 'uisOffset', '$compile', '$parse', '$timeout', function (t, e, n, i, r, a, o) { return { restrict: 'EA', templateUrl: function (t, n) { return (n.theme || e.theme) + (angular.isDefined(n.multiple) ? '/select-multiple.tpl.html' : '/select.tpl.html') }, replace: !0, transclude: !0, require: ['uiSelect', '^ngModel'], scope: !0, controller: 'uiSelectCtrl', controllerAs: '$select', compile: function (r, s) { const l = /{(.*)}\s*{(.*)}/.exec(s.ngClass); if (l) { const c = '{' + l[1] + ', ' + l[2] + '}'; s.ngClass = c, r.attr('ng-class', c) } return angular.isDefined(s.multiple) ? r.append('<ui-select-multiple/>').removeAttr('multiple') : r.append('<ui-select-single/>'), s.inputId && (r.querySelectorAll('input.ui-select-search')[0].id = s.inputId), function (r, s, l, c, u) { function h (t) { if (f.open) { if (!(window.jQuery ? window.jQuery.contains(s[0], t.target) : s[0].contains(t.target)) && !f.clickTriggeredSelect) { let e; if (f.skipFocusser)e = !0; else { const n = ['input', 'button', 'textarea', 'select']; const i = angular.element(t.target).controller('uiSelect'); e = i && i !== f, e || (e = ~n.indexOf(t.target.tagName.toLowerCase())) }f.close(e), r.$digest() }f.clickTriggeredSelect = !1 } } function p () { const e = i(s); v = angular.element('<div class="ui-select-placeholder"></div>'), v[0].style.width = e.width + 'px', v[0].style.height = e.height + 'px', s.after(v), y = s[0].style.width, t.find('body').append(s), s[0].style.position = 'absolute', s[0].style.left = e.left + 'px', s[0].style.top = e.top + 'px', s[0].style.width = e.width + 'px' } function d () { v !== null && (v.replaceWith(s), v = null, s[0].style.position = '', s[0].style.left = '', s[0].style.top = '', s[0].style.width = y, f.setFocus()) } var f = c[0]; const m = c[1]; f.generatedId = e.generateId(), f.baseTitle = l.title || 'Select box', f.focusserTitle = f.baseTitle + ' focus', f.focusserId = 'focusser-' + f.generatedId, f.closeOnSelect = (function () { return angular.isDefined(l.closeOnSelect) ? a(l.closeOnSelect)() : e.closeOnSelect }()), r.$watch('skipFocusser', function () { const t = r.$eval(l.skipFocusser); f.skipFocusser = void 0 !== t ? t : e.skipFocusser }), f.onSelectCallback = a(l.onSelect), f.onRemoveCallback = a(l.onRemove), f.ngModel = m, f.choiceGrouped = function (t) { return f.isGrouped && t && t.name }, l.tabindex && l.$observe('tabindex', function (t) { f.focusInput.attr('tabindex', t), s.removeAttr('tabindex') }), r.$watch(function () { return r.$eval(l.searchEnabled) }, function (t) { f.searchEnabled = void 0 !== t ? t : e.searchEnabled }), r.$watch('sortable', function () { const t = r.$eval(l.sortable); f.sortable = void 0 !== t ? t : e.sortable }), l.$observe('backspaceReset', function () { const t = r.$eval(l.backspaceReset); f.backspaceReset = void 0 === t || t }), l.$observe('limit', function () { f.limit = angular.isDefined(l.limit) ? parseInt(l.limit, 10) : void 0 }), r.$watch('removeSelected', function () { const t = r.$eval(l.removeSelected); f.removeSelected = void 0 !== t ? t : e.removeSelected }), l.$observe('disabled', function () { f.disabled = void 0 !== l.disabled && l.disabled }), l.$observe('resetSearchInput', function () { const t = r.$eval(l.resetSearchInput); f.resetSearchInput = void 0 === t || t }), l.$observe('paste', function () { f.paste = r.$eval(l.paste) }), l.$observe('tagging', function () { if (void 0 !== l.tagging) { const t = r.$eval(l.tagging); f.tagging = { isActivated: !0, fct: !0 !== t ? t : void 0 } } else f.tagging = { isActivated: !1, fct: void 0 } }), l.$observe('taggingLabel', function () { void 0 !== l.tagging && (l.taggingLabel === 'false' ? f.taggingLabel = !1 : f.taggingLabel = void 0 !== l.taggingLabel ? l.taggingLabel : '(new)') }), l.$observe('taggingTokens', function () { if (void 0 !== l.tagging) { const t = void 0 !== l.taggingTokens ? l.taggingTokens.split('|') : [',', 'ENTER']; f.taggingTokens = { isActivated: !0, tokens: t } } }), l.$observe('spinnerEnabled', function () { const t = r.$eval(l.spinnerEnabled); f.spinnerEnabled = void 0 !== t ? t : e.spinnerEnabled }), l.$observe('spinnerClass', function () { const t = l.spinnerClass; f.spinnerClass = void 0 !== t ? l.spinnerClass : e.spinnerClass }), angular.isDefined(l.autofocus) && o(function () { f.setFocus() }), angular.isDefined(l.focusOn) && r.$on(l.focusOn, function () { o(function () { f.setFocus() }) }), t.on('click', h), r.$on('$destroy', function () { t.off('click', h) }), u(r, function (t) { const e = angular.element('<div>').append(t); const i = e.querySelectorAll('.ui-select-match'); if (i.removeAttr('ui-select-match'), i.removeAttr('data-ui-select-match'), i.length !== 1) throw n('transcluded', "Expected 1 .ui-select-match but got '{0}'.", i.length); s.querySelectorAll('.ui-select-match').replaceWith(i); const r = e.querySelectorAll('.ui-select-choices'); if (r.removeAttr('ui-select-choices'), r.removeAttr('data-ui-select-choices'), r.length !== 1) throw n('transcluded', "Expected 1 .ui-select-choices but got '{0}'.", r.length); s.querySelectorAll('.ui-select-choices').replaceWith(r); const a = e.querySelectorAll('.ui-select-no-choice'); a.removeAttr('ui-select-no-choice'), a.removeAttr('data-ui-select-no-choice'), a.length == 1 && s.querySelectorAll('.ui-select-no-choice').replaceWith(a) }); const g = r.$eval(l.appendToBody); (void 0 !== g ? g : e.appendToBody) && (r.$watch('$select.open', function (t) { t ? p() : d() }), r.$on('$destroy', function () { d() })); var v = null; var y = ''; let b = null; r.$watch('$select.open', function () { f.dropdownPosition !== 'auto' && f.dropdownPosition !== 'up' || r.calculateDropdownPos() }); const x = function (t, e) { t = t || i(s), e = e || i(b), b[0].style.position = 'absolute', b[0].style.top = -1 * e.height + 'px', s.addClass('direction-up') }; const w = function (t, e) { s.removeClass('direction-up'), t = t || i(s), e = e || i(b), b[0].style.position = '', b[0].style.top = '' }; const _ = function () { o(function () { if (f.dropdownPosition === 'up')x(); else { s.removeClass('direction-up'); const e = i(s); const n = i(b); const r = t[0].documentElement.scrollTop || t[0].body.scrollTop; e.top + e.height + n.height > r + t[0].documentElement.clientHeight ? x(e, n) : w(e, n) }b[0].style.opacity = 1 }) }; let $ = !1; r.calculateDropdownPos = function () { if (f.open) { if (b = angular.element(s).querySelectorAll('.ui-select-dropdown'), b.length === 0) return; if (f.search !== '' || $ || (b[0].style.opacity = 0, $ = !0), !i(b).height && f.$animate && f.$animate.on && f.$animate.enabled(b)) { let t = !0; f.$animate.on('enter', b, function (e, n) { n === 'close' && t && (_(), t = !1) }) } else _() } else { if (b === null || b.length === 0) return; b[0].style.opacity = 0, b[0].style.position = '', b[0].style.top = '', s.removeClass('direction-up') } } } } } }]), i.directive('uiSelectMatch', ['uiSelectConfig', function (t) { function e (t, e) { return t[0].hasAttribute(e) ? t.attr(e) : t[0].hasAttribute('data-' + e) ? t.attr('data-' + e) : t[0].hasAttribute('x-' + e) ? t.attr('x-' + e) : void 0 } return { restrict: 'EA', require: '^uiSelect', replace: !0, transclude: !0, templateUrl: function (n) { n.addClass('ui-select-match'); const i = n.parent(); return (e(i, 'theme') || t.theme) + (angular.isDefined(e(i, 'multiple')) ? '/match-multiple.tpl.html' : '/match.tpl.html') }, link: function (e, n, i, r) { function a (t) { r.allowClear = !!angular.isDefined(t) && (t === '' || t.toLowerCase() === 'true') }r.lockChoiceExpression = i.uiLockChoice, i.$observe('placeholder', function (e) { r.placeholder = void 0 !== e ? e : t.placeholder }), i.$observe('allowClear', a), a(i.allowClear), r.multiple && r.sizeSearchInput() } } }]), i.directive('uiSelectMultiple', ['uiSelectMinErr', '$timeout', function (n, i) { return { restrict: 'EA', require: ['^uiSelect', '^ngModel'], controller: ['$scope', '$timeout', function (t, e) { let n; const i = this; const r = t.$select; angular.isUndefined(r.selected) && (r.selected = []), t.$evalAsync(function () { n = t.ngModel }), i.activeMatchIndex = -1, i.updateModel = function () { n.$setViewValue(Date.now()), i.refreshComponent() }, i.refreshComponent = function () { r.refreshItems && r.refreshItems(), r.sizeSearchInput && r.sizeSearchInput() }, i.removeChoice = function (n) { if (r.isLocked(null, n)) return !1; const a = r.selected[n]; const o = {}; return o[r.parserResult.itemName] = a, r.selected.splice(n, 1), i.activeMatchIndex = -1, r.sizeSearchInput(), e(function () { r.onRemoveCallback(t, { $item: a, $model: r.parserResult.modelMapper(t, o) }) }), i.updateModel(), !0 }, i.getPlaceholder = function () { if (!r.selected || !r.selected.length) return r.placeholder } }], controllerAs: '$selectMultiple', link: function (r, a, o, s) { function l (t) { return angular.isNumber(t.selectionStart) ? t.selectionStart : t.value.length } function c (t) { const n = l(p.searchInput[0]); const i = p.selected.length; const r = i - 1; const a = f.activeMatchIndex; const o = f.activeMatchIndex + 1; const s = f.activeMatchIndex - 1; let c = a; return !(n > 0 || p.search.length && t == e.RIGHT) && (p.close(), c = (function () { switch (t) { case e.LEFT:return ~f.activeMatchIndex ? s : r; case e.RIGHT:return ~f.activeMatchIndex && a !== r ? o : (p.activate(), !1); case e.BACKSPACE:return ~f.activeMatchIndex ? f.removeChoice(a) ? s : a : r; case e.DELETE:return !!~f.activeMatchIndex && (f.removeChoice(f.activeMatchIndex), a) } }()), p.selected.length && !1 !== c ? f.activeMatchIndex = Math.min(r, Math.max(0, c)) : f.activeMatchIndex = -1, !0) } function u (t) { return void 0 !== t && void 0 !== p.search && t.filter(function (t) { return void 0 !== p.search.toUpperCase() && void 0 !== t && t.toUpperCase() === p.search.toUpperCase() }).length > 0 } function h (t, e) { let n = -1; if (angular.isArray(t)) for (let i = angular.copy(t), r = 0; r < i.length; r++) if (void 0 === p.tagging.fct)i[r] + ' ' + p.taggingLabel === e && (n = r); else { const a = i[r]; angular.isObject(a) && (a.isTag = !0), angular.equals(a, e) && (n = r) } return n } var p = s[0]; const d = r.ngModel = s[1]; var f = r.$selectMultiple; p.multiple = !0, p.focusInput = p.searchInput, d.$isEmpty = function (t) { return !t || t.length === 0 }, d.$parsers.unshift(function () { for (var t, e = {}, n = [], i = p.selected.length - 1; i >= 0; i--)e = {}, e[p.parserResult.itemName] = p.selected[i], t = p.parserResult.modelMapper(r, e), n.unshift(t); return n }), d.$formatters.unshift(function (t) { let e; const n = p.parserResult && p.parserResult.source(r, { $select: { search: '' } }); const i = {}; if (!n) return t; const a = []; const o = function (t, n) { if (t && t.length) { for (let o = t.length - 1; o >= 0; o--) { if (i[p.parserResult.itemName] = t[o], e = p.parserResult.modelMapper(r, i), p.parserResult.trackByExp) { const s = /(\w*)\./.exec(p.parserResult.trackByExp); const l = /\.([^\s]+)/.exec(p.parserResult.trackByExp); if (s && s.length > 0 && s[1] == p.parserResult.itemName && l && l.length > 0 && e[l[1]] == n[l[1]]) return a.unshift(t[o]), !0 } if (angular.equals(e, n)) return a.unshift(t[o]), !0 } return !1 } }; if (!t) return a; for (let s = t.length - 1; s >= 0; s--)o(p.selected, t[s]) || o(n, t[s]) || a.unshift(t[s]); return a }), r.$watchCollection(function () { return d.$modelValue }, function (t, e) { e != t && (angular.isDefined(d.$modelValue) && (d.$modelValue = null), f.refreshComponent()) }), d.$render = function () { if (!angular.isArray(d.$viewValue)) { if (!t(d.$viewValue)) throw n('multiarr', "Expected model value to be array but got '{0}'", d.$viewValue); d.$viewValue = [] }p.selected = d.$viewValue, f.refreshComponent(), r.$evalAsync() }, r.$on('uis:select', function (t, e) { if (!(p.selected.length >= p.limit)) { p.selected.push(e); const n = {}; n[p.parserResult.itemName] = e, i(function () { p.onSelectCallback(r, { $item: e, $model: p.parserResult.modelMapper(r, n) }) }), f.updateModel() } }), r.$on('uis:activate', function () { f.activeMatchIndex = -1 }), r.$watch('$select.disabled', function (t, e) { e && !t && p.sizeSearchInput() }), p.searchInput.on('keydown', function (t) { const n = t.which; r.$apply(function () { let i = !1; e.isHorizontalMovement(n) && (i = c(n)), i && n != e.TAB && (t.preventDefault(), t.stopPropagation()) }) }), p.searchInput.on('keyup', function (t) { if (e.isVerticalMovement(t.which) || r.$evalAsync(function () { p.activeIndex = !1 === p.taggingLabel ? -1 : 0 }), p.tagging.isActivated && p.search.length > 0) { if (t.which === e.TAB || e.isControl(t) || e.isFunctionKey(t) || t.which === e.ESC || e.isVerticalMovement(t.which)) return; if (p.activeIndex = !1 === p.taggingLabel ? -1 : 0, !1 === p.taggingLabel) return; let n; let i; let a; let o; let s = angular.copy(p.items); let l = angular.copy(p.items); let c = !1; let d = -1; if (void 0 !== p.tagging.fct) { if (a = p.$filter('filter')(s, { isTag: !0 }), a.length > 0 && (o = a[0]), s.length > 0 && o && (c = !0, s = s.slice(1, s.length), l = l.slice(1, l.length)), n = p.tagging.fct(p.search), l.some(function (t) { return angular.equals(t, n) }) || p.selected.some(function (t) { return angular.equals(t, n) })) return void r.$evalAsync(function () { p.activeIndex = 0, p.items = s }); n && (n.isTag = !0) } else { if (a = p.$filter('filter')(s, function (t) { return t.match(p.taggingLabel) }), a.length > 0 && (o = a[0]), i = s[0], void 0 !== i && s.length > 0 && o && (c = !0, s = s.slice(1, s.length), l = l.slice(1, l.length)), n = p.search + ' ' + p.taggingLabel, h(p.selected, p.search) > -1) return; if (u(l.concat(p.selected))) return void (c && (s = l, r.$evalAsync(function () { p.activeIndex = 0, p.items = s }))); if (u(l)) return void (c && (p.items = l.slice(1, l.length))) }c && (d = h(p.selected, n)), d > -1 ? s = s.slice(d + 1, s.length - 1) : (s = [], n && s.push(n), s = s.concat(l)), r.$evalAsync(function () { if (p.activeIndex = 0, p.items = s, p.isGrouped) { const t = n ? s.slice(1) : s; p.setItemsFn(t), n && (p.items.unshift(n), p.groups.unshift({ name: '', items: [n], tagging: !0 })) } }) } }), p.searchInput.on('blur', function () { i(function () { f.activeMatchIndex = -1 }) }) } } }]), i.directive('uiSelectNoChoice', ['uiSelectConfig', function (t) { return { restrict: 'EA', require: '^uiSelect', replace: !0, transclude: !0, templateUrl: function (e) { return e.addClass('ui-select-no-choice'), (e.parent().attr('theme') || t.theme) + '/no-choice.tpl.html' } } }]), i.directive('uiSelectSingle', ['$timeout', '$compile', function (n, i) { return { restrict: 'EA', require: ['^uiSelect', '^ngModel'], link: function (r, a, o, s) { const l = s[0]; const c = s[1]; c.$parsers.unshift(function (e) { if (t(e)) return e; const n = {}; return n[l.parserResult.itemName] = e, l.parserResult.modelMapper(r, n) }), c.$formatters.unshift(function (e) { if (t(e)) return e; let n; const i = l.parserResult && l.parserResult.source(r, { $select: { search: '' } }); const a = {}; if (i) { const o = function (t) { return a[l.parserResult.itemName] = t, (n = l.parserResult.modelMapper(r, a)) === e }; if (l.selected && o(l.selected)) return l.selected; for (let s = i.length - 1; s >= 0; s--) if (o(i[s])) return i[s] } return e }), r.$watch('$select.selected', function (t) { c.$viewValue !== t && c.$setViewValue(t) }), c.$render = function () { l.selected = c.$viewValue }, r.$on('uis:select', function (e, i) { l.selected = i; const a = {}; a[l.parserResult.itemName] = i, n(function () { l.onSelectCallback(r, { $item: i, $model: t(i) ? i : l.parserResult.modelMapper(r, a) }) }) }), r.$on('uis:close', function (t, e) { n(function () { l.focusser.prop('disabled', !1), e || l.focusser[0].focus() }, 0, !1) }), r.$on('uis:activate', function () { u.prop('disabled', !0) }); var u = angular.element("<input ng-disabled='$select.disabled' class='ui-select-focusser ui-select-offscreen' type='text' id='{{ $select.focusserId }}' aria-label='{{ $select.focusserTitle }}' aria-haspopup='true' role='button' />"); i(u)(r), l.focusser = u, l.focusInput = u, a.parent().append(u), u.bind('focus', function () { r.$evalAsync(function () { l.focus = !0 }) }), u.bind('blur', function () { r.$evalAsync(function () { l.focus = !1 }) }), u.bind('keydown', function (t) { if (t.which === e.BACKSPACE && !1 !== l.backspaceReset) return t.preventDefault(), t.stopPropagation(), l.select(void 0), void r.$apply(); t.which === e.TAB || e.isControl(t) || e.isFunctionKey(t) || t.which === e.ESC || (t.which != e.DOWN && t.which != e.UP && t.which != e.ENTER && t.which != e.SPACE || (t.preventDefault(), t.stopPropagation(), l.activate()), r.$digest()) }), u.bind('keyup input', function (t) { t.which === e.TAB || e.isControl(t) || e.isFunctionKey(t) || t.which === e.ESC || t.which == e.ENTER || t.which === e.BACKSPACE || (l.activate(u.val()), u.val(''), r.$digest()) }) } } }]), i.directive('uiSelectSort', ['$timeout', 'uiSelectConfig', 'uiSelectMinErr', function (t, e, n) { return { require: ['^^uiSelect', '^ngModel'], link: function (e, i, r, a) { if (e[r.uiSelectSort] === null) throw n('sort', 'Expected a list to sort'); const o = a[0]; const s = a[1]; const l = angular.extend({ axis: 'horizontal' }, e.$eval(r.uiSelectSortOptions)); const c = l.axis; e.$watch(function () { return o.sortable }, function (t) { t ? i.attr('draggable', !0) : i.removeAttr('draggable') }), i.on('dragstart', function (t) { i.addClass('dragging'), (t.dataTransfer || t.originalEvent.dataTransfer).setData('text', e.$index.toString()) }), i.on('dragend', function () { p('dragging') }); let u; const h = function (t, e) { this.splice(e, 0, this.splice(t, 1)[0]) }; var p = function (t) { angular.forEach(o.$element.querySelectorAll('.' + t), function (e) { angular.element(e).removeClass(t) }) }; const d = function (t) { t.preventDefault(), (c === 'vertical' ? t.offsetY || t.layerY || (t.originalEvent ? t.originalEvent.offsetY : 0) : t.offsetX || t.layerX || (t.originalEvent ? t.originalEvent.offsetX : 0)) < this[c === 'vertical' ? 'offsetHeight' : 'offsetWidth'] / 2 ? (p('dropping-after'), i.addClass('dropping-before')) : (p('dropping-before'), i.addClass('dropping-after')) }; const f = function (e) { e.preventDefault(); const n = parseInt((e.dataTransfer || e.originalEvent.dataTransfer).getData('text'), 10); t.cancel(u), u = t(function () { m(n) }, 20) }; var m = function (t) { const n = e.$eval(r.uiSelectSort); const a = n[t]; let o = null; o = i.hasClass('dropping-before') ? t < e.$index ? e.$index - 1 : e.$index : t < e.$index ? e.$index : e.$index + 1, h.apply(n, [t, o]), s.$setViewValue(Date.now()), e.$apply(function () { e.$emit('uiSelectSort:change', { array: n, item: a, from: t, to: o }) }), p('dropping'), p('dropping-before'), p('dropping-after'), i.off('drop', f) }; i.on('dragenter', function () { i.hasClass('dragging') || (i.addClass('dropping'), i.on('dragover', d), i.on('drop', f)) }), i.on('dragleave', function (t) { t.target == i && (p('dropping'), p('dropping-before'), p('dropping-after'), i.off('dragover', d), i.off('drop', f)) }) } } }]), i.directive('uisOpenClose', ['$parse', '$timeout', function (t, e) { return { restrict: 'A', require: 'uiSelect', link: function (n, i, r, a) { a.onOpenCloseCallback = t(r.uisOpenClose), n.$watch('$select.open', function (t, i) { t !== i && e(function () { a.onOpenCloseCallback(n, { isOpen: t }) }) }) } } }]), i.service('uisRepeatParser', ['uiSelectMinErr', '$parse', function (t, e) {
    const n = this; n.parse = function (n) {
      let i; if (!(i = n.match(/^\s*(?:([\s\S]+?)\s+as\s+)?(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+(\s*[\s\S]+?)?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/))) throw t('iexp', "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", n); let r = i[5]; let a = ''; if (i[3]) { r = i[5].replace(/(^\()|(\)$)/g, ''); const o = i[5].match(/^\s*(?:[\s\S]+?)(?:[^\|]|\|\|)+([\s\S]*)\s*$/); o && o[1].trim() && (a = o[1], r = r.replace(a, '')) } return {
        itemName: i[4] || i[2],
        keyName: i[3],
        source: e(r),
        filters: a,
        trackByExp: i[6],
        modelMapper: e(i[1] || i[4] || i[2]),
        repeatExpression: function (t) { let e = this.itemName + ' in ' + (t ? '$group.items' : '$select.items'); return this.trackByExp && (e += ' track by ' + this.trackByExp), e }
      }
    }, n.getGroupNgRepeatExpression = function () { return '$group in $select.groups track by $group.name' }
  }])
}()), angular.module('ui.select').run(['$templateCache', function (t) { t.put('bootstrap/choices.tpl.html', '<ul class="ui-select-choices ui-select-choices-content ui-select-dropdown dropdown-menu" ng-show="$select.open && $select.items.length > 0"><li class="ui-select-choices-group" id="ui-select-choices-{{ $select.generatedId }}"><div class="divider" ng-show="$select.isGrouped && $index > 0"></div><div ng-show="$select.isGrouped" class="ui-select-choices-group-label dropdown-header" ng-bind="$group.name"></div><div ng-attr-id="ui-select-choices-row-{{ $select.generatedId }}-{{$index}}" class="ui-select-choices-row" ng-class="{active: $select.isActive(this), disabled: $select.isDisabled(this)}" role="option"><span class="ui-select-choices-row-inner"></span></div></li></ul>'), t.put('bootstrap/match-multiple.tpl.html', '<span class="ui-select-match"><span ng-repeat="$item in $select.selected track by $index"><span class="ui-select-match-item btn btn-default btn-xs" tabindex="-1" type="button" ng-disabled="$select.disabled" ng-click="$selectMultiple.activeMatchIndex = $index;" ng-class="{\'btn-primary\':$selectMultiple.activeMatchIndex === $index, \'select-locked\':$select.isLocked(this, $index)}" ui-select-sort="$select.selected"><span class="close ui-select-match-close" ng-hide="$select.disabled" ng-click="$selectMultiple.removeChoice($index)">&nbsp;&times;</span> <span uis-transclude-append=""></span></span></span></span>'), t.put('bootstrap/match.tpl.html', '<div class="ui-select-match" ng-hide="$select.open && $select.searchEnabled" ng-disabled="$select.disabled" ng-class="{\'btn-default-focus\':$select.focus}"><span tabindex="-1" class="btn btn-default form-control ui-select-toggle" aria-label="{{ $select.baseTitle }} activate" ng-disabled="$select.disabled" ng-click="$select.activate()" style="outline: 0;"><span ng-show="$select.isEmpty()" class="ui-select-placeholder text-muted">{{$select.placeholder}}</span> <span ng-hide="$select.isEmpty()" class="ui-select-match-text pull-left" ng-class="{\'ui-select-allow-clear\': $select.allowClear && !$select.isEmpty()}" ng-transclude=""></span> <i class="caret pull-right" ng-click="$select.toggle($event)"></i> <a ng-show="$select.allowClear && !$select.isEmpty() && ($select.disabled !== true)" aria-label="{{ $select.baseTitle }} clear" style="margin-right: 10px" ng-click="$select.clear($event)" class="btn btn-xs btn-link pull-right"><i class="glyphicon glyphicon-remove" aria-hidden="true"></i></a></span></div>'), t.put('bootstrap/no-choice.tpl.html', '<ul class="ui-select-no-choice dropdown-menu" ng-show="$select.items.length == 0"><li ng-transclude=""></li></ul>'), t.put('bootstrap/select-multiple.tpl.html', '<div class="ui-select-container ui-select-multiple ui-select-bootstrap dropdown form-control" ng-class="{open: $select.open}"><div><div class="ui-select-match"></div><input type="search" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" class="ui-select-search input-xs" placeholder="{{$selectMultiple.getPlaceholder()}}" ng-disabled="$select.disabled" ng-click="$select.activate()" ng-model="$select.search" role="combobox" aria-expanded="{{$select.open}}" aria-label="{{$select.baseTitle}}" ng-class="{\'spinner\': $select.refreshing}" ondrop="return false;"></div><div class="ui-select-choices"></div><div class="ui-select-no-choice"></div></div>'), t.put('bootstrap/select.tpl.html', '<div class="ui-select-container ui-select-bootstrap dropdown" ng-class="{open: $select.open}"><div class="ui-select-match"></div><span ng-show="$select.open && $select.refreshing && $select.spinnerEnabled" class="ui-select-refreshing {{$select.spinnerClass}}"></span> <input type="search" autocomplete="off" tabindex="-1" aria-expanded="true" aria-label="{{ $select.baseTitle }}" aria-owns="ui-select-choices-{{ $select.generatedId }}" class="form-control ui-select-search" ng-class="{ \'ui-select-search-hidden\' : !$select.searchEnabled }" placeholder="{{$select.placeholder}}" ng-model="$select.search" ng-show="$select.open"><div class="ui-select-choices"></div><div class="ui-select-no-choice"></div></div>'), t.put('select2/choices.tpl.html', '<ul tabindex="-1" class="ui-select-choices ui-select-choices-content select2-results"><li class="ui-select-choices-group" ng-class="{\'select2-result-with-children\': $select.choiceGrouped($group) }"><div ng-show="$select.choiceGrouped($group)" class="ui-select-choices-group-label select2-result-label" ng-bind="$group.name"></div><ul id="ui-select-choices-{{ $select.generatedId }}" ng-class="{\'select2-result-sub\': $select.choiceGrouped($group), \'select2-result-single\': !$select.choiceGrouped($group) }"><li role="option" ng-attr-id="ui-select-choices-row-{{ $select.generatedId }}-{{$index}}" class="ui-select-choices-row" ng-class="{\'select2-highlighted\': $select.isActive(this), \'select2-disabled\': $select.isDisabled(this)}"><div class="select2-result-label ui-select-choices-row-inner"></div></li></ul></li></ul>'), t.put('select2/match-multiple.tpl.html', '<span class="ui-select-match"><li class="ui-select-match-item select2-search-choice" ng-repeat="$item in $select.selected track by $index" ng-class="{\'select2-search-choice-focus\':$selectMultiple.activeMatchIndex === $index, \'select2-locked\':$select.isLocked(this, $index)}" ui-select-sort="$select.selected"><span uis-transclude-append=""></span> <a href="javascript:;" class="ui-select-match-close select2-search-choice-close" ng-click="$selectMultiple.removeChoice($index)" tabindex="-1"></a></li></span>'), t.put('select2/match.tpl.html', '<a class="select2-choice ui-select-match" ng-class="{\'select2-default\': $select.isEmpty()}" ng-click="$select.toggle($event)" aria-label="{{ $select.baseTitle }} select"><span ng-show="$select.isEmpty()" class="select2-chosen">{{$select.placeholder}}</span> <span ng-hide="$select.isEmpty()" class="select2-chosen" ng-transclude=""></span> <abbr ng-if="$select.allowClear && !$select.isEmpty()" class="select2-search-choice-close" ng-click="$select.clear($event)"></abbr> <span class="select2-arrow ui-select-toggle"><b></b></span></a>'), t.put('select2/no-choice.tpl.html', '<div class="ui-select-no-choice dropdown" ng-show="$select.items.length == 0"><div class="dropdown-content"><div data-selectable="" ng-transclude=""></div></div></div>'), t.put('select2/select-multiple.tpl.html', '<div class="ui-select-container ui-select-multiple select2 select2-container select2-container-multi" ng-class="{\'select2-container-active select2-dropdown-open open\': $select.open, \'select2-container-disabled\': $select.disabled}"><ul class="select2-choices"><span class="ui-select-match"></span><li class="select2-search-field"><input type="search" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" role="combobox" aria-expanded="true" aria-owns="ui-select-choices-{{ $select.generatedId }}" aria-label="{{ $select.baseTitle }}" aria-activedescendant="ui-select-choices-row-{{ $select.generatedId }}-{{ $select.activeIndex }}" class="select2-input ui-select-search" placeholder="{{$selectMultiple.getPlaceholder()}}" ng-disabled="$select.disabled" ng-hide="$select.disabled" ng-model="$select.search" ng-click="$select.activate()" style="width: 34px;" ondrop="return false;"></li></ul><div class="ui-select-dropdown select2-drop select2-with-searchbox select2-drop-active" ng-class="{\'select2-display-none\': !$select.open || $select.items.length === 0}"><div class="ui-select-choices"></div></div></div>'), t.put('select2/select.tpl.html', '<div class="ui-select-container select2 select2-container" ng-class="{\'select2-container-active select2-dropdown-open open\': $select.open, \'select2-container-disabled\': $select.disabled, \'select2-container-active\': $select.focus, \'select2-allowclear\': $select.allowClear && !$select.isEmpty()}"><div class="ui-select-match"></div><div class="ui-select-dropdown select2-drop select2-with-searchbox select2-drop-active" ng-class="{\'select2-display-none\': !$select.open}"><div class="search-container" ng-class="{\'ui-select-search-hidden\':!$select.searchEnabled, \'select2-search\':$select.searchEnabled}"><input type="search" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" ng-class="{\'select2-active\': $select.refreshing}" role="combobox" aria-expanded="true" aria-owns="ui-select-choices-{{ $select.generatedId }}" aria-label="{{ $select.baseTitle }}" class="ui-select-search select2-input" ng-model="$select.search"></div><div class="ui-select-choices"></div><div class="ui-select-no-choice"></div></div></div>'), t.put('selectize/choices.tpl.html', '<div ng-show="$select.open" class="ui-select-choices ui-select-dropdown selectize-dropdown" ng-class="{\'single\': !$select.multiple, \'multi\': $select.multiple}"><div class="ui-select-choices-content selectize-dropdown-content"><div class="ui-select-choices-group optgroup"><div ng-show="$select.isGrouped" class="ui-select-choices-group-label optgroup-header" ng-bind="$group.name"></div><div role="option" class="ui-select-choices-row" ng-class="{active: $select.isActive(this), disabled: $select.isDisabled(this)}"><div class="option ui-select-choices-row-inner" data-selectable=""></div></div></div></div></div>'), t.put('selectize/match-multiple.tpl.html', '<div class="ui-select-match" data-value="" ng-repeat="$item in $select.selected track by $index" ng-click="$selectMultiple.activeMatchIndex = $index;" ng-class="{\'active\':$selectMultiple.activeMatchIndex === $index}" ui-select-sort="$select.selected"><span class="ui-select-match-item" ng-class="{\'select-locked\':$select.isLocked(this, $index)}"><span uis-transclude-append=""></span> <span class="remove ui-select-match-close" ng-hide="$select.disabled" ng-click="$selectMultiple.removeChoice($index)">&times;</span></span></div>'), t.put('selectize/match.tpl.html', '<div ng-hide="$select.searchEnabled && ($select.open || $select.isEmpty())" class="ui-select-match"><span ng-show="!$select.searchEnabled && ($select.isEmpty() || $select.open)" class="ui-select-placeholder text-muted">{{$select.placeholder}}</span> <span ng-hide="$select.isEmpty() || $select.open" ng-transclude=""></span></div>'), t.put('selectize/no-choice.tpl.html', '<div class="ui-select-no-choice selectize-dropdown" ng-show="$select.items.length == 0"><div class="selectize-dropdown-content"><div data-selectable="" ng-transclude=""></div></div></div>'), t.put('selectize/select-multiple.tpl.html', '<div class="ui-select-container selectize-control multi plugin-remove_button" ng-class="{\'open\': $select.open}"><div class="selectize-input" ng-class="{\'focus\': $select.open, \'disabled\': $select.disabled, \'selectize-focus\' : $select.focus}" ng-click="$select.open && !$select.searchEnabled ? $select.toggle($event) : $select.activate()"><div class="ui-select-match"></div><input type="search" autocomplete="off" tabindex="-1" class="ui-select-search" ng-class="{\'ui-select-search-hidden\':!$select.searchEnabled}" placeholder="{{$selectMultiple.getPlaceholder()}}" ng-model="$select.search" ng-disabled="$select.disabled" aria-expanded="{{$select.open}}" aria-label="{{ $select.baseTitle }}" ondrop="return false;"></div><div class="ui-select-choices"></div><div class="ui-select-no-choice"></div></div>'), t.put('selectize/select.tpl.html', '<div class="ui-select-container selectize-control single" ng-class="{\'open\': $select.open}"><div class="selectize-input" ng-class="{\'focus\': $select.open, \'disabled\': $select.disabled, \'selectize-focus\' : $select.focus}" ng-click="$select.open && !$select.searchEnabled ? $select.toggle($event) : $select.activate()"><div class="ui-select-match"></div><input type="search" autocomplete="off" tabindex="-1" class="ui-select-search ui-select-toggle" ng-class="{\'ui-select-search-hidden\':!$select.searchEnabled}" ng-click="$select.toggle($event)" placeholder="{{$select.placeholder}}" ng-model="$select.search" ng-hide="!$select.isEmpty() && !$select.open" ng-disabled="$select.disabled" aria-label="{{ $select.baseTitle }}"></div><div class="ui-select-choices"></div><div class="ui-select-no-choice"></div></div>') }]), (function (t, e) { 'use strict'; function n () { function n (t, e) { let n; const i = {}; const r = t.split(','); for (n = 0; n < r.length; n++)i[e ? l(r[n]) : r[n]] = !0; return i } function i (e, n) { e === null || void 0 === e ? e = '' : typeof e !== 'string' && (e = '' + e), y.innerHTML = e; let i = 5; do { if (i === 0) throw p('uinput', 'Failed to sanitize html because the input is unstable'); i--, t.document.documentMode && g(y), e = y.innerHTML, y.innerHTML = e } while (e !== y.innerHTML); for (var r = y.firstChild; r;) { switch (r.nodeType) { case 1:n.start(r.nodeName.toLowerCase(), d(r.attributes)); break; case 3:n.chars(r.textContent) } var a; if (!((a = r.firstChild) || (r.nodeType === 1 && n.end(r.nodeName.toLowerCase()), a = r.nextSibling))) for (;a == null && (r = r.parentNode) !== y;)a = r.nextSibling, r.nodeType === 1 && n.end(r.nodeName.toLowerCase()); r = a } for (;r = y.firstChild;)y.removeChild(r) } function d (t) { for (var e = {}, n = 0, i = t.length; n < i; n++) { const r = t[n]; e[r.name] = r.value } return e } function f (t) { return t.replace(/&/g, '&amp;').replace(b, function (t) { return '&#' + (1024 * (t.charCodeAt(0) - 55296) + (t.charCodeAt(1) - 56320) + 65536) + ';' }).replace(x, function (t) { return '&#' + t.charCodeAt(0) + ';' }).replace(/</g, '&lt;').replace(/>/g, '&gt;') } function m (t, e) { let n = !1; const i = r(t, t.push); return { start: function (t, r) { t = l(t), !n && E[t] && (n = t), n || !0 !== A[t] || (i('<'), i(t), o(r, function (n, r) { const a = l(r); const o = t === 'img' && a === 'src' || a === 'background'; !0 !== O[a] || !0 === P[a] && !e(n, o) || (i(' '), i(r), i('="'), i(f(n)), i('"')) }), i('>')) }, end: function (t) { t = l(t), n || !0 !== A[t] || !0 === w[t] || (i('</'), i(t), i('>')), t == n && (n = !1) }, chars: function (t) { n || i(f(t)) } } } function g (e) { for (;e;) { if (e.nodeType === t.Node.ELEMENT_NODE) for (let n = e.attributes, i = 0, r = n.length; i < r; i++) { const a = n[i]; const o = a.name.toLowerCase(); o !== 'xmlns:ns1' && o.lastIndexOf('ns1:', 0) !== 0 || (e.removeAttributeNode(a), i--, r--) } const s = e.firstChild; s && g(s), e = e.nextSibling } } let v = !1; this.$get = ['$$sanitizeUri', function (t) { return v && a(A, C), function (e) { const n = []; return u(e, h(n, function (e, n) { return !/^unsafe:/.test(t(e, n)) })), n.join('') } }], this.enableSvg = function (t) { return s(t) ? (v = t, this) : v }, r = e.bind, a = e.extend, o = e.forEach, s = e.isDefined, l = e.lowercase, c = e.noop, u = i, h = m; let y; var b = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g; var x = /([^#-~ |!])/g; var w = n('area,br,col,hr,img,wbr'); const _ = n('colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr'); const $ = n('rp,rt'); const T = a({}, $, _); const S = a({}, _, n('address,article,aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,section,table,ul')); const M = a({}, $, n('a,abbr,acronym,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s,samp,small,span,strike,strong,sub,sup,time,tt,u,var')); var C = n('circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph,hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline,radialGradient,rect,stop,svg,switch,text,title,tspan'); var E = n('script,style'); var A = a({}, w, S, M, T); var P = n('background,cite,href,longdesc,src,xlink:href'); const k = n('abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,scope,scrolling,shape,size,span,start,summary,tabindex,target,title,type,valign,value,vspace,width'); const D = n('accent-height,accumulate,additive,alphabetic,arabic-form,ascent,baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content,cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch,font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging,height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical,max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1,path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position,underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility,width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan', !0); var O = a({}, P, D, k); !(function (t) { let e; if (!t.document || !t.document.implementation) throw p('noinert', "Can't create an inert html document"); e = t.document.implementation.createHTMLDocument('inert'); const n = e.documentElement || e.getDocumentElement(); const i = n.getElementsByTagName('body'); if (i.length === 1)y = i[0]; else { const r = e.createElement('html'); y = e.createElement('body'), r.appendChild(y), e.appendChild(r) } }(t)) } function i (t) { const e = []; return h(e, c).chars(t), e.join('') } let r; let a; let o; let s; let l; let c; let u; let h; var p = e.$$minErr('$sanitize'); e.module('ngSanitize', []).provider('$sanitize', n), e.module('ngSanitize').filter('linky', ['$sanitize', function (t) { const n = e.$$minErr('linky'); const r = e.isDefined; const a = e.isFunction; const o = e.isObject; const s = e.isString; return function (e, l, c) { function u (t) { t && g.push(i(t)) } if (e == null || e === '') return e; if (!s(e)) throw n('notstring', 'Expected string but received: {0}', e); for (var h, p, d, f = a(c) ? c : o(c) ? function () { return c } : function () { return {} }, m = e, g = []; h = m.match(/((ftp|https?):\/\/|(www\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>"\u201d\u2019]/i);)p = h[0], h[2] || h[4] || (p = (h[3] ? 'http://' : 'mailto:') + p), d = h.index, u(m.substr(0, d)), (function (t, e) { let n; const i = f(t); g.push('<a '); for (n in i)g.push(n + '="' + i[n] + '" '); !r(l) || 'target' in i || g.push('target="', l, '" '), g.push('href="', t.replace(/"/g, '&quot;'), '">'), u(e), g.push('</a>') }(p, h[0].replace(/^mailto:/i, ''))), m = m.substring(d + h[0].length); return u(m), t(g.join('')) } }]) }(window, window.angular)), angular.module('colorpicker.module', []).factory('Helper', function () { 'use strict'; return { closestSlider: function (t) { return (t.matches || t.webkitMatchesSelector || t.mozMatchesSelector || t.msMatchesSelector).bind(t)('I') ? t.parentNode : t }, getOffset: function (t, e) { for (var n = 0, i = 0, r = t.getBoundingClientRect(); t && !isNaN(t.offsetLeft) && !isNaN(t.offsetTop);)e || t.tagName !== 'BODY' ? (n += t.scrollLeft, i += t.scrollTop) : (n += document.documentElement.scrollLeft || t.scrollLeft, i += document.documentElement.scrollTop || t.scrollTop), t = t.offsetParent; return { top: r.top + window.pageYOffset, left: r.left + window.pageXOffset, scrollX: n, scrollY: i } }, stringParsers: [{ re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/, parse: function (t) { return [t[1], t[2], t[3], t[4]] } }, { re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/, parse: function (t) { return [2.55 * t[1], 2.55 * t[2], 2.55 * t[3], t[4]] } }, { re: /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/, parse: function (t) { return [parseInt(t[1], 16), parseInt(t[2], 16), parseInt(t[3], 16)] } }, { re: /#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/, parse: function (t) { return [parseInt(t[1] + t[1], 16), parseInt(t[2] + t[2], 16), parseInt(t[3] + t[3], 16)] } }] } }).factory('Color', ['Helper', function (t) { 'use strict'; return { value: { h: 1, s: 1, b: 1, a: 1 }, rgb: function () { const t = this.toRGB(); return 'rgb(' + t.r + ',' + t.g + ',' + t.b + ')' }, rgba: function () { const t = this.toRGB(); return 'rgba(' + t.r + ',' + t.g + ',' + t.b + ',' + t.a + ')' }, hex: function () { return this.toHex() }, RGBtoHSB: function (t, e, n, i) { t /= 255, e /= 255, n /= 255; let r, a, o, s; return o = Math.max(t, e, n), s = o - Math.min(t, e, n), r = s === 0 ? null : o === t ? (e - n) / s : o === e ? (n - t) / s + 2 : (t - e) / s + 4, r = (r + 360) % 6 * 60 / 360, a = s === 0 ? 0 : s / o, { h: r || 1, s: a, b: o, a: i || 1 } }, setColor: function (e) { e = e ? e.toLowerCase() : e; for (const n in t.stringParsers) if (t.stringParsers.hasOwnProperty(n)) { const i = t.stringParsers[n]; const r = i.re.exec(e); const a = r && i.parse(r); if (a) return this.value = this.RGBtoHSB.apply(null, a), !1 } }, setHue: function (t) { this.value.h = 1 - t }, setSaturation: function (t) { this.value.s = t }, setLightness: function (t) { this.value.b = 1 - t }, setAlpha: function (t) { this.value.a = parseInt(100 * (1 - t), 10) / 100 }, toRGB: function (t, e, n, i) { t || (t = this.value.h, e = this.value.s, n = this.value.b), t *= 360; let r, a, o, s, l; return t = t % 360 / 60, l = n * e, s = l * (1 - Math.abs(t % 2 - 1)), r = a = o = n - l, t = ~~t, r += [l, s, 0, 0, s, l][t], a += [s, l, l, s, 0, 0][t], o += [0, 0, s, l, l, s][t], { r: Math.round(255 * r), g: Math.round(255 * a), b: Math.round(255 * o), a: i || this.value.a } }, toHex: function (t, e, n, i) { const r = this.toRGB(t, e, n, i); return '#' + (1 << 24 | parseInt(r.r, 10) << 16 | parseInt(r.g, 10) << 8 | parseInt(r.b, 10)).toString(16).substr(1) } } }]).factory('Slider', ['Helper', function (t) { 'use strict'; let e = { maxLeft: 0, maxTop: 0, callLeft: null, callTop: null, knob: { top: 0, left: 0 } }; let n = {}; return { getSlider: function () { return e }, getLeftPosition: function (t) { return Math.max(0, Math.min(e.maxLeft, e.left + ((t.pageX || n.left) - n.left))) }, getTopPosition: function (t) { return Math.max(0, Math.min(e.maxTop, e.top + ((t.pageY || n.top) - n.top))) }, setSlider: function (i, r) { const a = t.closestSlider(i.target); const o = t.getOffset(a, r); const s = a.getBoundingClientRect(); const l = i.clientX - s.left; const c = i.clientY - s.top; e.knob = a.children[0].style, e.left = i.pageX - o.left - window.pageXOffset + o.scrollX, e.top = i.pageY - o.top - window.pageYOffset + o.scrollY, n = { left: i.pageX - (l - e.left), top: i.pageY - (c - e.top) } }, setSaturation: function (t, n, i) { e = { maxLeft: i, maxTop: i, callLeft: 'setSaturation', callTop: 'setLightness' }, this.setSlider(t, n) }, setHue: function (t, n, i) { e = { maxLeft: 0, maxTop: i, callLeft: !1, callTop: 'setHue' }, this.setSlider(t, n) }, setAlpha: function (t, n, i) { e = { maxLeft: 0, maxTop: i, callLeft: !1, callTop: 'setAlpha' }, this.setSlider(t, n) }, setKnob: function (t, n) { e.knob.top = t + 'px', e.knob.left = n + 'px' } } }]).directive('colorpicker', ['$document', '$compile', 'Color', 'Slider', 'Helper', function (t, e, n, i, r) { 'use strict'; return { require: '?ngModel', restrict: 'A', link: function (a, o, s, l) { function c () { t.on('mousemove', h), t.on('mouseup', p) } function u () { try { R.css('backgroundColor', D[x]()) } catch (t) { R.css('backgroundColor', D.toHex()) }I.css('backgroundColor', D.toHex(D.value.h, 1, 1, 1)), x === 'rgba' && (b.css.backgroundColor = D.toHex()) } function h (t) { const e = i.getLeftPosition(t); const n = i.getTopPosition(t); const r = i.getSlider(); i.setKnob(n, e), r.callLeft && D[r.callLeft].call(D, e / M), r.callTop && D[r.callTop].call(D, n / M), u(); const s = D[x](); return o.val(s), l && a.$apply(l.$setViewValue(s)), S && F.val(s), !1 } function p () { v('colorpicker-selected'), t.off('mousemove', h), t.off('mouseup', p) } function d (t) { D.value = O, D.setColor(o.val()), S && !t && F.val(o.val()), N.eq(0).css({ left: D.value.s * M + 'px', top: M - D.value.b * M + 'px' }), N.eq(1).css('top', M * (1 - D.value.h) + 'px'), N.eq(2).css('top', M * (1 - D.value.a) + 'px'), O = D.value, u() } function f () { let t; const e = r.getOffset(o[0]); return angular.isDefined(s.colorpickerParent) && (e.left = 0, e.top = 0), w === 'top' ? t = { top: e.top - 147, left: e.left } : w === 'right' ? t = { top: e.top, left: e.left + 126 } : w === 'bottom' ? t = { top: e.top + o[0].offsetHeight + 2, left: e.left } : w === 'left' && (t = { top: e.top, left: e.left - 150 }), { top: t.top + 'px', left: t.left + 'px' } } function m () { y() } function g () { k.hasClass('colorpicker-visible') || (d(), k.addClass('colorpicker-visible').css(f()), v('colorpicker-shown'), !1 === _ && t.on('mousedown', m), s.colorpickerIsOpen && (a[s.colorpickerIsOpen] = !0, a.$$phase && a.$root.$$phase || a.$digest())) } function v (t) { l && a.$emit(t, { name: s.ngModel, value: l.$modelValue }) } function y () { k.hasClass('colorpicker-visible') && (k.removeClass('colorpicker-visible'), v('colorpicker-closed'), t.off('mousedown', m), s.colorpickerIsOpen && (a[s.colorpickerIsOpen] = !1, a.$$phase && a.$root.$$phase || a.$digest())) } let b; var x = s.colorpicker ? s.colorpicker : 'hex'; var w = angular.isDefined(s.colorpickerPosition) ? s.colorpickerPosition : 'bottom'; var _ = !!angular.isDefined(s.colorpickerInline) && s.colorpickerInline; const $ = !!angular.isDefined(s.colorpickerFixedPosition) && s.colorpickerFixedPosition; const T = angular.isDefined(s.colorpickerParent) ? o.parent() : angular.element(document.body); var S = !!angular.isDefined(s.colorpickerWithInput) && s.colorpickerWithInput; var M = angular.isDefined(s.colorpickerSize) ? s.colorpickerSize : 100; const C = M + 'px'; const E = S ? '<input type="text" name="colorpicker-input" spellcheck="false">' : ''; const A = _ ? '' : '<button type="button" class="close close-colorpicker">&times;</button>'; const P = '<div class="colorpicker dropdown"><div class="dropdown-menu"><colorpicker-saturation><i></i></colorpicker-saturation><colorpicker-hue><i></i></colorpicker-hue><colorpicker-alpha><i></i></colorpicker-alpha><colorpicker-preview></colorpicker-preview>' + E + A + '</div></div>'; var k = angular.element(P); var D = n; var O = { h: 1, s: 0, b: 1, a: 1 }; const L = k.find('colorpicker-hue'); var I = k.find('colorpicker-saturation'); var R = k.find('colorpicker-preview'); var N = k.find('i'); if (e(k)(a), k.css('min-width', parseInt(M) + 29 + 'px'), I.css({ width: C, height: C }), L.css('height', C), S) { var F = k.find('input'); F.css('width', C), F.on('mousedown', function (t) { t.stopPropagation() }).on('keyup', function () { const t = this.value; o.val(t), l && l.$modelValue !== t && (a.$apply(l.$setViewValue(t)), d(!0)) }) }x === 'rgba' && (k.addClass('alpha'), b = k.find('colorpicker-alpha'), b.css('height', C), b.on('click', function (t) { i.setAlpha(t, $, M), h(t) }).on('mousedown', function (t) { i.setAlpha(t, $, M), c() }).on('mouseup', function (t) { v('colorpicker-selected-alpha') })), L.on('click', function (t) { i.setHue(t, $, M), h(t) }).on('mousedown', function (t) { i.setHue(t, $, M), c() }).on('mouseup', function (t) { v('colorpicker-selected-hue') }), I.on('click', function (t) { i.setSaturation(t, $, M), h(t), angular.isDefined(s.colorpickerCloseOnSelect) && y() }).on('mousedown', function (t) { i.setSaturation(t, $, M), c() }).on('mouseup', function (t) { v('colorpicker-selected-saturation') }), $ && k.addClass('colorpicker-fixed-position'), k.addClass('colorpicker-position-' + w), _ === 'true' && k.addClass('colorpicker-inline'), T.append(k), l && (l.$render = function () { o.val(l.$viewValue), d() }), o.on('blur keyup change', function () { d() }), o.on('$destroy', function () { k.remove() }), !1 === _ ? o.on('click', g) : g(), k.on('mousedown', function (t) { t.stopPropagation(), t.preventDefault() }), k.find('button').on('click', function () { y() }), s.colorpickerIsOpen && a.$watch(s.colorpickerIsOpen, function (t) { !0 === t ? g() : !1 === t && y() }) } } }]), (function (t) { 'use strict'; if (t.URL = t.URL || t.webkitURL, t.Blob && t.URL) try { return void new Blob() } catch (t) {} const e = t.BlobBuilder || t.WebKitBlobBuilder || t.MozBlobBuilder || (function (t) { const e = function (t) { return Object.prototype.toString.call(t).match(/^\[object\s(.*)\]$/)[1] }; const n = function () { this.data = [] }; const i = function (t, e, n) { this.data = t, this.size = t.length, this.type = e, this.encoding = n }; const r = n.prototype; const a = i.prototype; const o = t.FileReaderSync; const s = function (t) { this.code = this[this.name = t] }; const l = 'NOT_FOUND_ERR SECURITY_ERR ABORT_ERR NOT_READABLE_ERR ENCODING_ERR NO_MODIFICATION_ALLOWED_ERR INVALID_STATE_ERR SYNTAX_ERR'.split(' '); let c = l.length; const u = t.URL || t.webkitURL || t; const h = u.createObjectURL; const p = u.revokeObjectURL; let d = u; const f = t.btoa; const m = t.atob; const g = t.ArrayBuffer; const v = t.Uint8Array; for (i.fake = a.fake = !0; c--;)s.prototype[l[c]] = c + 1; return u.createObjectURL || (d = t.URL = function (t) { let e; const n = document.createElementNS('http://www.w3.org/1999/xhtml', 'a'); return n.href = t, 'origin' in n || (n.protocol.toLowerCase() === 'data:' ? n.origin = null : (e = t.match(/^[\w-]+:\/*\[?[\w\.:-]+\]?(?::[0-9]+)?/), n.origin = e && e[1])), n }), d.createObjectURL = function (t) { let e; let n = t.type; return n === null && (n = 'application/octet-stream'), t instanceof i ? (e = 'data:' + n, t.encoding === 'base64' ? e + ';base64,' + t.data : t.encoding === 'URI' ? e + ',' + decodeURIComponent(t.data) : f ? e + ';base64,' + f(t.data) : e + ',' + encodeURIComponent(t.data)) : h ? h.call(u, t) : void 0 }, d.revokeObjectURL = function (t) { t.substring(0, 5) !== 'data:' && p && p.call(u, t) }, r.append = function (t) { const n = this.data; if (v && (t instanceof g || t instanceof v)) { for (var r = '', a = new v(t), l = 0, c = a.length; l < c; l++)r += String.fromCharCode(a[l]); n.push(r) } else if (e(t) === 'Blob' || e(t) === 'File') { if (!o) throw new s('NOT_READABLE_ERR'); const u = new o(); n.push(u.readAsBinaryString(t)) } else t instanceof i ? t.encoding === 'base64' && m ? n.push(m(t.data)) : t.encoding === 'URI' ? n.push(decodeURIComponent(t.data)) : t.encoding === 'raw' && n.push(t.data) : (typeof t !== 'string' && (t += ''), n.push(unescape(encodeURIComponent(t)))) }, r.getBlob = function (t) { return arguments.length || (t = null), new i(this.data.join(''), t, 'raw') }, r.toString = function () { return '[object BlobBuilder]' }, a.slice = function (t, e, n) { const r = arguments.length; return r < 3 && (n = null), new i(this.data.slice(t, r > 1 ? e : this.data.length), n, this.encoding) }, a.toString = function () { return '[object Blob]' }, a.close = function () { this.size = 0, delete this.data }, n }(t)); t.Blob = function (t, n) { const i = n ? n.type || '' : ''; const r = new e(); if (t) for (let a = 0, o = t.length; a < o; a++)Uint8Array && t[a] instanceof Uint8Array ? r.append(t[a].buffer) : r.append(t[a]); const s = r.getBlob(i); return !s.slice && s.webkitSlice && (s.slice = s.webkitSlice), s }; const n = Object.getPrototypeOf || function (t) { return t.__proto__ }; t.Blob.prototype = n(new t.Blob()) }(typeof self !== 'undefined' && self || typeof window !== 'undefined' && window || this.content || this)); var saveAs = saveAs || (function (t) { 'use strict'; if (typeof navigator === 'undefined' || !/MSIE [1-9]\./.test(navigator.userAgent)) { const e = t.document; const n = function () { return t.URL || t.webkitURL || t }; const i = e.createElementNS('http://www.w3.org/1999/xhtml', 'a'); const r = 'download' in i; const a = function (n) { const i = e.createEvent('MouseEvents'); i.initMouseEvent('click', !0, !1, t, 0, 0, 0, 0, 0, !1, !1, !1, !1, 0, null), n.dispatchEvent(i) }; const o = t.webkitRequestFileSystem; const s = t.requestFileSystem || o || t.mozRequestFileSystem; const l = function (e) { (t.setImmediate || t.setTimeout)(function () { throw e }, 0) }; let c = 0; const u = function (e) { const i = function () { typeof e === 'string' ? n().revokeObjectURL(e) : e.remove() }; t.chrome ? i() : setTimeout(i, 500) }; const h = function (t, e, n) { e = [].concat(e); for (let i = e.length; i--;) { const r = t['on' + e[i]]; if (typeof r === 'function') try { r.call(t, n || t) } catch (t) { l(t) } } }; const p = function (t) { return /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(t.type) ? new Blob(['\ufeff', t], { type: t.type }) : t }; const d = function (e, l) { e = p(e); let d; let f; let m; const g = this; const v = e.type; let y = !1; const b = function () { h(g, 'writestart progress write writeend'.split(' ')) }; const x = function () { if (!y && d || (d = n().createObjectURL(e)), f)f.location.href = d; else { void 0 == t.open(d, '_blank') && typeof safari !== 'undefined' && (t.location.href = d) }g.readyState = g.DONE, b(), u(d) }; const w = function (t) { return function () { if (g.readyState !== g.DONE) return t.apply(this, arguments) } }; const _ = { create: !0, exclusive: !1 }; return g.readyState = g.INIT, l || (l = 'download'), r ? (d = n().createObjectURL(e), i.href = d, i.download = l, a(i), g.readyState = g.DONE, b(), void u(d)) : (t.chrome && v && v !== 'application/octet-stream' && (m = e.slice || e.webkitSlice, e = m.call(e, 0, e.size, 'application/octet-stream'), y = !0), o && l !== 'download' && (l += '.download'), (v === 'application/octet-stream' || o) && (f = t), s ? (c += e.size, void s(t.TEMPORARY, c, w(function (t) { t.root.getDirectory('saved', _, w(function (t) { const n = function () { t.getFile(l, _, w(function (t) { t.createWriter(w(function (n) { n.onwriteend = function (e) { f.location.href = t.toURL(), g.readyState = g.DONE, h(g, 'writeend', e), u(t) }, n.onerror = function () { const t = n.error; t.code !== t.ABORT_ERR && x() }, 'writestart progress write abort'.split(' ').forEach(function (t) { n['on' + t] = g['on' + t] }), n.write(e), g.abort = function () { n.abort(), g.readyState = g.DONE }, g.readyState = g.WRITING }), x) }), x) }; t.getFile(l, { create: !1 }, w(function (t) { t.remove(), n() }), w(function (t) { t.code === t.NOT_FOUND_ERR ? n() : x() })) }), x) }), x)) : void x()) }; const f = d.prototype; const m = function (t, e) { return new d(t, e) }; return typeof navigator !== 'undefined' && navigator.msSaveOrOpenBlob ? function (t, e) { return navigator.msSaveOrOpenBlob(p(t), e) } : (f.abort = function () { const t = this; t.readyState = t.DONE, h(t, 'abort') }, f.readyState = f.INIT = 0, f.WRITING = 1, f.DONE = 2, f.error = f.onwritestart = f.onprogress = f.onwrite = f.onabort = f.onerror = f.onwriteend = null, m) } }(typeof self !== 'undefined' && self || typeof window !== 'undefined' && window || this.content)); typeof module !== 'undefined' && module.exports ? module.exports.saveAs = saveAs : typeof define !== 'undefined' && define !== null && define.amd != null && define([], function () { return saveAs }), (function (t, e) {
  if (typeof exports === 'object' && typeof module === 'object')module.exports = e(); else if (typeof define === 'function' && define.amd)define([], e); else { const n = e(); for (const i in n)(typeof exports === 'object' ? exports : t)[i] = n[i] }
}(this, function () { return (function (t) { function e (i) { if (n[i]) return n[i].exports; const r = n[i] = { exports: {}, id: i, loaded: !1 }; return t[i].call(r.exports, r, r.exports, e), r.loaded = !0, r.exports } var n = {}; return e.m = t, e.c = n, e.p = '', e(0) }([function (t, e, n) { 'use strict'; t.exports = 'ngFileSaver', angular.module('ngFileSaver', []).factory('FileSaver', ['Blob', 'SaveAs', 'FileSaverUtils', n(1)]).factory('FileSaverUtils', [n(2)]).factory('Blob', ['$window', n(3)]).factory('SaveAs', [n(5)]) }, function (t, e) { 'use strict'; t.exports = function (t, e, n) { function i (t, i, r) { try { e(t, i, r) } catch (t) { n.handleErrors(t.message) } } return { saveAs: function (t, e, r) { return n.isBlobInstance(t) || n.handleErrors('Data argument should be a blob instance'), n.isString(e) || n.handleErrors('Filename argument should be a string'), i(t, e, r) } } } }, function (t, e) { 'use strict'; t.exports = function () { return { handleErrors: function (t) { throw new Error(t) }, isString: function (t) { return typeof t === 'string' || t instanceof String }, isUndefined: function (t) { return void 0 === t }, isBlobInstance: function (t) { return t instanceof Blob } } } }, function (t, e, n) { 'use strict'; n(4), t.exports = function (t) { return t.Blob } }, function (t, e) { !(function (t) { 'use strict'; if (t.URL = t.URL || t.webkitURL, t.Blob && t.URL) try { return void new Blob() } catch (t) {} const e = t.BlobBuilder || t.WebKitBlobBuilder || t.MozBlobBuilder || (function (t) { const e = function (t) { return Object.prototype.toString.call(t).match(/^\[object\s(.*)\]$/)[1] }; const n = function () { this.data = [] }; const i = function (t, e, n) { this.data = t, this.size = t.length, this.type = e, this.encoding = n }; const r = n.prototype; const a = i.prototype; const o = t.FileReaderSync; const s = function (t) { this.code = this[this.name = t] }; const l = 'NOT_FOUND_ERR SECURITY_ERR ABORT_ERR NOT_READABLE_ERR ENCODING_ERR NO_MODIFICATION_ALLOWED_ERR INVALID_STATE_ERR SYNTAX_ERR'.split(' '); let c = l.length; const u = t.URL || t.webkitURL || t; const h = u.createObjectURL; const p = u.revokeObjectURL; let d = u; const f = t.btoa; const m = t.atob; const g = t.ArrayBuffer; const v = t.Uint8Array; for (i.fake = a.fake = !0; c--;)s.prototype[l[c]] = c + 1; return u.createObjectURL || (d = t.URL = function (t) { let e; const n = document.createElementNS('http://www.w3.org/1999/xhtml', 'a'); return n.href = t, 'origin' in n || (n.protocol.toLowerCase() === 'data:' ? n.origin = null : (e = t.match(/^[\w-]+:\/*\[?[\w\.:-]+\]?(?::[0-9]+)?/), n.origin = e && e[1])), n }), d.createObjectURL = function (t) { let e; let n = t.type; return n === null && (n = 'application/octet-stream'), t instanceof i ? (e = 'data:' + n, t.encoding === 'base64' ? e + ';base64,' + t.data : t.encoding === 'URI' ? e + ',' + decodeURIComponent(t.data) : f ? e + ';base64,' + f(t.data) : e + ',' + encodeURIComponent(t.data)) : h ? h.call(u, t) : void 0 }, d.revokeObjectURL = function (t) { t.substring(0, 5) !== 'data:' && p && p.call(u, t) }, r.append = function (t) { const n = this.data; if (v && (t instanceof g || t instanceof v)) { for (var r = '', a = new v(t), l = 0, c = a.length; l < c; l++)r += String.fromCharCode(a[l]); n.push(r) } else if (e(t) === 'Blob' || e(t) === 'File') { if (!o) throw new s('NOT_READABLE_ERR'); const u = new o(); n.push(u.readAsBinaryString(t)) } else t instanceof i ? t.encoding === 'base64' && m ? n.push(m(t.data)) : t.encoding === 'URI' ? n.push(decodeURIComponent(t.data)) : t.encoding === 'raw' && n.push(t.data) : (typeof t !== 'string' && (t += ''), n.push(unescape(encodeURIComponent(t)))) }, r.getBlob = function (t) { return arguments.length || (t = null), new i(this.data.join(''), t, 'raw') }, r.toString = function () { return '[object BlobBuilder]' }, a.slice = function (t, e, n) { const r = arguments.length; return r < 3 && (n = null), new i(this.data.slice(t, r > 1 ? e : this.data.length), n, this.encoding) }, a.toString = function () { return '[object Blob]' }, a.close = function () { this.size = 0, delete this.data }, n }(t)); t.Blob = function (t, n) { const i = n ? n.type || '' : ''; const r = new e(); if (t) for (let a = 0, o = t.length; a < o; a++)Uint8Array && t[a] instanceof Uint8Array ? r.append(t[a].buffer) : r.append(t[a]); const s = r.getBlob(i); return !s.slice && s.webkitSlice && (s.slice = s.webkitSlice), s }; const n = Object.getPrototypeOf || function (t) { return t.__proto__ }; t.Blob.prototype = n(new t.Blob()) }(typeof self !== 'undefined' && self || typeof window !== 'undefined' && window || this.content || this)) }, function (t, e, n) { 'use strict'; t.exports = function () { return n(6).saveAs || function () {} } }, function (t, e, n) { let i; var r = r || (function (t) { 'use strict'; if (!(void 0 === t || typeof navigator !== 'undefined' && /MSIE [1-9]\./.test(navigator.userAgent))) { const e = t.document; const n = function () { return t.URL || t.webkitURL || t }; const i = e.createElementNS('http://www.w3.org/1999/xhtml', 'a'); const r = 'download' in i; const a = function (t) { const e = new MouseEvent('click'); t.dispatchEvent(e) }; const o = /constructor/i.test(t.HTMLElement) || t.safari; const s = /CriOS\/[\d]+/.test(navigator.userAgent); const l = function (e) { (t.setImmediate || t.setTimeout)(function () { throw e }, 0) }; const c = function (t) { const e = function () { typeof t === 'string' ? n().revokeObjectURL(t) : t.remove() }; setTimeout(e, 4e4) }; const u = function (t, e, n) { e = [].concat(e); for (let i = e.length; i--;) { const r = t['on' + e[i]]; if (typeof r === 'function') try { r.call(t, n || t) } catch (t) { l(t) } } }; const h = function (t) { return /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(t.type) ? new Blob([String.fromCharCode(65279), t], { type: t.type }) : t }; const p = function (e, l, p) { p || (e = h(e)); let d; const f = this; const m = e.type; const g = m === 'application/octet-stream'; const v = function () { u(f, 'writestart progress write writeend'.split(' ')) }; if (f.readyState = f.INIT, r) return d = n().createObjectURL(e), void setTimeout(function () { i.href = d, i.download = l, a(i), v(), c(d), f.readyState = f.DONE }); !(function () { if ((s || g && o) && t.FileReader) { const i = new FileReader(); return i.onloadend = function () { let e = s ? i.result : i.result.replace(/^data:[^;]*;/, 'data:attachment/file;'); t.open(e, '_blank') || (t.location.href = e), e = void 0, f.readyState = f.DONE, v() }, i.readAsDataURL(e), void (f.readyState = f.INIT) } if (d || (d = n().createObjectURL(e)), g)t.location.href = d; else { t.open(d, '_blank') || (t.location.href = d) }f.readyState = f.DONE, v(), c(d) }()) }; const d = p.prototype; const f = function (t, e, n) { return new p(t, e || t.name || 'download', n) }; return typeof navigator !== 'undefined' && navigator.msSaveOrOpenBlob ? function (t, e, n) { return e = e || t.name || 'download', n || (t = h(t)), navigator.msSaveOrOpenBlob(t, e) } : (d.abort = function () {}, d.readyState = d.INIT = 0, d.WRITING = 1, d.DONE = 2, d.error = d.onwritestart = d.onprogress = d.onwrite = d.onabort = d.onerror = d.onwriteend = null, f) } }(typeof self !== 'undefined' && self || typeof window !== 'undefined' && window || this.content)); void 0 !== t && t.exports ? t.exports.saveAs = r : n(7) !== null && n(8) !== null && void 0 !== (i = (function () { return r }.call(e, n, e, t))) && (t.exports = i) }, function (t, e) { t.exports = function () { throw new Error('define cannot be used indirect') } }, function (t, e) { (function (e) { t.exports = e }).call(e, {}) }])) }))
